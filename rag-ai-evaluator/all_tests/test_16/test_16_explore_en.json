{
  "test_id": "test_016_explore_en",
  "query": "I’m on Angular 16 – can I use the routing feature you describe?",
  "endpoint": "reader_explore_text",
  "user": {
    "tier": "elevate",
    "language": "en"
  },
  "prompt": "main",
  "actual_response": "arrow_forward_iosDeine Suchergebnisse:  Supercharge your Apps with Incremental Hydr... Alexander ThalhammerInternational JavaScript Conference Munich 2025 Is Angular 16 Starting a (R)evolution? Karsten SitterbergJavaScript Magazine Volume 8 Jetzt schlägt’s 15: Was ist neu in Angular ... Karsten SitterbergJava Magazin 2.2023 Java 16: Das JDK auf dem Weg zur nächsten L... Falk SippachJAXenter 3.2021 Angular 16 released Karsten SitterbergiJS Magazin Band 27 Angular 15: New Features and Breaking Chang... Karsten SitterbergJavaScript Magazine Volume 7 Sweet 16 Falk SippachJava Magazin 5.2021 Getting the most out of Angular DevTools Sam VloeberghsInternational JavaScript Conference Munich 2025 How to architect Angular apps in 2025 Alain ChautardInternational JavaScript New York 2025 AI-powered Angular Apps Michael Egger-ZikesInternational JavaScript Conference Munich 2025 Scaling Node.js Applications with NestJS: P... Tyler SteckInternational JavaScript New York 2025 The Supreme Discipline of Micro Frontends: ... Manfred SteyerInternational JavaScript Conference Munich 2025 Manfred Steyer on Angular 20: Signals, Dyna... Manfred SteyeriJS Magazine Volume 19 The Art of Testing Rainer HahnekampInternational JavaScript Conference London 2025 Angular’s New Era: Unveiling the Most Excit... Pankaj ParkarInternational JavaScript Conference Singapore 2024 Level-up your Angular Codebase with Cutting... Michael Egger-ZikesInternational JavaScript Conference Munich 2024 The Power of Angular’s Dependency Injection... Michael Egger-ZikesInternational JavaScript Conference Munich 2024 Optimizing Angular Applications - Technique... Sonu KapoorInternational JavaScript New York 2024 Angular 18: Neue Features optimal nutzen un... Christian LiebelBASTA! Herbst 2024 Renovate your Angular App! Michael Egger-ZikesInternational JavaScript Conference London 2024I’m on Angular 16 – can I use the routing feature you describe?gpt-4.1-mini keyword: {\n  'phrase_out': 'Angular 16 routing feature',\n  'primary_version_array': ['16'],\n  'secondary_version_array': ['15','14'],\n  'year_array': [],\n  'issue_array': []\n} \nAngular 16 introduces significant improvements and new features, including enhancements to routing, but the full modern routing capabilities you might be referring to—such as the new Control Flow syntax, Standalone APIs, and advanced route integration with signals—are evolving and becoming more stable in later versions like Angular 17 and beyond.\nKey points about routing in Angular 16 relevant to your question:\n\nAngular 16 supports improved routing with Standalone Components and APIs, making NgModules optional and simplifying route configuration. This allows for more modular and maintainable routing setups compared to earlier versions [1.]  [2.].\n\nThe new Control Flow syntax and enhanced server-side rendering support are part of Angular’s ongoing evolution, with some features still in preview or experimental stages in Angular 16. These features improve template readability and performance but may require cautious adoption [2.].\n\nAngular 16’s router integration includes features like input bindings for route parameters, which simplify accessing URL parameters directly as component inputs, improving developer ergonomics [3.].\n\nZone.js is becoming optional, and Angular 16 introduces experimental support for zone-less change detection, which can impact routing behavior and performance optimizations [4.].\n\nWhile Angular 16 is stable and production-ready, some of the most advanced routing features, such as Incremental Hydration and Hybrid Routing, are introduced in Angular 19 and later versions, so they are not available in Angular 16 yet [5.].\n\n\nIn summary, you can definitely use the improved routing features in Angular 16, including Standalone Components and enhanced route parameter handling, which simplify and modernize routing compared to earlier Angular versions. However, some of the newest routing innovations and server-side rendering enhancements are planned for Angular 17 and later, so they are not fully available in Angular 16 yet. Your current version supports a solid and modern routing experience with backward compatibility and incremental adoption in mind [1.]  [3.]  [2.].\nIf you want to leverage the absolute latest routing capabilities, consider planning an upgrade path beyond Angular 16 when those features become stable.\nLet me know if you want guidance on migrating your routing setup or examples of Angular 16 routing usage!\n\nSources\n\nLevel-up your Angular Codebase with Cutting-Edge APIs This conference talk examines how new Angular APIs enable modern codebases, focusing on migration strategies and developer experience. ℹ️ This talk of International JavaScript Conference Munich 2024 was part of a past event. Booking is no longer available, but you can discover the current edition right here on the platform.\n\nRenovate your Angular App! This conference talk examines Angular’s evolution toward standalone APIs, signals, and modern migration strategies for future-proof applications. ℹ️ This talk of International JavaScript Conference London 2024 was part of a past event. Booking is no longer available, but you can discover the current edition right here on the platform.\n\nRenovate your Angular App! This conference talk examines Angular’s latest APIs, migration strategies, and features for modernizing enterprise applications with future-proof architecture. ℹ️ This talk of International JavaScript Conference San Diego 2024 was part of a past event. Booking is no longer available, but you can discover the current edition right here on the platform.\n\nOptimizing Angular Applications - Techniques for Performance Excellence This conference talk presents advanced strategies and practical techniques for optimizing Angular application performance in modern web development. ℹ️ This talk of International JavaScript New York 2024 was part of a past event. Booking is no longer available, but you can discover the current edition right here on the platform.\n\nSupercharge your Apps with Incremental Hydration This conference talk examines how Angular’s incremental hydration and deferrable views enhance SSR performance and user experience. ✅ You still have access to the recordings for this talk of International JavaScript Conference Munich 2025 until 2026-04-28. Unfortunately, recordings are not available for workshops, but you can still access the slides and your certificate. Dive back in anytime!\n\n\n\nMore on this Topic\n\nIs Angular 16 Starting a (R)evolution? - Breaking changes, features, and everything new in Angular 16 This article examines Angular 16’s breaking changes, novel features and APIs (CLI, framework, signals, hydration), and implications for migration and future direction. ✅ This content is included with your elevate membership.\n\nAI-powered Angular Apps This conference talk examines how large language models can enable dynamic runtime configuration and navigation in Angular enterprise applications. ✅ You still have access to the recordings for this talk of International JavaScript Conference Munich 2025 until 2026-04-28. Unfortunately, recordings are not available for workshops, but you can still access the slides and your certificate. Dive back in anytime!\n\nAngular 16 released - Alles zu neuen Features und Breaking Changes This article overviews Angular 16’s key new features and breaking changes across TypeScript, CLI, framework, Signals, SSR, and dependency updates. ✅ This content is included with your elevate membership.\n\nGetting the most out of Angular DevTools This conference talk presents practical techniques for using Angular DevTools to debug, profile, and optimize modern Angular applications. ✅ You still have access to the recordings for this talk of International JavaScript Conference Munich 2025 until 2026-04-27. Unfortunately, recordings are not available for workshops, but you can still access the slides and your certificate. Dive back in anytime!\n\n\nReference:\n{\n  'translated_headers': {\n    'sources': 'Sources',\n    'more_on_this_topic': 'More on this Topic'\n  },\n  'sources': [],\n  'more_on_this_topic': [\n    {\n      'doc_id': '5ecf87915aa99dfe10bb64dd'\n    },\n    {\n      'doc_id': '169cb8b4177f542b161210ec'\n    },\n    {\n      'doc_id': '5047e9550eef9d941aaa1376'\n    },\n    {\n      'doc_id': '64ace3828d8056484c3534ab'\n    },\n    {\n      'doc_id': 'ac8bcbad20150e9773f7400b'\n    }\n  ]\n}\n\nChunks:\n'documentId': 'PnApHFiNAR2RR6pkD'\n'chunk_id': '687a2dde9bbcb45d2a11f093'\n'access': 'restricted'\n'part_number': 1\n'total_parts': 20\n'contentType': 'RHEINGOLD'\n'title': Modern Angular: Harnessing Signals, Hydration, and Modern Tooling for Seamless Coding\n'parentName': International JavaScript Conference San Diego 2024\n'language': 'EN'\n'date': '2024-05-21T09:30:00.000Z'\n'abstract': Angular is gaining more and more momentum. First, it introduced Standalone Components and new functional approaches like inject, guards, and interceptors. But the innovation didn't stop there. Instead, it increased its pace. Signals and a better hydration keep moving the framework even further. In this talk, I will write a new application from scratch. I'll show what a modern tooling setup can look like and make use of all the latest features that Angular provides. Coding in Angular has never been easier.\n'parentId': 'BYZWRge2q657D9ZYR'\n'parentDescription': The Fullstack Conference for JS Development\n'indexBrandName': 'InternationalJavaScriptCon'\n'indexSeriesName': 'SanDiego'\n'author': 'Rainer Hahnekamp'\n'chunkSource': 'text'\n'text': Modern Angular: Harnessing Signals, Hydration, and Modern Tooling for Seamless Coding Angular is gaining more and more momentum. First, it introduced Standalone Components and new functional approaches like inject, guards, and interceptors. But the innovation didn't stop there. Instead, it increased its pace. Signals and a better hydration keep moving the framework even further. In this talk, I will write a new application from scratch. I'll show what a modern tooling setup can look like and make use of all the latest features that Angular provides. Coding in Angular has never been easier. Okay, so 1130, we are not that many, but still I will start with my talk more on ing. So yeah, quick introduction of mine. So my name is Rena Amp and part of Ingrid Architects. And uh, to give you maybe a quick overview of what we're going to do, that's not going to be a talk, that's going to be a life coding session. So there are some slides, but you will not see so many of them. 'cause what I'm going to do is that I will start with a newer angle applications just from scratch and try to implement something which at the end should look like this. So there is a quiz available where I can answer some questions and then I get of course a status result telling me, uh, how good how, how good I have done. And the goal is that I try to use as many of the new features that are available in English as possible. So that's, that's the way how it works. What We, we will do, or what I have already done, I have already initialized a new angular project for that. I didn't install the Angular CLI, what I did instead it that I just executed NPM in it at Angular. That's the new approach. And then internally just downloads the latest angular versions running in new and that's already there. So we have an MT angle application and what we are going to see are the standalone components and the API. We'll also then see the functional interceptors and the CO and the guards. So things which you have already for quite some time. And then new template blocks, cell site rendering. And then of course also the signals. Good. So I'll sit down and I'll just start right. So I'm using intelli chain, as you can see, uh, mouse good, right? And the application, the way how it looks like at the moment looks like this. So that's the empty and empty app component first. Whenever you run Engine U, uh, really, uh, with a new version of Angular, what you will see is\n'slidetext': ''\n'from': 'vector'\n'score': 0.9059744477272034\n'normalizedScore': 0.8764817153140882\n'beforeDatePenaltyScore': 0.9059744477272034\n\n'documentId': 'mrkFPBdm5bQQ8Q8nY'\n'chunk_id': '687a355fca798166d3ba5e20'\n'access': 'restricted'\n'part_number': 3\n'total_parts': 22\n'contentType': 'RHEINGOLD'\n'title': Renovate your Angular App!\n'parentName': International JavaScript Conference London 2024\n'language': 'EN'\n'date': '2024-04-10T08:30:00.000Z'\n'abstract': The Angular Team is currently pushing the popular enterprise frontend framework into a bright future. New APIs which are prooved as Solid in the JavaScript ecosystem and Qwiker start-up time by introducing more advanced server-side rendering support are combined with the new Control Flow syntax that feels like a perfect joint-venture between Svelte and .NET. The Standalone APIs make NgModules optional as well as RxJS and Zone.js will not be mandatory dependencies in the future anymore. But what does this mean for your current codebase? Which refactoring strategy is the best compromise between good preparation for the future and tight project budgets? The good news - all of this comes with backwards compatibility in mind. It is your own decision which pace to use to refactor your own codebase to the latest framework features. In this practical session, we will discuss those new APIs and discover ways to transform your code into a future-proof application.\n'parentId': 'cKCGY58YaztJ8GQ9k'\n'parentDescription': The JavaScript Fullstack Conference - Angular, Node.js, React and more\n'indexBrandName': 'InternationalJavaScriptCon'\n'indexSeriesName': 'London'\n'author': 'Michael Egger-Zikes'\n'chunkSource': 'text'\n'text': uh, JavaScript community, if you normally ask them what's the, the really powerful API that Angular has, uh, where Angular has really was really in innovative and, and, um, implemented a set of features that the other frameworks did not have back then. Um, basically it's dependence injection, so that's a big success story. It makes things far easier, uh, in a lean manner, connecting your, um, your dependencies to components, directives and so on. And the system stayed the same, but we received new APIs on how to work with the dependent injection. Um, also because of the standalone, uh, APIs that were introduced, because if you think back, or maybe it's even currently still in your code base, that's perfectly fine. Um, how did we add roots, for example, with the route the module, uh, for root and with the route the module for a child. Today, we make this differently. We have provider functions. We also do this for state management to connect the new states life into our application. Um, we'll also talk about the control flow. That's another nice feature that was added, uh, with the last nature release. Um, it makes, uh, it transforms your code with a schematic generator that we can use, uh, from NG NG four NG switch to a kind of different template language with an add symbol in front. And it looks more like something erect component. You can also say selt component, or there are also similar notations in.net applications, for example, where we can really have code blocks in the template, or at least it looks like a code block. It's still HTML template, but, um, it's, it's far easier to read and, and therefore also not only for reading, uh, something beneficial, but also for performance because the, the angle application can render all your iterable lists like an array, for example, um, more performant than in the past. And then dot, dot, dot, uh, the spread operator. Right? Um, we have some, some other nice features as well, uh, that, that I will take here at least briefly in an overview slide at end. Um, my name is Mikey. I work at the Angular Architects. Um, so together with Maner Van Amp and some other guys, we try to help our customers and Angola with trainings, consultancies and reviews and sometimes, uh, yeah, and even here at conferences, um, hopefully giving you some, some nice inputs about, uh, current topics that, uh, are relevant for the Angular development. Um, yeah, you can find me also on Twitter. I still see Twitter\n'slidetext': ''\n'from': 'vector'\n'score': 0.9097973704338074\n'normalizedScore': 0.8780557795738378\n'beforeDatePenaltyScore': 0.9097973704338074\n\n'documentId': 'mrkFPBdm5bQQ8Q8nY'\n'chunk_id': '687a355fca798166d3ba5e1c'\n'access': 'restricted'\n'part_number': 1\n'total_parts': 22\n'contentType': 'RHEINGOLD'\n'title': Renovate your Angular App!\n'parentName': International JavaScript Conference London 2024\n'language': 'EN'\n'date': '2024-04-10T08:30:00.000Z'\n'abstract': The Angular Team is currently pushing the popular enterprise frontend framework into a bright future. New APIs which are prooved as Solid in the JavaScript ecosystem and Qwiker start-up time by introducing more advanced server-side rendering support are combined with the new Control Flow syntax that feels like a perfect joint-venture between Svelte and .NET. The Standalone APIs make NgModules optional as well as RxJS and Zone.js will not be mandatory dependencies in the future anymore. But what does this mean for your current codebase? Which refactoring strategy is the best compromise between good preparation for the future and tight project budgets? The good news - all of this comes with backwards compatibility in mind. It is your own decision which pace to use to refactor your own codebase to the latest framework features. In this practical session, we will discuss those new APIs and discover ways to transform your code into a future-proof application.\n'parentId': 'cKCGY58YaztJ8GQ9k'\n'parentDescription': The JavaScript Fullstack Conference - Angular, Node.js, React and more\n'indexBrandName': 'InternationalJavaScriptCon'\n'indexSeriesName': 'London'\n'author': 'Michael Egger-Zikes'\n'chunkSource': 'text'\n'text': Renovate your Angular App! The Angular Team is currently pushing the popular enterprise frontend framework into a bright future. New APIs which are prooved as Solid in the JavaScript ecosystem and Qwiker start-up time by introducing more advanced server-side rendering support are combined with the new Control Flow syntax that feels like a perfect joint-venture between Svelte and .NET. The Standalone APIs make NgModules optional as well as RxJS and Zone.js will not be mandatory dependencies in the future anymore. But what does this mean for your current codebase? Which refactoring strategy is the best compromise between good preparation for the future and tight project budgets? The good news - all of this comes with backwards compatibility in mind. It is your own decision which pace to use to refactor your own codebase to the latest framework features. In this practical session, we will discuss those new APIs and discover ways to transform your code into a future-proof application. All, Now it works. Hi. Hi again to everyone. Uh, we are, um, today talking about the new Angular features. Uh, the talk is called Runway Weight Your Angle app because, um, actually we are now on version 17 and quite a bunch of features were added recently. If you look back in time, the new generation of Angular two plus applications, some even called it Angular three already because we never had a version three in our framework. Um, it's, it, it changes quite that much, um, that we could even argue. Maybe it's a, it's, it's the third generation of the Angola framework, but this time not that way. Like we had the transition, the, to be honest, painful transition from Angular one to Angular two this time. Um, Ola team learned quite a lot from, uh, those days back then and from the feedback of the community that wasn't, that the community wasn't that happy about all the migration projects that still are today a thing for some companies to migrate. The Angular J called base to Angular two plus applications Angular 17, maybe today. Um, and so they found a quite better strategy, a strategy that leads to more effort for them and not more effort for us implementing our Angular applications and will exactly tackle that topic today. That means, um, since Angular 14 at least, um, they had quite a, a high pace implementing new features, offering new features, offering, develop a preview with, uh, the signals, API with the new control flow with, uh, standalone components at the beginning with Angola. 14. Uh, what else did we receive? Uh, typed finally typed forms. So quite a bunch of\n'slidetext': ''\n'from': 'vector'\n'score': 0.9104529023170471\n'normalizedScore': 0.8787113114577118\n'beforeDatePenaltyScore': 0.9104529023170471\n\n'documentId': 'b3ayobXPMcKfG7CMq'\n'chunk_id': '687a2f7b9bbcb45d2a120133'\n'access': 'restricted'\n'part_number': 1\n'total_parts': 1\n'contentType': 'FLEX_CAMP'\n'title': Lektion 6: Routing | verfügbar bis 21.07.2024\n'parentName': Angular Camp - Flexible Basic Camp Juni 2024 | online\n'language': 'DE'\n'date': '2024-07-08T05:00:00.000Z'\n'abstract': Der Router ist der Dreh-und-Angelpunkt der meisten Angular-Anwendungen. Er simuliert Seiten innerhalb einer Single-Page-Application und erlaubt Deep-Linking:\n'parentId': 'Qsb3zs9SGfqD8fyQN'\n'parentDescription': Das Angular Training für Einsteiger:innen mit Manfred Steyer im zeitlich flexiblen Online-Format\n'indexBrandName': 'AngularCamp'\n'indexSeriesName': 'FlexibleBasicCamp'\n'author': 'Manfred Steyer'\n'chunkSource': 'text'\n'text': Lektion 6: Routing | verfügbar bis 21.07.2024 Der Router ist der Dreh-und-Angelpunkt der meisten Angular-Anwendungen. Er simuliert Seiten innerhalb einer Single-Page-Application und erlaubt Deep-Linking:\n'slidetext': ''\n'from': 'vector'\n'score': 0.90860915184021\n'normalizedScore': 0.8817362824414277\n'beforeDatePenaltyScore': 0.90860915184021\n\n'documentId': 'N9G6dCb5BArvu6cbr'\n'chunk_id': '687a2d529bbcb45d2a11eaa3'\n'access': 'restricted'\n'part_number': 1\n'total_parts': 23\n'contentType': 'RHEINGOLD'\n'title': Renovate your Angular App!\n'parentName': International JavaScript Conference San Diego 2024\n'language': 'EN'\n'date': '2024-05-21T12:30:00.000Z'\n'abstract': The Angular Team is currently pushing the popular enterprise frontend framework into a bright future. New APIs proved to be solid in the JavaScript ecosystem and quicker start-up time introduced more advanced server-side rendering support. Combined with the new Control Flow syntax, it feels like a perfect joint venture between Svelte and .NET. The Standalone APIs make NgModules optional too. RxJS and Zone.js won't be a mandatory dependency in the future anymore. But what does this mean for your current codebase? Which refactoring strategy is the best compromise between good preparation for the future and tight project budgets? The good news is that all of this comes with backward compatibility in mind. It is your decision which pace to use to refactor your codebase to the latest framework features. In a practical session, we'll discuss those new APIs and discover ways to transform your code into a future-proof application.\n'parentId': 'BYZWRge2q657D9ZYR'\n'parentDescription': The Fullstack Conference for JS Development\n'indexBrandName': 'InternationalJavaScriptCon'\n'indexSeriesName': 'SanDiego'\n'author': 'Michael Egger-Zikes'\n'chunkSource': 'text'\n'text': Renovate your Angular App! The Angular Team is currently pushing the popular enterprise frontend framework into a bright future. New APIs proved to be solid in the JavaScript ecosystem and quicker start-up time introduced more advanced server-side rendering support. Combined with the new Control Flow syntax, it feels like a perfect joint venture between Svelte and .NET. The Standalone APIs make NgModules optional too. RxJS and Zone.js won't be a mandatory dependency in the future anymore. But what does this mean for your current codebase? Which refactoring strategy is the best compromise between good preparation for the future and tight project budgets? The good news is that all of this comes with backward compatibility in mind. It is your decision which pace to use to refactor your codebase to the latest framework features. In a practical session, we'll discuss those new APIs and discover ways to transform your code into a future-proof application. So then let's get the party Started. Microphone on fine. Then. Um, yeah, I've learned I'm not allowed to move that far, but that should be fine. Okay. Uh, welcome everyone here in the room, in, in San Diego, beautiful San Diego and everyone also, uh, connected online, um, through Deaf meal. Uh, hello everyone. Um, I would like to, um, talk a little bit about, uh, renovating Your Angle applications. That means we have received so many APIs that it's basically a challenge to really figure out what to, uh, refactor immediately, what to refactor later. Um, so quite a lot to do for applications and yeah, let's dive directly into that. Um, as soon as my clicker reacts list, um, we will talk about standalone migration. Um, we can do so with some, uh, schematics, but also manually. Um, we look into the signals, API also how we can, uh, refactor our current components into new ones. Um, and, uh, we will talk about the router integration. There are several features, um, that basically makes it easier for us and it, to be honest, feels better than in the past to work with ENG router. So for example, uh, getting an ID out of the URL, uh, using, uh, quite a bunch of modern features, signal, signal inputs, um, and other features, um, to, to get, uh, access to the routing state and, and use it in your child components there. Um, we will also talk about, uh, provider functions and inject functions. So they are important right now. Um, on one hand, you know them basically, uh, maybe already from the Angular framework itself,\n'slidetext': ''\n'from': 'vector'\n'score': 0.9119873642921448\n'normalizedScore': 0.8825014811972691\n'beforeDatePenaltyScore': 0.9119873642921448\n\n'documentId': 'xrng8DfDqckoEKvMr'\n'chunk_id': '687a30f3ca798166d3ba4157'\n'access': 'restricted'\n'part_number': 4\n'total_parts': 30\n'contentType': 'RHEINGOLD'\n'title': Angular 18: Neue Features optimal nutzen und Bestandsprojekte effizient migrieren\n'parentName': BASTA! Herbst 2024\n'language': 'DE'\n'date': '2024-09-18T13:30:00.000Z'\n'abstract': Seit Angular 16 hat Google umfassende Änderungen an seinem SPA-Framework vorgenommen, um es in das nächste Jahrzehnt der Webentwicklung zu führen. Damit einher geht eine nachhaltige Veränderung der Gestalt von Angular-Anwendungen: Es setzen sich zunehmend funktionale Schnittstellen durch, die die alten objektorientierten APIs sowie TypeScript-Dekoratoren ersetzen. Signals breiten sich Stück für Stück im Framework aus, sodass reaktive Programmierung immer wichtiger wird. Standalone-Komponenten und -APIs sind längst zum Standard geworden und die neue Kontrollfluss-Syntax vereinfacht häufige Anwendungsfälle im Template erheblich. Nicht zuletzt ist auch Server-Side Rendering nun zentraler Bestandteil des Frameworks geworden und . Christian Liebel stellt in dieser Session die Neuerungen in Angular 18 vor und gibt eine Einschätzung, ob, wann und wie Entwickler auf die neuen Features umsteigen sollen. Kommen Sie vorbei und bringen Sie Ihr Angular-Wissen auf den neusten Stand!\n'parentId': 'Hm6SdzajQWSYS6foi'\n'parentDescription': Die Konferenz für .NET, Windows & Open Innovation\n'indexBrandName': 'BASTA!'\n'indexSeriesName': 'Herbst'\n'author': 'Christian Liebel'\n'chunkSource': 'text'\n'text': eine andere Route gehen. Das hat man auch davor schon bauen können. Mit einem Guard hätte man es zum Beispiel implementieren können. Kann man jetzt einfach per Funktion machen und auf diese Art hinterlegen. Auch hier wieder eine kleine praktische Weiterentwicklung. Dann habt ihr vielleicht ng-content im Einsatz. Hier gibt es die Möglichkeit mithilfe des Select-Attributs sich ein spezielles einen speziellen Node zu ziehen, der dann in meinem Content als Komponente enthalten ist. Was bisher nicht ging, ist zu sagen, wenn ich dieses spezielle Ding nicht finde, dann einen Fallback anzuzeigen. Hier in dem konkreten Fall geht es also darum, plötzlich eine Begrüßung anzuzeigen, wenn es innerhalb des Contents von AppProfile einen Dom-Knoten gab, der auf die Klasse Greeting hört und wenn der nicht da ist, dann will ich einen Fallback anzeigen. Das war davor möglich, aber es war sehr hässlich. Das zu implementieren geht jetzt ganz einfach, indem man dann einen ng-content hinzufügt, das dann quasi keinen Select hat. Das würde dann angezeigt, wenn es eben keins mit Greeting davor gab. Das ist Fallback-Content, das ist sehr praktisch und eine gute Sache. Dann haben wir in Angular Material jetzt die Unterstützung für Material 3. Vielleicht habt ihr das im Einsatz und es sieht wunderschön aus, ja wie man sehen kann. Das letzte setzt eben die Stilvorgaben von Material 3 um. Dann haben wir TypeScript 5.4. Bei Angular Release werden ja die Dependencies quasi mit hochgezogen. Jetzt haben wir Unterstützung für TypeScript 5.4. Wenn man also dort spezielle Features aus diesem TypeScript Release braucht, kann man die mit Angular 18 einsetzen. Das sind einige der Neuerungen, die jetzt gekommen sind mit Angular 18. Wie gesagt, kleinere Dinge, die das Leben besser machen, aber für mich persönlich eben noch nicht so die richtig großen Knaller. Das sind nämlich vier andere Themen. Das sind zum einen Signals. Nichts Neues an und für sich. Signals werfen bereits seit längerem ihre Schatten voraus, was das Angular-Framework anbelangt. sind ein neuer reaktiver Basis-Datentyp, den man verwenden kann, der Reactive Primitive, wie man es nennt, und die Sie jetzt immer weiter im Framework ausbreiten. Das\n'slidetext': ''\n'from': 'vector'\n'score': 0.9071764945983887\n'normalizedScore': 0.8842682370717524\n'beforeDatePenaltyScore': 0.9071764945983887\n\n'documentId': 'ec8de39dac90e93f9fd00a92'\n'chunk_id': '687a312cca798166d3ba43b5'\n'access': 'restricted'\n'part_number': 11\n'total_parts': 12\n'contentType': 'RHEINGOLD'\n'title': Optimizing Angular Applications - Techniques for Performance Excellence\n'parentName': International JavaScript New York 2024\n'language': 'EN'\n'date': '2024-10-09T14:15:00.000Z'\n'abstract': In today’s fast-paced digital landscape, delivering high-performance applications is crucial for a seamless user experience. This presentation dives deep into proven strategies and best practices for optimizing Angular applications. We will explore advanced techniques such as lazy loading, change detection strategies, signal-based state management, and leveraging NgOptimizedImage for better load times. Attendees will gain insights into optimizing bundle sizes, efficient HTTP communication, tree-shaking, and more. Whether you're dealing with large-scale apps or looking to enhance performance in smaller projects, this session provides actionable takeaways to improve your Angular application's speed and efficiency.\n'parentId': 'xhXxg9ohmYPxSZtL6'\n'parentDescription': The JavaScript Fullstack Conference - Angular, Node.js, React and more\n'indexBrandName': 'InternationalJavaScriptCon'\n'indexSeriesName': 'NewYork'\n'author': 'Sonu Kapoor'\n'chunkSource': 'text'\n'text': significant performance when implemented correctly. So in order to implement this, you need to add the, provide experimental zones, change detection during the application bootstrap rep. You also need to remove zone js from your polyfil and make sure that you're using at least angular version 18. So before you enable zone less in your application, keep in mind that this API is currently experimental, so anything can change at any time. Uh, regardless of that, here is a snippet of how you could try this out and if you run into any issues, I suggest that you open a ticket in the GitHub angular repo so that the Angular team is aware of it. And that's it. I hope these tips were helpful and as always, please connect with me over LinkedIn or Twitter. Um, and again, the repo with all the amazing animations I did, um, are here in the GitHub repo. Any questions? Yeah, go ahead please. I think you refer something incorrect there actually on post, we'll check double three, not just confidence that changes. Okay. Right. So from what I remember, I think it's just the, the component and its ancestors, right? No, it checks the all three, but what does constantly checking, Okay, just When we say okay, check now. Yeah, change on input on observable. Yeah, asy observable and things like that. Yeah. Yes, but it'll select complete not only the company, what's changed that year is the signoffs. With signoffs we can, uh, use our push to as a way to be stable. Um, constant tracking and Okay, I was under the impression that it only checks the component, uh, and not the entire tree because then what's the difference between? Difference Is that it's not automatically changing. Uh, every time you plate changes you on complex, you can use use or push and you decide when all the updates finish. Mm-Hmm. Then you will call the, I don't remember the directive buyer, but force the check You Okay. Will Happen on the complete. Yeah. So you don't, you don't actually have to force it. Um, so if you have on push set up and any of your input references change, then it will automatically trigger the change detection. And also when you have async operations right, then it will also automatically do that. Um, yeah. But thank you. Any other questions? I think you had one. Yeah. Um, lazy loading, first part From the routing. Yeah. Seems so easy to implement. Is there, uh, any reason you wouldn't wanna implement that application? Um, that's a good question. I mean, it should be the default I think, right? Um,\n'slidetext': ''\n'from': 'vector'\n'score': 0.9078865051269531\n'normalizedScore': 0.8861306448605909\n'beforeDatePenaltyScore': 0.9078865051269531\n\n'documentId': '5ca564ac8c4557f4f949b660'\n'chunk_id': '687a2b82495b49563aa87acf'\n'access': 'restricted'\n'part_number': 3\n'total_parts': 9\n'contentType': 'RHEINGOLD'\n'title': Level-up your Angular Codebase with Cutting-Edge APIs\n'parentName': International JavaScript Conference Munich 2024\n'language': 'EN'\n'date': '2024-11-13T10:45:00.000Z'\n'abstract': The Angular team is propelling the enterprise frontend framework into a promising future with new, robust APIs. Modern concepts, validated in the JavaScript ecosystem, such as enhanced server-side rendering support, the new Control Flow syntax, Standalone APIs instead of NgModules, and optional RxJS, as well as Zone.js, are paving the way for a brighter future with an easier-to-manage codebase and an excellent developer experience. But how does this impact your current codebase? What refactoring strategy strikes the ideal balance between future-proofing and budget constraints? The reassuring news is that backward compatibility remains paramount. The pace at which you refactor your codebase to leverage the latest framework features is entirely your choice. Join my talk for a practical session where we explore these new APIs and discuss strategies to transform your code into a future-proof application.\n'parentId': 'R8y8tP2vbKi3twHpf'\n'parentDescription': The JavaScript Fullstack Conference - Angular, Node.js, React and more\n'indexBrandName': 'InternationalJavaScriptCon'\n'indexSeriesName': 'Munich'\n'author': 'Michael Egger-Zikes'\n'chunkSource': 'text'\n'text': 19. You might argue. Now that's not good Um, don't worry about that just add standalone falls to your other, uh, So the, the concept of angular working with the CLI that this is really nothing to worry. NG module, uh, based, uh, implementations uh, standalone APIs. uh, of a smart component. The smart component is engine module based, variables in general is all of them. This was, at the beginning at least, everyone expected components, but it turned out that we have right now, no matter whether or do already require the standalone API, so especially of your ad component decorator. if you want to switch your routing configuration, uh, and not, uh, engine modules anymore, they again, need to be standalone, Um, one day that they will come, clear guidance from the angular team, Uh, so we are, they will ask the community whether, uh, yet, but of course, we can expect one day in future, uh, so many years now. Um, so yes, definitely it will be necessary, um, uh, angular 15. or already, uh, production support for standalone. How can you do so? I will answer this in a moment. Um, Standalone features, uh, from existing engine modules by, uh, using, sorry, to implement new features, that's the point here. Don't, um, uh, use engine modules So try to, to implement new features already where, you know, that's an existing feature, Then consider, uh, turning that into, uh, support of migration? You cannot one So it's really a nice assistance, uh, compared at angular core standalone command. The first step is, um, of your repository you want to change. Yeah. So if you have a repository with several apps to generate the component in or the service in then you will find it's not the It's this time at angular core. Um, so that's also the reason why we typically choose the migration code, right? that would be the equivalent and you just tell the CLI, which package to use for that. And as mentioned, it's not a project like the project flag. to turn the whole repository with all apps or you want to dig deeper that application or only one feature of that application. to turn components, directives, pipes, um, where the module is currently located. And basically that's the thing that the CLI helps you with. uh, for you directly. So turning your, uh, feature based feature modules But this can be done quite easily manually, So whether it is safe to remove the feature module We have here repository So we have normal, uh, ENG modules, um, a boarding, g\n'slidetext': ''\n'from': 'vector'\n'score': 0.9060287475585938\n'normalizedScore': 0.8861827046431955\n'beforeDatePenaltyScore': 0.9060287475585938\n\n'documentId': 'N9G6dCb5BArvu6cbr'\n'chunk_id': '687a2d549bbcb45d2a11eac1'\n'access': 'restricted'\n'part_number': 14\n'total_parts': 23\n'contentType': 'RHEINGOLD'\n'title': Renovate your Angular App!\n'parentName': International JavaScript Conference San Diego 2024\n'language': 'EN'\n'date': '2024-05-21T12:30:00.000Z'\n'abstract': The Angular Team is currently pushing the popular enterprise frontend framework into a bright future. New APIs proved to be solid in the JavaScript ecosystem and quicker start-up time introduced more advanced server-side rendering support. Combined with the new Control Flow syntax, it feels like a perfect joint venture between Svelte and .NET. The Standalone APIs make NgModules optional too. RxJS and Zone.js won't be a mandatory dependency in the future anymore. But what does this mean for your current codebase? Which refactoring strategy is the best compromise between good preparation for the future and tight project budgets? The good news is that all of this comes with backward compatibility in mind. It is your decision which pace to use to refactor your codebase to the latest framework features. In a practical session, we'll discuss those new APIs and discover ways to transform your code into a future-proof application.\n'parentId': 'BYZWRge2q657D9ZYR'\n'parentDescription': The Fullstack Conference for JS Development\n'indexBrandName': 'InternationalJavaScriptCon'\n'indexSeriesName': 'SanDiego'\n'author': 'Michael Egger-Zikes'\n'chunkSource': 'text'\n'text': implemented with normal APIs as we use them before angular, even 14 maybe. Uh, and the rest of the application or the child component can be implemented with signals. Also, the other ways allow them internally using input output decorators in the parent and, uh, signals suppose is fine. Okay, so let's turn back to the slides. Uh, what about the route integration? Um, we can use, um, uh, a route of configuration. Um, and, uh, instead of the feature module, we are using an array right now. Um, that means, um, often not that much to refactor because, uh, if you already generated your feature modules, feature routing modules, um, with the Angular CLI, so, uh, NG generate module minus, minus routing, then it already created a feature routing module and had already, uh, a rooting constant for your arrays. So in this case, you just need to get rid of the module part and can reuse the array that is already present and provide the, um, array through lazy loading. And on the root level, we are using provide router, so provide router to, uh, actually hand over the, um, configuration on the root scope. Um, we can also use the Ford exports. So that's basically a nice thing to get rid of the, um, of the dense statements in your lazy loading load children configuration or load component configuration. Um, and, uh, we can also use a quiet nice, a really loved feature component input bindings, that's a feature for the angular router. Um, in the past, uh, without, uh, that feature, we needed to, uh, inject the activated route to get access to UL parameters or also, um, resolver data or static root data. All of that was only present through the activated route and we needed to inject it and subscribe to observers and all that stuff. Um, this time we can really use, um, the route to map, um, all those parts. So there are specific priority order on query parameters, dynamic parameters of the UL data block in the routing configuration and resolver data. Uh, and basically, um, if the route finds something with that name, with that respective name, for example, I'm interested in the id, then I have an ID input binding, and it works with input decorators, but also with input signal functions, both this, um, supported by the feature. So if someone, if the root of finds a respective property in the target component and there's something in the URL or in the rooting configuration that matches the exact name, then it automatically sets the input. So in the past, it was not very helpful to have input properties for root able\n'slidetext': ''\n'from': 'vector'\n'score': 0.9156763553619385\n'normalizedScore': 0.8861904722683311\n'beforeDatePenaltyScore': 0.9156763553619385\n\n'documentId': 'XE4Euthn2BEnPwhbr'\n'chunk_id': '687a2eed9bbcb45d2a11fb63'\n'access': 'restricted'\n'part_number': 1\n'total_parts': 1\n'contentType': 'FLEX_CAMP'\n'title': Lektion 6: Routing | verfügbar bis 06.10.2024\n'parentName': Angular Camp - Flexible Basic Camp September 2024 | online\n'language': 'DE'\n'date': '2024-09-23T06:00:00.000Z'\n'abstract': Der Router ist der Dreh-und-Angelpunkt der meisten Angular-Anwendungen. Er simuliert Seiten innerhalb einer Single-Page-Application und erlaubt Deep-Linking.\n'parentId': 'xBQz8C6wGGBZCG99t'\n'parentDescription': Das Angular Training für Einsteiger:innen mit Manfred Steyer im zeitlich flexiblen Online-Format\n'indexBrandName': 'AngularCamp'\n'indexSeriesName': 'FlexibleBasicCamp'\n'author': 'Manfred Steyer'\n'chunkSource': 'text'\n'text': Lektion 6: Routing | verfügbar bis 06.10.2024 Der Router ist der Dreh-und-Angelpunkt der meisten Angular-Anwendungen. Er simuliert Seiten innerhalb einer Single-Page-Application und erlaubt Deep-Linking.\n'slidetext': ''\n'from': 'vector'\n'score': 0.9090116620063782\n'normalizedScore': 0.8863602537948104\n'beforeDatePenaltyScore': 0.9090116620063782\n\n'documentId': '04d78d5f018fc264533778bd'\n'chunk_id': '687a2114a98d5a30b3a341b0'\n'access': 'restricted'\n'part_number': 3\n'total_parts': 9\n'contentType': 'RHEINGOLD'\n'title': The Power of Angular’s Dependency Injection and Directives\n'parentName': International JavaScript Conference Munich 2024\n'language': 'EN'\n'date': '2024-11-12T13:15:00.000Z'\n'abstract': The Angular framework's built-in Dependency Injection (DI) mechanism has been integral since its inception, earning praise from the JavaScript ecosystem. While DI is commonly used for root-scoped services, its versatility extends beyond this. In this in-depth talk, developers will gain practical insights to unlock Angular's DI system fully.From understanding provider hierarchies to utilizing Dependency Injection for customizing your application, attendees will enhance their personal Angular toolbox. Additionally, we'll demystify the Injection tree, clarifying Injector node lifecycles and utilization. Directives are seamlessly integrated to imbue your Components with a generic, reusable approach by locally adding Providers.Join me as we explore Angular's Dependency Injection system practically to streamline your development workflows for greater efficiency.\n'parentId': 'R8y8tP2vbKi3twHpf'\n'parentDescription': The JavaScript Fullstack Conference - Angular, Node.js, React and more\n'indexBrandName': 'InternationalJavaScriptCon'\n'indexSeriesName': 'Munich'\n'author': 'Michael Egger-Zikes'\n'chunkSource': 'text'\n'text': CP client. I can even say disable my initial navigation. Yeah. Um, so basically we can tell the router, Hey, to specify some config. and is then automatically configured. we have quite a bunch of demos. because of all of those demos we have. zoom out a little bit Is this fine or Yeah, let's see. I turn my application quite small Then I just reload my application and then we are fine. and we can already see the dome structure here angular implementations, right? So why is there a list item? because that directive creates an injector node, added, um, to the dome. and components that are visibly. Give me a second. We have the whole the environment injector hierarchy, We had this on the previous slide, right? and if I further zoom out so that we can see the, dynamic tree changes. that it, yeah, it moves to the right. Yeah, those are the nodes So, um, but really zooming in again, we can see there is, otherwise we cannot grab the correct nodes. Like once again, I guess I, I hit one of the nodes and Yeah, it seems maybe it's a back in the, There's a router outlet, and that's really annoying. Yeah, I can't actually, I picked one of the last notes. move in the right direction. We have a, a engine style note here. structural directive, um, uh, components, uh, everything Be aware that part here, the element in chapter three, the one that stays in the do. therefore the injector node for the respective on a component level can lead on one hand again, it's recreated. to be loaded twice, with the very same configuration. the libraries back then, um, we are not, uh, that they were not correctly implemented. um, that back then you just never added a module Today we use providers instead of the od. providers array of the component. So they introduced typing the, so-called, uh, environment, can only be used for environment injector node. or in a lazy engine module. So it would just give you the feedback. Yeah, so those are the environment so-called NI injector as well. Give me a second. Um, so basically same again. it has a root node, then, um, then the, Uh, and then we have the platform scope. angular platform specific stuff. and then inside that platform, one I'm a hundred percent sure you all know that injector node, If you forget to provide a dependency service is never provided. then you receive the Nile injector So the top most is responsible only for throwing the errors. then it goes one level up, next\n'slidetext': ''\n'from': 'vector'\n'score': 0.9068311452865601\n'normalizedScore': 0.8869360156131709\n'beforeDatePenaltyScore': 0.9068311452865601\n\n'documentId': '5ca564ac8c4557f4f949b660'\n'chunk_id': '687a2b82495b49563aa87ace'\n'access': 'restricted'\n'part_number': 2\n'total_parts': 9\n'contentType': 'RHEINGOLD'\n'title': Level-up your Angular Codebase with Cutting-Edge APIs\n'parentName': International JavaScript Conference Munich 2024\n'language': 'EN'\n'date': '2024-11-13T10:45:00.000Z'\n'abstract': The Angular team is propelling the enterprise frontend framework into a promising future with new, robust APIs. Modern concepts, validated in the JavaScript ecosystem, such as enhanced server-side rendering support, the new Control Flow syntax, Standalone APIs instead of NgModules, and optional RxJS, as well as Zone.js, are paving the way for a brighter future with an easier-to-manage codebase and an excellent developer experience. But how does this impact your current codebase? What refactoring strategy strikes the ideal balance between future-proofing and budget constraints? The reassuring news is that backward compatibility remains paramount. The pace at which you refactor your codebase to leverage the latest framework features is entirely your choice. Join my talk for a practical session where we explore these new APIs and discuss strategies to transform your code into a future-proof application.\n'parentId': 'R8y8tP2vbKi3twHpf'\n'parentDescription': The JavaScript Fullstack Conference - Angular, Node.js, React and more\n'indexBrandName': 'InternationalJavaScriptCon'\n'indexSeriesName': 'Munich'\n'author': 'Michael Egger-Zikes'\n'chunkSource': 'text'\n'text': managing quite a bunch of things for us. Um, and that's basically a thing that that helps us So with, uh, Angola 14, they introduced, um, having a new API that works, again, compatible side by side, in, uh, NG modules. Uh, control flow is an API that, uh, makes, uh, with Angola 16, um, as a, as a first version, um, Not all the parts or the APIs are stable right now. and hydration, that's, uh, moved much closer, uh, Does everyone need server-side rendering? So also as, uh, a feature that, um, they worked on introducing a new build tool with the that dramatic breaking changes. Um, but at the end, um, a lot but it was also a quite solid story or is still one. for signals like supporting data access scenarios, um, Uh, what's the news about about that? what you should work on right now I'm working in the Angular to pronounce for in almost every language, including German. and I'm happy to speak at conference conferences like this. and always happy to help with other, um, customers in, or have, they will call it in future. to discussions on social media platforms. you know, platform effect So if you like, um, my talks, then maybe one a new format using the new APIs. Uh, so let's get back to the topic. to the Angular team, um, a company enterprise, uh, with quite a, uh, quite a bunch to stay backwards compatible, in the other direction. That means if they would try to keep it but keep everything as it is, likely there would be a threat there's more going on in the React ecosystem, to a different tech stack, let's do that On the other hand, if you do innovation, different concepts found a really nice sweet spot in between of innovating, Engine modules, no signals, RXGS usage. Yeah. that you never need to, to upgrade your applications to upgrade your code base in future. of your companies, um, need to be aware of. That's also one thing that we as a developer, uh, need for the company, uh, possible as well. So if they say, no, we don't, we don't like the, They also have breaking changes. Same for you. Yeah. Fine. clearly set a replacement for engine modules. And this will change with Angola 19. You might argue. Now that's not good Um, don't worry about that just add standalone falls to your other, uh, So the, the concept of angular working with the CLI that this is really nothing to worry. NG module, uh,\n'slidetext': ''\n'from': 'vector'\n'score': 0.9087773561477661\n'normalizedScore': 0.888931313233002\n'beforeDatePenaltyScore': 0.9087773561477661\n\n'documentId': 'hzv9J8cq9SXBKG4bM'\n'chunk_id': '687a3240ca798166d3ba4f14'\n'access': 'restricted'\n'part_number': 1\n'total_parts': 1\n'contentType': 'FLEX_CAMP'\n'title': Lektion 6: Routing | verfügbar bis 01.12.2024\n'parentName': Angular Camp - Flexible Basic Camp November 2024 | online\n'language': 'DE'\n'date': '2024-11-18T07:00:00.000Z'\n'abstract': Der Router ist der Dreh-und-Angelpunkt der meisten Angular-Anwendungen. Er simuliert Seiten innerhalb einer Single-Page-Application und erlaubt Deep-Linking.\n'parentId': 'gum8pjxG5By6f2Fqv'\n'parentDescription': Das Angular Training für Einsteiger:innen mit Manfred Steyer im zeitlich flexiblen Online-Format\n'indexBrandName': 'AngularCamp'\n'indexSeriesName': 'FlexibleBasicCamp'\n'author': 'Manfred Steyer'\n'chunkSource': 'text'\n'text': Lektion 6: Routing | verfügbar bis 01.12.2024 Der Router ist der Dreh-und-Angelpunkt der meisten Angular-Anwendungen. Er simuliert Seiten innerhalb einer Single-Page-Application und erlaubt Deep-Linking.\n'slidetext': ''\n'from': 'vector'\n'score': 0.9090287685394287\n'normalizedScore': 0.8894481365835687\n'beforeDatePenaltyScore': 0.9090287685394287\n\n'documentId': '5ca564ac8c4557f4f949b660'\n'chunk_id': '687a2b82495b49563aa87acd'\n'access': 'restricted'\n'part_number': 1\n'total_parts': 9\n'contentType': 'RHEINGOLD'\n'title': Level-up your Angular Codebase with Cutting-Edge APIs\n'parentName': International JavaScript Conference Munich 2024\n'language': 'EN'\n'date': '2024-11-13T10:45:00.000Z'\n'abstract': The Angular team is propelling the enterprise frontend framework into a promising future with new, robust APIs. Modern concepts, validated in the JavaScript ecosystem, such as enhanced server-side rendering support, the new Control Flow syntax, Standalone APIs instead of NgModules, and optional RxJS, as well as Zone.js, are paving the way for a brighter future with an easier-to-manage codebase and an excellent developer experience. But how does this impact your current codebase? What refactoring strategy strikes the ideal balance between future-proofing and budget constraints? The reassuring news is that backward compatibility remains paramount. The pace at which you refactor your codebase to leverage the latest framework features is entirely your choice. Join my talk for a practical session where we explore these new APIs and discuss strategies to transform your code into a future-proof application.\n'parentId': 'R8y8tP2vbKi3twHpf'\n'parentDescription': The JavaScript Fullstack Conference - Angular, Node.js, React and more\n'indexBrandName': 'InternationalJavaScriptCon'\n'indexSeriesName': 'Munich'\n'author': 'Michael Egger-Zikes'\n'chunkSource': 'text'\n'text': Level-up your Angular Codebase with Cutting-Edge APIs The Angular team is propelling the enterprise frontend framework into a promising future with new, robust APIs. Modern concepts, validated in the JavaScript ecosystem, such as enhanced server-side rendering support, the new Control Flow syntax, Standalone APIs instead of NgModules, and optional RxJS, as well as Zone.js, are paving the way for a brighter future with an easier-to-manage codebase and an excellent developer experience. But how does this impact your current codebase? What refactoring strategy strikes the ideal balance between future-proofing and budget constraints? The reassuring news is that backward compatibility remains paramount. The pace at which you refactor your codebase to leverage the latest framework features is entirely your choice. Join my talk for a practical session where we explore these new APIs and discuss strategies to transform your code into a future-proof application. Um, I'm giving you a talk today about Angola again, quite nice, and we, the architects mantra already gave him No, we are not talking about shell symbolize a little bit older, tiny, nice, the new wave of features started actually, um, refactoring, uh, the rendering engine Ivy, you know. to make this compatible also internally for Google. It's like a, a surgery on the open heart, right? So they really learned out of the, I would might even say, The whole community was angry about that. to do this completely in a different way, So not the Angular bubble, only and maybe only with Angola. and the React people are thinking the same. So JavaScript experts and how the Angular team is meanwhile, um, trying, Uh, this is actually part of my presentation today. which new feature was added. Uh, people are not sure which APIs they need to implement one of the APIs that we're currently working and of course, questions are always welcomed. then feel free to ask. to the table that we can use right now So with Angular 13, they also did a quite important change, So Angular is a modern framework, As their, uh, support for Internet Explorer dropped out, um, of polyfils, although there was already a possible solution separately compiled. but, um, it, it turned out to be a good one. they introduced Atmos script models for the browser. Uh, if there are Atmos script models The CLI is managing quite a bunch of things for us. Um, and that's basically a thing that that helps us So with, uh, Angola 14, they introduced, um, having a new API that works, again, compatible side by side, in, uh,\n'slidetext': ''\n'from': 'vector'\n'score': 0.9100843667984009\n'normalizedScore': 0.890238323884271\n'beforeDatePenaltyScore': 0.9100843667984009\n\n'documentId': '73a55b4bbeecf374b233deaf'\n'chunk_id': '687a299f2491ed518a3f0cf6'\n'access': 'restricted'\n'part_number': 1\n'total_parts': 1\n'contentType': 'RHEINGOLD'\n'title': Angular’s New Era: Unveiling the Most Exciting Features Yet\n'parentName': International JavaScript Conference Singapore 2024\n'language': 'EN'\n'date': '2024-11-27T09:15:00.000Z'\n'abstract': In this session, we'll explore the groundbreaking features of Angular that are transforming the way we build modern web applications. From a simplified developer experience for creating new apps to standalone components that improve modularity, Angular is stepping up its game. We’ll dive into lazy loading for routes and components, optimizing performance and load times, and explore the power of control flow for dynamic, responsive UIs. Discover the magic of deferrable views that help you prioritize critical content, and get an inside look at signals—a new, reactive paradigm for managing state and change detection. We’ll also uncover the potential of zoneless Angular, offering maximum performance by reducing overhead, and take a peek into some of the forthcoming features that promise to shape the future of Angular development. Join us to discover how these game-changing features can take your Angular apps to the next level.\n'parentId': 'gdaJCohaAMyedJZCT'\n'parentDescription': The JavaScript Fullstack Conference - Angular, Node.js, React and more\n'indexBrandName': 'InternationalJavaScriptCon'\n'indexSeriesName': 'Singapore'\n'author': 'Pankaj Parkar'\n'chunkSource': 'text'\n'text': Angular’s New Era: Unveiling the Most Exciting Features Yet In this session, we'll explore the groundbreaking features of Angular that are transforming the way we build modern web applications. From a simplified developer experience for creating new apps to standalone components that improve modularity, Angular is stepping up its game. We’ll dive into lazy loading for routes and components, optimizing performance and load times, and explore the power of control flow for dynamic, responsive UIs. Discover the magic of deferrable views that help you prioritize critical content, and get an inside look at signals—a new, reactive paradigm for managing state and change detection. We’ll also uncover the potential of zoneless Angular, offering maximum performance by reducing overhead, and take a peek into some of the forthcoming features that promise to shape the future of Angular development. Join us to discover how these game-changing features can take your Angular apps to the next level.\n'slidetext': ''\n'from': 'vector'\n'score': 0.9106927514076233\n'normalizedScore': 0.8916104071236304\n'beforeDatePenaltyScore': 0.9106927514076233\n\n'documentId': '57ca0d48729b52fa55c618a2'\n'chunk_id': '68baebf1c846ad0013b2721b'\n'access': 'restricted'\n'part_number': 12\n'total_parts': 19\n'contentType': 'RHEINGOLD'\n'title': The Art of Testing\n'parentName': International JavaScript Conference London 2025\n'language': 'EN'\n'date': '2025-05-14T08:30:00.000Z'\n'abstract': The question of how to test effectively often sparks debate. Many of us are familiar with the testing pyramid, where the emphasis traditionally falls on unit tests because they are fast and efficient. However, with advances in technology and lessons learned from experience, the industry seems to have reached a consensus: the days of the testing pyramid are behind us. The focus has shifted more toward the middle of the pyramid. In this talk, I’ll explore the reasoning behind this shift with objective insights and a live-coding demo to illustrate the practical implications.\n'parentId': 'a1b41ab44fd3e90faf564397'\n'parentDescription': The JavaScript Fullstack Conference - Angular, Node.js, React and more\n'indexBrandName': 'InternationalJavaScriptCon'\n'indexSeriesName': 'London'\n'author': 'Rainer Hahnekamp'\n'chunkSource': 'text'\n'text': should load, it needs to go to the route to the URL. And in the URL there is always an ID available. So you see this, um, here it says quiz for holiday ID 16. And um, I say okay, if the ID comes from the URL, then I don't want to again work around the URL or or around the routing service. I'm just going to set up here a particular URL where the routing configuration. And then I hope again that angular provides me something which allows me to um, deal with this routing stuff very easily, which Anglia is doing. So you don't see here anything in terms of I'm overriding the template, I leave the imports as they are. I also don't do anything with the quiz store. I just leave it. I say all these things should be included and then I want to have the component. But I'm not saying here create component because I say I want to navigate to this component. And here Angular provides us something which is called the router testing harness. So it says, given the routing configuration that you have, if you say router testing, harness create, I'm simulating for you. So I have something in my testing framework which says I can simulate the behavior of a routing navigation together with the way how it works with a component exactly as it would be in the application. It is very important that Angular provides this because they know how the routing system works. If we write this, then we could make very quickly errors 'cause we don't know all the details, but in this case, angular says if you use the router testing harness, you can be sure your component behaves like in real life. So I say here I wanna navigate to quiz one, then the first thing that my quiz component should do is that it should start to request data for my quiz. And then again, we have here another fake, in this case it's testing controller, meaning the end in angular. You just, you, these are the main two things. We see them already right here. And with the testing controller, I can say expect one. So I'm expecting that this request happens and then I wanna return here this data. So I'm not really caring about what the quiz store is doing. Again, I'm just saying this is the response when somebody, uh, requests the data and then I say again, angular now has to do some work. There might be some asynchronous tasks which have been executed. I don't know, to be honest, I don't even care. I just say angular. You do know whatever you think you have to do. And if\n'slidetext': ''\n'from': 'vector'\n'score': 0.9094759821891785\n'normalizedScore': 0.899597405027839\n'beforeDatePenaltyScore': 0.9094759821891785\n\n'documentId': '1fed2c6361980d606789e315'\n'chunk_id': '68c26fcc0a53cd001394ab93'\n'access': 'granted'\n'part_number': 3\n'total_parts': 8\n'contentType': 'READ'\n'title': Manfred Steyer on Angular 20: Signals, Dynamic Components, AI, and What’s Next - Exploring selectorless components, signal-based forms, and other features in Angular\n'parentName': iJS Magazine Volume 19\n'language': 'EN'\n'date': '2025-06-24T22:00:00.000Z'\n'abstract': In this interview, GDE Manfred Steyer highlights Angular’s journey towards a more reactive future. We discuss the framework’s strengths, challenges, and what’s ahead with the release of Angular 20.\n'parentId': 'a1269c65e87d5b8ebcde4b28'\n'parentDescription': Broaden your knowledge and expand your JavaScript techniques and practices. From Angular, React, and WebAssembly, to the best JavaScript IDEs, open source tools and more, you’ll learn insights on everything JS from seasoned experts in their field. Keep up with JavaScript news, tips, and advice with interviews, tutorials, and in-depth articles.\n'indexBrandName': ''\n'indexSeriesName': ''\n'author': 'Manfred Steyer'\n'chunkSource': 'text'\n'text': beta stages. Around that time, I also began consulting companies on adopting Angular 2. Ines Chargui: How would you describe the Angular journey? After everything that the framework went through, is it on the right track? Does it disappoint sometimes? Manfred Steyer: I think it's really on the right track. The Angular team has consistently proven that the underlying philosophy and the whole architecture pay off. It allows Angular to reinvent itself underneath the covers. We don't see a lot of those reinventions, but Angular manages to keep up with all of the innovations out there, at least all the ones important for single-page applications or web applications in general. Just one example: several years ago, they switched out the whole rendering engine for the new Ivy engine. That happened largely behind the scenes, with no major breaking changes, effectively giving us a modernized framework without the usual migration pain. Now, Angular is doing it again. NgModules are optional, zones are becoming optional, and we’re getting a new set of reactivity primitives with Signals. All of this works without breaking changes. Existing code continues to work, which is very important in enterprise environments, where applications are expected to be maintained for years or even decades. Reinvention without disruption is the theme behind Angular, and so far, it’s proven it can deliver on that promise. Ines Chargui: With the upcoming release of Angular 20 on May 28, 2025, what features or improvements are you most excited about exploring? Manfred Steyer: Well, the Signal story will evolve. Many building blocks, such as effects or the RxJS interop will become stable. The Resource API that fetches data within the reactive Signal-based flow will transition to developer preview. The same is the case for Incremental Hydration, Hybrid Routing, and Zone-less Change Detection. Ines Chargui: What do you think about these features in developer preview? Have you experimented with any of these? Manfred Steyer: Absolutely. I was an early adopter of the reactivity features like the Resource API and linked signals. For me, they have always been necessary, even though they were experimental, because they were filling a gap in Angular’s reactivity story. Without them, when working only with Signals, for instance, there is no way to do data fetching as part of the reactive flow. For this, we need resources and a brand new HTTP resource; the linked signal gives us a local working copy. For example, this is necessary when binding read-only data from a store into a template-driven form. Since forms need to update values, and read-only signals can’t be changed directly, linked\n'slidetext': ''\n'from': 'vector'\n'score': 0.9096366763114929\n'normalizedScore': 0.9020354964104275\n'beforeDatePenaltyScore': 0.9096366763114929\n\n'documentId': '74929d5c8003451930366f98'\n'chunk_id': '6903455752f58e0014b29b84'\n'access': 'granted'\n'part_number': 10\n'total_parts': 16\n'contentType': 'RHEINGOLD'\n'title': The Supreme Discipline of Micro Frontends: Multi-Version and Multi-Framework Scenarios\n'parentName': International JavaScript Conference Munich 2025\n'language': 'EN'\n'date': '2025-10-29T14:15:00.000Z'\n'abstract': Micro frontends are especially appealing for large enterprise solutions, as they grant individual teams more autonomy — bringing the agility of small, fast-moving teams to even the most complex projects. Things get truly challenging, however, when different versions and frameworks need to coexist. In this session, we’ll explore the key challenges and present practical solutions, with a strong emphasis on using web standards to ensure long-term maintainability. By the end of this talk, you’ll understand how to combine different versions and frameworks in your micro frontend architecture, what implications this has, and how to overcome the associated challenges.\n'parentId': 'd9a5c0715a7cff50bbb51e14'\n'parentDescription': \n'indexBrandName': 'InternationalJavaScriptCon'\n'indexSeriesName': 'Munich'\n'author': 'Manfred Steyer'\n'chunkSource': 'text'\n'text': we don't do this lightly. There are some challenges that are solvable, but there are some challenges we need to think of. For instance, when we are using Angular, there is the zone chairs, and if you really have a fine-grained integration. Between your web components, then you need to make sure you only instantiate Sojas ones. This is doable. Sharingone shares via the global name space is doable. Then we just have it once. And you know, if I'm saying global name space, I'm referring to the window object, yeah. We can do the same with the platform object if not going with standalone components in Angular. We just need to implement or not implement to instantiate a platform object like browser platform, server platform, and there is a limitation in there. We can only instantiate the platform object once per version. And also this means once instantiated we need to share it somehow, for instance, also here via the global name space. That means when bootstrapping the application we need to check is already a platform object in place. If yes, take it. If no, create another one, use it, and put it into the global name space. And as discussed before, for combining several routers, we need to tweak the routers a bit, we need to tell the router, well, please only look at those segments and you only look at the further segments. Yeah, Angola is a bit special in there, but I have a good message for you. With more than angular, option 1 and option 2 is gone, because with more than angular, since angular 20.2, we are zone less by default. Zone less is stable meanwhile, and when we go with standalone components, we don't need to deal with this platform object anymore. So this is really a beautiful addition to Angular that really, really helps us here in the space of micro front ends. We still need to deal with the meta routing, with configuring all the routers, and this is regardless whether we are using Angular or React or Few or Svelt or something else. OK, so this is a solution that works quite well in a lot of huge companies we are supporting companies with let's say 80 teams around the globe, 100 teams around the globe, and larger. However, there are some alternatives. There are always alternatives, and the nice part of this, and this really brings us to the core of what software architecture is, all the alternatives have their very own advantages and disadvantages. There are always trade-offs here, and so we need to find out which trade-offs are more or less suitable for our goals.\n'slidetext': ''\n'from': 'vector'\n'score': 0.9060550928115845\n'normalizedScore': 0.9053951229555469\n'beforeDatePenaltyScore': 0.9060550928115845\n\n'documentId': '918dc8a09612c28c04090931'\n'chunk_id': '68f25086d754e200146e6f0a'\n'access': 'restricted'\n'part_number': 16\n'total_parts': 16\n'contentType': 'RHEINGOLD'\n'title': Scaling Node.js Applications with NestJS: Patterns for Clean Architecture and High Performance\n'parentName': International JavaScript New York 2025\n'language': 'EN'\n'date': '2025-09-30T15:15:00.000Z'\n'abstract': NestJS is changing how we build scalable, maintainable Node.js applications. This session explores how its modular architecture, dependency injection, and declarative programming style simplify complex systems. Learn proven patterns for clean architecture and performance gains, plus how these practices naturally enable smoother AI-assisted development workflows.\n'parentId': '9f97d5cdc68d72a05f834df4'\n'parentDescription': The JavaScript Fullstack Conference - Angular, Node.js, React and more\n'indexBrandName': 'InternationalJavaScriptCon'\n'indexSeriesName': 'NewYork'\n'author': 'Tyler Steck'\n'chunkSource': 'text'\n'text': all the benefits that we were getting there, that they wanted a node framework that was just as similar to Angular on how to orchestrate that. And the dependency injection yeah, is definitely, um, a lot to be wanted there. I don't know if they are or are not. I don't know the specifics on that of the future of dependency injection with following angulars foot track footstep. Any other questions? All right. Was this helpful? Good. Actually, today, that was rough. Hey, that's, that's all right. You gotta do it for the people for watch it later, you know? Yes. My first question.\n'slidetext': ''\n'from': 'vector'\n'score': 0.907709002494812\n'normalizedScore': 0.9054622746485411\n'beforeDatePenaltyScore': 0.907709002494812\n\n'documentId': '5047e9550eef9d941aaa1376'\n'chunk_id': '690347ae52f58e0014b29b92'\n'access': 'granted'\n'part_number': 7\n'total_parts': 22\n'contentType': 'RHEINGOLD'\n'title': AI-powered Angular Apps\n'parentName': International JavaScript Conference Munich 2025\n'language': 'EN'\n'date': '2025-10-30T08:00:00.000Z'\n'abstract': Artificial intelligence is increasingly becoming part of our daily lives. For software developers, this opens up new opportunities — from writing source code to refactoring it. In this talk, we focus on how AI can enhance Angular frontends at runtime. How can a new micro-frontend be discovered and integrated with the help of AI? How can routing be extended using natural language, and how can the navigation bar be updated accordingly? How can new views be seamlessly integrated into an existing application? The combination of generic programming, micro-frontend architectures, and large language models (LLMs) paves the way for a new era of software development — enabling applications to be extended in specific areas without requiring deep technical expertise. This talk is aimed at software developers, architects, and technical managers who want to learn more about the interplay between artificial intelligence and web-based enterprise UIs.\n'parentId': 'd9a5c0715a7cff50bbb51e14'\n'parentDescription': \n'indexBrandName': 'InternationalJavaScriptCon'\n'indexSeriesName': 'Munich'\n'author': 'Michael Egger-Zikes'\n'chunkSource': 'text'\n'text': because it's, it's not that funny to always copy over the one feature to the next subfolder and just change, uh, two or three names. Uh, sometimes generic programming, of course, affords, um. More knowledge about the framework, quite often more knowledge about angulars dependency injection, but on the other hand it's really nice if you write a generic API because uh having such an implementation that you can configure. Um, with just this chasing structure is quite something that can save a lot of time for the future, yeah, so if you have similar use cases, uh, like adding links over time in this case, um, changing, uh, form definitions, uh, during the run time, and many other things, uh, all of that is possible with quite similar approaches. Um, this time as mentioned dynamic navigation and routing, um, basically, uh, we build, uh, uh, implementation here that that supports exactly this some parts of the of the angular router, some custom services, um, provider functions that can configure your angular application that way. Um, I have a chasing-based configuration you already saw that, um, in, uh, this case for the, for the initial configuration part of the asset folder could also be a real API, yeah, then of course the, the form. Uh, not the form structure, navigation structure that that was basically generated with help of the large language model can then also be written back to the server. That means after reload you have already the, uh, the updated, uh, configuration in my case, in case it's, um, at the moment for simplicity reasons just a simple, uh, JSON file, but of course you could use your own back end written in any language that you like, uh, returning such a JSN structure. Um, we have some dynamic router features applied here. We have a dynamic sidebar implementation. So those, those are the two, generic implementations that we use here. On one hand, a custom component, um, that knows nothing about the navigation links, about your domains, about the features, um, it just, uh, offers you a way, um, to display links in the sidebar. So it's basically a combination of a generic component and a service that provides a state that can be configured over time, yeah, either by loading the initial uh chasten definition or later on uh by using the um result what the large language model actually returned. Um, we have a loading configuration for that, so some loaders you can decide what you need actually. Um, don't overengineer your applications if you say it's, uh, ask for my use cases that I have this declarative structure made available\n'slidetext': ''\n'from': 'vector'\n'score': 0.906197726726532\n'normalizedScore': 0.9055782819846497\n'beforeDatePenaltyScore': 0.906197726726532\n\n'documentId': '5047e9550eef9d941aaa1376'\n'chunk_id': '690347ad52f58e0014b29b8e'\n'access': 'granted'\n'part_number': 3\n'total_parts': 22\n'contentType': 'RHEINGOLD'\n'title': AI-powered Angular Apps\n'parentName': International JavaScript Conference Munich 2025\n'language': 'EN'\n'date': '2025-10-30T08:00:00.000Z'\n'abstract': Artificial intelligence is increasingly becoming part of our daily lives. For software developers, this opens up new opportunities — from writing source code to refactoring it. In this talk, we focus on how AI can enhance Angular frontends at runtime. How can a new micro-frontend be discovered and integrated with the help of AI? How can routing be extended using natural language, and how can the navigation bar be updated accordingly? How can new views be seamlessly integrated into an existing application? The combination of generic programming, micro-frontend architectures, and large language models (LLMs) paves the way for a new era of software development — enabling applications to be extended in specific areas without requiring deep technical expertise. This talk is aimed at software developers, architects, and technical managers who want to learn more about the interplay between artificial intelligence and web-based enterprise UIs.\n'parentId': 'd9a5c0715a7cff50bbb51e14'\n'parentDescription': \n'indexBrandName': 'InternationalJavaScriptCon'\n'indexSeriesName': 'Munich'\n'author': 'Michael Egger-Zikes'\n'chunkSource': 'text'\n'text': other social networks where you, uh, find some nice angular communities to connect and discuss all the new APIs. Um, we also offer workshops, so feel free to visit our, our website or join our workshop tomorrow here at the IAS conference. Uh, first of all, I would like to start directly with a demonstration. So, um, my demonstration is, uh, typically application that we normally use for training and consulting purpose. It's our flat application and it typically looks like that ready-made, uh, maybe in some. Um, implementations of this code base we have a hard coded sidebar with hard coded navigation links. In others, uh, I have already dynamic, uh, navigation links, but you can see it here, it claims to be a modern angular application, um, that teaches a bit about architecture, signal, signal forms, enterprise data management, and all the other stuff today also AI. Um, we can link on the site links here, uh, click on the sideper links here, uh, like, um, booking, check-in, boarding, all of that is possible, and of course the router then, um, does the router navigation. Some lazy loading happens behind the covers and so on. So that's, uh, typical application like you would, um. Uh Likely also implemented in in your own code base. Um, now let's take a bit, uh, deeper look into how the navigation structure looks like, and for that I have my shell application here. Uh, I love to have just a thin application layer, um, without subfolders, and everything that is then connected with the application is part of the library folder, uh, not necessarily always that fine grained like in an X repositories, but per feature group, per domain, however you would call it. Um, it's, it's quite nice to put this with a clear public API into the LIS folder, uh, but architecture is not the, the, the main topic, uh, for today. We have here our app routes, and as you can see here I will find, uh, uh. Default redirect for the empty pass, a home component, an admin component for an AI console that we will use later on, and the wildcat rod, but interestingly. I also have a booking, a check-in and the boarding navigation here and you can even see that's quite tiny here on the screen, um, but, uh, boarding departures or if I click on booking, uh, booking flight search for example, yeah, so the routing functionality works somehow but surprisingly those uh router objects do not exist in this routing configuration so um already um in this. Um, version of the application, there are some\n'slidetext': ''\n'from': 'vector'\n'score': 0.9064753651618958\n'normalizedScore': 0.9058559204200135\n'beforeDatePenaltyScore': 0.9064753651618958\n\n'documentId': '5047e9550eef9d941aaa1376'\n'chunk_id': '690347ae52f58e0014b29b95'\n'access': 'granted'\n'part_number': 10\n'total_parts': 22\n'contentType': 'RHEINGOLD'\n'title': AI-powered Angular Apps\n'parentName': International JavaScript Conference Munich 2025\n'language': 'EN'\n'date': '2025-10-30T08:00:00.000Z'\n'abstract': Artificial intelligence is increasingly becoming part of our daily lives. For software developers, this opens up new opportunities — from writing source code to refactoring it. In this talk, we focus on how AI can enhance Angular frontends at runtime. How can a new micro-frontend be discovered and integrated with the help of AI? How can routing be extended using natural language, and how can the navigation bar be updated accordingly? How can new views be seamlessly integrated into an existing application? The combination of generic programming, micro-frontend architectures, and large language models (LLMs) paves the way for a new era of software development — enabling applications to be extended in specific areas without requiring deep technical expertise. This talk is aimed at software developers, architects, and technical managers who want to learn more about the interplay between artificial intelligence and web-based enterprise UIs.\n'parentId': 'd9a5c0715a7cff50bbb51e14'\n'parentDescription': \n'indexBrandName': 'InternationalJavaScriptCon'\n'indexSeriesName': 'Munich'\n'author': 'Michael Egger-Zikes'\n'chunkSource': 'text'\n'text': was available, so full lazy loading support. That's important here. Somewhere you need to have those, uh, dynamic imports referenced because that's the only way that the compiler, uh, can split off the bundles and basically create different bundles for booking, checking, and boarding, right? And even. Uh, Additional bundles if they have common dependencies and so on, so the, the normal chunking process of Angular, but this time not in the routing configuration. So I can just look up this constant here and then, uh, by, uh, choosing the name booking, uh, I have a function available that I can then use in a dynamically generated routing object and that's basically what's happening here. I created a provide dynamic navigation function that you already saw here in the app config so that was the sync. That I showed you before where we pointed to the to the Jason file could also be your API. I pass in the app route without the booking check-in information and I pass in my dictionary with the lazy with the lazy features basically making all of that available. Uh, we first of all provide the navigation service so that we can use this for state management for a sidebar, and then I have just an app initializer logic so it waits, um, as the angular application bootstraps until, um, everything is available, meaning in this case the configuration file was loaded so that it can use its state. To configure the route, yeah, so basically it it's use the HTTPPI and um it connects to the back end API um through that path that uh passed in here and then it does a little bit of object array transformations to filter out um those uh items that's uh that are part of the um of the navigation sidebar but maybe not part of the of the lazy configuration. Uh, here in the lazy features, so for example the home component, right, so if we look inside them. Maybe let's put this here side by side. Then you can see we have here configuration for home for booking at the moment in the initial conflict and home is uh for example not part of the of the lazy loading uh configuration. So I have a logic applied here inside. Um, that, that can basically, uh, figure this out if there's no, um, lazy loading logic available then just, um, skip that and, and, uh, do not add it to the maybe to the sidebar but not, um, to the routing configuration because the home route is already available here hard coded in the, in the routing definition, yeah, um, what else is possible? I, um, tell my. Uh, implementation here to, um, also,\n'slidetext': ''\n'from': 'vector'\n'score': 0.9066430330276489\n'normalizedScore': 0.9060235882857667\n'beforeDatePenaltyScore': 0.9066430330276489\n\n'documentId': '0747f0655ef3790a97eba95b'\n'chunk_id': '68f24b683134c10012c3d12d'\n'access': 'restricted'\n'part_number': 2\n'total_parts': 16\n'contentType': 'RHEINGOLD'\n'title': How to architect Angular apps in 2025\n'parentName': International JavaScript New York 2025\n'language': 'EN'\n'date': '2025-10-01T08:15:00.000Z'\n'abstract': In this talk, Alain showcases several architecture concepts he uses to optimize apps for performance, readability, and scalability in 2025 and beyond. We’ll touch on using Signals as state in our services, how to control access to such Signals, using the new resource API, and more!\n'parentId': '9f97d5cdc68d72a05f834df4'\n'parentDescription': The JavaScript Fullstack Conference - Angular, Node.js, React and more\n'indexBrandName': 'InternationalJavaScriptCon'\n'indexSeriesName': 'NewYork'\n'author': 'Alain Chautard'\n'chunkSource': 'text'\n'text': done all continents except Antarctica because that's, that's tricky to, to find an audience there, but that's okay. So as I told you earlier, angular, and as you probably know, there's been a lot of things changing lately in the past two, three years, even more. It really started with signals version 16, and then everything kind of became crazy and faster in terms of pace of change. So I listed some of the main things that changed here. Uh, starting at V 14. We got standalone components 16, angular signals 17, the new control flow blocks, uh, 19 HTP resource V 20 is on as is stable. And V 21 coming soon, we we're gonna have signal forms. So that's a lot. And you can write Angular code today that looks nothing like what it would look like five years ago. Well, you, you'll still recognize things, but you can do things in a way that's completely different. So we'll see why these changes are happening, what's the motivation behind this and what the impact on our code and on, you know, what we, what we're supposed to do with this. So the main idea of the Angular team was really to make Angular easier to learn, easier to understand, easier to maintain. 'cause the thing is, this is an Angular talk. If you go to a React talk, there's gonna be more people. And the fact of the matter is, is that React has always advertised itself as the easier option, right? Easier to learn. It's fast. It's like jQuery, just add something, you can use it, blah, blah, blah. So Angular lasts a lot of audience to react because of that, mostly on kind of reputation I would say. But, um, and so that perceived difficulty is something that the Angular team is trying to fight against and say, no, angular is not that difficult. And so all of the things that's changed since V 14 are really going into that idea of, well, angular is actually easy to learn. We don't need to know that much about RXJS. You don't need to know about all of these extra things. You can start with the basics. So one of the things that started in the 14 was NG modules, right? Angular modules. It's one of the things that if you come into the Angular world, you're like, why do we have that? React doesn't have that view, doesn't have that. Why do we have NG modules in Angular? So standalone fixes that we remove NG modules pretty much, and you can just do your thing like you would do with other\n'slidetext': ''\n'from': 'vector'\n'score': 0.9085772037506104\n'normalizedScore': 0.9063692886897275\n'beforeDatePenaltyScore': 0.9085772037506104\n\n'documentId': 'ac8bcbad20150e9773f7400b'\n'chunk_id': '69021a60a5de460012a1af2b'\n'access': 'granted'\n'part_number': 11\n'total_parts': 11\n'contentType': 'RHEINGOLD'\n'title': Getting the most out of Angular DevTools\n'parentName': International JavaScript Conference Munich 2025\n'language': 'EN'\n'date': '2025-10-29T09:15:00.000Z'\n'abstract': In this session, we’ll dive into Angular DevTools and how it can enhance your development experience. From getting started with installation and setup to exploring the interface, you'll learn how to quickly get it running and connected to your Angular app. We’ll cover debugging techniques using the component tree, tracking state changes, and spotting binding issues. You’ll also get hands-on with performance profiling, learn how to identify rendering bottlenecks, and understand what the timeline panel is really telling you. A dedicated section on inspecting injectors will help demystify Angular’s dependency injection. Finally, we’ll wrap up with tips and hidden gems to help you get the most value from DevTools day to day. Whether you're new to Angular or a seasoned developer, this session will give you practical, actionable ways to make Angular DevTools an essential part of your workflow.\n'parentId': 'd9a5c0715a7cff50bbb51e14'\n'parentDescription': \n'indexBrandName': 'InternationalJavaScriptCon'\n'indexSeriesName': 'Munich'\n'author': 'Sam Vloeberghs'\n'chunkSource': 'text'\n'text': the signal graph, yeah. Yeah, so I had to repeat for, for the audience online, the question was if there uh. Is a, uh, if you're using a signal store, will it uh allow, will the angular dev tools allow you to uh click through to the sources of the um of the signal stores signal store directly. Yeah. Any other questions? If you're shy and don't want to ask your question in public, you can always uh ask me privately as well. Um. And uh yeah, please um provide your feedback uh in the uh conference application afterwards. Thank you. There are some Questions from the audience as well. Let me see. There's a question from the audience. Uh, I do not have the router tree tap. Uh, is my angular De Tools an old version? It could be, um, it could be that you're using an older version of your, uh, in your angular application as well. But the uh router tree. Uh, let me see. Is a feature that you need to enable explicitly. So it's not enabled by default. You can use the top level, um, let me. Share my full screen. So the router tree is a feature that you'll need to explicitly enable. All right. Thank you.\n'slidetext': ''\n'from': 'vector'\n'score': 0.908271074295044\n'normalizedScore': 0.9075996889145265\n'beforeDatePenaltyScore': 0.908271074295044\n\n'documentId': 'a980d2604065cad105b1bfaa'\n'chunk_id': '687abc062be886398c2b0218'\n'access': 'granted'\n'part_number': 1\n'total_parts': 9\n'contentType': 'READ'\n'title': Sweet 16 - Java auf dem Weg zur nächsten LTS-Version\n'parentName': Java Magazin 5.2021\n'language': 'DE'\n'date': '2021-04-07T00:00:00.000Z'\n'abstract': 14, 15 oder doch schon 16? Da kann man schon mal durcheinanderkommen. Durch die mittlerweile halbjährlichen Major-Releases von Java fällt es gar nicht so leicht, die aktuelle Version richtig zu benennen. Vor Kurzem hat man sich in einem Vortrag noch über die Neuerungen des JDK 14 informiert, und wenig später wurden in einem Artikel bereits die Features von Version 15 näher beleuchtet. Und da sich die Welt bekanntlich schnell weiterdreht, ist nun im März 2021 bereits das OpenJDK 16 herausgekommen.\n'parentId': 'b3c6f33294fba41d508316c1'\n'parentDescription': Über neun Millionen Software-Entwickler weltweit sorgen dafür, dass die Java-Technologie in allen Geschäftsfeldern und in allen Branchen eine zentrale Rolle spielt. Zudem ist das Java-Ökosystem der wichtigste Takt- und Impulsgeber für die gesamte Software-Industrie, wenn es um technische Innovationen geht. Das Java Magazin begleitet seit über 20 Jahren alle wesentlichen Entwicklungen der Java-Welt aktuell, kritisch und mit großer praktischer Relevanz. Software-Architekten, Entwickler und Projektleiter vertrauen auf die anerkannte Kompetenz der Redaktion verbunden mit ihrem Experten-Netzwerk bekannter Fachautoren.\n'indexBrandName': ''\n'indexSeriesName': ''\n'author': 'Falk Sippach'\n'chunkSource': 'text'\n'text': Sweet 16 Java auf dem Weg zur nächsten LTS-Version 14, 15 oder doch schon 16? Da kann man schon mal durcheinanderkommen. Durch die mittlerweile halbjährlichen Major-Releases von Java fällt es gar nicht so leicht, die aktuelle Version richtig zu benennen. Vor Kurzem hat man sich in einem Vortrag noch über die Neuerungen des JDK 14 informiert, und wenig später wurden in einem Artikel bereits die Features von Version 15 näher beleuchtet. Und da sich die Welt bekanntlich schnell weiterdreht, ist nun im März 2021 bereits das OpenJDK 16 herausgekommen. 14, 15 oder doch schon 16? Da kann man schon mal durcheinanderkommen. Durch die mittlerweile halbjährlichen Major-Releases von Java fällt es gar nicht so leicht, die aktuelle Version richtig zu benennen. Vor Kurzem hat man sich in einem Vortrag noch über die Neuerungen des JDK 14 informiert, und wenig später wurden in einem Artikel bereits die Features von Version 15 näher beleuchtet. Und da sich die Welt bekanntlich schnell weiterdreht, ist nun im März 2021 bereits das OpenJDK 16 herausgekommen. Um die Verwirrung komplettzumachen, kann man sich natürlich auch nur auf die sogenannten Long-Term-Support-Versionen (LTS) konzentrieren, die alle drei Jahre erscheinen. Das ist im Moment Java 11, wobei in der freien Wildbahn die Version 8 ebenfalls noch sehr weit verbreitet ist. Im September 2021 wird nun mit dem JDK 17 das nächste LTS-Release erscheinen. Dort werden die Neuerungen der vergangenen drei Jahre (Java 12 bis 16) finalisiert, um bis zur darauffolgenden LTS-Version (JDK 23) gut dazustehen. In den vergangenen „Zwischen“-Releases wurden die diversen, teilweise auch größeren Änderungen häufig als Previews veröffentlicht. Dadurch konnte frühzeitig Feedback eingesammelt und bereits im nächsten Release eingearbeitet werden. (Nicht ganz so) neue Features Die Liste der für das OpenJDK 16 umgesetzten JEPs (Java Enhancement Proposals) sieht auf den ersten Blick wieder relativ lang aus [1]: - 338: Vector API (Incubator) - 347: Enable C++14 Language Features - 357: Migrate from Mercurial to Git - 369: Migrate to GitHub - 376: ZGC: Concurrent Thread-Stack Processing - 380: Unix-Domain Socket Channels - 386: Alpine Linux Port - 387: Elastic Metaspace - 388:\n'slidetext': ''\n'from': 'index'\n'score': 125.76042938232422\n'normalizedScore': 1.2576042938232421\n'beforeDatePenaltyScore': 1.2576042938232421\n\n'documentId': 'bb97d9e8205e4d23e8d34081'\n'chunk_id': '687814d2bed6dcd41a99b06b'\n'access': 'granted'\n'part_number': 9\n'total_parts': 13\n'contentType': 'READ'\n'title': Angular 15: New Features and Breaking Changes - Angular strongly focuses on standalone components\n'parentName': JavaScript Magazine Volume 7\n'language': 'EN'\n'date': '2022-11-04T02:00:00.000Z'\n'abstract': Angular 15 is here! In this tutorial, we take a closer look at the new features and enhancements for the JavaScript framework and provide guidance on dealing with incompatible changes in Angular 15.\n'parentId': '1c6fbd6381a62df9f43c9b0b'\n'parentDescription': Broaden your knowledge and expand your JavaScript techniques and practices. From Angular, React, and WebAssembly, to the best JavaScript IDEs, open source tools and more, you’ll learn insights on everything JS from seasoned experts in their field. Keep up with JavaScript news, tips, and advice with interviews, tutorials, and in-depth articles.\n'indexBrandName': ''\n'indexSeriesName': ''\n'author': 'Karsten Sitterberg'\n'chunkSource': 'text'\n'text': was a transition period afterwards, where you could switch back and forth between the old view engine and Ivy. There was the compiler flag “enableIvy” for this. But since the old view engine no longer exists, this flag has now been removed. To remove old APIs that are no longer recommended for subsequent Angular versions, Angular 15 also includes some deprecations. For example, it was previously possible to bind services to a module by assigning that module to the “providedIn” option of an “@Injectable” decorator. An example of this can be seen in Listing 11. This should make the services treeshakeable, but still bind them tightly to a module. Since this variant was hardly used—and sometimes incorrectly too—this feature is now deprecated. Instead, the service should now either be marked as “providedIn: 'root'” or defined as a provider in the corresponding module. In addition to the module variant, the “providedIn: 'any'” syntax was also deprecated, since the any option was essentially only used internally in the framework and was also misleading. Listing 11: Assigning modules to providedIn is now deprecated. @Injectable({ providedIn: MyModule }) export class MyService {} For the date pipe, the Angular team combined a new feature with a deprecation. Previously, there was the injection token “DATE_PIPE_DEFAULT_TIMEZONE”, which could be used to set the date pipe’s time zone to a default value app-wide. This token is now deprecated and you should use the “DATE_PIPE_DEFAULT_OPTIONS” token instead. This can be used to set the default date format app-wide, or module-wide, as well as the default time zone. Listing 12 shows how to use the new token to configure the format “'shortDate'” as the default value for formatting date values and the time zone “-0200”, corresponding to Azores’ time zone. Listing 12: Set defaults for the DatePipe providers: [ { provide: DATE_PIPE_DEFAULT_OPTIONS, useValue: { dateFormat: 'shortDate', timezone: '-0200' } } ] In Angular, navigation operations in the app are started with the router’s help. There is both imperative routing by calling the router from the TypeScript code, and declarative routing from Angular templates. For the latter, the “[routerLink]” directive can be used. Previously, these were technically two different directives. For HTML anchor elements, there was the “RouterLinkWithHref” directive, which can also be seen in Listing 13, while all other elements used the RouterLink directive. To avoid code duplication, these directives have now been unified and “RouterLinkWithHref” is just an alias for the actual RouterLink. Therefore, the “RouterLink” can now simply be used for anchor elements too. This only has an effect\n'slidetext': ''\n'from': 'index'\n'score': 125.91600036621094\n'normalizedScore': 1.2591600036621093\n'beforeDatePenaltyScore': 1.2591600036621093\n\n'documentId': '64ace3828d8056484c3534ab'\n'chunk_id': '687814c4bed6dcd41a99b01d'\n'access': 'granted'\n'part_number': 5\n'total_parts': 21\n'contentType': 'READ'\n'title': Angular 16 released - Alles zu neuen Features und Breaking Changes\n'parentName': iJS Magazin Band 27\n'language': 'DE'\n'date': '2023-04-06T00:00:00.000Z'\n'abstract': Wir geben einen Überblick zu allen wichtigen Infos zum Release von Angular 16. Alles zu Signals, der Angular-CLI und TypeScript in Angular 16 erfahren Sie hier.\n'parentId': '5093fc7a779ccfe852d8fe7b'\n'parentDescription': Kaum ein Softwareprojekt, das nicht in wesentlichen Teilen auf der JavaScript-Technologie basiert. Eine breite Unterstützung sowie, leistungsfähige Programmiersprachen, die Vielzahl moderner Tools, sowie ausgereifte Frameworks wie Angular, React, Vue.js oder Node.js machen den JavaScript-Werkzeugkasten zu einem Alleskönner. Das iJS Magazin informiert aktuell und umfassend über die wichtige und innovative Entwicklungen im JavaScript-Universum und bietet handfeste Praxisinformationen für Softwareentwickler und -architekten.\n'indexBrandName': ''\n'indexSeriesName': ''\n'author': 'Karsten Sitterberg'\n'chunkSource': 'text'\n'text': erweitert. Außerdem kann der esbuild-DevServer nun z.B. SSL nutzen. Die Einbindung erfolgt, wie mit dem bestehenden Setup, per ng serve --ssl. Weiterhin können auch zusätzliche Scripte in den Build einbezogen werden. Das ist zum Beispiel bei der Einbindung von globalen Scripten wie dem Google Tag Manager praktisch. Auch für das bestehende Buildsystem wurden einige Erweiterungen vorgenommen: So können neue Anwendungen als Standalone-Anwendungen (also ohne @NgModules) generiert werden. Dazu wird bei der Generierung der Anwendung das Flag --standalone mitgegeben. Um die Funktionalität von Standalone-Anwendungen an die Funktionalität von bisherigen Angular-Anwendungen anzugleichen, ist es nun auch möglich, Service-Worker und App-Shells für Standalone-Anwendungen per Schematics zu generieren. Breaking Changes in Angular-CLI 16 Mit der neuen Major-Version des Angular-CLI gibt es natürlich auch einige Breaking Changes: So wurde der Support für TypeScript 4.8 und Node.js 14 entfernt. Stattdessen wird als Standard TypeScript 5 verwendet, Node.js sollte in Version 16, 18 oder neuer vorliegen. Auch in Angular-CLI 16 werden einige veraltete oder überhole Zöpfe abgeschnitten: So wird der Angular-Compatibility-Compiler NGCC mit Angular-CLI 16 entfernt. NGCC war dafür zuständig, alte, noch auf der View-Engine beruhende Libraries so zu transformieren, dass diese kompatibel mit dem neuen Ivy-Compiler werden. Da die View-Engine schon seit Angular 12 deprecated ist, geht das Angular-Team davon aus, dass alle wesentlichen Libraries bereits entsprechend so angepasst sind, dass sie Ivy-kompatibel zur Verfügung gestellt werden. Das bedeutet, dass Projekte, die noch Libraries verwenden, die lediglich für die View-Engine gebaut sind, nicht auf Angular 16 umstellen können, solange die Libraries nicht angepasst wurden. Handelt es sich dabei um transitive Abhängigkeiten, ist einem dieses potentielle Problem unter Umständen gar nicht bewusst. Um eine Library für Ivy kompatibel zu machen, sollte die jeweilige Library auf eine aktuellere Angular-Version umgestellt werden (mindestens 12) und in der tsconfig.lib.prod.json der Compiler-Modus auf partial gestellt werden, siehe Listing 6. Da dadurch in der Regel keine negativen Auswirkungen entstehen, sollte dieser Modus definitiv aktiviert werden. Mit dieser Änderung ist die Transition von der alten View-Engine endgültig abgeschlossen. Durch den so wegfallenden Code\n'slidetext': ''\n'from': 'index'\n'score': 128.09193420410156\n'normalizedScore': 1.2809193420410157\n'beforeDatePenaltyScore': 1.2809193420410157\n\n'documentId': '64ace3828d8056484c3534ab'\n'chunk_id': '687814c4bed6dcd41a99b01c'\n'access': 'granted'\n'part_number': 4\n'total_parts': 21\n'contentType': 'READ'\n'title': Angular 16 released - Alles zu neuen Features und Breaking Changes\n'parentName': iJS Magazin Band 27\n'language': 'DE'\n'date': '2023-04-06T00:00:00.000Z'\n'abstract': Wir geben einen Überblick zu allen wichtigen Infos zum Release von Angular 16. Alles zu Signals, der Angular-CLI und TypeScript in Angular 16 erfahren Sie hier.\n'parentId': '5093fc7a779ccfe852d8fe7b'\n'parentDescription': Kaum ein Softwareprojekt, das nicht in wesentlichen Teilen auf der JavaScript-Technologie basiert. Eine breite Unterstützung sowie, leistungsfähige Programmiersprachen, die Vielzahl moderner Tools, sowie ausgereifte Frameworks wie Angular, React, Vue.js oder Node.js machen den JavaScript-Werkzeugkasten zu einem Alleskönner. Das iJS Magazin informiert aktuell und umfassend über die wichtige und innovative Entwicklungen im JavaScript-Universum und bietet handfeste Praxisinformationen für Softwareentwickler und -architekten.\n'indexBrandName': ''\n'indexSeriesName': ''\n'author': 'Karsten Sitterberg'\n'chunkSource': 'text'\n'text': erkennt TypeScript, dass ein solcher Zugriff abgesichert und damit erlaubt ist. Listing 4: Type-Narrowing durch Type-Guard interface Cow { giveMilk(): void; } interface Bird { layEggs(): void; } function doItWithObjects(value: Cow | Bird) { if ('layEggs' in value) { value.layEggs(); // value is vom Typ 'Bird' } } Listing 5: Type-Narrowing bei unbekannten Typen function tryGetDataContent(data: unknown): string | undefined { if (data && typeof data === 'object') { if ('content' in data && typeof data.content === 'string') { // ^ Bisher: TypeError return data.content; } } return undefined; } Mehr zum Thema Angular © gdainti/Shutterstock.com Change Detection performanter und leichtgewichtiger mit Signals Sarah Drasner, die als Director of Engineering bei Googleu. a. auch dem Angular-Team vorsteht, hat auf Twitter von einer Angular-Renaissance gesprochen. Das trifft es ziemlich gut, denn in den letzten Releases gab es tatsächlich einige Neuerungen, die Angular äußert attraktiv machen. Die wohl wichtigsten sind Standalone Components und Standalone APIs. Angulars neues Standalone API Die neuen Standalone Components ermöglichen Angular-Entwicklung ohne Ng-Modules. Wir zeigen, was das für eine bestehende Architektur heißt. Die neuesten Innovationen im Angular-Umfeld In den letzten Monaten hat Angular einige neue Features erhalten, die es ermöglichen, das Framework auf eine frische und leichtgewichtige Weise zu verwenden. Dieser Artikel zeigt, wie diese Neuerungen dazu beitragen, unsere Lösungen wartbarer zu gestalten. Angular-CLI Fast alle Angular-Projekte werden mit Angular-CLI aufgesetzt und gebaut. Angular-CLI bietet dabei eine Abstraktion über das zugrundeliegende Buildsystem. So konnte in der Vergangenheit zum Beispiel die Umstellung von SystemJS auf Webpack als Implementierungsdetail verborgen werden. Aktuell werden als Nachfolger von Webpack sowohl Vite aus dem Vue-Umfeld als auch esbuild untersucht. Bis zur tatsächlichen Umstellung ist es aber sicherlich noch mindestens ein Release hin. Doch auch in Angular-CLI 16 gibt es einige Neuerungen, einige davon betreffen auch die bereits angesprochenen Experimente. So wird der bestehende Support für das esbuild-basierte Build-Setup um Progress-Ausgaben erweitert. Außerdem kann der esbuild-DevServer nun z.B. SSL nutzen. Die Einbindung erfolgt, wie mit dem bestehenden Setup, per ng serve --ssl. Weiterhin können auch zusätzliche Scripte in den Build einbezogen werden. Das\n'slidetext': ''\n'from': 'index'\n'score': 127.52802276611328\n'normalizedScore': 1.2752802276611328\n'beforeDatePenaltyScore': 1.2752802276611328\n\n'documentId': '64ace3828d8056484c3534ab'\n'chunk_id': '687814c4bed6dcd41a99b019'\n'access': 'granted'\n'part_number': 1\n'total_parts': 21\n'contentType': 'READ'\n'title': Angular 16 released - Alles zu neuen Features und Breaking Changes\n'parentName': iJS Magazin Band 27\n'language': 'DE'\n'date': '2023-04-06T00:00:00.000Z'\n'abstract': Wir geben einen Überblick zu allen wichtigen Infos zum Release von Angular 16. Alles zu Signals, der Angular-CLI und TypeScript in Angular 16 erfahren Sie hier.\n'parentId': '5093fc7a779ccfe852d8fe7b'\n'parentDescription': Kaum ein Softwareprojekt, das nicht in wesentlichen Teilen auf der JavaScript-Technologie basiert. Eine breite Unterstützung sowie, leistungsfähige Programmiersprachen, die Vielzahl moderner Tools, sowie ausgereifte Frameworks wie Angular, React, Vue.js oder Node.js machen den JavaScript-Werkzeugkasten zu einem Alleskönner. Das iJS Magazin informiert aktuell und umfassend über die wichtige und innovative Entwicklungen im JavaScript-Universum und bietet handfeste Praxisinformationen für Softwareentwickler und -architekten.\n'indexBrandName': ''\n'indexSeriesName': ''\n'author': 'Karsten Sitterberg'\n'chunkSource': 'text'\n'text': Angular 16 released Alles zu neuen Features und Breaking Changes Wir geben einen Überblick zu allen wichtigen Infos zum Release von Angular 16. Alles zu Signals, der Angular-CLI und TypeScript in Angular 16 erfahren Sie hier. Angular 16 setzt in vielerlei Hinsicht neue Akzente. Das wird nicht jedem gefallen. Ob das Angular-Team - und dahinter Google - hier kluge Entscheidungen trifft, wird vermutlich erst die Zeit zeigen. Um sich selbst ein Bild zu machen, betrachten wir alle wichtigen Änderungen zu TypeScript in Angular, die Angular-CLI und besonders Signals von Angular 16 im folgenden Beitrag. Angular hat besonders da einen guten Ruf, wo es um langlebige Anwendungen geht, bei denen Investitutionsschutz ein sehr wichtiges Kriterium ist. Selbst bei sehr kritischen Umbaumaßnahmen, wie der Umstellung der Renderingengine auf Ivy hat das Angular-Team stets extrem gutes Fingerspitzengefühl bewiesen. Durch kontinuierliche Verbesserungen von ng-upgrade und gutes Engineering bedeuteten notwendige Migrationen für Entwickler immer weniger Aufwand. Zumal viele der Änderungen im Laufe mehrerer Versionen schrittweise umgesetzt wurden und oft sogar die API-Oberfläche für typische Anwendungen stabil gehalten werden konnte. TypeScript und Angular 16 Angular legt auch mit diesem Release ein Augenmerk darauf, seine eigenen Abhängigkeiten aktuell zu halten. So muss mit Angular 16 TypeScript in Version 4.9 oder 5.0 vorliegen. Daher schauen wir uns die wichtigsten Neuerungen in TypeScript 4.9 hier zunächst an. Die weiteren Neuerungen von TypeScript 5 können in folgenden Artikel nachgelesen werden: TypeScript 5: Neuerungen und Breaking Changes. Auch mit TypeScript 4.9 kamen einige Neuerungen: So gibt es etwa Verbesserungen bei der Build-Performance oder beim File-Watching durch den Dev-Server. Außerdem wurde ein “Auto-Accessor”-Keyword eingeführt (Verwendungsbeispiel: public accessor name: string;), das automatisch sowohl einen set- als auch einen get-Accessor für das Property name erzeugt. Es wurde auch ein Compiler-Hinweis eingefügt, der einen Fehler ausgibt, sobald ein Vergleich mit NaN ausgeführt wird, da diese Vergleiche eigentlich immer ein Fehler sind (NaN !== x ist immer true, selbst wenn x=NaN, während NaN === x immer false zurück liefert). Stattdessen sollte die Funktion Number.isNaN(someValue) verwendet werden. Es wurde auch ein\n'slidetext': ''\n'from': 'index'\n'score': 127.39582061767578\n'normalizedScore': 1.2739582061767578\n'beforeDatePenaltyScore': 1.2739582061767578\n\n'documentId': '2e2495f42751c019986f5bc4'\n'chunk_id': '687ab74d2be886398c2ad126'\n'access': 'granted'\n'part_number': 3\n'total_parts': 9\n'contentType': 'READ'\n'title': Java 16: Das JDK auf dem Weg zur nächsten LTS-Version - Sweet 16\n'parentName': JAXenter 3.2021\n'language': 'DE'\n'date': '2021-03-01T16:58:00.000Z'\n'abstract': 14, 15 oder doch schon 16? Da kann man schon mal durcheinanderkommen. Durch die mittlerweile halbjährlichen Major-Releases von Java fällt es gar nicht so leicht, die aktuelle Version richtig zu benennen. Vor Kurzem hat man sich in einem Vortrag noch über die Neuerungen des JDK 14 informiert, und wenig später wurden in einem Artikel bereits die Features von Version 15 näher beleuchtet. Und da sich die Welt bekanntlich schnell weiterdreht, ist nun im März 2021 bereits das OpenJDK 16 herausgekommen.\n'parentId': 'f3f07cfbd5f6d489e27c1d11'\n'parentDescription': n/a\n'indexBrandName': ''\n'indexSeriesName': ''\n'author': 'Falk Sippach'\n'chunkSource': 'text'\n'text': ist es, Redundanzen zu vermeiden und dadurch die Lesbarkeit zu erhöhen (Listing 1). Listing 1 boolean isNullOrEmpty( Object o ) { return o == null || o instanceof String s && s.isBlank() || o instanceof Collection c && c.isEmpty(); } Der Unterschied zum zusätzlichen Cast mag marginal erscheinen. Für die Puristen unter den Java-Entwicklern spart das allerdings eine kleine, aber dennoch lästige Redundanz ein. Laut Brian Goetz soll die Sprache dadurch prägnanter und die Verwendung sicherer gemacht werden. Erzwungene Typumwandlungen werden vermieden und stattdessen implizit durchgeführt. Bereits die zweite Preview, die im JDK 15 erschienen war, hatte keine nennenswerten Änderungen mehr mit sich gebracht. Deswegen wird das Feature jetzt als JEP 394 finalisiert. In zukünftigen Java-Versionen wird es aber noch weitere Funktionen rund um das Pattern Matching geben, zum Beispiel in Zusammenarbeit mit den Switch Expressions. Versiegelte Klassen Erst das zweite Mal dabei sind die Sealed Classes. Sie wurden in Java 15 als Previewfeature eingeführt und verbleiben als JEP 397 auch im JDK 16 im Vorschaumodus. Es gibt ein paar kleine Ergänzungen gegenüber der letzten Version und vermutlich werden sie dann im LTS-Release des OpenJDK 17 finalisiert. Bis dahin möchten die Macher aber noch Rückmeldungen einsammeln. Dieses Feature wurde übrigens im Rahmen von Projekt Amber entwickelt und gehört ebenfalls zu einer Reihe von vorbereitenden Maßnahmen für die Umsetzung von Pattern-Matching-Mechanismen in Java. Ganz konkret soll es bei der Analyse von Mustern unterstützen. Aber auch für Framework-Entwickler bieten die Sealed Classes einen interessanten Mehrwert. Die Idee ist, dass versiegelte Klassen und Interfaces entscheiden können, welche Subklassen oder -interfaces von ihnen abgeleitet werden dürfen. Bisher konnte man als Entwickler Ableitungen von Klassen nur durch Zugriffsmodifikatoren (private, protected, …) einschränken oder durch die Deklaration der Klasse als final komplett durch den Compiler untersagen. Sealed Classes bieten nun einen deklarativen Weg, um gezielt bestimmten Subklassen die Ableitung zu erlauben: public sealed class Vehicle permits Car, Bike, Bus, Train { } Vehicle darf nur von den vier genannten Klassen überschrieben werden. Damit wird auch dem Aufrufer deutlich gemacht, welche\n'slidetext': ''\n'from': 'index'\n'score': 142.4487762451172\n'normalizedScore': 1.4244877624511718\n'beforeDatePenaltyScore': 1.4244877624511718\n\n'documentId': '2e2495f42751c019986f5bc4'\n'chunk_id': '687ab74e2be886398c2ad131'\n'access': 'granted'\n'part_number': 8\n'total_parts': 9\n'contentType': 'READ'\n'title': Java 16: Das JDK auf dem Weg zur nächsten LTS-Version - Sweet 16\n'parentName': JAXenter 3.2021\n'language': 'DE'\n'date': '2021-03-01T16:58:00.000Z'\n'abstract': 14, 15 oder doch schon 16? Da kann man schon mal durcheinanderkommen. Durch die mittlerweile halbjährlichen Major-Releases von Java fällt es gar nicht so leicht, die aktuelle Version richtig zu benennen. Vor Kurzem hat man sich in einem Vortrag noch über die Neuerungen des JDK 14 informiert, und wenig später wurden in einem Artikel bereits die Features von Version 15 näher beleuchtet. Und da sich die Welt bekanntlich schnell weiterdreht, ist nun im März 2021 bereits das OpenJDK 16 herausgekommen.\n'parentId': 'f3f07cfbd5f6d489e27c1d11'\n'parentDescription': n/a\n'indexBrandName': ''\n'indexSeriesName': ''\n'author': 'Falk Sippach'\n'chunkSource': 'text'\n'text': dieser Maßnahme ist die Erhöhung der Sicherheit und Wartbarkeit des JDK. Man möchte die Entwickler ermutigen, alte, auf Internas basierende Lösungen zukünftig für den Zugriff auf Standard-APIs umzubauen. Somit sollen sowohl Java-Entwickler als auch Endbenutzer viel problemloser auf zukünftige Versionen updaten können. Neben den prominenten JEPs gibt es in jeder neuen JDK-Version noch viele kleine Änderungen, zum Beispiel an der Java-Klassenbibliothek. Mit dem Java Version Almanac [4] kann man sehr einfach und kompakt die Differenzen zwischen den Releases, aber auch bei Versionssprüngen von z. B. JDK 8 auf 16 einsehen. Aus Entwicklersicht sind besonders zwei Neuerungen an der Klasse Stream interessant. Stream.toList() bietet eine prägnantere und im Einsatz mit parallel() meist auch effizientere Alternative zu Stream.collect(Collectors.toList()). Als Ergebnis wird eine nicht veränderbare (unmodifiable) ArrayList zurückgegeben. Weitere Informationen kann man der API-Dokumentation [5] oder dem Artikel von Donald Raab [6] entnehmen. Die zweite Neuerung in der Klasse Stream ist die in diversen Ausprägungen hinzugekommene Methode mapMulti(BiConsumer). Sie stellt eine imperative und schnellere Alternative zu flatMap dar. Nicolai Parlog hat die neue Funktion in einem Blogpost näher unter die Lupe genommen und zum Vergleich Performancemessungen durchgeführt [7]. Ausblick Schon kurz vor der Fertigstellung des OpenJDK 16 wurden die ersten Features für das JDK 17 angekündigt [8]. Unter anderem soll es eine neue Rendering Pipeline für macOS und die Erweiterung des Pseudozufallszahlengenerators geben. Höchstwahrscheinlich werden wir allerdings keine weiteren großen, prominenten Änderungen sehen. Schließlich werden mit Java 17 die Entwicklungen der vergangenen 36 Monate abgeschlossen und es wird eine Version bereitgestellt, die wieder für die nächsten Jahre mit Updates und Sicherheitpatches versorgt werden muss. Die wirklich spannenden Neuerungen und Syntaxerweiterungen werden wir dann voraussichtlich erst wieder in der Version 18 sehen. Ab da hat Oracle dann wieder zweieinhalb Jahre Zeit, Feedback zu Previewfeatures einzuarbeiten und diese abzurunden. Der 2018 eingeschlagene Weg – der anfangs nicht unumstritten war – wird weiterhin konsequent verfolgt. Die halbjährlichen Updates der Programmiersprache und der Plattform Java geben uns\n'slidetext': ''\n'from': 'index'\n'score': 142.36814880371094\n'normalizedScore': 1.4236814880371094\n'beforeDatePenaltyScore': 1.4236814880371094\n\n'documentId': '2e2495f42751c019986f5bc4'\n'chunk_id': '687ab74d2be886398c2ad124'\n'access': 'granted'\n'part_number': 2\n'total_parts': 9\n'contentType': 'READ'\n'title': Java 16: Das JDK auf dem Weg zur nächsten LTS-Version - Sweet 16\n'parentName': JAXenter 3.2021\n'language': 'DE'\n'date': '2021-03-01T16:58:00.000Z'\n'abstract': 14, 15 oder doch schon 16? Da kann man schon mal durcheinanderkommen. Durch die mittlerweile halbjährlichen Major-Releases von Java fällt es gar nicht so leicht, die aktuelle Version richtig zu benennen. Vor Kurzem hat man sich in einem Vortrag noch über die Neuerungen des JDK 14 informiert, und wenig später wurden in einem Artikel bereits die Features von Version 15 näher beleuchtet. Und da sich die Welt bekanntlich schnell weiterdreht, ist nun im März 2021 bereits das OpenJDK 16 herausgekommen.\n'parentId': 'f3f07cfbd5f6d489e27c1d11'\n'parentDescription': n/a\n'indexBrandName': ''\n'indexSeriesName': ''\n'author': 'Falk Sippach'\n'chunkSource': 'text'\n'text': Elastic Metaspace - 388: Windows/AArch64 Port - 389: Foreign Linker API (Incubator) - 390: Warnings for Value-Based Classes - 392: Packaging Tool - 393: Foreign-Memory Access API (Third Incubator) - 394: Pattern Matching for instanceof - 395: Records - 396: Strongly Encapsulate JDK Internals by Default - 397: Sealed Classes (Second Preview) Einige der Punkte sind für Java-Entwickler aber nicht direkt relevant. Dazu zählen beispielsweise die Migration zu Git/GitHub, die Aktivierung der C++-14-Sprachfeatures und auch das Foreign Linker API als zukünftiger Ersatz für das Java Native Interface (JNI). Wir schauen am Ende dieses Artikels trotzdem genauer darauf. Werfen wir aber zunächst einen Blick auf die Funktionen, die uns Entwickler betreffen. Dabei werden dem aufmerksamen Beobachter der vergangenen Java-Releases allerdings keine bahnbrechenden Neuerungen ins Auge springen. Das hängt vermutlich mit dem bevorstehenden LTS-Release zusammen, das im Herbst 2021 erscheinen wird. In Java 17 werden die neuen Features der vergangenen Monate stabilisiert, um für die folgenden Jahre eine gute Ausgangsbasis für die notwendigen Updates und Patches zu schaffen. Java goes Pattern Matching Bereits seit einiger Zeit schwebt das Thema Pattern Matching im Raum und hält nach und nach Einzug in Java. Dazu sind aber zur Vorbereitung diverse Änderungen in der Sprache selbst notwendig und deshalb erfolgt die Einführung nur schrittweise. Los ging es mit den Switch Expressions bereits im JDK 12. Seit Version 14 gab es zudem bereits zwei Previews zu „Pattern Matching for instanceof“. Das wird nun mit Java 16 abgeschlossen. Ein Pattern ist übrigens eine Kombination aus einem Prädikat (das auf eine Zielstruktur passt) und einer Menge von Variablen innerhalb dieses Musters. Diesen Variablen werden bei passenden Treffern die entsprechenden Inhalte zugewiesen und damit extrahiert. Die Intention des Pattern Matching ist letztlich die Destrukturierung von Objekten, also das Aufspalten in die Bestandteile und Zuweisen in einzelne Variablen zur weiteren Bearbeitung. Die Spezialform des Pattern Matching beim instanceof-Operator spart unnötige Casts auf die zu prüfenden Zieldatentypen. Wenn o ein String oder eine Collection ist, dann kann direkt mit den neuen Variablen (s und c) mit den entsprechenden Datentypen weitergearbeitet werden. Das Ziel ist\n'slidetext': ''\n'from': 'index'\n'score': 142.2671661376953\n'normalizedScore': 1.4226716613769532\n'beforeDatePenaltyScore': 1.4226716613769532\n\n'documentId': 'e9905bc3e1a3780619966899'\n'chunk_id': '687814d9bed6dcd41a99b098'\n'access': 'granted'\n'part_number': 11\n'total_parts': 17\n'contentType': 'READ'\n'title': Jetzt schlägt’s 15: Was ist neu in Angular 15? - Alle neuen Features von Angular 15 im Blick\n'parentName': Java Magazin 2.2023\n'language': 'DE'\n'date': '2023-01-03T02:00:00.000Z'\n'abstract': Angular 15 wurde für den produktiven Einsatz freigegeben. In diesem Tutorial werfen wir einen genauen Blick auf die neuen Features und Verbesserungen des JavaScript-Frameworks und geben Hinweise zum Umgang mit inkompatiblen Änderungen in Angular 15.\n'parentId': '9b91af29eb210add4465b516'\n'parentDescription': Über neun Millionen Software-Entwickler weltweit sorgen dafür, dass die Java-Technologie in allen Geschäftsfeldern und in allen Branchen eine zentrale Rolle spielt. Zudem ist das Java-Ökosystem der wichtigste Takt- und Impulsgeber für die gesamte Software-Industrie, wenn es um technische Innovationen geht. Das Java Magazin begleitet seit über 20 Jahren alle wesentlichen Entwicklungen der Java-Welt aktuell, kritisch und mit großer praktischer Relevanz. Software-Architekten, Entwickler und Projektleiter vertrauen auf die anerkannte Kompetenz der Redaktion verbunden mit ihrem Experten-Netzwerk bekannter Fachautoren.\n'indexBrandName': ''\n'indexSeriesName': ''\n'author': 'Karsten Sitterberg'\n'chunkSource': 'text'\n'text': ... } Nachdem das Angular-Team lange an der Ivy Rendering Engine gefeilt hat, wurde diese mit Angular 9 endlich veröffentlicht. Es gab danach eine Übergangszeit, in der man zwischen der alten View Engine und Ivy hin- und herwechseln konnte. Dafür gab es das Compilerflag enableIvy. Da es aber mittlerweile die alte View-Engine nicht mehr gibt, wurde dieses Flag nun entfernt. Deprecations Um alte, für die Zukunft nicht mehr empfohlene APIs in nachfolgenden Angular-Versionen besser entfernen zu können, gibt es auch einige Deprecations mit Angular 15. So war es bisher möglich, Services an ein Modul zu koppeln, indem dieses Modul an die providedIn-Option eines @Injectable-Decorator zugewiesen wurde. Ein Beispiel dazu findet sich in Listing 11. Das sollte die Services treeshakeable machen, aber trotzdem fest an ein Modul binden. Da diese Variante kaum – und zudem teilweise auch noch falsch – genutzt wurde, wird dieses Feature nun deprecated. Stattdessen sollte der Service nun entweder als providedIn: 'root' gekennzeichnet werden oder als Provider in dem entsprechenden Modul eingetragen werden. Neben der Modulvariante wurde auch die providedIn: 'any'-Syntax deprecated, da die any-Option im Wesentlichen nur Framework-intern genutzt wurde und auch missverständlich war. Listing 11: Module an providedIn zuzuweisen ist nun deprecated @Injectable({ providedIn: MyModule }) export class MyService {} Für die Date Pipe hat das Angular-Team ein neues Feature mit einer Deprecation verbunden: Bisher gab es das Injection-Token DATE_PIPE_DEFAULT_TIMEZONE, mit dem die Zeitzone der Date Pipe App-weit auf einen Standardwert gesetzt werden konnte. Dieses Token wird nun deprecated, da stattdessen das Token DATE_PIPE_DEFAULT_OPTIONS genutzt werden soll, mit dem neben der Standardzeitzone auch das Standarddatumsformat App- bzw. modulweit, eingestellt werden kann. In Listing 12 wird gezeigt, wie mit dem neuen Token das Format 'shortDate' als Standardwert zur Formatierung von Datumswerten und als Zeitzone -0200, was der Zeitzone der Azoren entspricht, konfiguriert wird. Listing 12: Defaults für die DatePipe setzen providers: [ { provide: DATE_PIPE_DEFAULT_OPTIONS, useValue: { dateFormat: 'shortDate', timezone: '-0200' } } ] Vereinheitlichung von Direktiven Navigationsvorgänge innerhalb der App werden in Angular mit Hilfe des Routers gestartet. Dabei gibt es sowohl imperatives Routing durch Aufruf des Routers aus\n'slidetext': ''\n'from': 'index'\n'score': 143.2830047607422\n'normalizedScore': 1.4328300476074218\n'beforeDatePenaltyScore': 1.4328300476074218\n\n'documentId': 'e9905bc3e1a3780619966899'\n'chunk_id': '687814d9bed6dcd41a99b099'\n'access': 'granted'\n'part_number': 12\n'total_parts': 17\n'contentType': 'READ'\n'title': Jetzt schlägt’s 15: Was ist neu in Angular 15? - Alle neuen Features von Angular 15 im Blick\n'parentName': Java Magazin 2.2023\n'language': 'DE'\n'date': '2023-01-03T02:00:00.000Z'\n'abstract': Angular 15 wurde für den produktiven Einsatz freigegeben. In diesem Tutorial werfen wir einen genauen Blick auf die neuen Features und Verbesserungen des JavaScript-Frameworks und geben Hinweise zum Umgang mit inkompatiblen Änderungen in Angular 15.\n'parentId': '9b91af29eb210add4465b516'\n'parentDescription': Über neun Millionen Software-Entwickler weltweit sorgen dafür, dass die Java-Technologie in allen Geschäftsfeldern und in allen Branchen eine zentrale Rolle spielt. Zudem ist das Java-Ökosystem der wichtigste Takt- und Impulsgeber für die gesamte Software-Industrie, wenn es um technische Innovationen geht. Das Java Magazin begleitet seit über 20 Jahren alle wesentlichen Entwicklungen der Java-Welt aktuell, kritisch und mit großer praktischer Relevanz. Software-Architekten, Entwickler und Projektleiter vertrauen auf die anerkannte Kompetenz der Redaktion verbunden mit ihrem Experten-Netzwerk bekannter Fachautoren.\n'indexBrandName': ''\n'indexSeriesName': ''\n'author': 'Karsten Sitterberg'\n'chunkSource': 'text'\n'text': 'shortDate', timezone: '-0200' } } ] Vereinheitlichung von Direktiven Navigationsvorgänge innerhalb der App werden in Angular mit Hilfe des Routers gestartet. Dabei gibt es sowohl imperatives Routing durch Aufruf des Routers aus dem TypeScript-Code als auch deklaratives Routing aus den Angular-Templates. Für Letzteres kann die [routerLink]-Direktive verwendet werden. Bisher handelte es sich dabei technisch gesehen allerdings um zwei verschiedene Direktiven: Für HTML-Anchor-Elemente gab es die RouterLinkWithHref-Direktive, die auch in Listing 13 zu sehen ist, während alle anderen Elemente die RouterLink-Direktive verwendeten. Um Codeduplikation zu vermeiden, wurden diese Direktiven nun vereinheitlicht und RouterLinkWithHref ist nur noch ein Alias für den eigentlichen RouterLink. So kann nun auch für Anchor-Elemente einfach der RouterLink verwendet werden. Im Code wirkt sich dies nur dann aus, wenn man die RouterLinkWithHref-Direktive z. B. als Standalone-Direktive importiert oder in View- bzw. ContentChildren verwendet. Einen Vergleich liefern die beiden Listings 13 und 14. Listing 13: Anchor mit RouterLink in Angular 14.2 @Component({ template: ``, standalone: true, imports: [RouterLinkWithHref] }) export class MyComponent { @ViewChild(RouterLinkWithHref) link!: RouterLinkWithHref } Listing 14: Anchor mit RouterLink in Angular 15 @Component({ template: ``, standalone: true, imports: [RouterLink] }) export class MyComponent { @ViewChild(RouterLink) link!: RouterLink } Angular CLI In Version 15 wurden analog zu Angular auch im Angular CLI die Versionen der Abhängigkeiten erhöht, sodass z. B. Node.js in folgenden Versionen oder höher vorliegen muss (dabei ist das „höher“ immer auf das jeweilige Major-Release bezogen): 14.20.x, 16.13.x oder 18.10.x. Außerdem wird TypeScript mindestens in Version 4.8.2 benötigt. Weiterhin wurde die Kompilations-Pipeline so angepasst, dass Angular nicht mehr mit ECMAScript ES5 als Zielplattform gebaut werden kann. Das sollte keine Auswirkungen auf die Nutzer:innen haben, da alle Browser, die Angular unterstützt, ohnehin die Standards ES2015+ beherrschen. Nach welchem ECMAScript-Standard der Build-Output genau generiert wurde, konnte bisher in der tsconfig.json des Projekts im Feld target eingestellt werden. Mit Angular 15 wird das Target nun automatisch anhand der .browserlistrc ermittelt. Es kann allerdings\n'slidetext': ''\n'from': 'index'\n'score': 142.87586975097656\n'normalizedScore': 1.4287586975097657\n'beforeDatePenaltyScore': 1.4287586975097657\n\n'documentId': 'e9905bc3e1a3780619966899'\n'chunk_id': '687814d7bed6dcd41a99b08e'\n'access': 'granted'\n'part_number': 1\n'total_parts': 17\n'contentType': 'READ'\n'title': Jetzt schlägt’s 15: Was ist neu in Angular 15? - Alle neuen Features von Angular 15 im Blick\n'parentName': Java Magazin 2.2023\n'language': 'DE'\n'date': '2023-01-03T02:00:00.000Z'\n'abstract': Angular 15 wurde für den produktiven Einsatz freigegeben. In diesem Tutorial werfen wir einen genauen Blick auf die neuen Features und Verbesserungen des JavaScript-Frameworks und geben Hinweise zum Umgang mit inkompatiblen Änderungen in Angular 15.\n'parentId': '9b91af29eb210add4465b516'\n'parentDescription': Über neun Millionen Software-Entwickler weltweit sorgen dafür, dass die Java-Technologie in allen Geschäftsfeldern und in allen Branchen eine zentrale Rolle spielt. Zudem ist das Java-Ökosystem der wichtigste Takt- und Impulsgeber für die gesamte Software-Industrie, wenn es um technische Innovationen geht. Das Java Magazin begleitet seit über 20 Jahren alle wesentlichen Entwicklungen der Java-Welt aktuell, kritisch und mit großer praktischer Relevanz. Software-Architekten, Entwickler und Projektleiter vertrauen auf die anerkannte Kompetenz der Redaktion verbunden mit ihrem Experten-Netzwerk bekannter Fachautoren.\n'indexBrandName': ''\n'indexSeriesName': ''\n'author': 'Karsten Sitterberg'\n'chunkSource': 'text'\n'text': Jetzt schlägt’s 15: Was ist neu in Angular 15? Alle neuen Features von Angular 15 im Blick Angular 15 wurde für den produktiven Einsatz freigegeben. In diesem Tutorial werfen wir einen genauen Blick auf die neuen Features und Verbesserungen des JavaScript-Frameworks und geben Hinweise zum Umgang mit inkompatiblen Änderungen in Angular 15. Angular 15 wurde für den produktiven Einsatz freigegeben. In diesem Tutorial werfen wir einen genauen Blick auf die neuen Features und Verbesserungen des JavaScript-Frameworks und geben Hinweise zum Umgang mit inkompatiblen Änderungen in Angular 15. Zusammen mit dem Angular-Framework wurden auch das Angular-CLI für Entwicklung und Build und das Angular-Material-Komponentensystem in den entsprechenden Versionen veröffentlicht. Angular 15 steht stark unter dem Gesichtspunkt der Standalone Components. Erstmals in Angular 14 als Preview veröffentlicht, sind die Standalone Components nun als stabil deklariert. In diesem Zuge sind nun weitere Bestandteile des Frameworks wie der Router und Route Guards angepasst worden, um gut mit Standalone Components und den nun optionalen NgModules umzugehen. Werfen wir zunächst einen kurzen Blick auf TypeScript, das Angular ab jetzt mindestens in Version 4.8 erfordert. TypeScript In der neuen TypeScript-Version gibt es einige, teils vorbereitende Anpassungen an kommende ECMAScript-Standards. So zum Beispiel den noch immer nicht endgültig spezifizierten Decorator-Standard. Angular nutzt die Decorators, um Typen mit Metadaten anzureichern und damit zum Beispiel für Dependency-Injection auszuzeichnen. Java-Entwickler kennen das verwandte Konzept der Annotations, die mit Java 5 eingeführt wurden. Daneben wurden einige Anpassungen an der Typinferenz von null und undefined bei Verwendung mit Generics oder Intersection-Types vorgenommen. Das kann in einigen Ausnahmefällen dazu führen, dass bestehende Anwendungslogik angepasst werden muss. In diesem Fall sollte es helfen, wenn zusätzliche Null-Checks eingebaut werden, wie in Listing 1 gezeigt wird. Listing 1: Erweitertes Type Narrowing von generischen Typparametern function throwIfNullable(value: T): NonNullable { if (value === undefined || value === null) { throw Error('Nullable value!'); } // War bisher Compilerfehler, da 'T' nicht an 'NonNullable' zuweisbar war. // Funktioniert jetzt, da Type Narrowing zu 'T & {}' durchgeführt wird, das entspricht //dann 'NonNullable'. return value; } Das\n'slidetext': ''\n'from': 'index'\n'score': 140.92239379882812\n'normalizedScore': 1.4092239379882812\n'beforeDatePenaltyScore': 1.4092239379882812\n\n'documentId': '5ecf87915aa99dfe10bb64dd'\n'chunk_id': '687814bebed6dcd41a99aff9'\n'access': 'granted'\n'part_number': 1\n'total_parts': 16\n'contentType': 'READ'\n'title': Is Angular 16 Starting a (R)evolution? - Breaking changes, features, and everything new in Angular 16\n'parentName': JavaScript Magazine Volume 8\n'language': 'EN'\n'date': '2023-03-08T23:00:00.000Z'\n'abstract': The newest version of Angular is here. Angular 16 introduces some new breaking changes and features and sets a new tone for the framework. This article dives into all of the changes and what developers need to know before migrating.\n'parentId': '4169b80642e03abd714cf6fe'\n'parentDescription': Broaden your knowledge and expand your JavaScript techniques and practices. From Angular, React, and WebAssembly, to the best JavaScript IDEs, open source tools and more, you’ll learn insights on everything JS from seasoned experts in their field. Keep up with JavaScript news, tips, and advice with interviews, tutorials, and in-depth articles.\n'indexBrandName': ''\n'indexSeriesName': ''\n'author': 'Karsten Sitterberg'\n'chunkSource': 'text'\n'text': Is Angular 16 Starting a (R)evolution? Breaking changes, features, and everything new in Angular 16 The newest version of Angular is here. Angular 16 introduces some new breaking changes and features and sets a new tone for the framework. This article dives into all of the changes and what developers need to know before migrating. Angular has an especially good reputation when it comes to long-lived applications where investment protection is an important criteria. Even during critical builds, like converting the rendering engine to Ivy, the Angular team has always shown good instinct. Through continuous ng-upgrade improvements and good engineering, necessary migrations means less effort for developers. This is especially true since many changes were implemented incrementally over the course of several releases. Often, even the API interface for typical applications could be kept stable. Angular 16 sets a new tone in that regard and not everyone will like that. Only time will tell whether the Angular team, and Google behind them, is making smart decisions. To get an idea ourselves, we’ll take a look at the important changes in Angular 16 in this article. TypeScript Angular also pays attention to keeping its own dependencies up to date with this release. Therefore, in Angular 16, TypeScript must be version 4.9 or 5.0. Let’s look at the major new features in TypeScript 4.9 first. The other new features in TypeScript 5 can be read in this article here. With TypeScript 4.9, came some innovations. For example, there are improvements in build performance or file-watching by the dev server. Additionally, an “auto-accessor” keyword was introduced (example: “public accessor name: string;”), which automatically creates both a “set” and a “get” accessor for the “name” property. A compiler hint was also added to print an error as soon as a comparison with “NaN” is performed, since these comparisons are actually always an error (“NaN !== x” is always “true”, even if “x=NaN”, while “NaN === x” always returns “false:). Instead, the function “Number.isNaN(someValue)” should be used. A new, helpful operator was also introduced. The new “satisfies” operator makes type-checking a bit more flexible. For example, an object should be created that corresponds to the “Campaign” data structure from Listing 1. Thanks to TypeScript's structural type system, a simple object “oldCampaign” can be constructed to match this structure. See Listing 1. Thanks to TypeScript’s structural type system, a simple object “oldCampaign” can be constructed that corresponds to this structure. See Listing 1. However, an error found its way into this object. The “enddate” property has a typo. The\n'slidetext': ''\n'from': 'index'\n'score': 141.46890258789062\n'normalizedScore': 1.4146890258789062\n'beforeDatePenaltyScore': 1.4146890258789062\n\n'documentId': '5ecf87915aa99dfe10bb64dd'\n'chunk_id': '687814bfbed6dcd41a99b003'\n'access': 'granted'\n'part_number': 11\n'total_parts': 16\n'contentType': 'READ'\n'title': Is Angular 16 Starting a (R)evolution? - Breaking changes, features, and everything new in Angular 16\n'parentName': JavaScript Magazine Volume 8\n'language': 'EN'\n'date': '2023-03-08T23:00:00.000Z'\n'abstract': The newest version of Angular is here. Angular 16 introduces some new breaking changes and features and sets a new tone for the framework. This article dives into all of the changes and what developers need to know before migrating.\n'parentId': '4169b80642e03abd714cf6fe'\n'parentDescription': Broaden your knowledge and expand your JavaScript techniques and practices. From Angular, React, and WebAssembly, to the best JavaScript IDEs, open source tools and more, you’ll learn insights on everything JS from seasoned experts in their field. Keep up with JavaScript news, tips, and advice with interviews, tutorials, and in-depth articles.\n'indexBrandName': ''\n'indexSeriesName': ''\n'author': 'Karsten Sitterberg'\n'chunkSource': 'text'\n'text': 'CSP_NONCE' injection token to set a CSP nonce, which Angular appends to the inline styles. If the index.html can still be modified at production time by the delivering server, then instead of the injection token, the attribute 'ngCspNonce' can simply be set on the app element. See Listing 17. It’s especially important here that the value of 'XYZ' is not a fixed value. It must be recalculated each time the index.html is delivered. A fixed nonce would have similar security properties as the CSP directive 'unsafe-inline'. Together with the nonce property in the index.html, the nonce must also be included in the CSP directive. For example: 'style-src 'nonce-XYZ' 'self'' or somewhat more strictly 'style-src 'nonce-XYZ' 'strict-dynamic''. This feature was developed in collaboration between the Angular core, -material and -CLI teams, so these packages also support the new mechanism accordingly. Listing 17: Dynamic configuration of CSP nonce value in index.html  Another new small feature is the 'DestroyRef'. This can be injected like a service and allows to register logic via callback, which is executed when the component is OnDestroy. For example, resources can be released this way without having to implement the 'ngOnDestroy()' lifecycle hook, see also Listing 18. To remove the Destroy logic again, for example, if a resource has already been released for a different reason, the 'unregisterFn()' can be called. In this example, 'doSomethingOnDestroy()' would no longer be called. Besides the DestroyRef, a new package '@angular/rxjs-interop' has also been introduced, which is mainly used with the new signals. This package offers the function 'takeUntilDestroyed()'. This function is a pipeable rxjs operator and can be used to terminate observables once the associated component has been destroyed. Under the hood, this new operator uses a DestroyRef. Listing 18 shows how to use the operator to terminate an interval observable once the component is cleared. In this case, the 'takeUntilDestroyed' operator is explicitly given a DestroyRef. This step can also be omitted, then the operator gets the DestroyRef itself via 'inject()' function. This would mean that the operator - or the entire observable - must be created in the constructor, since the 'inject()' mechanism requires the constructor context. Listing 18: Example of how to use the DestroyRef constructor(private destroyRef: DestroyRef) { const unregisterFn = destroyRef.onDestroy(() => doSomethingOnDestroy() ); // unregisterFn(); // Takes back onDestroy logic } ngOnInit(): void { interval(1000) .pipe(takeUntilDestroyed(this.destroyRef)) .subscribe(val => console.log('value:', val)) } Listen to the signals… Angular 16 introduces a new\n'slidetext': ''\n'from': 'index'\n'score': 141.4591827392578\n'normalizedScore': 1.4145918273925782\n'beforeDatePenaltyScore': 1.4145918273925782\n\n'documentId': '5ecf87915aa99dfe10bb64dd'\n'chunk_id': '687814bfbed6dcd41a99affc'\n'access': 'granted'\n'part_number': 4\n'total_parts': 16\n'contentType': 'READ'\n'title': Is Angular 16 Starting a (R)evolution? - Breaking changes, features, and everything new in Angular 16\n'parentName': JavaScript Magazine Volume 8\n'language': 'EN'\n'date': '2023-03-08T23:00:00.000Z'\n'abstract': The newest version of Angular is here. Angular 16 introduces some new breaking changes and features and sets a new tone for the framework. This article dives into all of the changes and what developers need to know before migrating.\n'parentId': '4169b80642e03abd714cf6fe'\n'parentDescription': Broaden your knowledge and expand your JavaScript techniques and practices. From Angular, React, and WebAssembly, to the best JavaScript IDEs, open source tools and more, you’ll learn insights on everything JS from seasoned experts in their field. Keep up with JavaScript news, tips, and advice with interviews, tutorials, and in-depth articles.\n'indexBrandName': ''\n'indexSeriesName': ''\n'author': 'Karsten Sitterberg'\n'chunkSource': 'text'\n'text': outputs. Furthermore, the esbuild DevServer can now use e.g. SSL. The inclusion is done as with the existing setup via “ng serve --ssl”. Additional scripts can be included in the build. This is handy when including global scripts like the Google Tag Manager. Some enhancements have also been made to the existing build system: For example, new applications can be generated as standalone applications (i.e. without @NgModules). For this purpose, the flag “--standalone” is included when generating the application. In order to align the functionality of standalone applications with the functionality of previous Angular applications, it is now also possible to generate service workers and app shells for standalone applications via schematics. The app or expertise in the app must be tested to ensure that the functionality of the applications you painstakingly built is guaranteed in the long term. There are different levels of testing for this, such as E2E or unit tests. Support for Protractor as the default E2E tool was discontinued several Angular CLI versions ago. Since then, Protractor itself has also been discontinued. Now it continues with unit tests. Karma was also initiated by Google, but has been discontinued in the meantime. Therefore, Angular is working on a successor. There will probably be different options. If less value is placed on a browser-oriented test environment, and the test execution speed is more important, then the Jest tool can be used. This comes from the React environment. A preview implementation for this tool is coming in Angular-CLI 16, but it shouldn’t be used in production yet. It can be activated by switching to the new Jest test builder ('builder': '@angular-devkit/build-angular:karma') instead of the previous test builder ('builder': '@angular-devkit/build-angular:jest'). Alternatively, there are efforts to connect the 'Vitest' test system from the Vue environment. In order to be able to continue to run tests in the browser, Angular-CLI will prospectively switch the current Karma/Jasmine tests to the “Web Test Runner”/Jasmine combination. Similar to Karma, the “Web Test Runner” can run tests in the browser. The Jasmine syntax will continue to be used as the text syntax in order to make the changeover as simple as possible. Breaking Changes in Angular-CLI 16 Of course, with the new major Angular CLI version, there are also some breaking changes. Support for TypeScript 4.8 and Node.js 14 has been removed. Instead, TypeScript 5 is used as the default, and Node.js should be version 16, 18, or newer. Angular CLI 16 also cuts some obsolete or outdated braids. The Angular compatibility compiler NGCC is removed in Angular CLI 16. NGCC was responsible for transforming old\n'slidetext': ''\n'from': 'index'\n'score': 140.78968811035156\n'normalizedScore': 1.4078968811035155\n'beforeDatePenaltyScore': 1.4078968811035155\n\n'documentId': '169cb8b4177f542b161210ec'\n'chunk_id': '69037b9752f58e0014b29c22'\n'access': 'granted'\n'part_number': 10\n'total_parts': 19\n'contentType': 'RHEINGOLD'\n'title': Supercharge your Apps with Incremental Hydration\n'parentName': International JavaScript Conference Munich 2025\n'language': 'EN'\n'date': '2025-10-30T11:00:00.000Z'\n'abstract': Discover how Server-Side Rendering (SSR) can boost the performance and user experience of your Angular applications. In this talk, I'll guide you through @angular/ssr, a modern SSR solution that has evolved significantly in recent years to deliver faster initial loads. We'll explore Static Site Generation (SSG, aka Prerendering) during the build process and the features Full-App Hydration (since v16), Deferrable Views (v17) Event Replay (v18), and Hybrid Rendering (v19). The spotlight will be on Incremental Hydration (since v19, stable in v20) – the cutting-edge evolution of @defer blocks combined with SSG. I'll explain how this technique works, highlight its potential, and demonstrate its application with selected examples. The session is aimed at both Angular developers who are just getting started with SSR and experienced Angular pros looking to get to know the latest SSR capabilities. slug: angular-ssr-incremental-hydration\n'parentId': 'd9a5c0715a7cff50bbb51e14'\n'parentDescription': \n'indexBrandName': 'InternationalJavaScriptCon'\n'indexSeriesName': 'Munich'\n'author': 'Alexander Thalhammer'\n'chunkSource': 'text'\n'text': click will be repeated. So for the user it seems like uh everything is just working while, uh, he has clicked on a button without a function, so that's pretty cool. And that's needed for for incremental hydration, but I will come back to that later. Another interesting feature is hybrid rendering, which is also usable from Angola 19, and this is where you can select the render mode for each route. So we already talked about client side rendering, server side rendering, static side generation, and in Angular it's called pre-render, server, and client. So you can specify for each route in your server routes. It's a little bit, um, yeah, boilerplatey in my opinion. Because now you have app routes and you and you additionally have app server routes, I hope, um, Or broad server, I hope in the future they they might merge these, uh, two configs together, these, these two rout arrays together, but yeah, let's see. It's pretty new, so there might be some improvements in the near future. Another feature we get with Angle and 19 is, uh, or with hybrid rendering is you can now, uh, on the server create redirects. And uh for 4 pages. Which previously you couldn't and um yeah that's pretty cool because you enter a URL on your browser and then on on the server you will be already redirected so you don't have to uh because uh in the old let's say version you would have had to download and bootstrap the application and to be redirected one once the application has already bootstrapped and all the JavaScript, uh, has been, uh, parsed and executed. So this is of course also um much faster for the for the redirect. Another, uh, the final ingredient that we need for, uh, incremental hydration are standalone components. Future is standalone. I had to remember this, uh, image from the blog post, uh, a few years ago. So of course, uh, you should be using standalone components to avoid this issue which I regularly, uh, encounter in my, uh, trainings and consultings with, uh, the performance topic because most teams, uh, have worked like this. They had, uh, lazy loading implemented, but, um, yeah, they had this huge shared module with all shared dependencies with the design system, the component framework, the chart library and the table library and, and so on and so forth. And everything was put into the shared module which has 90 or 95% of the bundle size, and then that shared model is used in every feature model, so, uh, you basically ruin your lazy loading completely. How did\n'slidetext': ''\n'from': 'vector'\n'score': 0.9099029302597046\n'normalizedScore': 0.9092903348341592\n'beforeDatePenaltyScore': 0.9099029302597046\n\n\nReferenceChunks:\n'documentId': '169cb8b4177f542b161210ec'\n'chunk_id': '69037b9752f58e0014b29c22'\n'access': 'granted'\n'part_number': 10\n'total_parts': 19\n'poc_summary': 'This conference talk examines how Angular’s incremental hydration and deferrable views enhance SSR performance and user experience.'\n'chunk_summary': 'It explains hybrid rendering, allowing route-specific render modes and server-side redirects in Angular.'\n'access_message': '✅ You still have access to the recordings for this talk of International JavaScript Conference Munich 2025 until 2026-04-28. Unfortunately, recordings are not available for workshops, but you can still access the slides and your certificate. Dive back in anytime!'\n\n'documentId': '5ecf87915aa99dfe10bb64dd'\n'chunk_id': '687814bfbed6dcd41a99affc'\n'access': 'granted'\n'part_number': 4\n'total_parts': 16\n'poc_summary': 'This article examines Angular 16’s breaking changes, novel features and APIs (CLI, framework, signals, hydration), and implications for migration and future direction.'\n'chunk_summary': 'It highlights Angular CLI 16’s esbuild DevServer support with SSL and progress output enhancements.'\n'access_message': '✅ This content is included with your elevate membership.'\n\n'documentId': 'e9905bc3e1a3780619966899'\n'chunk_id': '687814d7bed6dcd41a99b08e'\n'access': 'granted'\n'part_number': 1\n'total_parts': 17\n'poc_summary': 'This article reviews Angular 15’s enhancements, detailing its stabilized standalone APIs, TypeScript and CLI updates, new functional guards and interceptors, and key migration steps.'\n'chunk_summary': 'It explains TypeScript 4.8’s improved generic type narrowing illustrated by the throwIfNullable function example.'\n'access_message': '✅ This content is included with your elevate membership.'\n\n'documentId': '2e2495f42751c019986f5bc4'\n'chunk_id': '687ab74d2be886398c2ad124'\n'access': 'granted'\n'part_number': 2\n'total_parts': 9\n'poc_summary': 'This article surveys Java 16’s key features—from pattern matching, sealed classes, and records to tooling improvements—to support the transition to the next LTS release.'\n'chunk_summary': 'It explains Java 16’s finalization of Pattern Matching for instanceof (JEP 394) to eliminate casts.'\n'access_message': '✅ This content is included with your elevate membership.'\n\n'documentId': '64ace3828d8056484c3534ab'\n'chunk_id': '687814c4bed6dcd41a99b019'\n'access': 'granted'\n'part_number': 1\n'total_parts': 21\n'poc_summary': 'This article overviews Angular 16’s key new features and breaking changes across TypeScript, CLI, framework, Signals, SSR, and dependency updates.'\n'chunk_summary': 'It notes that Angular 16 now requires TypeScript 4.9 or 5.0.'\n'access_message': '✅ This content is included with your elevate membership.'\n\n'documentId': 'bb97d9e8205e4d23e8d34081'\n'chunk_id': '687814d2bed6dcd41a99b06b'\n'access': 'granted'\n'part_number': 9\n'total_parts': 13\n'poc_summary': 'This article examines Angular 15’s focus on stable standalone components and updated APIs while providing guidance on new features and handling breaking changes.'\n'chunk_summary': 'It explains the hostDirectives API for applying CdkMenuTrigger with input/output mappings.'\n'access_message': '✅ This content is included with your elevate membership.'\n\n'documentId': 'a980d2604065cad105b1bfaa'\n'chunk_id': '687abc062be886398c2b0218'\n'access': 'granted'\n'part_number': 1\n'total_parts': 9\n'poc_summary': 'This article reviews Java’s upcoming LTS roadmap for JDK 17 by examining Java 16’s key enhancements like pattern matching, sealed classes, records, APIs and tooling changes.'\n'chunk_summary': 'It emphasizes Java’s halfannual major releases and triennial LTS cycle; JDK 17 arrives September 2021.'\n'access_message': '✅ This content is included with your elevate membership.'\n\n'documentId': 'ac8bcbad20150e9773f7400b'\n'chunk_id': '69021a60a5de460012a1af2b'\n'access': 'granted'\n'part_number': 11\n'total_parts': 11\n'poc_summary': 'This conference talk presents practical techniques for using Angular DevTools to debug, profile, and optimize modern Angular applications.'\n'chunk_summary': 'It answers audience questions about signal store integration and router tree availability in Angular DevTools.'\n'access_message': '✅ You still have access to the recordings for this talk of International JavaScript Conference Munich 2025 until 2026-04-27. Unfortunately, recordings are not available for workshops, but you can still access the slides and your certificate. Dive back in anytime!'\n\n'documentId': '0747f0655ef3790a97eba95b'\n'chunk_id': '68f24b683134c10012c3d12d'\n'access': 'restricted'\n'part_number': 2\n'total_parts': 16\n'poc_summary': 'This conference talk examines modern Angular architecture in 2025, focusing on signals, resources, and lazy loading for scalable, maintainable apps.'\n'chunk_summary': 'It highlights Angular’s evolution from version 14 onward, emphasizing the shift to standalone components and signals for simplicity.'\n'access_message': 'ℹ️ This talk of International JavaScript New York 2025 was part of a past event. Booking is no longer available, but you can discover the current edition right here on the platform.'\n\n'documentId': '5047e9550eef9d941aaa1376'\n'chunk_id': '690347ae52f58e0014b29b95'\n'access': 'granted'\n'part_number': 10\n'total_parts': 22\n'poc_summary': 'This conference talk examines how large language models can enable dynamic runtime configuration and navigation in Angular enterprise applications.'\n'chunk_summary': 'It presents a provider function that injects dynamic routes and manages lazy loading based on configuration.'\n'access_message': '✅ You still have access to the recordings for this talk of International JavaScript Conference Munich 2025 until 2026-04-28. Unfortunately, recordings are not available for workshops, but you can still access the slides and your certificate. Dive back in anytime!'\n\n'documentId': '918dc8a09612c28c04090931'\n'chunk_id': '68f25086d754e200146e6f0a'\n'access': 'restricted'\n'part_number': 16\n'total_parts': 16\n'poc_summary': 'This conference talk examines how NestJS enables scalable, maintainable Node.js applications through modular architecture, dependency injection, and clean design patterns.'\n'chunk_summary': 'It confirms that NestJS’s architecture was inspired by Angular, especially regarding dependency injection and orchestration.'\n'access_message': 'ℹ️ This talk of International JavaScript New York 2025 was part of a past event. Booking is no longer available, but you can discover the current edition right here on the platform.'\n\n'documentId': '74929d5c8003451930366f98'\n'chunk_id': '6903455752f58e0014b29b84'\n'access': 'granted'\n'part_number': 10\n'total_parts': 16\n'poc_summary': 'This conference talk examines practical strategies for integrating multiple versions and frameworks in micro frontend architectures using web standards.'\n'chunk_summary': 'It explains technical constraints like zone.js and platform objects, and how Angular 20.2 improves micro frontend integration.'\n'access_message': '✅ You still have access to the recordings for this talk of International JavaScript Conference Munich 2025 until 2026-04-27. Unfortunately, recordings are not available for workshops, but you can still access the slides and your certificate. Dive back in anytime!'\n\n'documentId': '1fed2c6361980d606789e315'\n'chunk_id': '68c26fcc0a53cd001394ab93'\n'access': 'granted'\n'part_number': 3\n'total_parts': 8\n'poc_summary': 'This article discusses Angular 20’s evolution, focusing on signals, reactivity, dynamic components, and the framework’s future direction.'\n'chunk_summary': 'It describes Angular’s ability to evolve internally, like the Ivy engine and optional NgModules, without breaking changes.'\n'access_message': '✅ This content is included with your elevate membership.'\n\n'documentId': '57ca0d48729b52fa55c618a2'\n'chunk_id': '68baebf1c846ad0013b2721b'\n'access': 'restricted'\n'part_number': 12\n'total_parts': 19\n'poc_summary': 'This conference talk examines evolving testing strategies in Angular, emphasizing the shift from unit tests to integration-focused approaches.'\n'chunk_summary': 'It describes simulating routing and backend responses to test the quiz feature’s behavior in integration tests.'\n'access_message': 'ℹ️ This talk of International JavaScript Conference London 2025 was part of a past event. Booking is no longer available, but you can discover the current edition right here on the platform.'\n\n'documentId': '73a55b4bbeecf374b233deaf'\n'chunk_id': '687a299f2491ed518a3f0cf6'\n'access': 'restricted'\n'part_number': 1\n'total_parts': 1\n'poc_summary': 'This conference talk examines Angular’s latest innovations for building modern, high-performance web applications.'\n'chunk_summary': 'It highlights standalone components, lazy loading, control flow, deferrable views, signals, and zoneless Angular.'\n'access_message': 'ℹ️ This talk of International JavaScript Conference Singapore 2024 was part of a past event. Booking is no longer available, but you can discover the current edition right here on the platform.'\n\n'documentId': '5ca564ac8c4557f4f949b660'\n'chunk_id': '687a2b82495b49563aa87acd'\n'access': 'restricted'\n'part_number': 1\n'total_parts': 9\n'poc_summary': 'This conference talk examines how new Angular APIs enable modern codebases, focusing on migration strategies and developer experience.'\n'chunk_summary': 'It highlights Angular’s shift to standalone APIs, enhanced server-side rendering, and optional RxJS for easier code management.'\n'access_message': 'ℹ️ This talk of International JavaScript Conference Munich 2024 was part of a past event. Booking is no longer available, but you can discover the current edition right here on the platform.'\n\n'documentId': 'hzv9J8cq9SXBKG4bM'\n'chunk_id': '687a3240ca798166d3ba4f14'\n'access': 'restricted'\n'part_number': 1\n'total_parts': 1\n'poc_summary': 'This flexible seminar lesson introduces the role of the Angular Router in enabling navigation within single-page applications.'\n'chunk_summary': 'It explains how the Router enables deep-linking and simulates multiple pages in Angular apps.'\n'access_message': 'ℹ️ This talk of Angular Camp - Flexible Basic Camp November 2024 | online was part of a past event. Booking is no longer available, but you can discover the current edition right here on the platform.'\n\n'documentId': '04d78d5f018fc264533778bd'\n'chunk_id': '687a2114a98d5a30b3a341b0'\n'access': 'restricted'\n'part_number': 3\n'total_parts': 9\n'poc_summary': 'This conference talk provides practical insights into Angular’s Dependency Injection system and the use of directives for flexible application configuration.'\n'chunk_summary': 'It demonstrates the environment injector hierarchy and the consequences of missing dependency providers.'\n'access_message': 'ℹ️ This talk of International JavaScript Conference Munich 2024 was part of a past event. Booking is no longer available, but you can discover the current edition right here on the platform.'\n\n'documentId': 'XE4Euthn2BEnPwhbr'\n'chunk_id': '687a2eed9bbcb45d2a11fb63'\n'access': 'restricted'\n'part_number': 1\n'total_parts': 1\n'poc_summary': 'This flexible seminar lesson introduces the role of the Angular Router in enabling navigation within single-page applications.'\n'chunk_summary': 'It explains how the router enables deep-linking and simulates multiple pages in Angular apps.'\n'access_message': 'ℹ️ This talk of Angular Camp - Flexible Basic Camp September 2024 | online was part of a past event. Booking is no longer available, but you can discover the current edition right here on the platform.'\n\n'documentId': 'N9G6dCb5BArvu6cbr'\n'chunk_id': '687a2d549bbcb45d2a11eac1'\n'access': 'restricted'\n'part_number': 14\n'total_parts': 23\n'poc_summary': 'This conference talk examines Angular’s latest APIs, migration strategies, and features for modernizing enterprise applications with future-proof architecture.'\n'chunk_summary': 'It introduces component input bindings in the Angular router, allowing automatic mapping of route parameters to component inputs.'\n'access_message': 'ℹ️ This talk of International JavaScript Conference San Diego 2024 was part of a past event. Booking is no longer available, but you can discover the current edition right here on the platform.'\n\n'documentId': 'ec8de39dac90e93f9fd00a92'\n'chunk_id': '687a312cca798166d3ba43b5'\n'access': 'restricted'\n'part_number': 11\n'total_parts': 12\n'poc_summary': 'This conference talk presents advanced strategies and practical techniques for optimizing Angular application performance in modern web development.'\n'chunk_summary': 'It discusses experimental zone-less APIs and clarifies how OnPush change detection works in practice.'\n'access_message': 'ℹ️ This talk of International JavaScript New York 2024 was part of a past event. Booking is no longer available, but you can discover the current edition right here on the platform.'\n\n'documentId': 'xrng8DfDqckoEKvMr'\n'chunk_id': '687a30f3ca798166d3ba4157'\n'access': 'restricted'\n'part_number': 4\n'total_parts': 30\n'poc_summary': 'This conference talk presents Angular 18’s new features and migration strategies for updating existing projects efficiently.'\n'chunk_summary': 'It shows improvements like fallback content for ng-content, Material 3 support, and TypeScript 5.4 compatibility.'\n'access_message': 'ℹ️ This talk of BASTA! Herbst 2024 was part of a past event. Booking is no longer available, but you can discover the current edition right here on the platform.'\n\n'documentId': 'b3ayobXPMcKfG7CMq'\n'chunk_id': '687a2f7b9bbcb45d2a120133'\n'access': 'restricted'\n'part_number': 1\n'total_parts': 1\n'poc_summary': 'This flexible seminar lesson introduces the role of the router in Angular applications for simulating pages and enabling deep linking.'\n'chunk_summary': 'It explains how the Angular router acts as the central component in most applications.'\n'access_message': 'ℹ️ This talk of Angular Camp - Flexible Basic Camp Juni 2024 | online was part of a past event. Booking is no longer available, but you can discover the current edition right here on the platform.'\n\n'documentId': 'mrkFPBdm5bQQ8Q8nY'\n'chunk_id': '687a355fca798166d3ba5e1c'\n'access': 'restricted'\n'part_number': 1\n'total_parts': 22\n'poc_summary': 'This conference talk examines Angular’s evolution toward standalone APIs, signals, and modern migration strategies for future-proof applications.'\n'chunk_summary': 'It introduces Angular’s recent features, including advanced server-side rendering and the new control flow syntax.'\n'access_message': 'ℹ️ This talk of International JavaScript Conference London 2024 was part of a past event. Booking is no longer available, but you can discover the current edition right here on the platform.'\n\n'documentId': 'PnApHFiNAR2RR6pkD'\n'chunk_id': '687a2dde9bbcb45d2a11f093'\n'access': 'restricted'\n'part_number': 1\n'total_parts': 20\n'poc_summary': 'This conference talk demonstrates building a modern Angular app from scratch using standalone components, signals, template blocks, and server-side rendering.'\n'chunk_summary': 'The talk introduces a live coding session focused on leveraging Angular's latest features in a quiz application.'\n'access_message': 'ℹ️ This talk of International JavaScript Conference San Diego 2024 was part of a past event. Booking is no longer available, but you can discover the current edition right here on the platform.'\n\n\nTop Atlas:\n'documentId': '2e2495f42751c019986f5bc4'\n'chunk_id': '687ab74d2be886398c2ad123'\n'access': 'granted'\n'part_number': 1\n'total_parts': 9\n'contentType': 'READ'\n'title': Java 16: Das JDK auf dem Weg zur nächsten LTS-Version - Sweet 16\n'parentName': JAXenter 3.2021\n'language': 'DE'\n'date': '2021-03-01T16:58:00.000Z'\n'abstract': 14, 15 oder doch schon 16? Da kann man schon mal durcheinanderkommen. Durch die mittlerweile halbjährlichen Major-Releases von Java fällt es gar nicht so leicht, die aktuelle Version richtig zu benennen. Vor Kurzem hat man sich in einem Vortrag noch über die Neuerungen des JDK 14 informiert, und wenig später wurden in einem Artikel bereits die Features von Version 15 näher beleuchtet. Und da sich die Welt bekanntlich schnell weiterdreht, ist nun im März 2021 bereits das OpenJDK 16 herausgekommen.\n'parentId': 'f3f07cfbd5f6d489e27c1d11'\n'parentDescription': n/a\n'indexBrandName': ''\n'indexSeriesName': ''\n'author': 'Falk Sippach'\n'chunkSource': 'text'\n'text': Java 16: Das JDK auf dem Weg zur nächsten LTS-Version Sweet 16 14, 15 oder doch schon 16? Da kann man schon mal durcheinanderkommen. Durch die mittlerweile halbjährlichen Major-Releases von Java fällt es gar nicht so leicht, die aktuelle Version richtig zu benennen. Vor Kurzem hat man sich in einem Vortrag noch über die Neuerungen des JDK 14 informiert, und wenig später wurden in einem Artikel bereits die Features von Version 15 näher beleuchtet. Und da sich die Welt bekanntlich schnell weiterdreht, ist nun im März 2021 bereits das OpenJDK 16 herausgekommen. 14, 15 oder doch schon 16? Da kann man schon mal durcheinanderkommen. Durch die mittlerweile halbjährlichen Major-Releases von Java fällt es gar nicht so leicht, die aktuelle Version richtig zu benennen. Vor Kurzem hat man sich in einem Vortrag noch über die Neuerungen des JDK 14 informiert, und wenig später wurden in einem Artikel bereits die Features von Version 15 näher beleuchtet. Und da sich die Welt bekanntlich schnell weiterdreht, ist nun im März 2021 bereits das OpenJDK 16 herausgekommen. Um die Verwirrung komplettzumachen, kann man sich natürlich auch nur auf die sogenannten Long-Term-Support-Versionen (LTS) konzentrieren, die alle drei Jahre erscheinen. Das ist im Moment Java 11, wobei in der freien Wildbahn die Version 8 ebenfalls noch sehr weit verbreitet ist. Im September 2021 wird nun mit dem JDK 17 das nächste LTS-Release erscheinen. Dort werden die Neuerungen der vergangenen drei Jahre (Java 12 bis 16) finalisiert, um bis zur darauffolgenden LTS-Version (JDK 23) gut dazustehen. In den vergangenen „Zwischen“-Releases wurden die diversen, teilweise auch größeren Änderungen häufig als Previews veröffentlicht. Dadurch konnte frühzeitig Feedback eingesammelt und bereits im nächsten Release eingearbeitet werden. (Nicht ganz so) neue Features Die Liste der für das OpenJDK 16 umgesetzten JEPs (Java Enhancement Proposals) sieht auf den ersten Blick wieder relativ lang aus [1]: - 338: Vector API (Incubator) - 347: Enable C++14 Language Features - 357: Migrate from Mercurial to Git - 369: Migrate to GitHub - 376: ZGC: Concurrent Thread-Stack Processing - 380: Unix-Domain Socket Channels - 386: Alpine Linux Port - 387: Elastic\n'slidetext': ''\n'from': 'index'\n'score': 145.7696990966797\n'normalizedScore': 1.457696990966797\n'beforeDatePenaltyScore': 1.457696990966797\n\n'documentId': '5ecf87915aa99dfe10bb64dd'\n'chunk_id': '687814bfbed6dcd41a99affd'\n'access': 'granted'\n'part_number': 5\n'total_parts': 16\n'contentType': 'READ'\n'title': Is Angular 16 Starting a (R)evolution? - Breaking changes, features, and everything new in Angular 16\n'parentName': JavaScript Magazine Volume 8\n'language': 'EN'\n'date': '2023-03-08T23:00:00.000Z'\n'abstract': The newest version of Angular is here. Angular 16 introduces some new breaking changes and features and sets a new tone for the framework. This article dives into all of the changes and what developers need to know before migrating.\n'parentId': '4169b80642e03abd714cf6fe'\n'parentDescription': Broaden your knowledge and expand your JavaScript techniques and practices. From Angular, React, and WebAssembly, to the best JavaScript IDEs, open source tools and more, you’ll learn insights on everything JS from seasoned experts in their field. Keep up with JavaScript news, tips, and advice with interviews, tutorials, and in-depth articles.\n'indexBrandName': ''\n'indexSeriesName': ''\n'author': 'Karsten Sitterberg'\n'chunkSource': 'text'\n'text': is used as the default, and Node.js should be version 16, 18, or newer. Angular CLI 16 also cuts some obsolete or outdated braids. The Angular compatibility compiler NGCC is removed in Angular CLI 16. NGCC was responsible for transforming old libraries still based on the view engine to make them compatible with the new Ivy compiler. Since the view engine has already been deprecated since Angular 12, the Angular team assumes that all essential libraries have already been adapted accordingly so that they are made available in an Ivy-compatible way. This means that projects still using libraries built only for the view engine cannot migrate to Angular 16 until the libraries have been adapted. If these are transitive dependencies, you may not even be aware of this potential problem. In order to make a library compatible for Ivy, the respective library should be changed to a more recent Angular version (at least 12) and in the “tsconfig.lib.prod.json” the compiler mode should be set to “partial”. See Listing 6. Since this usually doesn’t have any negative effects, this mode should definitely be activated. With this change, the transition from the old view engine is finally complete. Ultimately, code omitted in this way should allow the application bundles to get smaller again. Listing 6: Partial library compile mode { // ... 'angularCompilerOptions': { 'compilationMode': 'partial' } } In Angular 15, the “CanMatch” guard has been added to the router. This guard allows individual routes from the Angular route configuration to be blocked for matching, which occurs during every routing process. This means that the guard starts earlier in the routing process than the old CanLoad and CanActivate guards. This makes the Guard much more flexible. Because of this, the schematic for the CanLoad guard is removed in the Angular CLI. Instead, the new CanMatch guard is used. In the routing process, resolvers allow data to be loaded in parallel with a routing operation. They can be included in the route configuration similarly to the guards and are executed after the guards in the routing process. The previously class-based resolvers and guards are now generated as functional resolvers and guards, respectively, by default. This is in line with the new standard, which we will look at in more detail in the Angular section later. The old behavior of Angular Schematics is still available until further notice. For this, “--no-functional” has to be specified as an additional switch. The class-based implementation is marked as deprecated, so developers should deal with the issue now and change if necessary. Furthermore, various configuration parameters of angular.json have been removed after they were already deprecated in previous versions. This affects “defaultProject”, which could be used to configure the\n'slidetext': ''\n'from': 'index'\n'score': 144.7579345703125\n'normalizedScore': 1.447579345703125\n'beforeDatePenaltyScore': 1.447579345703125\n\n'documentId': '5ecf87915aa99dfe10bb64dd'\n'chunk_id': '687814bfbed6dcd41a99b000'\n'access': 'granted'\n'part_number': 8\n'total_parts': 16\n'contentType': 'READ'\n'title': Is Angular 16 Starting a (R)evolution? - Breaking changes, features, and everything new in Angular 16\n'parentName': JavaScript Magazine Volume 8\n'language': 'EN'\n'date': '2023-03-08T23:00:00.000Z'\n'abstract': The newest version of Angular is here. Angular 16 introduces some new breaking changes and features and sets a new tone for the framework. This article dives into all of the changes and what developers need to know before migrating.\n'parentId': '4169b80642e03abd714cf6fe'\n'parentDescription': Broaden your knowledge and expand your JavaScript techniques and practices. From Angular, React, and WebAssembly, to the best JavaScript IDEs, open source tools and more, you’ll learn insights on everything JS from seasoned experts in their field. Keep up with JavaScript news, tips, and advice with interviews, tutorials, and in-depth articles.\n'indexBrandName': ''\n'indexSeriesName': ''\n'author': 'Karsten Sitterberg'\n'chunkSource': 'text'\n'text': others that can be used to configure dependency injection, are not yet possible with the new specification. Since it is not yet certain whether parameter decorators will be included in the ECMAScript and TypeScript specifications, Angular continues to use 'experimentalDecorators' by default. If both TypeScript 5 decorators and DI configurations will be used, the 'inject()' function introduced in Angular 14 must be used, as seen in Listing 9. Listing 9: inject()function with Flags @Component({}) class DemoComponent { readonly demoService = inject(DemoService, { optional: true, host: true }); } As mentioned previously, the router guard and resolver interfaces are deprecated. Therefore, all references to these interfaces will be deleted by an automatic migration when upgrading to Angular 16. At first, the Guard can continue to be used as usual, since TypeScript now checks the Guard function’s signature itself. Listing 10 shows an example of a 'CanActivate' guard. Its 'canActivate()' method must match the 'CanActivateFn' type for the guard to be used as a CanActivate guard. Listing 10 also shows what a functional 'CanActivate' guard looks like in principle. It should be mentioned here that you can also inject services in functional guards. The 'inject()' function must be used for this. See Listing 10. In the future, guards will only be written functionally, but you will also still be able to write guards and resolvers class-based. In future Angular versions, this guard must be converted. The conversion can be done in the route definition. Angular provides the conversion functions. Listing 11 shows an example of the conversion function 'mapToCanActivate()', which can be used to transform an array of class-based CanActivate guards into functional guards. Listing 11 also shows that class-based and functional guards can be used on the same route by concatenating the two. Listing 10: Class-based Guard and Functional Guard @Injectable({providedIn: 'root'}) export class DemoClassGuard { constructor(private authService: DemoAuthService) {} canActivate(route: ActivatedRouteSnapshot, state: RouterStateSnapshot): boolean | UrlTree { return this.auth.isLoggedIn(); } } export const demoFuncGuard: CanActivateFn = (route, state) => { const authService = inject(DemoAuthService) return authService.isLoggedIn(); }; Listing 11: Future integration of Guards const routes: Routes = [ { path: 'demo', canActivate: mapToCanActivate([DemoClassGuard]) .concat(demoFuncGuard), component: DemoComponent } ]; Another pleasant feature has been added to the router in version 16, which can make a lot of boilerplate redundant. Now you can bind data from the routing process directly to component inputs. This can involve binding data dynamically loaded via resolver, and data from the query parameters to the component. Listing 12 shows a component that is bound using the route configuration from Listing\n'slidetext': ''\n'from': 'index'\n'score': 144.26171875\n'normalizedScore': 1.4426171875\n'beforeDatePenaltyScore': 1.4426171875\n\n'documentId': 'e9905bc3e1a3780619966899'\n'chunk_id': '687814d9bed6dcd41a99b098'\n'access': 'granted'\n'part_number': 11\n'total_parts': 17\n'contentType': 'READ'\n'title': Jetzt schlägt’s 15: Was ist neu in Angular 15? - Alle neuen Features von Angular 15 im Blick\n'parentName': Java Magazin 2.2023\n'language': 'DE'\n'date': '2023-01-03T02:00:00.000Z'\n'abstract': Angular 15 wurde für den produktiven Einsatz freigegeben. In diesem Tutorial werfen wir einen genauen Blick auf die neuen Features und Verbesserungen des JavaScript-Frameworks und geben Hinweise zum Umgang mit inkompatiblen Änderungen in Angular 15.\n'parentId': '9b91af29eb210add4465b516'\n'parentDescription': Über neun Millionen Software-Entwickler weltweit sorgen dafür, dass die Java-Technologie in allen Geschäftsfeldern und in allen Branchen eine zentrale Rolle spielt. Zudem ist das Java-Ökosystem der wichtigste Takt- und Impulsgeber für die gesamte Software-Industrie, wenn es um technische Innovationen geht. Das Java Magazin begleitet seit über 20 Jahren alle wesentlichen Entwicklungen der Java-Welt aktuell, kritisch und mit großer praktischer Relevanz. Software-Architekten, Entwickler und Projektleiter vertrauen auf die anerkannte Kompetenz der Redaktion verbunden mit ihrem Experten-Netzwerk bekannter Fachautoren.\n'indexBrandName': ''\n'indexSeriesName': ''\n'author': 'Karsten Sitterberg'\n'chunkSource': 'text'\n'text': ... } Nachdem das Angular-Team lange an der Ivy Rendering Engine gefeilt hat, wurde diese mit Angular 9 endlich veröffentlicht. Es gab danach eine Übergangszeit, in der man zwischen der alten View Engine und Ivy hin- und herwechseln konnte. Dafür gab es das Compilerflag enableIvy. Da es aber mittlerweile die alte View-Engine nicht mehr gibt, wurde dieses Flag nun entfernt. Deprecations Um alte, für die Zukunft nicht mehr empfohlene APIs in nachfolgenden Angular-Versionen besser entfernen zu können, gibt es auch einige Deprecations mit Angular 15. So war es bisher möglich, Services an ein Modul zu koppeln, indem dieses Modul an die providedIn-Option eines @Injectable-Decorator zugewiesen wurde. Ein Beispiel dazu findet sich in Listing 11. Das sollte die Services treeshakeable machen, aber trotzdem fest an ein Modul binden. Da diese Variante kaum – und zudem teilweise auch noch falsch – genutzt wurde, wird dieses Feature nun deprecated. Stattdessen sollte der Service nun entweder als providedIn: 'root' gekennzeichnet werden oder als Provider in dem entsprechenden Modul eingetragen werden. Neben der Modulvariante wurde auch die providedIn: 'any'-Syntax deprecated, da die any-Option im Wesentlichen nur Framework-intern genutzt wurde und auch missverständlich war. Listing 11: Module an providedIn zuzuweisen ist nun deprecated @Injectable({ providedIn: MyModule }) export class MyService {} Für die Date Pipe hat das Angular-Team ein neues Feature mit einer Deprecation verbunden: Bisher gab es das Injection-Token DATE_PIPE_DEFAULT_TIMEZONE, mit dem die Zeitzone der Date Pipe App-weit auf einen Standardwert gesetzt werden konnte. Dieses Token wird nun deprecated, da stattdessen das Token DATE_PIPE_DEFAULT_OPTIONS genutzt werden soll, mit dem neben der Standardzeitzone auch das Standarddatumsformat App- bzw. modulweit, eingestellt werden kann. In Listing 12 wird gezeigt, wie mit dem neuen Token das Format 'shortDate' als Standardwert zur Formatierung von Datumswerten und als Zeitzone -0200, was der Zeitzone der Azoren entspricht, konfiguriert wird. Listing 12: Defaults für die DatePipe setzen providers: [ { provide: DATE_PIPE_DEFAULT_OPTIONS, useValue: { dateFormat: 'shortDate', timezone: '-0200' } } ] Vereinheitlichung von Direktiven Navigationsvorgänge innerhalb der App werden in Angular mit Hilfe des Routers gestartet. Dabei gibt es sowohl imperatives Routing durch Aufruf des Routers aus\n'slidetext': ''\n'from': 'index'\n'score': 143.2830047607422\n'normalizedScore': 1.4328300476074218\n'beforeDatePenaltyScore': 1.4328300476074218\n\n'documentId': 'e9905bc3e1a3780619966899'\n'chunk_id': '687814d9bed6dcd41a99b099'\n'access': 'granted'\n'part_number': 12\n'total_parts': 17\n'contentType': 'READ'\n'title': Jetzt schlägt’s 15: Was ist neu in Angular 15? - Alle neuen Features von Angular 15 im Blick\n'parentName': Java Magazin 2.2023\n'language': 'DE'\n'date': '2023-01-03T02:00:00.000Z'\n'abstract': Angular 15 wurde für den produktiven Einsatz freigegeben. In diesem Tutorial werfen wir einen genauen Blick auf die neuen Features und Verbesserungen des JavaScript-Frameworks und geben Hinweise zum Umgang mit inkompatiblen Änderungen in Angular 15.\n'parentId': '9b91af29eb210add4465b516'\n'parentDescription': Über neun Millionen Software-Entwickler weltweit sorgen dafür, dass die Java-Technologie in allen Geschäftsfeldern und in allen Branchen eine zentrale Rolle spielt. Zudem ist das Java-Ökosystem der wichtigste Takt- und Impulsgeber für die gesamte Software-Industrie, wenn es um technische Innovationen geht. Das Java Magazin begleitet seit über 20 Jahren alle wesentlichen Entwicklungen der Java-Welt aktuell, kritisch und mit großer praktischer Relevanz. Software-Architekten, Entwickler und Projektleiter vertrauen auf die anerkannte Kompetenz der Redaktion verbunden mit ihrem Experten-Netzwerk bekannter Fachautoren.\n'indexBrandName': ''\n'indexSeriesName': ''\n'author': 'Karsten Sitterberg'\n'chunkSource': 'text'\n'text': 'shortDate', timezone: '-0200' } } ] Vereinheitlichung von Direktiven Navigationsvorgänge innerhalb der App werden in Angular mit Hilfe des Routers gestartet. Dabei gibt es sowohl imperatives Routing durch Aufruf des Routers aus dem TypeScript-Code als auch deklaratives Routing aus den Angular-Templates. Für Letzteres kann die [routerLink]-Direktive verwendet werden. Bisher handelte es sich dabei technisch gesehen allerdings um zwei verschiedene Direktiven: Für HTML-Anchor-Elemente gab es die RouterLinkWithHref-Direktive, die auch in Listing 13 zu sehen ist, während alle anderen Elemente die RouterLink-Direktive verwendeten. Um Codeduplikation zu vermeiden, wurden diese Direktiven nun vereinheitlicht und RouterLinkWithHref ist nur noch ein Alias für den eigentlichen RouterLink. So kann nun auch für Anchor-Elemente einfach der RouterLink verwendet werden. Im Code wirkt sich dies nur dann aus, wenn man die RouterLinkWithHref-Direktive z. B. als Standalone-Direktive importiert oder in View- bzw. ContentChildren verwendet. Einen Vergleich liefern die beiden Listings 13 und 14. Listing 13: Anchor mit RouterLink in Angular 14.2 @Component({ template: ``, standalone: true, imports: [RouterLinkWithHref] }) export class MyComponent { @ViewChild(RouterLinkWithHref) link!: RouterLinkWithHref } Listing 14: Anchor mit RouterLink in Angular 15 @Component({ template: ``, standalone: true, imports: [RouterLink] }) export class MyComponent { @ViewChild(RouterLink) link!: RouterLink } Angular CLI In Version 15 wurden analog zu Angular auch im Angular CLI die Versionen der Abhängigkeiten erhöht, sodass z. B. Node.js in folgenden Versionen oder höher vorliegen muss (dabei ist das „höher“ immer auf das jeweilige Major-Release bezogen): 14.20.x, 16.13.x oder 18.10.x. Außerdem wird TypeScript mindestens in Version 4.8.2 benötigt. Weiterhin wurde die Kompilations-Pipeline so angepasst, dass Angular nicht mehr mit ECMAScript ES5 als Zielplattform gebaut werden kann. Das sollte keine Auswirkungen auf die Nutzer:innen haben, da alle Browser, die Angular unterstützt, ohnehin die Standards ES2015+ beherrschen. Nach welchem ECMAScript-Standard der Build-Output genau generiert wurde, konnte bisher in der tsconfig.json des Projekts im Feld target eingestellt werden. Mit Angular 15 wird das Target nun automatisch anhand der .browserlistrc ermittelt. Es kann allerdings\n'slidetext': ''\n'from': 'index'\n'score': 142.87586975097656\n'normalizedScore': 1.4287586975097657\n'beforeDatePenaltyScore': 1.4287586975097657\n\n'documentId': '2e2495f42751c019986f5bc4'\n'chunk_id': '687ab74d2be886398c2ad126'\n'access': 'granted'\n'part_number': 3\n'total_parts': 9\n'contentType': 'READ'\n'title': Java 16: Das JDK auf dem Weg zur nächsten LTS-Version - Sweet 16\n'parentName': JAXenter 3.2021\n'language': 'DE'\n'date': '2021-03-01T16:58:00.000Z'\n'abstract': 14, 15 oder doch schon 16? Da kann man schon mal durcheinanderkommen. Durch die mittlerweile halbjährlichen Major-Releases von Java fällt es gar nicht so leicht, die aktuelle Version richtig zu benennen. Vor Kurzem hat man sich in einem Vortrag noch über die Neuerungen des JDK 14 informiert, und wenig später wurden in einem Artikel bereits die Features von Version 15 näher beleuchtet. Und da sich die Welt bekanntlich schnell weiterdreht, ist nun im März 2021 bereits das OpenJDK 16 herausgekommen.\n'parentId': 'f3f07cfbd5f6d489e27c1d11'\n'parentDescription': n/a\n'indexBrandName': ''\n'indexSeriesName': ''\n'author': 'Falk Sippach'\n'chunkSource': 'text'\n'text': ist es, Redundanzen zu vermeiden und dadurch die Lesbarkeit zu erhöhen (Listing 1). Listing 1 boolean isNullOrEmpty( Object o ) { return o == null || o instanceof String s && s.isBlank() || o instanceof Collection c && c.isEmpty(); } Der Unterschied zum zusätzlichen Cast mag marginal erscheinen. Für die Puristen unter den Java-Entwicklern spart das allerdings eine kleine, aber dennoch lästige Redundanz ein. Laut Brian Goetz soll die Sprache dadurch prägnanter und die Verwendung sicherer gemacht werden. Erzwungene Typumwandlungen werden vermieden und stattdessen implizit durchgeführt. Bereits die zweite Preview, die im JDK 15 erschienen war, hatte keine nennenswerten Änderungen mehr mit sich gebracht. Deswegen wird das Feature jetzt als JEP 394 finalisiert. In zukünftigen Java-Versionen wird es aber noch weitere Funktionen rund um das Pattern Matching geben, zum Beispiel in Zusammenarbeit mit den Switch Expressions. Versiegelte Klassen Erst das zweite Mal dabei sind die Sealed Classes. Sie wurden in Java 15 als Previewfeature eingeführt und verbleiben als JEP 397 auch im JDK 16 im Vorschaumodus. Es gibt ein paar kleine Ergänzungen gegenüber der letzten Version und vermutlich werden sie dann im LTS-Release des OpenJDK 17 finalisiert. Bis dahin möchten die Macher aber noch Rückmeldungen einsammeln. Dieses Feature wurde übrigens im Rahmen von Projekt Amber entwickelt und gehört ebenfalls zu einer Reihe von vorbereitenden Maßnahmen für die Umsetzung von Pattern-Matching-Mechanismen in Java. Ganz konkret soll es bei der Analyse von Mustern unterstützen. Aber auch für Framework-Entwickler bieten die Sealed Classes einen interessanten Mehrwert. Die Idee ist, dass versiegelte Klassen und Interfaces entscheiden können, welche Subklassen oder -interfaces von ihnen abgeleitet werden dürfen. Bisher konnte man als Entwickler Ableitungen von Klassen nur durch Zugriffsmodifikatoren (private, protected, …) einschränken oder durch die Deklaration der Klasse als final komplett durch den Compiler untersagen. Sealed Classes bieten nun einen deklarativen Weg, um gezielt bestimmten Subklassen die Ableitung zu erlauben: public sealed class Vehicle permits Car, Bike, Bus, Train { } Vehicle darf nur von den vier genannten Klassen überschrieben werden. Damit wird auch dem Aufrufer deutlich gemacht, welche\n'slidetext': ''\n'from': 'index'\n'score': 142.4487762451172\n'normalizedScore': 1.4244877624511718\n'beforeDatePenaltyScore': 1.4244877624511718\n\n'documentId': '2e2495f42751c019986f5bc4'\n'chunk_id': '687ab74e2be886398c2ad131'\n'access': 'granted'\n'part_number': 8\n'total_parts': 9\n'contentType': 'READ'\n'title': Java 16: Das JDK auf dem Weg zur nächsten LTS-Version - Sweet 16\n'parentName': JAXenter 3.2021\n'language': 'DE'\n'date': '2021-03-01T16:58:00.000Z'\n'abstract': 14, 15 oder doch schon 16? Da kann man schon mal durcheinanderkommen. Durch die mittlerweile halbjährlichen Major-Releases von Java fällt es gar nicht so leicht, die aktuelle Version richtig zu benennen. Vor Kurzem hat man sich in einem Vortrag noch über die Neuerungen des JDK 14 informiert, und wenig später wurden in einem Artikel bereits die Features von Version 15 näher beleuchtet. Und da sich die Welt bekanntlich schnell weiterdreht, ist nun im März 2021 bereits das OpenJDK 16 herausgekommen.\n'parentId': 'f3f07cfbd5f6d489e27c1d11'\n'parentDescription': n/a\n'indexBrandName': ''\n'indexSeriesName': ''\n'author': 'Falk Sippach'\n'chunkSource': 'text'\n'text': dieser Maßnahme ist die Erhöhung der Sicherheit und Wartbarkeit des JDK. Man möchte die Entwickler ermutigen, alte, auf Internas basierende Lösungen zukünftig für den Zugriff auf Standard-APIs umzubauen. Somit sollen sowohl Java-Entwickler als auch Endbenutzer viel problemloser auf zukünftige Versionen updaten können. Neben den prominenten JEPs gibt es in jeder neuen JDK-Version noch viele kleine Änderungen, zum Beispiel an der Java-Klassenbibliothek. Mit dem Java Version Almanac [4] kann man sehr einfach und kompakt die Differenzen zwischen den Releases, aber auch bei Versionssprüngen von z. B. JDK 8 auf 16 einsehen. Aus Entwicklersicht sind besonders zwei Neuerungen an der Klasse Stream interessant. Stream.toList() bietet eine prägnantere und im Einsatz mit parallel() meist auch effizientere Alternative zu Stream.collect(Collectors.toList()). Als Ergebnis wird eine nicht veränderbare (unmodifiable) ArrayList zurückgegeben. Weitere Informationen kann man der API-Dokumentation [5] oder dem Artikel von Donald Raab [6] entnehmen. Die zweite Neuerung in der Klasse Stream ist die in diversen Ausprägungen hinzugekommene Methode mapMulti(BiConsumer). Sie stellt eine imperative und schnellere Alternative zu flatMap dar. Nicolai Parlog hat die neue Funktion in einem Blogpost näher unter die Lupe genommen und zum Vergleich Performancemessungen durchgeführt [7]. Ausblick Schon kurz vor der Fertigstellung des OpenJDK 16 wurden die ersten Features für das JDK 17 angekündigt [8]. Unter anderem soll es eine neue Rendering Pipeline für macOS und die Erweiterung des Pseudozufallszahlengenerators geben. Höchstwahrscheinlich werden wir allerdings keine weiteren großen, prominenten Änderungen sehen. Schließlich werden mit Java 17 die Entwicklungen der vergangenen 36 Monate abgeschlossen und es wird eine Version bereitgestellt, die wieder für die nächsten Jahre mit Updates und Sicherheitpatches versorgt werden muss. Die wirklich spannenden Neuerungen und Syntaxerweiterungen werden wir dann voraussichtlich erst wieder in der Version 18 sehen. Ab da hat Oracle dann wieder zweieinhalb Jahre Zeit, Feedback zu Previewfeatures einzuarbeiten und diese abzurunden. Der 2018 eingeschlagene Weg – der anfangs nicht unumstritten war – wird weiterhin konsequent verfolgt. Die halbjährlichen Updates der Programmiersprache und der Plattform Java geben uns\n'slidetext': ''\n'from': 'index'\n'score': 142.36814880371094\n'normalizedScore': 1.4236814880371094\n'beforeDatePenaltyScore': 1.4236814880371094\n\n'documentId': '2e2495f42751c019986f5bc4'\n'chunk_id': '687ab74d2be886398c2ad124'\n'access': 'granted'\n'part_number': 2\n'total_parts': 9\n'contentType': 'READ'\n'title': Java 16: Das JDK auf dem Weg zur nächsten LTS-Version - Sweet 16\n'parentName': JAXenter 3.2021\n'language': 'DE'\n'date': '2021-03-01T16:58:00.000Z'\n'abstract': 14, 15 oder doch schon 16? Da kann man schon mal durcheinanderkommen. Durch die mittlerweile halbjährlichen Major-Releases von Java fällt es gar nicht so leicht, die aktuelle Version richtig zu benennen. Vor Kurzem hat man sich in einem Vortrag noch über die Neuerungen des JDK 14 informiert, und wenig später wurden in einem Artikel bereits die Features von Version 15 näher beleuchtet. Und da sich die Welt bekanntlich schnell weiterdreht, ist nun im März 2021 bereits das OpenJDK 16 herausgekommen.\n'parentId': 'f3f07cfbd5f6d489e27c1d11'\n'parentDescription': n/a\n'indexBrandName': ''\n'indexSeriesName': ''\n'author': 'Falk Sippach'\n'chunkSource': 'text'\n'text': Elastic Metaspace - 388: Windows/AArch64 Port - 389: Foreign Linker API (Incubator) - 390: Warnings for Value-Based Classes - 392: Packaging Tool - 393: Foreign-Memory Access API (Third Incubator) - 394: Pattern Matching for instanceof - 395: Records - 396: Strongly Encapsulate JDK Internals by Default - 397: Sealed Classes (Second Preview) Einige der Punkte sind für Java-Entwickler aber nicht direkt relevant. Dazu zählen beispielsweise die Migration zu Git/GitHub, die Aktivierung der C++-14-Sprachfeatures und auch das Foreign Linker API als zukünftiger Ersatz für das Java Native Interface (JNI). Wir schauen am Ende dieses Artikels trotzdem genauer darauf. Werfen wir aber zunächst einen Blick auf die Funktionen, die uns Entwickler betreffen. Dabei werden dem aufmerksamen Beobachter der vergangenen Java-Releases allerdings keine bahnbrechenden Neuerungen ins Auge springen. Das hängt vermutlich mit dem bevorstehenden LTS-Release zusammen, das im Herbst 2021 erscheinen wird. In Java 17 werden die neuen Features der vergangenen Monate stabilisiert, um für die folgenden Jahre eine gute Ausgangsbasis für die notwendigen Updates und Patches zu schaffen. Java goes Pattern Matching Bereits seit einiger Zeit schwebt das Thema Pattern Matching im Raum und hält nach und nach Einzug in Java. Dazu sind aber zur Vorbereitung diverse Änderungen in der Sprache selbst notwendig und deshalb erfolgt die Einführung nur schrittweise. Los ging es mit den Switch Expressions bereits im JDK 12. Seit Version 14 gab es zudem bereits zwei Previews zu „Pattern Matching for instanceof“. Das wird nun mit Java 16 abgeschlossen. Ein Pattern ist übrigens eine Kombination aus einem Prädikat (das auf eine Zielstruktur passt) und einer Menge von Variablen innerhalb dieses Musters. Diesen Variablen werden bei passenden Treffern die entsprechenden Inhalte zugewiesen und damit extrahiert. Die Intention des Pattern Matching ist letztlich die Destrukturierung von Objekten, also das Aufspalten in die Bestandteile und Zuweisen in einzelne Variablen zur weiteren Bearbeitung. Die Spezialform des Pattern Matching beim instanceof-Operator spart unnötige Casts auf die zu prüfenden Zieldatentypen. Wenn o ein String oder eine Collection ist, dann kann direkt mit den neuen Variablen (s und c) mit den entsprechenden Datentypen weitergearbeitet werden. Das Ziel ist\n'slidetext': ''\n'from': 'index'\n'score': 142.2671661376953\n'normalizedScore': 1.4226716613769532\n'beforeDatePenaltyScore': 1.4226716613769532\n\n'documentId': '5ecf87915aa99dfe10bb64dd'\n'chunk_id': '687814bebed6dcd41a99aff9'\n'access': 'granted'\n'part_number': 1\n'total_parts': 16\n'contentType': 'READ'\n'title': Is Angular 16 Starting a (R)evolution? - Breaking changes, features, and everything new in Angular 16\n'parentName': JavaScript Magazine Volume 8\n'language': 'EN'\n'date': '2023-03-08T23:00:00.000Z'\n'abstract': The newest version of Angular is here. Angular 16 introduces some new breaking changes and features and sets a new tone for the framework. This article dives into all of the changes and what developers need to know before migrating.\n'parentId': '4169b80642e03abd714cf6fe'\n'parentDescription': Broaden your knowledge and expand your JavaScript techniques and practices. From Angular, React, and WebAssembly, to the best JavaScript IDEs, open source tools and more, you’ll learn insights on everything JS from seasoned experts in their field. Keep up with JavaScript news, tips, and advice with interviews, tutorials, and in-depth articles.\n'indexBrandName': ''\n'indexSeriesName': ''\n'author': 'Karsten Sitterberg'\n'chunkSource': 'text'\n'text': Is Angular 16 Starting a (R)evolution? Breaking changes, features, and everything new in Angular 16 The newest version of Angular is here. Angular 16 introduces some new breaking changes and features and sets a new tone for the framework. This article dives into all of the changes and what developers need to know before migrating. Angular has an especially good reputation when it comes to long-lived applications where investment protection is an important criteria. Even during critical builds, like converting the rendering engine to Ivy, the Angular team has always shown good instinct. Through continuous ng-upgrade improvements and good engineering, necessary migrations means less effort for developers. This is especially true since many changes were implemented incrementally over the course of several releases. Often, even the API interface for typical applications could be kept stable. Angular 16 sets a new tone in that regard and not everyone will like that. Only time will tell whether the Angular team, and Google behind them, is making smart decisions. To get an idea ourselves, we’ll take a look at the important changes in Angular 16 in this article. TypeScript Angular also pays attention to keeping its own dependencies up to date with this release. Therefore, in Angular 16, TypeScript must be version 4.9 or 5.0. Let’s look at the major new features in TypeScript 4.9 first. The other new features in TypeScript 5 can be read in this article here. With TypeScript 4.9, came some innovations. For example, there are improvements in build performance or file-watching by the dev server. Additionally, an “auto-accessor” keyword was introduced (example: “public accessor name: string;”), which automatically creates both a “set” and a “get” accessor for the “name” property. A compiler hint was also added to print an error as soon as a comparison with “NaN” is performed, since these comparisons are actually always an error (“NaN !== x” is always “true”, even if “x=NaN”, while “NaN === x” always returns “false:). Instead, the function “Number.isNaN(someValue)” should be used. A new, helpful operator was also introduced. The new “satisfies” operator makes type-checking a bit more flexible. For example, an object should be created that corresponds to the “Campaign” data structure from Listing 1. Thanks to TypeScript's structural type system, a simple object “oldCampaign” can be constructed to match this structure. See Listing 1. Thanks to TypeScript’s structural type system, a simple object “oldCampaign” can be constructed that corresponds to this structure. See Listing 1. However, an error found its way into this object. The “enddate” property has a typo. The\n'slidetext': ''\n'from': 'index'\n'score': 141.46890258789062\n'normalizedScore': 1.4146890258789062\n'beforeDatePenaltyScore': 1.4146890258789062\n\n'documentId': '5ecf87915aa99dfe10bb64dd'\n'chunk_id': '687814bfbed6dcd41a99b003'\n'access': 'granted'\n'part_number': 11\n'total_parts': 16\n'contentType': 'READ'\n'title': Is Angular 16 Starting a (R)evolution? - Breaking changes, features, and everything new in Angular 16\n'parentName': JavaScript Magazine Volume 8\n'language': 'EN'\n'date': '2023-03-08T23:00:00.000Z'\n'abstract': The newest version of Angular is here. Angular 16 introduces some new breaking changes and features and sets a new tone for the framework. This article dives into all of the changes and what developers need to know before migrating.\n'parentId': '4169b80642e03abd714cf6fe'\n'parentDescription': Broaden your knowledge and expand your JavaScript techniques and practices. From Angular, React, and WebAssembly, to the best JavaScript IDEs, open source tools and more, you’ll learn insights on everything JS from seasoned experts in their field. Keep up with JavaScript news, tips, and advice with interviews, tutorials, and in-depth articles.\n'indexBrandName': ''\n'indexSeriesName': ''\n'author': 'Karsten Sitterberg'\n'chunkSource': 'text'\n'text': 'CSP_NONCE' injection token to set a CSP nonce, which Angular appends to the inline styles. If the index.html can still be modified at production time by the delivering server, then instead of the injection token, the attribute 'ngCspNonce' can simply be set on the app element. See Listing 17. It’s especially important here that the value of 'XYZ' is not a fixed value. It must be recalculated each time the index.html is delivered. A fixed nonce would have similar security properties as the CSP directive 'unsafe-inline'. Together with the nonce property in the index.html, the nonce must also be included in the CSP directive. For example: 'style-src 'nonce-XYZ' 'self'' or somewhat more strictly 'style-src 'nonce-XYZ' 'strict-dynamic''. This feature was developed in collaboration between the Angular core, -material and -CLI teams, so these packages also support the new mechanism accordingly. Listing 17: Dynamic configuration of CSP nonce value in index.html  Another new small feature is the 'DestroyRef'. This can be injected like a service and allows to register logic via callback, which is executed when the component is OnDestroy. For example, resources can be released this way without having to implement the 'ngOnDestroy()' lifecycle hook, see also Listing 18. To remove the Destroy logic again, for example, if a resource has already been released for a different reason, the 'unregisterFn()' can be called. In this example, 'doSomethingOnDestroy()' would no longer be called. Besides the DestroyRef, a new package '@angular/rxjs-interop' has also been introduced, which is mainly used with the new signals. This package offers the function 'takeUntilDestroyed()'. This function is a pipeable rxjs operator and can be used to terminate observables once the associated component has been destroyed. Under the hood, this new operator uses a DestroyRef. Listing 18 shows how to use the operator to terminate an interval observable once the component is cleared. In this case, the 'takeUntilDestroyed' operator is explicitly given a DestroyRef. This step can also be omitted, then the operator gets the DestroyRef itself via 'inject()' function. This would mean that the operator - or the entire observable - must be created in the constructor, since the 'inject()' mechanism requires the constructor context. Listing 18: Example of how to use the DestroyRef constructor(private destroyRef: DestroyRef) { const unregisterFn = destroyRef.onDestroy(() => doSomethingOnDestroy() ); // unregisterFn(); // Takes back onDestroy logic } ngOnInit(): void { interval(1000) .pipe(takeUntilDestroyed(this.destroyRef)) .subscribe(val => console.log('value:', val)) } Listen to the signals… Angular 16 introduces a new\n'slidetext': ''\n'from': 'index'\n'score': 141.4591827392578\n'normalizedScore': 1.4145918273925782\n'beforeDatePenaltyScore': 1.4145918273925782\n\n'documentId': 'e9905bc3e1a3780619966899'\n'chunk_id': '687814d7bed6dcd41a99b08e'\n'access': 'granted'\n'part_number': 1\n'total_parts': 17\n'contentType': 'READ'\n'title': Jetzt schlägt’s 15: Was ist neu in Angular 15? - Alle neuen Features von Angular 15 im Blick\n'parentName': Java Magazin 2.2023\n'language': 'DE'\n'date': '2023-01-03T02:00:00.000Z'\n'abstract': Angular 15 wurde für den produktiven Einsatz freigegeben. In diesem Tutorial werfen wir einen genauen Blick auf die neuen Features und Verbesserungen des JavaScript-Frameworks und geben Hinweise zum Umgang mit inkompatiblen Änderungen in Angular 15.\n'parentId': '9b91af29eb210add4465b516'\n'parentDescription': Über neun Millionen Software-Entwickler weltweit sorgen dafür, dass die Java-Technologie in allen Geschäftsfeldern und in allen Branchen eine zentrale Rolle spielt. Zudem ist das Java-Ökosystem der wichtigste Takt- und Impulsgeber für die gesamte Software-Industrie, wenn es um technische Innovationen geht. Das Java Magazin begleitet seit über 20 Jahren alle wesentlichen Entwicklungen der Java-Welt aktuell, kritisch und mit großer praktischer Relevanz. Software-Architekten, Entwickler und Projektleiter vertrauen auf die anerkannte Kompetenz der Redaktion verbunden mit ihrem Experten-Netzwerk bekannter Fachautoren.\n'indexBrandName': ''\n'indexSeriesName': ''\n'author': 'Karsten Sitterberg'\n'chunkSource': 'text'\n'text': Jetzt schlägt’s 15: Was ist neu in Angular 15? Alle neuen Features von Angular 15 im Blick Angular 15 wurde für den produktiven Einsatz freigegeben. In diesem Tutorial werfen wir einen genauen Blick auf die neuen Features und Verbesserungen des JavaScript-Frameworks und geben Hinweise zum Umgang mit inkompatiblen Änderungen in Angular 15. Angular 15 wurde für den produktiven Einsatz freigegeben. In diesem Tutorial werfen wir einen genauen Blick auf die neuen Features und Verbesserungen des JavaScript-Frameworks und geben Hinweise zum Umgang mit inkompatiblen Änderungen in Angular 15. Zusammen mit dem Angular-Framework wurden auch das Angular-CLI für Entwicklung und Build und das Angular-Material-Komponentensystem in den entsprechenden Versionen veröffentlicht. Angular 15 steht stark unter dem Gesichtspunkt der Standalone Components. Erstmals in Angular 14 als Preview veröffentlicht, sind die Standalone Components nun als stabil deklariert. In diesem Zuge sind nun weitere Bestandteile des Frameworks wie der Router und Route Guards angepasst worden, um gut mit Standalone Components und den nun optionalen NgModules umzugehen. Werfen wir zunächst einen kurzen Blick auf TypeScript, das Angular ab jetzt mindestens in Version 4.8 erfordert. TypeScript In der neuen TypeScript-Version gibt es einige, teils vorbereitende Anpassungen an kommende ECMAScript-Standards. So zum Beispiel den noch immer nicht endgültig spezifizierten Decorator-Standard. Angular nutzt die Decorators, um Typen mit Metadaten anzureichern und damit zum Beispiel für Dependency-Injection auszuzeichnen. Java-Entwickler kennen das verwandte Konzept der Annotations, die mit Java 5 eingeführt wurden. Daneben wurden einige Anpassungen an der Typinferenz von null und undefined bei Verwendung mit Generics oder Intersection-Types vorgenommen. Das kann in einigen Ausnahmefällen dazu führen, dass bestehende Anwendungslogik angepasst werden muss. In diesem Fall sollte es helfen, wenn zusätzliche Null-Checks eingebaut werden, wie in Listing 1 gezeigt wird. Listing 1: Erweitertes Type Narrowing von generischen Typparametern function throwIfNullable(value: T): NonNullable { if (value === undefined || value === null) { throw Error('Nullable value!'); } // War bisher Compilerfehler, da 'T' nicht an 'NonNullable' zuweisbar war. // Funktioniert jetzt, da Type Narrowing zu 'T & {}' durchgeführt wird, das entspricht //dann 'NonNullable'. return value; } Das\n'slidetext': ''\n'from': 'index'\n'score': 140.92239379882812\n'normalizedScore': 1.4092239379882812\n'beforeDatePenaltyScore': 1.4092239379882812\n\n'documentId': '5ecf87915aa99dfe10bb64dd'\n'chunk_id': '687814bfbed6dcd41a99affc'\n'access': 'granted'\n'part_number': 4\n'total_parts': 16\n'contentType': 'READ'\n'title': Is Angular 16 Starting a (R)evolution? - Breaking changes, features, and everything new in Angular 16\n'parentName': JavaScript Magazine Volume 8\n'language': 'EN'\n'date': '2023-03-08T23:00:00.000Z'\n'abstract': The newest version of Angular is here. Angular 16 introduces some new breaking changes and features and sets a new tone for the framework. This article dives into all of the changes and what developers need to know before migrating.\n'parentId': '4169b80642e03abd714cf6fe'\n'parentDescription': Broaden your knowledge and expand your JavaScript techniques and practices. From Angular, React, and WebAssembly, to the best JavaScript IDEs, open source tools and more, you’ll learn insights on everything JS from seasoned experts in their field. Keep up with JavaScript news, tips, and advice with interviews, tutorials, and in-depth articles.\n'indexBrandName': ''\n'indexSeriesName': ''\n'author': 'Karsten Sitterberg'\n'chunkSource': 'text'\n'text': outputs. Furthermore, the esbuild DevServer can now use e.g. SSL. The inclusion is done as with the existing setup via “ng serve --ssl”. Additional scripts can be included in the build. This is handy when including global scripts like the Google Tag Manager. Some enhancements have also been made to the existing build system: For example, new applications can be generated as standalone applications (i.e. without @NgModules). For this purpose, the flag “--standalone” is included when generating the application. In order to align the functionality of standalone applications with the functionality of previous Angular applications, it is now also possible to generate service workers and app shells for standalone applications via schematics. The app or expertise in the app must be tested to ensure that the functionality of the applications you painstakingly built is guaranteed in the long term. There are different levels of testing for this, such as E2E or unit tests. Support for Protractor as the default E2E tool was discontinued several Angular CLI versions ago. Since then, Protractor itself has also been discontinued. Now it continues with unit tests. Karma was also initiated by Google, but has been discontinued in the meantime. Therefore, Angular is working on a successor. There will probably be different options. If less value is placed on a browser-oriented test environment, and the test execution speed is more important, then the Jest tool can be used. This comes from the React environment. A preview implementation for this tool is coming in Angular-CLI 16, but it shouldn’t be used in production yet. It can be activated by switching to the new Jest test builder ('builder': '@angular-devkit/build-angular:karma') instead of the previous test builder ('builder': '@angular-devkit/build-angular:jest'). Alternatively, there are efforts to connect the 'Vitest' test system from the Vue environment. In order to be able to continue to run tests in the browser, Angular-CLI will prospectively switch the current Karma/Jasmine tests to the “Web Test Runner”/Jasmine combination. Similar to Karma, the “Web Test Runner” can run tests in the browser. The Jasmine syntax will continue to be used as the text syntax in order to make the changeover as simple as possible. Breaking Changes in Angular-CLI 16 Of course, with the new major Angular CLI version, there are also some breaking changes. Support for TypeScript 4.8 and Node.js 14 has been removed. Instead, TypeScript 5 is used as the default, and Node.js should be version 16, 18, or newer. Angular CLI 16 also cuts some obsolete or outdated braids. The Angular compatibility compiler NGCC is removed in Angular CLI 16. NGCC was responsible for transforming old\n'slidetext': ''\n'from': 'index'\n'score': 140.78968811035156\n'normalizedScore': 1.4078968811035155\n'beforeDatePenaltyScore': 1.4078968811035155\n\n'documentId': 'e9905bc3e1a3780619966899'\n'chunk_id': '687814d7bed6dcd41a99b08f'\n'access': 'granted'\n'part_number': 2\n'total_parts': 17\n'contentType': 'READ'\n'title': Jetzt schlägt’s 15: Was ist neu in Angular 15? - Alle neuen Features von Angular 15 im Blick\n'parentName': Java Magazin 2.2023\n'language': 'DE'\n'date': '2023-01-03T02:00:00.000Z'\n'abstract': Angular 15 wurde für den produktiven Einsatz freigegeben. In diesem Tutorial werfen wir einen genauen Blick auf die neuen Features und Verbesserungen des JavaScript-Frameworks und geben Hinweise zum Umgang mit inkompatiblen Änderungen in Angular 15.\n'parentId': '9b91af29eb210add4465b516'\n'parentDescription': Über neun Millionen Software-Entwickler weltweit sorgen dafür, dass die Java-Technologie in allen Geschäftsfeldern und in allen Branchen eine zentrale Rolle spielt. Zudem ist das Java-Ökosystem der wichtigste Takt- und Impulsgeber für die gesamte Software-Industrie, wenn es um technische Innovationen geht. Das Java Magazin begleitet seit über 20 Jahren alle wesentlichen Entwicklungen der Java-Welt aktuell, kritisch und mit großer praktischer Relevanz. Software-Architekten, Entwickler und Projektleiter vertrauen auf die anerkannte Kompetenz der Redaktion verbunden mit ihrem Experten-Netzwerk bekannter Fachautoren.\n'indexBrandName': ''\n'indexSeriesName': ''\n'author': 'Karsten Sitterberg'\n'chunkSource': 'text'\n'text': War bisher Compilerfehler, da 'T' nicht an 'NonNullable' zuweisbar war. // Funktioniert jetzt, da Type Narrowing zu 'T & {}' durchgeführt wird, das entspricht //dann 'NonNullable'. return value; } Das TypeScript-Team nimmt natürlich auch Pull-Requests aus der Community an. So wurde beispielsweise eine Erweiterung aufgenommen, die unnötige Bugs durch falsche Vergleiche mit leeren Arrays verhindert. Ein solcher fehlerhafter Vergleich ist beispielhaft in Listing 2 zu sehen. Ein Vergleich mit einem leeren Array ist eigentlich immer ein Fehler. Wenn man andere Programmiersprachen, z. B. Python, gewöhnt ist, wo solche Vergleiche durchaus gängig sind, kann es allerdings zu solchen Vergleichen kommen. Diese Fehlerkategorie soll mit dem neuen Check verhindert werden. Listing 2: Fehlerhafter Vergleich mit einem leeren Array if (peopleAtHome === []) { // Diese Bedingung wird immer 'false' sein, // da JavaScript nur die beiden Objekt-Referenzen // vergleicht, nicht die Werte als solches. console.log('Hier kommt man niemals an...') adoptAnimals(); } Angular 14: Wie sah es vorher aus? Bevor wir in die Neuerungen von Angular 15 einsteigen, gilt es noch die Minor-Releases von Angular 14.x zu betrachten. Denn auch wenn die Versionsnummer sich nur im Kleinen ändert, so können sich dahinter auch große Neuerungen verbergen: Denn Semantic-Versioning sagt lediglich aus, dass keine inkompatiblen Änderungen vorgenommen werden dürfen. Neue Features und Erweiterungen sind gestattet. Versionen 14.1 und 14.2 Mit den Angular-14-Minor-Updates wurden vor allem die Standalone APIs für Komponenten weiter ausgebaut. So sind etwa die Direktiven und Pipes, die bisher aus dem CommonModule exportiert wurden, nun auch als Standalone markiert. Damit können nun z. B. NgIf, NgForOf, die DatePipe, die AsyncPipe und Co. einzeln importiert werden. Das ermöglicht unter anderem ein besseres Treeshaking der einzelnen Direktiven. Treeshaking sorgt dafür, dass nicht verwendete Features kein Teil der ausgelieferten Anwendung werden, wodurch sich unter anderem die Ladezeit verbessert. Natürlich ist es aber auch weiterhin möglich, die Direktiven und Pipes gesammelt über das CommonModule zu importieren. Auch für das Angular-Webkomponentenpaket @angular/elements ist nun eine Developer-Preview für den Standalone-Support verfügbar. Da Web\n'slidetext': ''\n'from': 'index'\n'score': 140.42816162109375\n'normalizedScore': 1.4042816162109375\n'beforeDatePenaltyScore': 1.4042816162109375\n\n'documentId': 'e9905bc3e1a3780619966899'\n'chunk_id': '687814d8bed6dcd41a99b093'\n'access': 'granted'\n'part_number': 6\n'total_parts': 17\n'contentType': 'READ'\n'title': Jetzt schlägt’s 15: Was ist neu in Angular 15? - Alle neuen Features von Angular 15 im Blick\n'parentName': Java Magazin 2.2023\n'language': 'DE'\n'date': '2023-01-03T02:00:00.000Z'\n'abstract': Angular 15 wurde für den produktiven Einsatz freigegeben. In diesem Tutorial werfen wir einen genauen Blick auf die neuen Features und Verbesserungen des JavaScript-Frameworks und geben Hinweise zum Umgang mit inkompatiblen Änderungen in Angular 15.\n'parentId': '9b91af29eb210add4465b516'\n'parentDescription': Über neun Millionen Software-Entwickler weltweit sorgen dafür, dass die Java-Technologie in allen Geschäftsfeldern und in allen Branchen eine zentrale Rolle spielt. Zudem ist das Java-Ökosystem der wichtigste Takt- und Impulsgeber für die gesamte Software-Industrie, wenn es um technische Innovationen geht. Das Java Magazin begleitet seit über 20 Jahren alle wesentlichen Entwicklungen der Java-Welt aktuell, kritisch und mit großer praktischer Relevanz. Software-Architekten, Entwickler und Projektleiter vertrauen auf die anerkannte Kompetenz der Redaktion verbunden mit ihrem Experten-Netzwerk bekannter Fachautoren.\n'indexBrandName': ''\n'indexSeriesName': ''\n'author': 'Karsten Sitterberg'\n'chunkSource': 'text'\n'text': die zu erwartende Größe des Bildes angegeben. Bei einem Bild, das etwa die Hälfte der Bildschirmbreite einnehmen soll, sollte sizes='50vw' gesetzt werden. Angular 15 Das Angular-Team legt für die Weiterentwicklung von Angular neben guten Performanceeigenschaften großen Wert darauf, dass auch die Zufriedenheit von Entwickler:innen mit dem Framework auf hohem Niveau bleibt bzw. sogar noch steigt. Das ist auch sehr wichtig, denn nicht selten finden sich Angular-Anwendungen, die sehr umfangreich sind und auch über einen langen Zeitraum gewartet werden sollen. Entwickler:innen und Firmen erwarten an dieser Stelle, dass das Investment in Angular sich auch langfristig bezahlt macht. Hier liegt eine wesentliche Stärke von Angular und dessen ist man sich auch im Angular-Team bewusst. Als Verbesserung wurde die Ausgabe von Fehlermeldungen von Angular optimiert. Konkret werden Stacktraces entschlackt und interne API-Aufrufe des Angular-Frameworks werden herausgefiltert. Dadurch kann Angular besser auf die tatsächlichen Fehlerursachen hindeuten, ohne die Entwickler:innen mit unnötigen Textmengen zu belasten. Dazu wurden auch zusätzliche Ausgaben ergänzt: Wenn beispielsweise eine Codestelle in Komponententemplates am Fehler beteiligt war, wird auf genau diese Zeile im Templatecode verwiesen. Künftige Releases sollen hier noch weiter gehen und sogar den entsprechenden Templatecodeausschnitt als Text in der Fehlermeldung anzeigen. Eine Optimierung der Build-Zeit bei gleichzeitiger Reduktion des Speicherbedarfs ergibt sich durch eine geschicktere Analyse externer Templates: Type Checks wurden bisher mehrfach ausgeführt, was nun durch einen Cache verhindert wird. Standalone-Features Aber auch echte Erweiterungen des Frameworks sind zu finden: In Angular 15 liegt ein großes Augenmerk auf den neuen Features rund um die Standalone APIs. Die Standalone-Features sind mit Angular 15 nun endgültig als stabil gekennzeichnet und noch weiter ausgebaut worden. So wurde der HttpClient erweitert, dass dieser nun auch ohne das HttpClientModule verwendet werden kann. Um den HttpClient zur Verfügung zu stellen, kann nun statt des Moduls die Providerfunktion provideHttpClient() verwendet werden. Dieser können dann weitere Konfigurationsfunktionen übergeben werden: Mit den Funktionen withXsrfConfiguration() und withNoXsrfProtection() kann zum Beispiel die eingebaute Unterstützung für\n'slidetext': ''\n'from': 'index'\n'score': 140.36471557617188\n'normalizedScore': 1.4036471557617187\n'beforeDatePenaltyScore': 1.4036471557617187\n\n'documentId': '5ecf87915aa99dfe10bb64dd'\n'chunk_id': '687814bfbed6dcd41a99b004'\n'access': 'granted'\n'part_number': 12\n'total_parts': 16\n'contentType': 'READ'\n'title': Is Angular 16 Starting a (R)evolution? - Breaking changes, features, and everything new in Angular 16\n'parentName': JavaScript Magazine Volume 8\n'language': 'EN'\n'date': '2023-03-08T23:00:00.000Z'\n'abstract': The newest version of Angular is here. Angular 16 introduces some new breaking changes and features and sets a new tone for the framework. This article dives into all of the changes and what developers need to know before migrating.\n'parentId': '4169b80642e03abd714cf6fe'\n'parentDescription': Broaden your knowledge and expand your JavaScript techniques and practices. From Angular, React, and WebAssembly, to the best JavaScript IDEs, open source tools and more, you’ll learn insights on everything JS from seasoned experts in their field. Keep up with JavaScript news, tips, and advice with interviews, tutorials, and in-depth articles.\n'indexBrandName': ''\n'indexSeriesName': ''\n'author': 'Karsten Sitterberg'\n'chunkSource': 'text'\n'text': destroyRef.onDestroy(() => doSomethingOnDestroy() ); // unregisterFn(); // Takes back onDestroy logic } ngOnInit(): void { interval(1000) .pipe(takeUntilDestroyed(this.destroyRef)) .subscribe(val => console.log('value:', val)) } Listen to the signals… Angular 16 introduces a new concept so groundbreaking that it deserves its own headline. We’re talking about 'Signals', a concept that was certainly inspired by Vue. The long-term goal is to get along without 'Zone.js' and to be able to map the change detection with other means. This is important to streamline standalone applications and potentially even open up the possibilities of implementing individual elements with Angular, comparable to React and Vue. The motivation given was that Angular applications will become simpler, since using RxJS is no longer mandatory. This should reduce the technical and conceptual complexity. But the topic also has a bit of an aftertaste. Official discussions only started publicly about three weeks before Angular 16’s first release candidate was adopted. With a development time of six months and the potentially huge consequences of such a design change, this seems very short-term. Critical comments in the RFC discussions were dismissed very diplomatically and it seems as if everything was decided internally by the Angular team and Google. Similarities to Paris 2016 cannot be overlooked. This approach represents a serious risk for the Angular community. Whether Angular will really become conceptually simpler as long as the included HttpClient uses RxJS is also doubtful. After all, developers inevitably come into contact with both concepts. But perhaps the HttpClient will be discontinued three weeks before the first release candidate of Angular 17 with the same argument. So even if these are promising visions and almost a new generation of Angular, a little more tact and transparency is desirable. Technically, Signals is a reactivity engine that allows changes to the state of specific data objects to cause updates to the associated DOM elements. Unlike Promises and RxJS Observable, actions on Signals are always synchronous. Since web applications are inherently driven by events, RxJS is a great fit in principle. For transformation between Signals and Observables there is the new package '@angular/rxjs-interop' which provides transformation APIs like 'toObservable()' and 'toSignal()'. A signal can be created simply by calling the new function 'signal()'. The type parameter 'T' stands for the data type to be managed by this signal. Listing 19 shows with the signal counter that the type of a signal can also be defined by defining an initial value, in this case it is the number 0. The signal is read by calling it like a function. This is shown in the component’s template\n'slidetext': ''\n'from': 'index'\n'score': 140.3214569091797\n'normalizedScore': 1.403214569091797\n'beforeDatePenaltyScore': 1.403214569091797\n\n'documentId': '5ecf87915aa99dfe10bb64dd'\n'chunk_id': '687814c0bed6dcd41a99b007'\n'access': 'granted'\n'part_number': 15\n'total_parts': 16\n'contentType': 'READ'\n'title': Is Angular 16 Starting a (R)evolution? - Breaking changes, features, and everything new in Angular 16\n'parentName': JavaScript Magazine Volume 8\n'language': 'EN'\n'date': '2023-03-08T23:00:00.000Z'\n'abstract': The newest version of Angular is here. Angular 16 introduces some new breaking changes and features and sets a new tone for the framework. This article dives into all of the changes and what developers need to know before migrating.\n'parentId': '4169b80642e03abd714cf6fe'\n'parentDescription': Broaden your knowledge and expand your JavaScript techniques and practices. From Angular, React, and WebAssembly, to the best JavaScript IDEs, open source tools and more, you’ll learn insights on everything JS from seasoned experts in their field. Keep up with JavaScript news, tips, and advice with interviews, tutorials, and in-depth articles.\n'indexBrandName': ''\n'indexSeriesName': ''\n'author': 'Karsten Sitterberg'\n'chunkSource': 'text'\n'text': lifecycle, the API also changes for signal components. With 'afterNextRender', a function is executed after the completion of the next DOM update cycle. This is similar to the previous 'ngAfterViewInit', but is called more often. With 'afterRender', the specified callback is called after each DOM update. Finally, there is 'afterRenderEffect', which calls an 'effect' with each 'afterRender'. Overall, the design already looks very promising and future-oriented. Only the question about API uniformity in view of RxJS use remains. However, a sensible hybrid concept can also be established. Currently, signals are still in a preview API and further development will depend on feedback from the community. Breaking Changes According to semantic versioning conventions, incompatible changes are always expected in major releases. Angular 16 is no exception, but the impact for the majority of users is limited. Therefore, version requirements for the tools and frameworks have changed. First, at least TypeScript 4.9 is required. Node.js must be at least version 16, as Node.js 14 has an end-of-life date of March 30, 2023. Zone.js versions older than 0.12 are no longer supported. As an old construct, ReflectiveInjector has already been marked deprecated and has been dropped. If needed, you can use Injector.create as a replacement. Since Angular 14, the BrowserTransferStateModule was empty. It is dropped in this release. The TransferState class can be injected directly without the module. In the BrowserModule, the withServerTransition method has been marked deprecated. This was used for SSR to set an App ID to the app. Now, you can use the injection token “APP_ID” to assign an ID. If multiple Angular apps are placed on the same page, you must set the APP ID to an individual value per app. If only one app is used, the App ID configuration can be omitted. In Router, all references to the “ComponentFactoryResolver” have been removed, which used to be responsible for lazy loading, among other things. However, since Angular 13, the “ComponentFactoryResolver” is no longer needed for this and is generally marked as “Deprecated”. Besides its use in the router, you could also create components manually with the “ComponentFactoryResolver”. To create components manually, simply a reference to the component class is enough. This can be used together with a “ViewContainerRef” to create a component via “viewContainerRef.createComponent()”. Especially in combination with standalone components, it’s also easy to lazy reload components independently of the router. Conclusion The Angular framework faces enormous competition. React, and increasingly Vue, are popular with newcomers. The perceived learning curve is flatter and the other frameworks also now have extensive ecosystems. There\n'slidetext': ''\n'from': 'index'\n'score': 140.30526733398438\n'normalizedScore': 1.4030526733398438\n'beforeDatePenaltyScore': 1.4030526733398438\n\n'documentId': '5ecf87915aa99dfe10bb64dd'\n'chunk_id': '687814bfbed6dcd41a99b001'\n'access': 'granted'\n'part_number': 9\n'total_parts': 16\n'contentType': 'READ'\n'title': Is Angular 16 Starting a (R)evolution? - Breaking changes, features, and everything new in Angular 16\n'parentName': JavaScript Magazine Volume 8\n'language': 'EN'\n'date': '2023-03-08T23:00:00.000Z'\n'abstract': The newest version of Angular is here. Angular 16 introduces some new breaking changes and features and sets a new tone for the framework. This article dives into all of the changes and what developers need to know before migrating.\n'parentId': '4169b80642e03abd714cf6fe'\n'parentDescription': Broaden your knowledge and expand your JavaScript techniques and practices. From Angular, React, and WebAssembly, to the best JavaScript IDEs, open source tools and more, you’ll learn insights on everything JS from seasoned experts in their field. Keep up with JavaScript news, tips, and advice with interviews, tutorials, and in-depth articles.\n'indexBrandName': ''\n'indexSeriesName': ''\n'author': 'Karsten Sitterberg'\n'chunkSource': 'text'\n'text': Now you can bind data from the routing process directly to component inputs. This can involve binding data dynamically loaded via resolver, and data from the query parameters to the component. Listing 12 shows a component that is bound using the route configuration from Listing 13. In this route configuration, a static data object with the property 'demoData' is stored for the route 'demo'. A resolver object with the property 'demoResolved' is also stored. The resolver is synchronous here, but it could also return an asynchronous observable or promise, since this would be resolved by the router. It’s no coincidence that the properties in the route definition are named the same as the '@Input' properties in the component. This is actually a prerequisite for mapping the corresponding properties to each other. The feature can be enabled by passing the function 'withComponentInputBinding()' when calling 'provideRouter()'. See Listing 13. If the new syntax is not yet used to create the router, but the RouterModule is, the flag 'bindToComponentInputs: true' can be set in the 'RouterModule.forRoot()'. Listing 14 shows an example of what values the component inputs assume when the '/demo?language=french' route is called in the application. It is important to note here that even the query parameters (and the matrix parameters assigned to the route) can be bound using this mechanism, which should simplify developer’s lives considerably. The query parameters to be bound must also have the same name as the input variable to be bound. If there are name collisions between the individual data sources, the data from the resolver has the highest priority. After that the static data from the route configuration is used, then the matrix parameters follow. If the property is not found in any of these sources, the data is extracted from the query params. Listing 12: Components with Input @Component({ template: '' }) export class DemoComponent { @Input() language?: string; @Input() demoResolved?: string; @Input() demoData?: string; } Listing 13: Route configuration const routes = [{ path: 'demo', component: DemoComponent, data: {'demoData': 'My static data'}, resolve: {'demoResolved': () => 'My resolved data'}, }]; // inside AppModule/app-config provideRouter(routes, withComponentInputBinding()) Listing 14: Component properties at runtime router.navigateByUrl('/demo?language=french') // component.language === 'french'; // component.demoData === 'My static data'; // component.demoResolved === 'My resolved data' A very important topic in this release is Angular's ability to dynamically render the browser application on the server side (server-side rendering, SSR) and send the result to the browser. This allows page content to be rendered directly after being sent to the client, without having to wait for the app to launch. This is especially\n'slidetext': ''\n'from': 'index'\n'score': 140.29998779296875\n'normalizedScore': 1.4029998779296875\n'beforeDatePenaltyScore': 1.4029998779296875\n\n'documentId': '2e2495f42751c019986f5bc4'\n'chunk_id': '687ab74e2be886398c2ad12f'\n'access': 'granted'\n'part_number': 7\n'total_parts': 9\n'contentType': 'READ'\n'title': Java 16: Das JDK auf dem Weg zur nächsten LTS-Version - Sweet 16\n'parentName': JAXenter 3.2021\n'language': 'DE'\n'date': '2021-03-01T16:58:00.000Z'\n'abstract': 14, 15 oder doch schon 16? Da kann man schon mal durcheinanderkommen. Durch die mittlerweile halbjährlichen Major-Releases von Java fällt es gar nicht so leicht, die aktuelle Version richtig zu benennen. Vor Kurzem hat man sich in einem Vortrag noch über die Neuerungen des JDK 14 informiert, und wenig später wurden in einem Artikel bereits die Features von Version 15 näher beleuchtet. Und da sich die Welt bekanntlich schnell weiterdreht, ist nun im März 2021 bereits das OpenJDK 16 herausgekommen.\n'parentId': 'f3f07cfbd5f6d489e27c1d11'\n'parentDescription': n/a\n'indexBrandName': ''\n'indexSeriesName': ''\n'author': 'Falk Sippach'\n'chunkSource': 'text'\n'text': hat die Mercurial Commit Messsages in das Git-Format überführt. Wer schon sehr lange in der Java-Welt unterwegs ist, wird sich vielleicht noch an das Java Native Interface (JNI) erinnern. Damit kann man nativen C-Code aus Java heraus aufrufen. Der Ansatz ist aber relativ aufwendig und fragil. Das Foreign Linker API (JEP 389) bietet nun einen statisch typisierten, rein Java-basierten Zugriff auf nativen Code. Zusammen mit dem Foreign-Memory Access API (JEP 393) kann diese Schnittstelle den bisher fehleranfälligen Prozess der Anbindung einer nativen Bibliothek beträchtlich vereinfachen. Mit Letzterer bekommen Java-Anwendungen die Möglichkeit, außerhalb des Heap zusätzlichen Speicher zu allokieren. Wer häufig mit primitiven Wrapper-Klassen (Integer, Boolean, …) arbeitet, wird ab dem JDK 16 womöglich über neue Deprecation-for-Removal-Warnungen stolpern. Das betrifft sowohl die Konstruktoren mit dem Stringparameter als auch mit dem jeweiligen primitiven Datentyp als Argument (int bei Integer). Hinter dieser Maßnahme steckt auch das Projekt Valhalla. Dort strebt man die Erweiterung des Java-Programmiermodells in Form von primitiven Klassen an. Diese primitiven Klassen sollen keine Identität besitzen und dadurch auch leicht vom Compiler bzw. dem Laufzeit-Interpreter „ge-inlined“ werden können. Dadurch lassen sie sich frei zwischen Speicherorten kopieren und als Werte von Instanzfeldern kodieren. Ebenfalls dem Vorschaufeature entwachsen ist mit dem OpenJDK 16 das jpackage-Werkzeug. Es unterstützt native Paketformate, um den Nutzern eine einfache Installation zu ermöglichen, inklusive der Angabe von Startparametern zum Zeitpunkt der Paketierung. Zu den Formaten gehören msi und exe unter Windows, pkg und dmg unter macOS, sowie deb und rpm unter Linux. Das Tool kann direkt über die Befehlszeile oder auch programmatisch aufgerufen werden. Durch das in Java 9 eingeführte Java Platform Modul System (JPMS) können nun JDK-interne Klassen vor dem Zugriff von außen geschützt werden. Bisher gab es zum Übergang aber die eingeschränkte Kapselung als Default, d. h., dass interne APIs weiterhin verwendet werden konnten. Dieses Schlupfloch wird mit dem OpenJDK 16 geschlossen. Die neue Standardeinstellung ist die strikte Kapselung der JDK-Internas, außer für sehr kritische interne APIs wie misc.Unsafe. Das Ziel dieser\n'slidetext': ''\n'from': 'index'\n'score': 140.23023986816406\n'normalizedScore': 1.4023023986816405\n'beforeDatePenaltyScore': 1.4023023986816405\n\n'documentId': 'e9905bc3e1a3780619966899'\n'chunk_id': '687814d9bed6dcd41a99b09b'\n'access': 'granted'\n'part_number': 14\n'total_parts': 17\n'contentType': 'READ'\n'title': Jetzt schlägt’s 15: Was ist neu in Angular 15? - Alle neuen Features von Angular 15 im Blick\n'parentName': Java Magazin 2.2023\n'language': 'DE'\n'date': '2023-01-03T02:00:00.000Z'\n'abstract': Angular 15 wurde für den produktiven Einsatz freigegeben. In diesem Tutorial werfen wir einen genauen Blick auf die neuen Features und Verbesserungen des JavaScript-Frameworks und geben Hinweise zum Umgang mit inkompatiblen Änderungen in Angular 15.\n'parentId': '9b91af29eb210add4465b516'\n'parentDescription': Über neun Millionen Software-Entwickler weltweit sorgen dafür, dass die Java-Technologie in allen Geschäftsfeldern und in allen Branchen eine zentrale Rolle spielt. Zudem ist das Java-Ökosystem der wichtigste Takt- und Impulsgeber für die gesamte Software-Industrie, wenn es um technische Innovationen geht. Das Java Magazin begleitet seit über 20 Jahren alle wesentlichen Entwicklungen der Java-Welt aktuell, kritisch und mit großer praktischer Relevanz. Software-Architekten, Entwickler und Projektleiter vertrauen auf die anerkannte Kompetenz der Redaktion verbunden mit ihrem Experten-Netzwerk bekannter Fachautoren.\n'indexBrandName': ''\n'indexSeriesName': ''\n'author': 'Karsten Sitterberg'\n'chunkSource': 'text'\n'text': die ngOnInit()-Methode generiert. Im Zuge der Vereinfachung des Projekt-Set-ups für Neueinsteiger:innen, und auch basierend auf einer Umfrage unter Angular-Entwickler:innen, wurde das Komponenten-Schematic nun so angepasst, dass der Konstruktor und ngOnInit() nicht mehr automatisch mitgeneriert werden. Beides kann natürlich bei Bedarf ergänzt werden. Natürlich gab es nicht nur bei TypeScript oder den Build-Tools von Angular Aktualisierungen. So gibt es zum Beispiel neue APIs und Best Practises im Umgang mit Sass/SCSS, die auch Auswirkungen auf den Angular-CLI-Build haben. So kann bzw. muss zum Import von Styles aus den Node Modules nicht länger die Tilde verwendet werden, sondern kann einfach entfallen, wie in Listing 16 für den Import aus Font-Awesome gezeigt wird. Dabei sollte man beachten: Das Sass-Team hat offiziell die Empfehlung ausgegeben, dass @imports nicht mehr verwendet werden sollte, sondern stattdessen @ use. Das ist allerdings noch nicht in allen Fällen – wie mit Font-Awesome – ohne Umwege möglich. Allgemein nutzt das Angular CLI nun das Sass Modern API. Falls weiter das alte API verwendet werden muss, kann es über die Umgebungsvariable NG_BUILD_LEGACY_SASS aktiviert werden, z. B. mit folgendem Befehl: NG_BUILD_LEGACY_SASS=1 ng build. Listing 16: Vergleich alter und neuer Import // Alter Import mit Tilde @import '~font-awesome/scss/font-awesome'; // Neuer Import ohne Tilde @import 'font-awesome/scss/font-awesome'; Angular-CLI-Container-Image Passend zum Angular CLI in Version 15 gibt es auch aktualisierte Container-Images, die vor allem zum Build auf einem CI-Server wie GitLab CI oder Jenkins, aber auch für GitHub Actions praktisch sind. Die Images sind sowohl mit Docker als auch anderen Container-Runtimes nutzbar und werden auf DockerHub und quay.io bereitgestellt [1]. Je nach Anwendungsfall (Build, Unit-Test, E2E-Test mit Protractor) gibt es Image-Varianten, die alle erforderlichen Tools inkl. Angular CLI als versioniertes Container-Image bereitstellen. Auch zur Auslieferung von Angular-Anwendungen selbst als Container-Images lassen sich die Images im Build gut einsetzen. Die Verwendung der Images wird im Artikel „Grundkurs Angular: Professionell bauen, testen und ausliefern mit GitLab CI und Docker“ auf entwickler.de erklärt [2]. Material Das Angular-Material-Team hat mit Version 15 einige grundlegende Veränderungen an Angular\n'slidetext': ''\n'from': 'index'\n'score': 139.97947692871094\n'normalizedScore': 1.3997947692871093\n'beforeDatePenaltyScore': 1.3997947692871093\n\n'documentId': 'e9905bc3e1a3780619966899'\n'chunk_id': '687814d8bed6dcd41a99b097'\n'access': 'granted'\n'part_number': 10\n'total_parts': 17\n'contentType': 'READ'\n'title': Jetzt schlägt’s 15: Was ist neu in Angular 15? - Alle neuen Features von Angular 15 im Blick\n'parentName': Java Magazin 2.2023\n'language': 'DE'\n'date': '2023-01-03T02:00:00.000Z'\n'abstract': Angular 15 wurde für den produktiven Einsatz freigegeben. In diesem Tutorial werfen wir einen genauen Blick auf die neuen Features und Verbesserungen des JavaScript-Frameworks und geben Hinweise zum Umgang mit inkompatiblen Änderungen in Angular 15.\n'parentId': '9b91af29eb210add4465b516'\n'parentDescription': Über neun Millionen Software-Entwickler weltweit sorgen dafür, dass die Java-Technologie in allen Geschäftsfeldern und in allen Branchen eine zentrale Rolle spielt. Zudem ist das Java-Ökosystem der wichtigste Takt- und Impulsgeber für die gesamte Software-Industrie, wenn es um technische Innovationen geht. Das Java Magazin begleitet seit über 20 Jahren alle wesentlichen Entwicklungen der Java-Welt aktuell, kritisch und mit großer praktischer Relevanz. Software-Architekten, Entwickler und Projektleiter vertrauen auf die anerkannte Kompetenz der Redaktion verbunden mit ihrem Experten-Netzwerk bekannter Fachautoren.\n'indexBrandName': ''\n'indexSeriesName': ''\n'author': 'Karsten Sitterberg'\n'chunkSource': 'text'\n'text': z. B. allowfullscreen, csp und sandbox. Falls versucht wird, eines dieser Properties dynamisch zu setzen, wird ein Fehler ausgegeben, der auf die Komponente hinweist, in der das Property fälschlicherweise dynamisch gesetzt wurde. Um das ungewollte Öffnen eines so fehlkonfigurierten iFrames zu verhindern, wird dann auch die src-Property auf einen leeren String zurückgesetzt. Auch beim Router gab es Breaking Changes: So wurde zum Beispiel die Konfigurationsoption relativeLinkResolution entfernt, da diese mit Angular 6.1. nur temporär eingeführt wurde. Es gab damals einen Bug bei der Rückwärtsnavigation mittels relativer Pfadangaben wie ../../. Das Property relativeLinkResolution wurde damals als Opt-out aus dem entsprechenden Bug-Fix eingeführt, um einen direkten Breaking Change für Code-Basen, die dadurch Probleme bekamen, zu vermeiden. Animationen Ein beliebtes Mittel von Webentwickler:innen, um Apps ansprechender zu gestalten, sind Animationen. In Angular-Anwendungen kann dazu entweder das eigene Animation-Framework von Angular verwendet werden oder aber CSS-Animationen. Um CSS-Animationen zu schreiben, ist es nötig, sogenannte @keyframes im CSS zu definieren, mit denen die verschiedenen Zustände bzw. Abschnitte angegeben werden können, die eine Animation durchläuft. Bisher wurden die Namen der Keyframes einfach übernommen, wie sie von Entwickler:innen definiert wurden. Das konnte dazu führen, dass verschiedene Keyframes-Angaben sich gegenseitig überschrieben haben, wenn in verschiedenen Komponenten die Keyframes gleich benannt wurden. Mit Angular 15 ist es nun so, dass die Keyframes zur Laufzeit mit dem technischen Identifier der Komponente versehen werden. Das ist damit analog zur Styleisolation der Komponenten-HTML-Elemente selbst, wie in Listing 10 zu sehen ist. Falls man dieses Verhalten nicht möchte, muss die Komponente nun auf ViewEncapsulation.ShadowDom oder ViewEncapsulation.None eingestellt werden oder die Keyframes müssen im globalen CSS hinterlegt werden. Listing 10: Vergleich CSS-Keyframes zur Laufzeit mit Angular 14 und 15 // Laufzeit Bisher: @keyframes demo-animation { ... } // Laufzeit mit Angular 15: @keyframes _ngcontent-yog-c64_demo-animation { ... } Nachdem das Angular-Team lange an der Ivy Rendering Engine gefeilt hat, wurde diese mit Angular 9 endlich veröffentlicht. Es gab danach eine Übergangszeit, in der man zwischen der alten View Engine und Ivy hin-\n'slidetext': ''\n'from': 'index'\n'score': 139.92098999023438\n'normalizedScore': 1.3992098999023437\n'beforeDatePenaltyScore': 1.3992098999023437\n\n'documentId': 'e9905bc3e1a3780619966899'\n'chunk_id': '687814d9bed6dcd41a99b09d'\n'access': 'granted'\n'part_number': 16\n'total_parts': 17\n'contentType': 'READ'\n'title': Jetzt schlägt’s 15: Was ist neu in Angular 15? - Alle neuen Features von Angular 15 im Blick\n'parentName': Java Magazin 2.2023\n'language': 'DE'\n'date': '2023-01-03T02:00:00.000Z'\n'abstract': Angular 15 wurde für den produktiven Einsatz freigegeben. In diesem Tutorial werfen wir einen genauen Blick auf die neuen Features und Verbesserungen des JavaScript-Frameworks und geben Hinweise zum Umgang mit inkompatiblen Änderungen in Angular 15.\n'parentId': '9b91af29eb210add4465b516'\n'parentDescription': Über neun Millionen Software-Entwickler weltweit sorgen dafür, dass die Java-Technologie in allen Geschäftsfeldern und in allen Branchen eine zentrale Rolle spielt. Zudem ist das Java-Ökosystem der wichtigste Takt- und Impulsgeber für die gesamte Software-Industrie, wenn es um technische Innovationen geht. Das Java Magazin begleitet seit über 20 Jahren alle wesentlichen Entwicklungen der Java-Welt aktuell, kritisch und mit großer praktischer Relevanz. Software-Architekten, Entwickler und Projektleiter vertrauen auf die anerkannte Kompetenz der Redaktion verbunden mit ihrem Experten-Netzwerk bekannter Fachautoren.\n'indexBrandName': ''\n'indexSeriesName': ''\n'author': 'Karsten Sitterberg'\n'chunkSource': 'text'\n'text': neue Implementierung der gleichen Komponente verwendet werden, da diese sich nicht vertragen. Nach dem initialen Update sollte das Migration-Tool ausgeführt werden, dazu dient der Befehl: ng generate @angular/material:mdc-migration Dieser versucht, alle Legacy-Implementierungen gegen die neuen MDC-basierten auszutauschen und macht dabei auch Anpassungen in TypeScript, Styles und Templates. Dabei kann das Tool natürlich nicht jede Situation vollständig automatisch lösen. In solchen Fällen wird ein Kommentar in folgender Form an die entsprechende Codestelle platziert: // TODO(mdc-migration): ... Nach diesen Code-Stellen lässt sich dann suchen, um die verbliebenen Probleme zu lösen. Es kann beispielsweise sein, dass auch selbst geschriebenes App-CSS oder DOM-Strukturen angepasst werden müssen. Abschließend sollten auch die Tests der App ausgeführt werden, um sicherzustellen, dass alles noch so funktioniert wie vor dem Update. Eine detaillierte Updateanleitung findet sich auf der offiziellen Angular-Material-Homepage [3]. Angular 15: Fazit und Ausblick Angular 15 bringt inkrementelle Änderungen zur besseren Integration von Standalone Components mit sich. Das Angular-Team achtet dabei auf Qualität und Stabilität: So wurden bei Google mehrere Tausend interne Anwendungen auf Angular 15 aktualisiert, um ein Gefühl dafür zu bekommen, welche Features von Angular wie genutzt werden und wie sich die Aktualisierungen auf Entwickler:innen und bestehende Anwendungen auswirkt. Grundsätzlich ist zu empfehlen, regelmäßige Wartung bei allen Anwendungen vorzunehmen. Das gilt auch für Angular-basierte Anwendungen. Je häufiger eine Synchronisation zu aktuellen Versionen vorgenommen wird, desto geringer sind Aufwand und Risiko für das jeweilige Update. Die Ausrichtung auf Standalone Components bei Angular bewerte ich grundsätzlich positiv. Dabei sehe ich allerdings auch die Gefahr, dass das Modulsystem lediglich als Overhead wahrgenommen wird und die damit verbundenen Vorteile vergessen werden. Ich bin als Berater in verschiedenen sehr großen Angular-Projekten unterwegs und gerade im Enterprise-Kontext bzw. bei Multi-Team-Anwendungen bringt Angular mit dem Modulsystem ein Alleinstellungsmerkmal mit sich. Es wirkt ein wenig so, als ob Angular Gefahr liefe, dieses aufzugeben, um einen einfacheren Einstieg zu ermöglichen. Davon abgesehen ist es ein gutes Zeichen, dass Angular und das umgebende Ökosystem sich\n'slidetext': ''\n'from': 'index'\n'score': 139.69155883789062\n'normalizedScore': 1.3969155883789062\n'beforeDatePenaltyScore': 1.3969155883789062\n\n'documentId': '2e2495f42751c019986f5bc4'\n'chunk_id': '687ab74d2be886398c2ad128'\n'access': 'granted'\n'part_number': 4\n'total_parts': 9\n'contentType': 'READ'\n'title': Java 16: Das JDK auf dem Weg zur nächsten LTS-Version - Sweet 16\n'parentName': JAXenter 3.2021\n'language': 'DE'\n'date': '2021-03-01T16:58:00.000Z'\n'abstract': 14, 15 oder doch schon 16? Da kann man schon mal durcheinanderkommen. Durch die mittlerweile halbjährlichen Major-Releases von Java fällt es gar nicht so leicht, die aktuelle Version richtig zu benennen. Vor Kurzem hat man sich in einem Vortrag noch über die Neuerungen des JDK 14 informiert, und wenig später wurden in einem Artikel bereits die Features von Version 15 näher beleuchtet. Und da sich die Welt bekanntlich schnell weiterdreht, ist nun im März 2021 bereits das OpenJDK 16 herausgekommen.\n'parentId': 'f3f07cfbd5f6d489e27c1d11'\n'parentDescription': n/a\n'indexBrandName': ''\n'indexSeriesName': ''\n'author': 'Falk Sippach'\n'chunkSource': 'text'\n'text': welche Subklassen erlaubt sind und überhaupt existieren. In Zukunft sollen Sealed Classes auch bei Switch Expressions eingesetzt werden können (im Rahmen des Pattern Matching). Wenn man dann je case-Zweig alle erlaubten Subklassen verwendet, kann der Einsatz des default-Blocks entfallen. Durch die Information aus der permit-Anweisung kann der Compiler sicherstellen, dass mindestens einer der Zweige aufgerufen wird (Listing 2). Listing 2 // noch kein gültiger Code, kommt erst in späteren Java-Versionen public BigDecimal calculateExpense(Vehicle vehicle) { return switch(vehicle) { case Car c -> calculateCarExpense(c); case Bike b -> calculateBikeExpense(b); case Bus b -> calculateBusExpense(b); case Train t -> calculateTrainExpense(t); } } Subklassen bergen immer die Gefahr, dass beim Überschreiben der Vertrag der Superklasse und damit das Liskovsche Substitutionsprinzip verletzt wird. Zum Beispiel ist es unmöglich, die Bedingungen der equals-Methode aus der Klasse Object zu erfüllen, wenn man Instanzen von einer Super- und einer Subklasse miteinander vergleichen will. Weitere Details dazu kann man in der API-Dokumentation [2] unter dem Stichwort Äquivalenzrelationen (konkret Symmetrie) nachlesen. Sealed Classes funktionieren auch mit abstrakten Klassen. Es gibt aber ein paar Einschränkungen. Eine Sealed Class und alle erlaubten Subklassen müssen im selben Modul existieren. Im Falle von Unnamed Modules müssen sie sogar im gleichen Package liegen. Außerdem muss jede erlaubte Subklasse direkt von der Sealed Class ableiten. Die abgeleiteten Klassen dürfen übrigens wieder selbst entscheiden, ob sie weiterhin versiegelt, final oder komplett offen sein wollen. Die zentrale Versiegelung einer ganzen Klassenhierarchie von oben bis zur untersten Hierarchiestufe ist nicht möglich. Records Bereits zum dritten Mal dabei sind wieder die in Java 14 eingeführten record-Datentypen. Mit dem JEP 395 sollen sie nun finalisiert werden. Es gab seit der zweiten Preview (JDK 15) noch einige kleine Änderungen, die sich aus den Rückmeldungen der letzten Monate ergeben haben. Bei den Records handelt es sich um eine eingeschränkte Form der Klassendeklaration, ähnlich den Enums. Entwickelt wurden Records im Rahmen des Projektes Valhalla. Es gibt gewisse Ähnlichkeiten zu Data Classes in Kotlin und Case Classes in Scala. Auch sie sind im Umfeld der Einführung von Pattern Matching entstanden\n'slidetext': ''\n'from': 'index'\n'score': 139.5652618408203\n'normalizedScore': 1.3956526184082032\n'beforeDatePenaltyScore': 1.3956526184082032\n\n'documentId': '5ecf87915aa99dfe10bb64dd'\n'chunk_id': '687814c0bed6dcd41a99b008'\n'access': 'granted'\n'part_number': 16\n'total_parts': 16\n'contentType': 'READ'\n'title': Is Angular 16 Starting a (R)evolution? - Breaking changes, features, and everything new in Angular 16\n'parentName': JavaScript Magazine Volume 8\n'language': 'EN'\n'date': '2023-03-08T23:00:00.000Z'\n'abstract': The newest version of Angular is here. Angular 16 introduces some new breaking changes and features and sets a new tone for the framework. This article dives into all of the changes and what developers need to know before migrating.\n'parentId': '4169b80642e03abd714cf6fe'\n'parentDescription': Broaden your knowledge and expand your JavaScript techniques and practices. From Angular, React, and WebAssembly, to the best JavaScript IDEs, open source tools and more, you’ll learn insights on everything JS from seasoned experts in their field. Keep up with JavaScript news, tips, and advice with interviews, tutorials, and in-depth articles.\n'indexBrandName': ''\n'indexSeriesName': ''\n'author': 'Karsten Sitterberg'\n'chunkSource': 'text'\n'text': lazy reload components independently of the router. Conclusion The Angular framework faces enormous competition. React, and increasingly Vue, are popular with newcomers. The perceived learning curve is flatter and the other frameworks also now have extensive ecosystems. There are also new developments, such as Qwik, which was co-founded by ex-Angular developers. We can only speculate about the real reasons behind all the decisions. Since the bi-weekly notes were discontinued in September 2022, motivations for transparency don’t seem to be at a high level anymore either. To be honest, the information content also decreased and became vanishingly small. But the RFC discussions also seem a bit like diplomatic tactics. Less than three weeks before Angular 16’s first release candidate, the RFC discussions on the signal API just began and criticism was 'closely watched'. Prior to this, there were appropriate internal discussions and design. The question then arises as to why this has not been transparently implemented. It looks like overall, Angular is facing political pressure from emerging frameworks. Similarly, investment in server-side rendering is also apparent. It also looks good in the Google Lighthouse metrics. They want to attract new users and make it easier to get started. So far, Angular has shone as a full-stack framework for any foreseeably complex and large applications with excellent maintainability. One hopes that this core group of enterprise developers won’t be so upset by the massive efforts involved in migrating to newer Angular versions that they no longer consider implementing new projects with Angular. As far as migrations to new versions are concerned, effort and benefit need to be proportionate. A look at things like IPv6, Python 3, and the many companies still using Java 11, or even below, shows how excellent Angular has been in the past. Hopefully, Angular will keep its eyes on the target group as well and not lose focus. Apart from that, big steps towards the Signal API and Zone.js as an optional implementation of change detection are future-oriented and almost seem like a secret vision for a new Angular generation. The same applies to the module system, which can be used as an optional means of structuring large applications well, keeping them maintainable without forcing unjustified complexity on newcomers or small applications. Developers should definitely stay on the ball here - and actively shape what the future of Angular looks like.\n'slidetext': ''\n'from': 'index'\n'score': 139.517578125\n'normalizedScore': 1.39517578125\n'beforeDatePenaltyScore': 1.39517578125\n\n'documentId': '5ecf87915aa99dfe10bb64dd'\n'chunk_id': '687814bfbed6dcd41a99b002'\n'access': 'granted'\n'part_number': 10\n'total_parts': 16\n'contentType': 'READ'\n'title': Is Angular 16 Starting a (R)evolution? - Breaking changes, features, and everything new in Angular 16\n'parentName': JavaScript Magazine Volume 8\n'language': 'EN'\n'date': '2023-03-08T23:00:00.000Z'\n'abstract': The newest version of Angular is here. Angular 16 introduces some new breaking changes and features and sets a new tone for the framework. This article dives into all of the changes and what developers need to know before migrating.\n'parentId': '4169b80642e03abd714cf6fe'\n'parentDescription': Broaden your knowledge and expand your JavaScript techniques and practices. From Angular, React, and WebAssembly, to the best JavaScript IDEs, open source tools and more, you’ll learn insights on everything JS from seasoned experts in their field. Keep up with JavaScript news, tips, and advice with interviews, tutorials, and in-depth articles.\n'indexBrandName': ''\n'indexSeriesName': ''\n'author': 'Karsten Sitterberg'\n'chunkSource': 'text'\n'text': the browser application on the server side (server-side rendering, SSR) and send the result to the browser. This allows page content to be rendered directly after being sent to the client, without having to wait for the app to launch. This is especially interesting if the application’s initial loading time has high priority or if the application is available on the free Internet and SEO (Search Engine Optimization) is relevant for the app. Until now, whenever the Angular app was loaded after the initial page load, there was a short flicker. The newly launched app was redrawing the complete DOM. Now you can let this process run non-destructively, without rebuilding the DOM and without flickering. This “non-destructive hydration” is still in developer preview mode. First, the serverside rendering functionality must be added to the app for the new hydration to work ('ng add @nguniversal/express-engine'). Then, in the AppModule’s providers (or the 'main.ts' for standalone apps), the function 'provideClientHydration()' must be added, similar to Listing 16. Listing 16: Configuration of non-destructive hydration in the AppModule or when bootstrapping the application in the case of standalone applications. providers: [provideClientHydration()] Another optimization is possible with the HttpClient. If Http requests are executed from the application on the server side to generate the application, the HttpClient can now be configured to cache the corresponding responses and use the cache on the client side when the application is started. To do this, the 'provideHttpClient()' function must be passed the new 'withHttpTransferCache()' call. If NgModules are used, the 'TransferHttpCacheModule' module can also simply be imported into the AppModule. Just like with Router and HttpClient, the Angular service worker has now been extended so it can be added to the app with function. This function is called 'provideServiceWorker()' and takes the same parameters that were previously passed to 'ServiceWorkerModule.register()'. Anyone who pays attention to the secure operation of their application has come into contact with the 'Content Security Policy' (CSP). If a CSP policy 'style-src 'self'' or even ''strict-dynamic'' is used for the styles, then the components will not work in Angular applications. This is because the browser does not allow inline styles with the setting that Angular uses for component styles. Here, the CSP directive “unsafe-inline” needed to be enabled, but this is considered potentially unsafe. In Angular 16, it’s now possible to use the 'CSP_NONCE' injection token to set a CSP nonce, which Angular appends to the inline styles. If the index.html can still be modified at production time by the delivering server, then instead of the injection token, the attribute 'ngCspNonce' can simply\n'slidetext': ''\n'from': 'index'\n'score': 139.4139862060547\n'normalizedScore': 1.394139862060547\n'beforeDatePenaltyScore': 1.394139862060547\n\n'documentId': '5ecf87915aa99dfe10bb64dd'\n'chunk_id': '687814bfbed6dcd41a99afff'\n'access': 'granted'\n'part_number': 7\n'total_parts': 16\n'contentType': 'READ'\n'title': Is Angular 16 Starting a (R)evolution? - Breaking changes, features, and everything new in Angular 16\n'parentName': JavaScript Magazine Volume 8\n'language': 'EN'\n'date': '2023-03-08T23:00:00.000Z'\n'abstract': The newest version of Angular is here. Angular 16 introduces some new breaking changes and features and sets a new tone for the framework. This article dives into all of the changes and what developers need to know before migrating.\n'parentId': '4169b80642e03abd714cf6fe'\n'parentDescription': Broaden your knowledge and expand your JavaScript techniques and practices. From Angular, React, and WebAssembly, to the best JavaScript IDEs, open source tools and more, you’ll learn insights on everything JS from seasoned experts in their field. Keep up with JavaScript news, tips, and advice with interviews, tutorials, and in-depth articles.\n'indexBrandName': ''\n'indexSeriesName': ''\n'author': 'Karsten Sitterberg'\n'chunkSource': 'text'\n'text': “separately” displayed components like modal dialogs, popups or even toasts. With the old view engine it was necessary to announce these separate components in the “entryComponents” property of a “@NgModule” (or a “@Component”). This is no longer necessary with Ivy, so the property has been deprecated since Angular 9. With Angular 16, the “entryComponents” property is now removed, since it had no effect after Ivy anyway. The “moduleId” property of the “@NgModule” has been deprecated. This dates back to Angular’s early days, when applications were built with SystemJS. For many versions now, this property has no function. To pass data to child components, “@Input()” bindings can be used. It has always been possible to pass a string parameter to the input decorator, by which the input was made available externally under an alias. However, this input renaming is only recommended in special constellations and should not be used excessively. With Angular 16, another configuration option for the @Input() decorator has been added. As of the new version, inputs can be set to “required”. For this, a new flag was introduced that can be given to the input decorator via the Config object. Listing 8 shows 3 variants as an example. Above shows the previous input renaming variant, which still works. Below is a “barVal” property that gets the alias “barAlias” and is also marked as “required”. At the bottom, a property is marked as “required” only. If a property is marked as “required”, then this property must be set from the outside in any case. If the outside component does not set such a property to a specific value, Angular throws a compiler error. Listing 8: @Input config parameter @Input('fooAlias') fooVal = ''; @Input({alias: 'barAlias', required: true}) barVal = ''; @Input({required: true}) bazVal = ''; In TypeScript version 5, decorators similar to the ECMAScript decorators specification were introduced. In the long term, these intend to replace the previous, experimental decorators. Angular uses the TypeScript decorators to provide meta information for the dependency injection system, among other things. The information can be stored for classes, the method parameters, or the constructor. However, the final decorators are only supported on types, so “@Component”, “@Directive”, '@Pipe', “@Injectable” and “@NgModule” can be implemented with the new standard. Constructor parameter decorators, such as '@Inject()', '@Host()', '@Optional()' and others that can be used to configure dependency injection, are not yet possible with the new specification. Since it is not yet certain whether parameter decorators will be included in the ECMAScript and TypeScript specifications, Angular continues to use 'experimentalDecorators' by\n'slidetext': ''\n'from': 'index'\n'score': 139.1884002685547\n'normalizedScore': 1.3918840026855468\n'beforeDatePenaltyScore': 1.3918840026855468\n\n'documentId': '5ecf87915aa99dfe10bb64dd'\n'chunk_id': '687814bfbed6dcd41a99affe'\n'access': 'granted'\n'part_number': 6\n'total_parts': 16\n'contentType': 'READ'\n'title': Is Angular 16 Starting a (R)evolution? - Breaking changes, features, and everything new in Angular 16\n'parentName': JavaScript Magazine Volume 8\n'language': 'EN'\n'date': '2023-03-08T23:00:00.000Z'\n'abstract': The newest version of Angular is here. Angular 16 introduces some new breaking changes and features and sets a new tone for the framework. This article dives into all of the changes and what developers need to know before migrating.\n'parentId': '4169b80642e03abd714cf6fe'\n'parentDescription': Broaden your knowledge and expand your JavaScript techniques and practices. From Angular, React, and WebAssembly, to the best JavaScript IDEs, open source tools and more, you’ll learn insights on everything JS from seasoned experts in their field. Keep up with JavaScript news, tips, and advice with interviews, tutorials, and in-depth articles.\n'indexBrandName': ''\n'indexSeriesName': ''\n'author': 'Karsten Sitterberg'\n'chunkSource': 'text'\n'text': is marked as deprecated, so developers should deal with the issue now and change if necessary. Furthermore, various configuration parameters of angular.json have been removed after they were already deprecated in previous versions. This affects “defaultProject”, which could be used to configure the “default project” in the Angular CLI workspace. “Default' here means that the CLI commands (ng serve, ng test, ...) were executed in the default for the default project, if it was not explicitly given a different project name. However, this behavior is now no longer part of the Angular CLI. Since a few versions ago, the project in whose subfolder the respective command is executed is simply set as the “default”. The 'defaultCollection' for setting the collection used when executing Schematics commands (“ng generate xyz”) has also been removed. Instead, the property is now “schematicCollections” a replacement, which can be passed an array of different schematic collection names. See Listing 7. Listing 7: Old and new specification of Schematic Collections // Previously 'defaultCollection': '@angular/material' // Now 'schematicCollections': ['@angular/material'] Angular A lot has also been done in the framework itself. Some of this can be seen as preparation for further planned design changes and restructuring measures. The focus is currently on the possibilities for server-side rendering, i.e. executing the Angular application dynamically by the server and sending the result to the client as finished HTML source code. This enables faster rendering of the first view, which can be measured in core web vitals. Higher user satisfaction and ranking in search engines should result. If you do not switch frequently between different Angular applications, or are in the enterprise environment, where internal applications are rarely started, these are admittedly not high priority goals. But for applications made for end users on the Internet, these can be essential criteria for success, since switching between websites often occurs. There is also an effort to be able to create Angular applications without the Angular module system. This should reduce the learning curve and enable less complexity, especially at the start. In particular, the Angular module system is a strength that should not be underestimated for larger and more complex projects. So we can only hope that the module system will continue to be a supported, albeit optional, feature in the future. That is exactly what it looks like at the moment. Besides components built in the “normal” component tree, there are usually “separately” displayed components like modal dialogs, popups or even toasts. With the old view engine it was necessary to announce these separate components in the “entryComponents” property of a “@NgModule” (or a “@Component”). This is no longer necessary with\n'slidetext': ''\n'from': 'index'\n'score': 138.99327087402344\n'normalizedScore': 1.3899327087402344\n'beforeDatePenaltyScore': 1.3899327087402344\n\n'documentId': 'e9905bc3e1a3780619966899'\n'chunk_id': '687814d9bed6dcd41a99b09c'\n'access': 'granted'\n'part_number': 15\n'total_parts': 17\n'contentType': 'READ'\n'title': Jetzt schlägt’s 15: Was ist neu in Angular 15? - Alle neuen Features von Angular 15 im Blick\n'parentName': Java Magazin 2.2023\n'language': 'DE'\n'date': '2023-01-03T02:00:00.000Z'\n'abstract': Angular 15 wurde für den produktiven Einsatz freigegeben. In diesem Tutorial werfen wir einen genauen Blick auf die neuen Features und Verbesserungen des JavaScript-Frameworks und geben Hinweise zum Umgang mit inkompatiblen Änderungen in Angular 15.\n'parentId': '9b91af29eb210add4465b516'\n'parentDescription': Über neun Millionen Software-Entwickler weltweit sorgen dafür, dass die Java-Technologie in allen Geschäftsfeldern und in allen Branchen eine zentrale Rolle spielt. Zudem ist das Java-Ökosystem der wichtigste Takt- und Impulsgeber für die gesamte Software-Industrie, wenn es um technische Innovationen geht. Das Java Magazin begleitet seit über 20 Jahren alle wesentlichen Entwicklungen der Java-Welt aktuell, kritisch und mit großer praktischer Relevanz. Software-Architekten, Entwickler und Projektleiter vertrauen auf die anerkannte Kompetenz der Redaktion verbunden mit ihrem Experten-Netzwerk bekannter Fachautoren.\n'indexBrandName': ''\n'indexSeriesName': ''\n'author': 'Karsten Sitterberg'\n'chunkSource': 'text'\n'text': Images wird im Artikel „Grundkurs Angular: Professionell bauen, testen und ausliefern mit GitLab CI und Docker“ auf entwickler.de erklärt [2]. Material Das Angular-Material-Team hat mit Version 15 einige grundlegende Veränderungen an Angular Material vorgenommen. Bisher haben die Angular-Material-Komponenten eine eigene Style-Implementierung verwendet, die sich an den Material-Design-Guidelines orientiert hat. Mit Version 15 wurden die Komponenten so überarbeitet oder umgeschrieben, dass sie direkt den offiziellen MDC-Style (Material Design Components for Web) verwenden. So wird auf der einen Seite die Einhaltung der Material-Design-Spezifikation besser gewährleistet, auf der anderen Seite können zukünftige Versionen der Spezifikation schneller umgesetzt werden, da nun eine gemeinsame Basis besteht. So wird Angular Material unter anderem auch von der besseren Accessibility bzw. Barrierefreiheit der MDC-Komponenten profitieren. Die Verwendung der Komponenten und auch ihre Selektoren bleiben in den meisten Fällen gleich, allerdings haben sich durchweg die DOM-Strukturen und CSS-Klassen geändert. Bei Komponenten wie dem mat-autocomplete, dem mat-datepicker oder den verschiedenen Buttonimplementierungen gab es Änderungen im TypeScript API. Einen genauen Blick sollte man auf die Umstellung der Komponenten form-field, chips, slider und list werfen, da sie größere Änderungen erfahren haben, bis hin zu kompletten Rewrites. Damit beim Update auf Angular Material 15 nicht zu viel kaputt geht, hat das Team die alten Implementierungen erst mal nur deprecated, aber noch nicht entfernt. Die alten Implementierungen stehen noch als Legacy-Varianten zur Verfügung. Zum Beispiel kann die alte Buttonimplementierung durch Import des MatLegacyButtonModule angeschoben werden: import {MatLegacyButtonModule} from '@angular/material/legacy-button'; Um ein bestehendes Projekt auf Version 15 zu aktualisieren, kann wie gewohnt ng update @angular/material verwendet werden. Dabei wird eine Migration ausgeführt, die automatisch alle Material-Imports auf die Legacy-Komponenten umschwenkt, um so schnell wie möglich auf die Version 15 umsteigen zu können. Danach kann die Anwendung Modul für Modul umgestellt werden. Dabei sollte aber darauf geachtet werden, dass im gleichen NgModule nicht die alte und die neue Implementierung der gleichen Komponente verwendet werden, da diese sich nicht vertragen. Nach dem initialen Update sollte das Migration-Tool ausgeführt werden, dazu dient der Befehl: ng generate @angular/material:mdc-migration Dieser\n'slidetext': ''\n'from': 'index'\n'score': 138.72418212890625\n'normalizedScore': 1.3872418212890625\n'beforeDatePenaltyScore': 1.3872418212890625\n\n'documentId': 'e9905bc3e1a3780619966899'\n'chunk_id': '687814d8bed6dcd41a99b095'\n'access': 'granted'\n'part_number': 8\n'total_parts': 17\n'contentType': 'READ'\n'title': Jetzt schlägt’s 15: Was ist neu in Angular 15? - Alle neuen Features von Angular 15 im Blick\n'parentName': Java Magazin 2.2023\n'language': 'DE'\n'date': '2023-01-03T02:00:00.000Z'\n'abstract': Angular 15 wurde für den produktiven Einsatz freigegeben. In diesem Tutorial werfen wir einen genauen Blick auf die neuen Features und Verbesserungen des JavaScript-Frameworks und geben Hinweise zum Umgang mit inkompatiblen Änderungen in Angular 15.\n'parentId': '9b91af29eb210add4465b516'\n'parentDescription': Über neun Millionen Software-Entwickler weltweit sorgen dafür, dass die Java-Technologie in allen Geschäftsfeldern und in allen Branchen eine zentrale Rolle spielt. Zudem ist das Java-Ökosystem der wichtigste Takt- und Impulsgeber für die gesamte Software-Industrie, wenn es um technische Innovationen geht. Das Java Magazin begleitet seit über 20 Jahren alle wesentlichen Entwicklungen der Java-Welt aktuell, kritisch und mit großer praktischer Relevanz. Software-Architekten, Entwickler und Projektleiter vertrauen auf die anerkannte Kompetenz der Redaktion verbunden mit ihrem Experten-Netzwerk bekannter Fachautoren.\n'indexBrandName': ''\n'indexSeriesName': ''\n'author': 'Karsten Sitterberg'\n'chunkSource': 'text'\n'text': konfigurieren. Sollte z. B. im Kontext eines lazy geladenen Modules ein neuer Interceptor hinzugefügt werden, so war das nicht möglich, ohne einen komplett eigenen HttpClient für dieses Modul zu erzeugen, der dann jedoch nicht automatisch über die Interceptors der restlichen Anwendung verfügte. Mit dem neuen HttpClient ist es nun auch vorgesehen, Interceptors beispielsweise im Kontext von lazy geladenen Modulen nachzuladen und trotzdem weiterhin auf die Interceptor-Infrastruktur aufzubauen. Dazu muss im lazy geladenen Modul die Funktion provideHttpClient() zusammen mit withRequestsMadeViaParent() aufgerufen werden. Ein Beispiel dazu wird in Listing 7 gezeigt. Dieser Aufruf sorgt dafür, dass die HTTP-Anfragen, nachdem sie von den lazy Interceptors verarbeitet wurden, an die HTT-Infrastruktur der überliegenden Anwendung weitergereicht werden. Tatsächlich können so beliebig tief verschachtelte HTTP-Infrastrukturen erschaffen werden. Listing 7: Lazy geladenes Modul mit Interceptor @NgModule({ //... providers: [ provideHttpClient( withRequestsMadeViaParent(), withInterceptors([featureInterceptor]) ) ] }) export class LazyFeatureModule {} Directive Composition API Ein von der Community sehr lange gefordertes Feature ist nun ebenfalls mit Angular 15 freigegeben worden: Das Directive Composition API, mit dem es möglich ist, die Logik von fremden Direktiven auf das Hostelement einer eigenen Komponente bzw. Direktive anzuwenden, ohne von den fremden Direktiven erben zu müssen. Dazu gibt es ein neues Property hostDirectives in den Metadaten von Komponenten bzw. Direktiven. In Listing 8 wird zum Beispiel eine eigene Direktive appMenu zum Öffnen eines Kontextmenüs geschrieben. Dabei kann nun einfach die Funktionalität der CdkMenuTrigger-Direktive aus dem Angular-CDK übernommen werden, indem CdkMenuTrigger in die hostDirectives aufgenommen wird. Damit das Menü, das geöffnet werden soll, auch an den CDK-Menütrigger weitergereicht werden kann, muss noch der entsprechende Input der CDK-Direktive übernommen bzw. in einen Input unserer App-Direktive verwandelt werden. Das geschieht im Bereich inputs durch den Mappingstring 'cdkMenuTriggerFor: appMenuTriggerFor'. Analog könnte ein Bereich outputs hinzugefügt werden, mit dem ein entsprechendes Mapping für die Output-Bindings angelegt werden kann. Listing 8: Direktive mit weiterer, eingetragener Host-Direktive @Directive({ selector: '[appMenu]', standalone: true, hostDirectives: [ {\n'slidetext': ''\n'from': 'index'\n'score': 138.70687866210938\n'normalizedScore': 1.3870687866210938\n'beforeDatePenaltyScore': 1.3870687866210938\n\n'documentId': 'e9905bc3e1a3780619966899'\n'chunk_id': '687814d9bed6dcd41a99b09a'\n'access': 'granted'\n'part_number': 13\n'total_parts': 17\n'contentType': 'READ'\n'title': Jetzt schlägt’s 15: Was ist neu in Angular 15? - Alle neuen Features von Angular 15 im Blick\n'parentName': Java Magazin 2.2023\n'language': 'DE'\n'date': '2023-01-03T02:00:00.000Z'\n'abstract': Angular 15 wurde für den produktiven Einsatz freigegeben. In diesem Tutorial werfen wir einen genauen Blick auf die neuen Features und Verbesserungen des JavaScript-Frameworks und geben Hinweise zum Umgang mit inkompatiblen Änderungen in Angular 15.\n'parentId': '9b91af29eb210add4465b516'\n'parentDescription': Über neun Millionen Software-Entwickler weltweit sorgen dafür, dass die Java-Technologie in allen Geschäftsfeldern und in allen Branchen eine zentrale Rolle spielt. Zudem ist das Java-Ökosystem der wichtigste Takt- und Impulsgeber für die gesamte Software-Industrie, wenn es um technische Innovationen geht. Das Java Magazin begleitet seit über 20 Jahren alle wesentlichen Entwicklungen der Java-Welt aktuell, kritisch und mit großer praktischer Relevanz. Software-Architekten, Entwickler und Projektleiter vertrauen auf die anerkannte Kompetenz der Redaktion verbunden mit ihrem Experten-Netzwerk bekannter Fachautoren.\n'indexBrandName': ''\n'indexSeriesName': ''\n'author': 'Karsten Sitterberg'\n'chunkSource': 'text'\n'text': ECMAScript-Standard der Build-Output genau generiert wurde, konnte bisher in der tsconfig.json des Projekts im Feld target eingestellt werden. Mit Angular 15 wird das Target nun automatisch anhand der .browserlistrc ermittelt. Es kann allerdings sein, dass diese Datei nicht vorhanden ist, da sie ebenfalls seit Angular 15 im Standard nicht mehr mit ausgeliefert wird. Falls man also eigene Targets konfigurieren möchte, muss man diese Datei einfach von Hand anlegen. Die Datei .browserlistrc steht dabei exemplarisch für einige weitere Dateien, die mit Angular CLI in Version 15 nicht mehr direkt mitgeneriert werden. Die Motivation dafür ist, dass das Projekt-Set-up vor allem für Einsteiger:innen vereinfacht und auch übersichtlicher werden soll. Dabei hilft es natürlich, wenn neuen Entwickler:innen initial weniger Dateien zu erklären sind. Es ist perspektivisch geplant, dass einige der Dateien in einer Folgeversion durch die bekannten Schematics erzeugbar sein sollen. Die .browserlistrc, die test.ts und die karma.conf.ts nehmen dabei Sonderpositionen ein: Sie haben interne Standards hinterlegt und müssen nur noch nachträglich zum Projekt hinzugefügt werden, wenn eine vom Standard abweichende Konfiguration benötigt wird. Die polyfills.ts wurde entfernt, Polyfills können jetzt in der angular.json im Property polyfills direkt eingetragen werden (Listing 15). Listing 15: Vergleich alte und neue Polyfill-Konfiguration in der angular.json // Bisher wurde die polyfills.ts referenziert polyfills: `${sourceRoot}/polyfills.ts`, // Mit Angular 15 werden Polyfills direkt eingetragen polyfills: [ './zone-flags.ts', 'zone.js', './other-polyfills.ts' ] Auch die Environment-Dateien environment.ts und environment.prod.ts werden im Standard nicht mehr mit ausgeliefert. Falls Environments gebraucht werden, können sie allerdings wie gehabt angelegt werden. Denn lediglich die Dateien werden initial nicht mehr generiert, der Environment-Mechanismus inklusive File-Replacements bleibt aber weiterhin Teil des Angular CLI. Perspektivisch soll zum Generieren von Environments eine eigene Schematic angelegt werden. Wenn mit Angular CLI per Schematic bisher eine neue Komponente generiert wurde, wurden in die Komponente automatisch ein Konstruktor und die ngOnInit()-Methode generiert. Im Zuge der Vereinfachung des Projekt-Set-ups für Neueinsteiger:innen, und auch basierend auf einer Umfrage unter Angular-Entwickler:innen, wurde das Komponenten-Schematic nun so angepasst,\n'slidetext': ''\n'from': 'index'\n'score': 138.69960021972656\n'normalizedScore': 1.3869960021972656\n'beforeDatePenaltyScore': 1.3869960021972656\n\n'documentId': '5ecf87915aa99dfe10bb64dd'\n'chunk_id': '687814bfbed6dcd41a99affb'\n'access': 'granted'\n'part_number': 3\n'total_parts': 16\n'contentType': 'READ'\n'title': Is Angular 16 Starting a (R)evolution? - Breaking changes, features, and everything new in Angular 16\n'parentName': JavaScript Magazine Volume 8\n'language': 'EN'\n'date': '2023-03-08T23:00:00.000Z'\n'abstract': The newest version of Angular is here. Angular 16 introduces some new breaking changes and features and sets a new tone for the framework. This article dives into all of the changes and what developers need to know before migrating.\n'parentId': '4169b80642e03abd714cf6fe'\n'parentDescription': Broaden your knowledge and expand your JavaScript techniques and practices. From Angular, React, and WebAssembly, to the best JavaScript IDEs, open source tools and more, you’ll learn insights on everything JS from seasoned experts in their field. Keep up with JavaScript news, tips, and advice with interviews, tutorials, and in-depth articles.\n'indexBrandName': ''\n'indexSeriesName': ''\n'author': 'Karsten Sitterberg'\n'chunkSource': 'text'\n'text': allowed in this context! The “in” operator can be used in TypeScript for what is known as type narrowing. For example, in Listing 4, the “in” operator is used in the function “doItWithObjects()” to cause type-narrowing of the union type “Cow | Bird”: If the variable value contains the property “layEggs”, then TypeScript assumes “value” must be of the type “Bird” and allows the function call. However, until now it wasn’t possible to generate type information about unknown objects with the “in” operator. For example, in Listing 5, the function “tryGetDataContent()” is passed a data object with unknown types, or the “unknown” type. To make sure that this passing value is in fact an object that isn’t “null”, the two queries in the first statement are needed. With these type guards, TypeScript knows that “data” is an object. It needs further type-guards to enable access to properties. Previously, you could not use the “in” operator to access properties that weren’t listed by type definitions. Accessing “data.content” resulted in a compiler error, despite being protected by an “in” typeguard. Now, in version 4.9, TypeScript recognizes that this access is protected and is therefore allowed. Listing 4: Type narrowing through type guard interface Cow { giveMilk(): void; } interface Bird { layEggs(): void; } function doItWithObjects(value: Cow | Bird) { if ('layEggs' in value) { value.layEggs(); // value is of type 'Bird' } } Listing 5: Type narrowing for unknown types function tryGetDataContent(data: unknown): string | undefined { if (data && typeof data === 'object') { if ('content' in data && typeof data.content === 'string') { // ^ Previously: TypeError return data.content; } } return undefined; } Angular CLI Almost all Angular projects are set up and built with Angular CLI. Angular CLI provides an abstraction over the underlying build system. For example, in the past, the switch from SystemJS to Webpack could be hidden as an implementation detail. Currently, both Vite from the Vue environment and esbuild are being investigated as successors for Webpack. However, it is certainly still at least one release away until the actual switchover. There are also some innovations in Angular CLI 16, some of which concern the aforementioned experiments. Therefore, existing support for the esbuild-based build setup is extended with progress outputs. Furthermore, the esbuild DevServer can now use e.g. SSL. The inclusion is done as with the existing setup via “ng serve --ssl”. Additional scripts can be included in the build. This is handy when including global scripts like the Google Tag\n'slidetext': ''\n'from': 'index'\n'score': 138.68161010742188\n'normalizedScore': 1.3868161010742188\n'beforeDatePenaltyScore': 1.3868161010742188\n\n'documentId': '2e2495f42751c019986f5bc4'\n'chunk_id': '687ab74e2be886398c2ad134'\n'access': 'granted'\n'part_number': 9\n'total_parts': 9\n'contentType': 'READ'\n'title': Java 16: Das JDK auf dem Weg zur nächsten LTS-Version - Sweet 16\n'parentName': JAXenter 3.2021\n'language': 'DE'\n'date': '2021-03-01T16:58:00.000Z'\n'abstract': 14, 15 oder doch schon 16? Da kann man schon mal durcheinanderkommen. Durch die mittlerweile halbjährlichen Major-Releases von Java fällt es gar nicht so leicht, die aktuelle Version richtig zu benennen. Vor Kurzem hat man sich in einem Vortrag noch über die Neuerungen des JDK 14 informiert, und wenig später wurden in einem Artikel bereits die Features von Version 15 näher beleuchtet. Und da sich die Welt bekanntlich schnell weiterdreht, ist nun im März 2021 bereits das OpenJDK 16 herausgekommen.\n'parentId': 'f3f07cfbd5f6d489e27c1d11'\n'parentDescription': n/a\n'indexBrandName': ''\n'indexSeriesName': ''\n'author': 'Falk Sippach'\n'chunkSource': 'text'\n'text': uns Entwicklern die einfache Möglichkeit, regelmäßig neue Funktionen ausprobieren zu können. Potenziell kann man sogar sein Produktivsystem alle sechs Monate aktualisieren und vermeidet langwierige Migrationsaufwände, die sonst irgendwann anfallen würden. Konservative Kunden können aber trotzdem LTS-Versionen einsetzen, die wie frühere Releases (vor Java 8) über mehrere Jahre mit Updates versorgt werden. Dabei hat man mittlerweile die freie Wahl zwischen verschiedenen Anbietern. Neben kommerziellen Versionen (Oracle JDK und andere) gibt es auch genügend JDKs mit freien Updates (allen voran AdoptOpenJDK). Das Java-Ökosystem ist also lebendiger denn je und weiterhin sehr innovativ. Konkurrenz wie beispielsweise Python (hauptsächlich wegen Machine/Deep Learning), Go und die C-basierten Sprachen beleben das Geschäft. Java, das besonders im Unternehmensanwendungsumfeld vertreten ist, wird aber weiterhin ein gewichtiges Wort mitreden.\n'slidetext': ''\n'from': 'index'\n'score': 138.5290069580078\n'normalizedScore': 1.385290069580078\n'beforeDatePenaltyScore': 1.385290069580078\n\n'documentId': '2e2495f42751c019986f5bc4'\n'chunk_id': '687ab74e2be886398c2ad12c'\n'access': 'granted'\n'part_number': 6\n'total_parts': 9\n'contentType': 'READ'\n'title': Java 16: Das JDK auf dem Weg zur nächsten LTS-Version - Sweet 16\n'parentName': JAXenter 3.2021\n'language': 'DE'\n'date': '2021-03-01T16:58:00.000Z'\n'abstract': 14, 15 oder doch schon 16? Da kann man schon mal durcheinanderkommen. Durch die mittlerweile halbjährlichen Major-Releases von Java fällt es gar nicht so leicht, die aktuelle Version richtig zu benennen. Vor Kurzem hat man sich in einem Vortrag noch über die Neuerungen des JDK 14 informiert, und wenig später wurden in einem Artikel bereits die Features von Version 15 näher beleuchtet. Und da sich die Welt bekanntlich schnell weiterdreht, ist nun im März 2021 bereits das OpenJDK 16 herausgekommen.\n'parentId': 'f3f07cfbd5f6d489e27c1d11'\n'parentDescription': n/a\n'indexBrandName': ''\n'indexSeriesName': ''\n'author': 'Falk Sippach'\n'chunkSource': 'text'\n'text': zeigt. Listing 6 public sealed interface Expr permits ConstantExpr, PlusExpr, TimesExpr, NegExpr { ... } public record ConstantExpr(int i) implements Expr {...} public record PlusExpr(Expr a, Expr b) implements Expr {...} public record TimesExpr(Expr a, Expr b) implements Expr {...} public record NegExpr(Expr e) implements Expr {...} Eine Familie von Records kann vom gleichen Sealed Interface ableiten. Die Kombination aus Records und versiegelten Datentypen führt uns zu algebraischen Datentypen, die vor allem in funktionalen Sprachen wie Haskell zum Einsatz kommen. Konkret können wir jetzt mit Records Produkttypen und mit versiegelten Klassen Summentypen abbilden. Und auch hier schließt sich wieder der Kreis zum Pattern Matching, das ebenfalls vor allem in funktionalen Sprachen zum Einsatz kommt. Die Modernisierung von Java entwickelt sich also weiterhin in die vielversprechende Richtung der funktionalen Programmierung. Aber bitte nicht erwarten, dass Java in ein paar Jahren eine rein funktionale Sprache sein wird. Da wird es auch in Zukunft besser geeignete Kandidaten (Haskell, Clojure, …) geben. Nichtsdestotrotz wird man auch bei der Entwicklung mit Java von einigen dieser Möglichkeiten profitieren. Weitere interessante Neuerungen Bisher wurde die Quellen des OpenJDK in Mercurial verwaltet, einem nicht so verbreiteten Versionsverwaltungssystem. Dadurch war die Hürde für neue Entwickler relativ hoch, sich an der Entwicklung des JDK zu beteiligen. Im Rahmen des JEP 357 wurde der Sourcecode nun in ein Git-Repository migriert und sogar noch nach GitHub [3] umgezogen (JEP 369). Dabei gab es drei Hauptgründe für die Migration: 1. Größe der Metadaten des Versionsveraltungssystems 2. verfügbare Werkzeuge für die Versionsverwaltung 3. Angebote an Hostingoptionen Bei den Metadaten kam es immerhin zu einer Reduktion von 1,2 GByte auf 300 MByte im .git-Ordner. Zudem wird bei vielen Tools wie IDEs oder Texteditoren Git bereits standardmäßig unterstützt oder lässt sich leicht über Plug-ins nachrüsten. Git hat den Markt für verteilte Versionsverwaltungssysteme in den letzten Jahren nahezu überrollt. Der Schritt, die Quellen des OpenJDK nach GitHub umzuziehen, ist also nachvollziehbar. Um alle relevanten Informationen wie die Historie und Tags mit zu übertragen, wurde eigens ein kleines Tool geschrieben. Dieses hat\n'slidetext': ''\n'from': 'index'\n'score': 138.5290069580078\n'normalizedScore': 1.385290069580078\n'beforeDatePenaltyScore': 1.385290069580078\n\n'documentId': '2e2495f42751c019986f5bc4'\n'chunk_id': '687ab74d2be886398c2ad12a'\n'access': 'granted'\n'part_number': 5\n'total_parts': 9\n'contentType': 'READ'\n'title': Java 16: Das JDK auf dem Weg zur nächsten LTS-Version - Sweet 16\n'parentName': JAXenter 3.2021\n'language': 'DE'\n'date': '2021-03-01T16:58:00.000Z'\n'abstract': 14, 15 oder doch schon 16? Da kann man schon mal durcheinanderkommen. Durch die mittlerweile halbjährlichen Major-Releases von Java fällt es gar nicht so leicht, die aktuelle Version richtig zu benennen. Vor Kurzem hat man sich in einem Vortrag noch über die Neuerungen des JDK 14 informiert, und wenig später wurden in einem Artikel bereits die Features von Version 15 näher beleuchtet. Und da sich die Welt bekanntlich schnell weiterdreht, ist nun im März 2021 bereits das OpenJDK 16 herausgekommen.\n'parentId': 'f3f07cfbd5f6d489e27c1d11'\n'parentDescription': n/a\n'indexBrandName': ''\n'indexSeriesName': ''\n'author': 'Falk Sippach'\n'chunkSource': 'text'\n'text': entstanden und werden in folgenden JDK-Releases noch relevanter werden. Zudem könnte die kompakte Syntax Bibliotheken wie Lombok in Zukunft zumindest zum Teil obsolet machen. Die einfache Definition einer Person mit zwei Feldern kann man nachfolgend betrachten: public record Person(String name, Person partner ) {} Eine erweiterte Variante mit einem zusätzlichen Konstruktor ist erlaubt. Dadurch lassen sich neben Pflichtfeldern auch optionale Felder abbilden (Listing 3). Listing 3 public record Person(String name, Person partner ) { public Person(String name ) { this( name, null ); } public String getNameInUppercase() { return name.toUpperCase(); } } Erzeugt wird vom Compiler eine unveränderbare (immutable) Klasse, die neben den beiden Attributen und den eigenen Methoden natürlich auch noch die Implementierungen für die Accessoren, den Konstruktor sowie equals/hashCode und toString enthält. Im Listing 4 sieht man den Pseudocode, den man dafür hätte schreiben müssen. Listing 4 public final class Person extends Record { private final String name; private final Person partner; public Person(String name) { this(name, null); } public Person(String name, Person partner) { this.name = name; this.partner = partner; } public String getNameInUppercase() { return name.toUpperCase(); } public String toString() { /* ... */ } public final int hashCode() { /* ... */ } public final boolean equals(Object o) { /* ... */ } public String name() { return name; } public Person partner() { return partner; } } Verwendet werden Records dann wie normale Java-Klassen. Der Aufrufer merkt also gar nicht, dass ein spezieller Typ instanziiert wird (Listing 5). Listing 5 var man = new Person('Adam'); var woman = new Person('Eve', man); woman.toString(); // ==> 'Person[name=Eve, partner=Person[name=Adam, partner=null]]' woman.partner().name(); // ==> 'Adam' woman.getNameInUppercase(); // ==> 'EVE' // Deep equals new Person('Eve', new Person('Adam')).equals( woman ); // ==> true Records sind übrigens keine klassischen Java Beans, da sie keine echten Getter enthalten. Man kann auf die Membervariablen aber über die gleichnamigen Methoden zugreifen (name() statt getName()). Sie können im Übrigen auch Annotationen oder JavaDocs enthalten. Im Body dürfen zudem statische Felder sowie Methoden, Konstruktoren oder Instanzmethoden deklariert werden. Nicht erlaubt ist die Definition von weiteren Instanzfeldern außerhalb des record-Headers. Zwischen Sealed Classes und den record-Typen gibt es eine Integration, wie das Beispiel in Listing 6 zeigt.\n'slidetext': ''\n'from': 'index'\n'score': 138.5290069580078\n'normalizedScore': 1.385290069580078\n'beforeDatePenaltyScore': 1.385290069580078\n\n'documentId': 'e9905bc3e1a3780619966899'\n'chunk_id': '687814d8bed6dcd41a99b096'\n'access': 'granted'\n'part_number': 9\n'total_parts': 17\n'contentType': 'READ'\n'title': Jetzt schlägt’s 15: Was ist neu in Angular 15? - Alle neuen Features von Angular 15 im Blick\n'parentName': Java Magazin 2.2023\n'language': 'DE'\n'date': '2023-01-03T02:00:00.000Z'\n'abstract': Angular 15 wurde für den produktiven Einsatz freigegeben. In diesem Tutorial werfen wir einen genauen Blick auf die neuen Features und Verbesserungen des JavaScript-Frameworks und geben Hinweise zum Umgang mit inkompatiblen Änderungen in Angular 15.\n'parentId': '9b91af29eb210add4465b516'\n'parentDescription': Über neun Millionen Software-Entwickler weltweit sorgen dafür, dass die Java-Technologie in allen Geschäftsfeldern und in allen Branchen eine zentrale Rolle spielt. Zudem ist das Java-Ökosystem der wichtigste Takt- und Impulsgeber für die gesamte Software-Industrie, wenn es um technische Innovationen geht. Das Java Magazin begleitet seit über 20 Jahren alle wesentlichen Entwicklungen der Java-Welt aktuell, kritisch und mit großer praktischer Relevanz. Software-Architekten, Entwickler und Projektleiter vertrauen auf die anerkannte Kompetenz der Redaktion verbunden mit ihrem Experten-Netzwerk bekannter Fachautoren.\n'indexBrandName': ''\n'indexSeriesName': ''\n'author': 'Karsten Sitterberg'\n'chunkSource': 'text'\n'text': hinzugefügt werden, mit dem ein entsprechendes Mapping für die Output-Bindings angelegt werden kann. Listing 8: Direktive mit weiterer, eingetragener Host-Direktive @Directive({ selector: '[appMenu]', standalone: true, hostDirectives: [ { directive: CdkMenuTrigger, inputs: ['cdkMenuTriggerFor: appMenuTriggerFor'] } ] }) export class MenuDirective { @HostBinding('style.border') border = '3px dashed green' } Zusätzlich zur Logik der CDK-Direktive könnten im Prinzip auch weitere Hostdirektiven hinzugefügt oder eine eigene Direktivenlogik implementiert werden. In unserem Beispiel wird zum Beispiel noch ein 3 Pixel breiter, gestreifter grüner Rahmen um das Hostelement gezeichnet. Verwendet werden kann unsere appMenu-Direktive dann ganz genau so, wie wir es schon gewohnt sind. Das Beispiel zeigt Listing 9. Listing 9: Verwendung unserer MenuDirective Trigger   Eintrag 1 Eintrag 2   Je nachdem, wie gut die Standalone APIs in der Community angenommen werden, plant das Angular-Team bisherige APIs wie RouterModule.forRoot() und das HttpClientModule in einem der kommenden Angular-Releases als deprecated zu markieren und dann irgendwann komplett zu entfernen. Abhängigkeiten, iFrames und Routerkonfiguration Angular 15 bringt, wie eigentlich jedes Major-Release, wieder ein paar Breaking Changes mit sich. Das ist nun mal gerade das Konzept bei einem Major-Release. Vor allem wurden zunächst die Angular-eigenen Abhängigkeiten aktualisiert. Damit ist zum Übersetzen von Quellcode einer Angular-15-Anwendung nun Node.js in Version 14.20.x, 16.13.x, 18.10.x oder höher notwendig. Auch die benötigte TypeScript-Version wurde angepasst, sodass nun TypeScript mindestens in der Version 4.8 vorliegen muss. Auch bei der Verwendung von iFrames mit Angular gilt es Änderungen zu beachten: Bisher war es möglich, einige sicherheitsrelevante iFrame-Attribute mit Angular dynamisch zu binden. Diese Attribute beeinflussen allerdings das Verhalten des iFrame und müssen dafür statisch bei der iFrame-Erzeugung gesetzt werden. Zu den jetzt nur noch statisch zu belegenden Properties gehören z. B. allowfullscreen, csp und sandbox. Falls versucht wird, eines dieser Properties dynamisch zu setzen, wird ein Fehler ausgegeben, der auf die Komponente hinweist, in der das Property fälschlicherweise dynamisch gesetzt\n'slidetext': ''\n'from': 'index'\n'score': 138.3671417236328\n'normalizedScore': 1.383671417236328\n'beforeDatePenaltyScore': 1.383671417236328\n\n'documentId': 'e9905bc3e1a3780619966899'\n'chunk_id': '687814d8bed6dcd41a99b091'\n'access': 'granted'\n'part_number': 4\n'total_parts': 17\n'contentType': 'READ'\n'title': Jetzt schlägt’s 15: Was ist neu in Angular 15? - Alle neuen Features von Angular 15 im Blick\n'parentName': Java Magazin 2.2023\n'language': 'DE'\n'date': '2023-01-03T02:00:00.000Z'\n'abstract': Angular 15 wurde für den produktiven Einsatz freigegeben. In diesem Tutorial werfen wir einen genauen Blick auf die neuen Features und Verbesserungen des JavaScript-Frameworks und geben Hinweise zum Umgang mit inkompatiblen Änderungen in Angular 15.\n'parentId': '9b91af29eb210add4465b516'\n'parentDescription': Über neun Millionen Software-Entwickler weltweit sorgen dafür, dass die Java-Technologie in allen Geschäftsfeldern und in allen Branchen eine zentrale Rolle spielt. Zudem ist das Java-Ökosystem der wichtigste Takt- und Impulsgeber für die gesamte Software-Industrie, wenn es um technische Innovationen geht. Das Java Magazin begleitet seit über 20 Jahren alle wesentlichen Entwicklungen der Java-Welt aktuell, kritisch und mit großer praktischer Relevanz. Software-Architekten, Entwickler und Projektleiter vertrauen auf die anerkannte Kompetenz der Redaktion verbunden mit ihrem Experten-Netzwerk bekannter Fachautoren.\n'indexBrandName': ''\n'indexSeriesName': ''\n'author': 'Karsten Sitterberg'\n'chunkSource': 'text'\n'text': oder false zurückliefert, um das Matching entweder zu erlauben oder zu verhindern. Alternativ ist es auch möglich, direkt einen URLTree zurückzugeben, um einen Redirect auszulösen. Der CanMatch Guard kann ab Angular 15 auch – wie alle Guards – per ng generate guard generiert werden. Listing 3: CanMatch-Guard mit mehreren gleichen Routen { path: 'team', canMatch: [CanMatchAdminUser] loadChildren: () => import('./team') .then(mod => mod.TeamModule), }, { path: 'team', component: LimitedTeamComponent } ]) Zusammen mit dem neuen Guard ist es auch möglich, dass alle Guards als einfache Funktionen ausgelegt werden können. In Listing 4 ist beispielsweise der CanDeactivate Guard der 'editor'-Route als Funktion ausgelegt. Wenn man in einem solchen funktionalen Guard z. B. einen Service benötigt, so kann dieser mit Hilfe der seit Angular 14 produktiv einsetzbaren inject()-Funktion bereitgestellt (injectet) werden. Das ist in Listing 4 im CanActivate-Guard der 'demo'-Route zu sehen. Dort wird mittels der inject-Funktion ein AuthService bereitgestellt, dessen isLoggedIn()-Funktion dann aufgerufen wird, um zu entscheiden, ob die Navigation stattfinden darf oder nicht. Listing 4: Funktionen als Guards RouterModule.forRoot([ { path: 'editor', component: EditorComponent, canDeactivate: [(cmp: EditorComponent) => !cmp.hasUnsavedChanges] }, { path: 'demo', component: DemoComponent, canActivate: [() => inject(AuthService).isLoggedIn()] } ]) In Angular 14.2 wurde eine neue Direktive eingeführt, die zusammen mit dem Google-Aurora-Team entwickelt wurde: NgOptimizedImage. Der Hintergrund des Aurora-Projekts ist, dass das Team von Google Chrome durch direkte Zusammenarbeit oder Sponsoring bei Open-Source-Projekten erreichen möchte, dass diese Optimierungen implementieren, von denen Endnutzer:innen im Web profitieren. Dabei zielen die Optimierungen auf Verbesserungen von Core-Web-Vital-(CWV-)Werten der mit den Frameworks erstellten Anwendungen ab. So ist es auch bei der NgOptimizedImage-Direktive: Ziel ist es, Bilder automatisiert zu optimieren. Das kann sich durch Lazy Loading, Verwendung von CDN-Optimierungen oder auch automatischer Auswahl der richtigen Bildgröße äußern. Die Direktive ist dabei einfach zu verwenden: Statt  wird dann  eingesetzt. Anschließend werden Best Practices entweder, sofern möglich, automatisch umgesetzt oder es werden Warnungen ausgegeben: Um einen Layout-Shift zu\n'slidetext': ''\n'from': 'index'\n'score': 138.2882843017578\n'normalizedScore': 1.3828828430175781\n'beforeDatePenaltyScore': 1.3828828430175781\n\n'documentId': 'e9905bc3e1a3780619966899'\n'chunk_id': '687814d8bed6dcd41a99b094'\n'access': 'granted'\n'part_number': 7\n'total_parts': 17\n'contentType': 'READ'\n'title': Jetzt schlägt’s 15: Was ist neu in Angular 15? - Alle neuen Features von Angular 15 im Blick\n'parentName': Java Magazin 2.2023\n'language': 'DE'\n'date': '2023-01-03T02:00:00.000Z'\n'abstract': Angular 15 wurde für den produktiven Einsatz freigegeben. In diesem Tutorial werfen wir einen genauen Blick auf die neuen Features und Verbesserungen des JavaScript-Frameworks und geben Hinweise zum Umgang mit inkompatiblen Änderungen in Angular 15.\n'parentId': '9b91af29eb210add4465b516'\n'parentDescription': Über neun Millionen Software-Entwickler weltweit sorgen dafür, dass die Java-Technologie in allen Geschäftsfeldern und in allen Branchen eine zentrale Rolle spielt. Zudem ist das Java-Ökosystem der wichtigste Takt- und Impulsgeber für die gesamte Software-Industrie, wenn es um technische Innovationen geht. Das Java Magazin begleitet seit über 20 Jahren alle wesentlichen Entwicklungen der Java-Welt aktuell, kritisch und mit großer praktischer Relevanz. Software-Architekten, Entwickler und Projektleiter vertrauen auf die anerkannte Kompetenz der Redaktion verbunden mit ihrem Experten-Netzwerk bekannter Fachautoren.\n'indexBrandName': ''\n'indexSeriesName': ''\n'author': 'Karsten Sitterberg'\n'chunkSource': 'text'\n'text': Moduls die Providerfunktion provideHttpClient() verwendet werden. Dieser können dann weitere Konfigurationsfunktionen übergeben werden: Mit den Funktionen withXsrfConfiguration() und withNoXsrfProtection() kann zum Beispiel die eingebaute Unterstützung für Schutz vor XSRF (Cross-Site Request Forgery) konfiguriert werden, mit withJsonpSupport() kann der Support für JSONP-Requests aktiviert werden. Durch Hinzufügen der Funktion withInterceptorsFromDi() werden automatisch die herkömmlichen, per Dependency Injection konfigurierten HTTP-Interceptors in den neuen HttpClient eingebunden. In Listing 5 kann auf diese Weise zum Beispiel der LoggingInterceptor auch mit der neuen HttpClient-Syntax verwendet werden. Listing 5: Initialisierung des HttpClient mit Interceptors @NgModule({ //... providers: [ { provide: HTTP_INTERCEPTORS, useClass: LoggingInterceptor, multi: true }, provideHttpClient( withInterceptorsFromDi(), withInterceptors([authInterceptor]) ) ] }) export class AppModule {} Neue Variante für Interceptors Damit kommen wir auch schon zur nächsten Neuerung: Mit Angular 15 gibt es eine neue Variante, Interceptors zu schreiben und zu konfigurieren. Dazu sehen wir in Listing 5 die Funktion withInterceptors(), die allerdings keine klassischen Interceptor-Klassen erwartet, sondern funktionale Interceptors, wie hier den authInterceptor, der im folgenden Listing 6 dargestellt ist. Die neuen funktionalen Interceptors sind vom Typ HttpInterceptorFn und entsprechen in ihrem API den intercept()-Methoden der bisherigen Interceptors. Einziger Unterschied ist der Übergabeparameter next, der entsprechend des neuen API nun ein direkter Aufruf der nächsten HttpHandler-Funktion ist und nicht wie bisher ein Methodenaufruf auf dem nächsten HttpHandler-Objekt. Mit der in Angular 14 eingeführten inject()-Funktion kann auch aus den neuen, funktionalen Injectors auf Services zugegriffen werden. In Listing 6 wird so zum Beispiel der AuthService injiziert, um im Beispiel ein Token für den API-Zugriff zu laden. Listing 6: Funktionaler Auth-Interceptor export function authInterceptor(request: HttpRequest, next: HttpHandlerFn): Observable<httpevent> { const token = inject(AuthService).getAuthToken(); const newRequest = request.clone({ headers: request.headers.append('Authorization', 'Bearer ' + token) }); return next(newRequest); } Mit dem bisherigen HttpClient war es nur möglich, Interceptors beim Start der Anwendung zu konfigurieren. Sollte z. B. im Kontext eines lazy geladenen Modules ein neuer Interceptor hinzugefügt werden, so war das nicht möglich, ohne einen komplett eigenen HttpClient für dieses Modul zu erzeugen, der</httpevent\n'slidetext': ''\n'from': 'index'\n'score': 138.00274658203125\n'normalizedScore': 1.3800274658203124\n'beforeDatePenaltyScore': 1.3800274658203124\n\n'documentId': '5ecf87915aa99dfe10bb64dd'\n'chunk_id': '687814c0bed6dcd41a99b006'\n'access': 'granted'\n'part_number': 14\n'total_parts': 16\n'contentType': 'READ'\n'title': Is Angular 16 Starting a (R)evolution? - Breaking changes, features, and everything new in Angular 16\n'parentName': JavaScript Magazine Volume 8\n'language': 'EN'\n'date': '2023-03-08T23:00:00.000Z'\n'abstract': The newest version of Angular is here. Angular 16 introduces some new breaking changes and features and sets a new tone for the framework. This article dives into all of the changes and what developers need to know before migrating.\n'parentId': '4169b80642e03abd714cf6fe'\n'parentDescription': Broaden your knowledge and expand your JavaScript techniques and practices. From Angular, React, and WebAssembly, to the best JavaScript IDEs, open source tools and more, you’ll learn insights on everything JS from seasoned experts in their field. Keep up with JavaScript news, tips, and advice with interviews, tutorials, and in-depth articles.\n'indexBrandName': ''\n'indexSeriesName': ''\n'author': 'Karsten Sitterberg'\n'chunkSource': 'text'\n'text': 'app-signal-demo', standalone: true, template: ` \n\n Counter: {{counter()}} Increase ` }) export class SignalDemoComponent { protected counter = signal(0); increase(): void { this.counter.set(this.counter() + 1); //this.counter.update(counter => counter + 1); } } Listing 20: Using the Signals API with objects @Component({ selector: 'app-signal-object-demo', standalone: true, template: ` \n\n Total Invoice Sum: {{total()}} GetNewInvoice ` }) export class SignalObjectDemoComponent { protected invoice = signal({price: 1}); protected total = computed(() => this.invoice().price); getNewInvoice(): void { this.invoice.mutate(inv => inv.price = 42); } } Besides signals, there are also effects. They don’t have anything to do with the NgRx effects, but they have a similar idea. Effects are supposed to execute side effects too. But that's where the similarities end. In the context of signals, effects are similar to computed signals - functions that are executed when one or more signals used in the effect have changed. Effects use the 'inject()' function internally, so effects must also always be called in the constructor or injector context. Listing 21 shows an example of what the constructor of the component from Listing 20 can look like. In this case, the 'effect()' simply logs out any value change of the 'invoice' signal to the console. In effects, to avoid infinite loops, signals should only ever be read, never written. This is also checked by the Signal API and an error is thrown if necessary. Listing 21: Example of logging as signal effect constructor() { effect(() => { console.log(this.invoice()) }) } Signals should also be able to control change detection in components independently of Zone.js. This behavior is not yet part of Angular 16, but you should be able to activate it by including “signals: true” in the component metadata. In this case, the component inputs will also be expressed as signals instead of changeable objects. However, the syntax used to write “@Input”, “@Output”, and similar also changes. Then, all of these Angular components are no longer @decorators, but are now special signals functions. For example, inputs become 'input()' signals and outputs become “output()” signals. This fits well with the fact that standard TypeScript decorators don’t work for parameters, but only for types. Similarly, queries for 'viewChild/ren' and 'contentChild/ren' are then also provided as signals. In the lifecycle, the API also changes for signal components. With 'afterNextRender', a function is executed after the completion of the next DOM update cycle. This is similar to the previous 'ngAfterViewInit', but is called more often. With 'afterRender', the specified callback\n'slidetext': ''\n'from': 'index'\n'score': 138.00100708007812\n'normalizedScore': 1.3800100708007812\n'beforeDatePenaltyScore': 1.3800100708007812\n\n'documentId': '5ecf87915aa99dfe10bb64dd'\n'chunk_id': '687814c0bed6dcd41a99b005'\n'access': 'granted'\n'part_number': 13\n'total_parts': 16\n'contentType': 'READ'\n'title': Is Angular 16 Starting a (R)evolution? - Breaking changes, features, and everything new in Angular 16\n'parentName': JavaScript Magazine Volume 8\n'language': 'EN'\n'date': '2023-03-08T23:00:00.000Z'\n'abstract': The newest version of Angular is here. Angular 16 introduces some new breaking changes and features and sets a new tone for the framework. This article dives into all of the changes and what developers need to know before migrating.\n'parentId': '4169b80642e03abd714cf6fe'\n'parentDescription': Broaden your knowledge and expand your JavaScript techniques and practices. From Angular, React, and WebAssembly, to the best JavaScript IDEs, open source tools and more, you’ll learn insights on everything JS from seasoned experts in their field. Keep up with JavaScript news, tips, and advice with interviews, tutorials, and in-depth articles.\n'indexBrandName': ''\n'indexSeriesName': ''\n'author': 'Karsten Sitterberg'\n'chunkSource': 'text'\n'text': 19 shows with the signal counter that the type of a signal can also be defined by defining an initial value, in this case it is the number 0. The signal is read by calling it like a function. This is shown in the component’s template in Listing 19. Normally, no function should be used for output in templates for performance reasons. In fact, this is usually more of an anti-pattern. But with Signals, this is an explicit design decision by the Angular team and may actually help performance in the long run. The signal itself 'notices' when its internal state changes. In case of a change, a signal can give Angular fine-grained hints about which part of the application needs to be updated. This is an important element for performant applications. There are several methods to change a signal’s internal state. The value can be set to a concrete value by the method '.set()'. In our case, we want to increase the counter by one. When we call '.set()', we read the instantaneous value of the signal. Therefore, we can simply use the '.update()' method. This method passes the signal’s current value as a parameter into a callback function. The return value of this callback becomes the new value of the signal. If a signal contains complex data structures like objects or arrays, the '.mutate()' method can be used to change the object or array internally. In the 'getNewInvoice()' from Listing 19, this is used to change the invoice amount in the 'invoice' signal. This could also be done asynchronously after an HTTP call, for instance. The signals always get to know when the internal state object changes and can inform the application about this even for purely mutating changes and without the reference changing. Besides these standard signals, there are also computed signals. The 'computed()' function can create a computed signal. It is used in Listing 20 to compute the total price 'total' from the invoice. The special thing about Computed Signals is that the compute function is called every time a signal used in the function changes its value. In Listing 19, only the 'invoice' is accessed in the 'total' signal. So every time something changes in the 'invoice', the 'total' signal is also recomputed. Theoretically, a computed signal can depend on any number of other signals. The computed signal is recalculated every time one of the other signals changes value. Listing 19: Example of using the Signal API @Component({ selector: 'app-signal-demo', standalone: true, template: ` \n\n Counter: {{counter()}} Increase ` }) export class SignalDemoComponent { protected counter = signal(0); increase(): void { this.counter.set(this.counter() + 1); //this.counter.update(counter => counter\n'slidetext': ''\n'from': 'index'\n'score': 137.95838928222656\n'normalizedScore': 1.3795838928222657\n'beforeDatePenaltyScore': 1.3795838928222657\n\n'documentId': 'e9905bc3e1a3780619966899'\n'chunk_id': '687814d8bed6dcd41a99b092'\n'access': 'granted'\n'part_number': 5\n'total_parts': 17\n'contentType': 'READ'\n'title': Jetzt schlägt’s 15: Was ist neu in Angular 15? - Alle neuen Features von Angular 15 im Blick\n'parentName': Java Magazin 2.2023\n'language': 'DE'\n'date': '2023-01-03T02:00:00.000Z'\n'abstract': Angular 15 wurde für den produktiven Einsatz freigegeben. In diesem Tutorial werfen wir einen genauen Blick auf die neuen Features und Verbesserungen des JavaScript-Frameworks und geben Hinweise zum Umgang mit inkompatiblen Änderungen in Angular 15.\n'parentId': '9b91af29eb210add4465b516'\n'parentDescription': Über neun Millionen Software-Entwickler weltweit sorgen dafür, dass die Java-Technologie in allen Geschäftsfeldern und in allen Branchen eine zentrale Rolle spielt. Zudem ist das Java-Ökosystem der wichtigste Takt- und Impulsgeber für die gesamte Software-Industrie, wenn es um technische Innovationen geht. Das Java Magazin begleitet seit über 20 Jahren alle wesentlichen Entwicklungen der Java-Welt aktuell, kritisch und mit großer praktischer Relevanz. Software-Architekten, Entwickler und Projektleiter vertrauen auf die anerkannte Kompetenz der Redaktion verbunden mit ihrem Experten-Netzwerk bekannter Fachautoren.\n'indexBrandName': ''\n'indexSeriesName': ''\n'author': 'Karsten Sitterberg'\n'chunkSource': 'text'\n'text': einfach zu verwenden: Statt  wird dann  eingesetzt. Anschließend werden Best Practices entweder, sofern möglich, automatisch umgesetzt oder es werden Warnungen ausgegeben: Um einen Layout-Shift zu verhindern, sollten Bilder stets mit den jeweiligen Abmessungen ausgezeichnet werden. Fehlen width/heigth an einem NgOptimizedImage, so führt das zu einer Warnung. Das geschieht auch, wenn die Werte angegeben sind, aber nicht zum Seitenverhältnis des referenzierten Bildes passen und damit zu einer Deformation der Inhalte führen würden. Falls ein Bild mit priority ausgezeichnet ist, wird das fetchpriority Attribut am Bild auf high gesetzt. Das sorgt dafür, dass aktuelle Browser die so priorisierten Bilder als erstes laden. Andernfalls wird der Wert auto vergeben. Analog wird die loading-Property konfiguriert, sodass Browser, die das unterstützen, automatisch nur Bilder laden, die in die Nähe des sichtbaren Bereichs gelangen. Der Wert kann bei Bedarf auch explizit überschrieben werden. Im Development-Modus erkennt Angular auch Bilder, denen das priority Attribut fehlt, obwohl sie den Largest Contentful Paint (LCP) ausmachen. Entsprechend wird eine Warnung ausgegeben. Weiterhin kann die Direktive Bilder durch ImageLoader laden. Wird ein ImageLoader verwendet, werden die Bilder nicht aus dem normalen Assets-Ordner geladen, sondern z. B. von einem CDN, das ggf. die Bilder noch zusätzlich für verschiedene Auflösungen optimieren kann. Die Direktive unterstützt direkt Cloudflare, Cloudinary, ImageKit und Imgix, es lassen sich jedoch auch leicht eigene ImageLoader definieren: Im Prinzip handelt es sich dabei um URL Templating mit den angefragten Abmessungen des erforderlichen Bilds. Um dem Browser die Möglichkeit zu geben, die optimale Datei für die gerade benötigte Dimension des Bildes in einem Responsive-Kontext zu laden, können in einem ngSrcset-Attribut verschiedene Varianten mit den zugehörigen Abmessungen bzw. Auflösungen angegeben werden. Soll das Bild keine feste Größe haben, sondern responsive sein, so sollte das sizes-Attribut gesetzt werden. Damit wird die zu erwartende Größe des Bildes angegeben. Bei einem Bild, das etwa die Hälfte der Bildschirmbreite einnehmen soll, sollte sizes='50vw' gesetzt werden. Angular 15 Das Angular-Team legt für die Weiterentwicklung\n'slidetext': ''\n'from': 'index'\n'score': 137.81192016601562\n'normalizedScore': 1.3781192016601562\n'beforeDatePenaltyScore': 1.3781192016601562\n\n'documentId': 'e9905bc3e1a3780619966899'\n'chunk_id': '687814d9bed6dcd41a99b09e'\n'access': 'granted'\n'part_number': 17\n'total_parts': 17\n'contentType': 'READ'\n'title': Jetzt schlägt’s 15: Was ist neu in Angular 15? - Alle neuen Features von Angular 15 im Blick\n'parentName': Java Magazin 2.2023\n'language': 'DE'\n'date': '2023-01-03T02:00:00.000Z'\n'abstract': Angular 15 wurde für den produktiven Einsatz freigegeben. In diesem Tutorial werfen wir einen genauen Blick auf die neuen Features und Verbesserungen des JavaScript-Frameworks und geben Hinweise zum Umgang mit inkompatiblen Änderungen in Angular 15.\n'parentId': '9b91af29eb210add4465b516'\n'parentDescription': Über neun Millionen Software-Entwickler weltweit sorgen dafür, dass die Java-Technologie in allen Geschäftsfeldern und in allen Branchen eine zentrale Rolle spielt. Zudem ist das Java-Ökosystem der wichtigste Takt- und Impulsgeber für die gesamte Software-Industrie, wenn es um technische Innovationen geht. Das Java Magazin begleitet seit über 20 Jahren alle wesentlichen Entwicklungen der Java-Welt aktuell, kritisch und mit großer praktischer Relevanz. Software-Architekten, Entwickler und Projektleiter vertrauen auf die anerkannte Kompetenz der Redaktion verbunden mit ihrem Experten-Netzwerk bekannter Fachautoren.\n'indexBrandName': ''\n'indexSeriesName': ''\n'author': 'Karsten Sitterberg'\n'chunkSource': 'text'\n'text': wirkt ein wenig so, als ob Angular Gefahr liefe, dieses aufzugeben, um einen einfacheren Einstieg zu ermöglichen. Davon abgesehen ist es ein gutes Zeichen, dass Angular und das umgebende Ökosystem sich kontinuierlich wie umsichtig weiterentwickeln. Verbesserungen der Build-Zeiten erfahren dabei gerade in größeren Projekten eine höhere Wertschätzung. Den Einsatz des Modulsystems in eine optionale Angelegenheit zu überführen ist dagegen eher für Neueinsteiger eine hilfreiche Verbesserung. Indem das Angular-Team in der Weiterentwicklung bemüht ist, alle Belangen unterschiedlicher Nutzer:innen gerecht zu werden, zeigt sich, dass Angular sich auch zukünftig als vielseitiges Framework für verschiedenartige Anwendungen positionieren kann. Karsten Sitterberg ist als freiberuflicher Entwickler, Trainer und Berater für Webtechnologien und Java tätig. Seine Schwerpunkte liegen im Bereich HTTP APIs, TypeScript und Angular. Karsten ist Physiker (MSc) und Oracle zertifizierter Java Developer. Regelmäßig berichtet er in Vorträgen und Artikeln über aktuelle Trends und Hintergründe zu Themen die für Entwickler und Architekten gleichermaßen relevant sind. In Münster hat er die Frontend Freunde als Meetup-Serie und die Java User Group mitgegründet. Links & Literatur [1] https://hub.docker.com/r/trion/ng-cli/ [2] https://entwickler.de/javascript/grundkurs-angular-professionell-bauen-testen-und-ausliefern-mit-gitlab-ci-und-docker/ [3] https://material.angular.io/guide/mdc-migration\n'slidetext': ''\n'from': 'index'\n'score': 137.730224609375\n'normalizedScore': 1.37730224609375\n'beforeDatePenaltyScore': 1.37730224609375\n\n'documentId': 'e9905bc3e1a3780619966899'\n'chunk_id': '687814d8bed6dcd41a99b090'\n'access': 'granted'\n'part_number': 3\n'total_parts': 17\n'contentType': 'READ'\n'title': Jetzt schlägt’s 15: Was ist neu in Angular 15? - Alle neuen Features von Angular 15 im Blick\n'parentName': Java Magazin 2.2023\n'language': 'DE'\n'date': '2023-01-03T02:00:00.000Z'\n'abstract': Angular 15 wurde für den produktiven Einsatz freigegeben. In diesem Tutorial werfen wir einen genauen Blick auf die neuen Features und Verbesserungen des JavaScript-Frameworks und geben Hinweise zum Umgang mit inkompatiblen Änderungen in Angular 15.\n'parentId': '9b91af29eb210add4465b516'\n'parentDescription': Über neun Millionen Software-Entwickler weltweit sorgen dafür, dass die Java-Technologie in allen Geschäftsfeldern und in allen Branchen eine zentrale Rolle spielt. Zudem ist das Java-Ökosystem der wichtigste Takt- und Impulsgeber für die gesamte Software-Industrie, wenn es um technische Innovationen geht. Das Java Magazin begleitet seit über 20 Jahren alle wesentlichen Entwicklungen der Java-Welt aktuell, kritisch und mit großer praktischer Relevanz. Software-Architekten, Entwickler und Projektleiter vertrauen auf die anerkannte Kompetenz der Redaktion verbunden mit ihrem Experten-Netzwerk bekannter Fachautoren.\n'indexBrandName': ''\n'indexSeriesName': ''\n'author': 'Karsten Sitterberg'\n'chunkSource': 'text'\n'text': es aber auch weiterhin möglich, die Direktiven und Pipes gesammelt über das CommonModule zu importieren. Auch für das Angular-Webkomponentenpaket @angular/elements ist nun eine Developer-Preview für den Standalone-Support verfügbar. Da Web Components besonders klein sein sollten, ist ein Einsatz von Standalone Components hier natürlich besonders sinnvoll. Die Direktiven des Angular Router sind mittlerweile ebenfalls als Standalone markiert, sodass man beispielsweise den RouterLink als eigene Direktive unabhängig vom RouterModule importieren kann. Zusammen mit den Standalone APIs wurde beim Angular Router auch die Möglichkeit geschaffen, einzelne Standalone-Komponenten per loadComponent-Angabe lazy nachzuladen. Für diese Art des Lazy Loading funktioniert der alte CanLoad Guard nicht mehr wie gewünscht, da dieser auf das Lazy Loading von Modulen ausgelegt ist. Aus diesem Grund gibt es nun den CanMatch Route Guard. Der CanMatch Guard kann dabei auf alle Arten von Routen, egal ob lazy oder nicht, angewendet werden. Damit funktioniert der CanMatch Guard etwas anders als die bisher vorhandenen Guards wie CanLoad oder CanActivate. Diese sind im Routingprozess zwischengeschaltet: Sie werden ausgeführt, nachdem anhand der Routenkonfiguration entschieden wurde, welche Route aktiviert werden soll und bevor die Komponente dann wirklich aktiviert bzw. das Modul geladen wird. Der CanMatch Guard setzt hier früher an. Er kann verhindern, dass eine Route als „zu nutzen“ erkannt wird. Das Matching wird unterdrückt. Auf den Angular Router wirkt eine solche Route dann so, als ob sie gar nicht in der Konfiguration hinterlegt ist. Das kann dann beispielsweise genutzt werden, um mehrere Routen mit dem gleichen Path zu hinterlegen. In Listing 3 sind zum Beispiel zwei Routen mit dem Pfad 'team' hinterlegt. Wenn der CanMatchAdminUser Guard nun false zurückliefert, wird diese Route übersprungen und statt der loadChildren-Angabe wird einfach die Komponente LimitedTeamComponent aktiviert. Intern ist das API eines CanMatch Guard ähnlich wie das eines CanLoad oder auch eines CanActivate Guard: Es muss eine Funktion canMatch() implementiert werden, die entweder true oder false zurückliefert, um das Matching entweder zu erlauben oder zu verhindern. Alternativ ist es auch möglich, direkt einen URLTree zurückzugeben, um einen Redirect auszulösen. Der CanMatch Guard kann ab Angular\n'slidetext': ''\n'from': 'index'\n'score': 137.62864685058594\n'normalizedScore': 1.3762864685058593\n'beforeDatePenaltyScore': 1.3762864685058593\n\n'documentId': '5ecf87915aa99dfe10bb64dd'\n'chunk_id': '687814bebed6dcd41a99affa'\n'access': 'granted'\n'part_number': 2\n'total_parts': 16\n'contentType': 'READ'\n'title': Is Angular 16 Starting a (R)evolution? - Breaking changes, features, and everything new in Angular 16\n'parentName': JavaScript Magazine Volume 8\n'language': 'EN'\n'date': '2023-03-08T23:00:00.000Z'\n'abstract': The newest version of Angular is here. Angular 16 introduces some new breaking changes and features and sets a new tone for the framework. This article dives into all of the changes and what developers need to know before migrating.\n'parentId': '4169b80642e03abd714cf6fe'\n'parentDescription': Broaden your knowledge and expand your JavaScript techniques and practices. From Angular, React, and WebAssembly, to the best JavaScript IDEs, open source tools and more, you’ll learn insights on everything JS from seasoned experts in their field. Keep up with JavaScript news, tips, and advice with interviews, tutorials, and in-depth articles.\n'indexBrandName': ''\n'indexSeriesName': ''\n'author': 'Karsten Sitterberg'\n'chunkSource': 'text'\n'text': See Listing 1. Thanks to TypeScript’s structural type system, a simple object “oldCampaign” can be constructed that corresponds to this structure. See Listing 1. However, an error found its way into this object. The “enddate” property has a typo. The “D” in “date” should be capitalized. This error was only noticed during further usage, or, in case of doubt, at runtime. To avoid these kinds of errors, the type can be included in the variable definition. See Listing 2. But this means that contextual information about the specific types used will be lost. Direct access to, for example, the “getFullYear()” method of “Date” is no longer possible, since the “endDate” in “Campaign” could also be the type “string” or “number”. They do not have this method. The type specification by the interface overwrites, so to speak, the information that the “endDate” is a real Date object here. The “satisfies” operator in TypeScript 4.9 now allows us to check if “oldCampaign” complies with the type “Campaign” without overriding the specific context information. See Listing 3. Therefore, TypeScript still detects (typing) errors, but access to the “getFullYear()” method is allowed without further ado. It’s important to know when using the “satisfies” operator that the type-checking is exact. So the operator does not allow additional properties either. An additional property “description” would throw an error here, since this property doesn’t exist in the campaign. Listing 1: Incorrect object for the “Campaign” interface interface Campaign { title: string; startDate: Date | number | string; endDate: Date | number | string; } const oldCampaign = { title: 'That Millenium Campaign!' startDate: '2000-01-01' , enddate: new Date('2000-12-31') // ^--- Runtime bug ahoy! } Listing 2: Object with type declaration const oldCampaign: Campaign = { title: 'That Millenium Campaign!' startDate: '2000-01-01' , endDate: new Date('2000-12-31') // ^--- Typo would trigger TypeError } oldCampaign.endDate.getFullYear() // TypeError: endDate could be string/number Listing 3: Using the “satisfies” operator const oldCampaign = { title: 'That Millenium Campaign!' startDate: '2000-01-01' , enddate: new Date('2000-12-31') // ^--- Typing error triggers TypeError here too description: 'Demo-Campaing' // ^--- Additional properties are errors too! } satisfies Campaign oldCampaign.endDate.getFullYear() // Access allowed in this context! The “in” operator can be used in TypeScript for what is known as type narrowing. For example, in Listing 4, the “in” operator is used in the function “doItWithObjects()” to cause type-narrowing of the\n'slidetext': ''\n'from': 'index'\n'score': 136.02078247070312\n'normalizedScore': 1.3602078247070313\n'beforeDatePenaltyScore': 1.3602078247070313\n\n'documentId': '64ace3828d8056484c3534ab'\n'chunk_id': '687814c5bed6dcd41a99b022'\n'access': 'granted'\n'part_number': 10\n'total_parts': 21\n'contentType': 'READ'\n'title': Angular 16 released - Alles zu neuen Features und Breaking Changes\n'parentName': iJS Magazin Band 27\n'language': 'DE'\n'date': '2023-04-06T00:00:00.000Z'\n'abstract': Wir geben einen Überblick zu allen wichtigen Infos zum Release von Angular 16. Alles zu Signals, der Angular-CLI und TypeScript in Angular 16 erfahren Sie hier.\n'parentId': '5093fc7a779ccfe852d8fe7b'\n'parentDescription': Kaum ein Softwareprojekt, das nicht in wesentlichen Teilen auf der JavaScript-Technologie basiert. Eine breite Unterstützung sowie, leistungsfähige Programmiersprachen, die Vielzahl moderner Tools, sowie ausgereifte Frameworks wie Angular, React, Vue.js oder Node.js machen den JavaScript-Werkzeugkasten zu einem Alleskönner. Das iJS Magazin informiert aktuell und umfassend über die wichtige und innovative Entwicklungen im JavaScript-Universum und bietet handfeste Praxisinformationen für Softwareentwickler und -architekten.\n'indexBrandName': ''\n'indexSeriesName': ''\n'author': 'Karsten Sitterberg'\n'chunkSource': 'text'\n'text': Routen-Definition selbst geschehen, die Umwandlungsfunktionen stellt Angular zur Verfügung. In Listing 11 ist beispielhaft die Umwandlungsfunktion mapToCanActivate() dargestellt, mit der ein Array von klassenbasierten CanActivate-Guards in funktionale Guards transformiert werden kann. In Listing 11 ist auch dargestellt, dass klassenbasierte und funktionale Guards auch an der gleichen Route verwendet werden können, indem beide miteinander konkateniert werden. Listing 10: Klassenbasierter Guard und funktionaler Guard @Injectable({providedIn: 'root'}) export class DemoClassGuard { constructor(private authService: DemoAuthService) {} canActivate(route: ActivatedRouteSnapshot, state: RouterStateSnapshot): boolean | UrlTree { return this.auth.isLoggedIn(); } } export const demoFuncGuard: CanActivateFn = (route, state) => { const authService = inject(DemoAuthService) return authService.isLoggedIn(); }; Listing 11: Zukünftige Einbindung von Guards const routes: Routes = [ { path: 'demo', canActivate: mapToCanActivate([DemoClassGuard]) .concat(demoFuncGuard), component: DemoComponent } ]; Dem Router wurde in Version 16 noch ein weiteres und sehr angenehmes Feature hinzugefügt, das viel Boilerplate auf einfache Art und Weise überflüssig machen kann. Denn es ist nun möglich, Daten aus dem Routing-Vorgang direkt an Komponenten-Inputs zu binden. Dabei können Daten sowohl dynamisch per Resolver geladene Daten, als auch Daten aus den Query-Parameter an die Komponente gebunden werden. Um dies zu veranschaulichen, ist in Listing 12 eine Komponente gezeigt, die mit der Routen-Konfiguration aus Listing 13 eingebunden ist. In dieser Routen-Konfiguration ist für die Route demo zum einen ein statisches Datenobjekt mit dem Property demoData hinterlegt, zum anderen ein Resolver-Objekt mit Property demoResolved hinterlegt. Der Resolver ist hier zwar synchron, könnte aber genauso ein asynchrones Observable oder Promise zurückliefern, da dies vom Router aufgelöst würde. Dabei ist es hier explizit kein Zufall, dass die Properties in der Routen-Definition genau gleich heißen, wie die @Input-Properties in der Komponente. Das ist tatsächlich eine Voraussetzung dafür, dass die entsprechenden Eigenschaften aufeinander abgebildet werden können. Das Feature kann aktiviert werden, indem beim Aufruf von provideRouter() die Funktion _withComponentInputBinding()- mitgegeben wird, siehe unten in Listing 13. Falls noch nicht die neue Syntax zum Erzeugen des Routers verwendet wird, sondern das RouterModule, kann im RouterModule.forRoot() das Flag\n'slidetext': ''\n'from': 'index'\n'score': 130.16064453125\n'normalizedScore': 1.3016064453125\n'beforeDatePenaltyScore': 1.3016064453125\n\n'documentId': '64ace3828d8056484c3534ab'\n'chunk_id': '687814c5bed6dcd41a99b025'\n'access': 'granted'\n'part_number': 13\n'total_parts': 21\n'contentType': 'READ'\n'title': Angular 16 released - Alles zu neuen Features und Breaking Changes\n'parentName': iJS Magazin Band 27\n'language': 'DE'\n'date': '2023-04-06T00:00:00.000Z'\n'abstract': Wir geben einen Überblick zu allen wichtigen Infos zum Release von Angular 16. Alles zu Signals, der Angular-CLI und TypeScript in Angular 16 erfahren Sie hier.\n'parentId': '5093fc7a779ccfe852d8fe7b'\n'parentDescription': Kaum ein Softwareprojekt, das nicht in wesentlichen Teilen auf der JavaScript-Technologie basiert. Eine breite Unterstützung sowie, leistungsfähige Programmiersprachen, die Vielzahl moderner Tools, sowie ausgereifte Frameworks wie Angular, React, Vue.js oder Node.js machen den JavaScript-Werkzeugkasten zu einem Alleskönner. Das iJS Magazin informiert aktuell und umfassend über die wichtige und innovative Entwicklungen im JavaScript-Universum und bietet handfeste Praxisinformationen für Softwareentwickler und -architekten.\n'indexBrandName': ''\n'indexSeriesName': ''\n'author': 'Karsten Sitterberg'\n'chunkSource': 'text'\n'text': Falls für die Styles eine CSP-Policy style-src 'self' oder gar 'strict-dynamic' verwendet wird, hat dies die Konsequenz, dass die Komponenten-Styles in Angular-Anwendungen nicht funktioniert haben. Das liegt daran, dass der Browser bei einer solchen Einstellung keine Inline-Styles erlaubt hat, die Angular für die Komponenten-Styles nutzt. In einem solchen Fall musste dann die CSP-Direktive unsafe-inline aktiviert werden, die jedoch als potentiell unsicher gilt. Mit Angular 16 ist es nun möglich, das Injection-Token CSP_NONCE zu nutzen, um einen sogenannten CSP-Nonce zu setzen, der dann von Angular an die Inline-Styles angefügt wird. Falls die index.html zur Produktionszeit durch den ausliefernden Server noch modifiziert werden kann, so kann statt des Injection-Tokens einfach das Attribut ngCspNonce auf dem App-Element gesetzt werden, siehe Listing 17. Es ist dabei explizit wichtig, dass der Wert von XYZ nicht irgendein fixer Wert ist, sondern jedesmal, wenn die index.html ausgeliefert wird, neu berechnet werden muss. Ein fixer Nonce hätte ähnliche Security-Eigenschaften wie die CSP-Direktive unsafe-inline. Zusammen mit dem Nonce-Property in der index.html muss der Nonce auch in die CSP-Direktive aufgenommen werden, z.B. auf diese Art: style-src 'nonce-XYZ' 'self' oder etwas strikter style-src 'nonce-XYZ' 'strict-dynamic'. Dieses Feature wurde in Zusammenarbeit zwischen dem Angular-Core-, dem Angular-Material- und dem Angular-CLI-Team entwickelt, sodass auch diese Pakete den neuen Mechanismus entsprechend unterstützen. Listing 17: Dynamische Konfiguration des CSP-Nonce-Wertes in der index.html  Als weiteres kleines Feature ist die DestroyRef hinzugekommen. Diese kann wie ein Service injected werden und erlaubt es, Logik per Callback zu registrieren, die beim OnDestroy der Komponente ausgeführt wird. Beispielsweise können auf diese Art und Weise Ressourcen freigegeben werden, ohne den ngOnDestroy()-Lifecycle-Hook implementieren zu müssen, siehe auch Listing 18. Um die Destroy-Logik wieder zu entfernen, z.B. weil eine Ressource bereits aus anderem Grund wieder freigegeben wurde, kann die unregisterFn() aufgerufen werden. Dann würde in diesem Beispiel doSomethingOnDestroy() nicht mehr aufgerufen. Neben der DestroyRef wurde noch ein neues Paket @angular/rxjs-interop eingeführt, das vor allem mit\n'slidetext': ''\n'from': 'index'\n'score': 128.195068359375\n'normalizedScore': 1.28195068359375\n'beforeDatePenaltyScore': 1.28195068359375\n\n'documentId': '64ace3828d8056484c3534ab'\n'chunk_id': '687814c4bed6dcd41a99b01e'\n'access': 'granted'\n'part_number': 6\n'total_parts': 21\n'contentType': 'READ'\n'title': Angular 16 released - Alles zu neuen Features und Breaking Changes\n'parentName': iJS Magazin Band 27\n'language': 'DE'\n'date': '2023-04-06T00:00:00.000Z'\n'abstract': Wir geben einen Überblick zu allen wichtigen Infos zum Release von Angular 16. Alles zu Signals, der Angular-CLI und TypeScript in Angular 16 erfahren Sie hier.\n'parentId': '5093fc7a779ccfe852d8fe7b'\n'parentDescription': Kaum ein Softwareprojekt, das nicht in wesentlichen Teilen auf der JavaScript-Technologie basiert. Eine breite Unterstützung sowie, leistungsfähige Programmiersprachen, die Vielzahl moderner Tools, sowie ausgereifte Frameworks wie Angular, React, Vue.js oder Node.js machen den JavaScript-Werkzeugkasten zu einem Alleskönner. Das iJS Magazin informiert aktuell und umfassend über die wichtige und innovative Entwicklungen im JavaScript-Universum und bietet handfeste Praxisinformationen für Softwareentwickler und -architekten.\n'indexBrandName': ''\n'indexSeriesName': ''\n'author': 'Karsten Sitterberg'\n'chunkSource': 'text'\n'text': dadurch in der Regel keine negativen Auswirkungen entstehen, sollte dieser Modus definitiv aktiviert werden. Mit dieser Änderung ist die Transition von der alten View-Engine endgültig abgeschlossen. Durch den so wegfallenden Code sollten die Anwendungs-Bundles letztlich nochmal kleiner werden können. Listing 6: Partieller Library-Compile-Modus { // ... 'angularCompilerOptions': { 'compilationMode': 'partial' } } Mit Angular 15 wurde der Router um den CanMatch-Guard erweitert. Dieser Guard erlaubt es, einzelne Routen aus der Angular-Routen-Konfiguration für das Matching zu sperren, das bei jedem Routing-Vorgang stattfindet. Damit setzt der Guard früher im Routing-Prozess an als die alten CanLoad- und CanActivate-Guards. Das macht den Guard deutlich flexibler. Aus diesem Grund wird im Angular-CLI die Schematic für den CanLoad-Guard entfernt. Stattdessen ist der neue CanMatch-Guard zu verwenden. Im Routing-Prozess ermöglichen es Resolver, parallel zu einem Routing-Vorgang Daten zu laden. Sie können in der Routen-Konfiguration ähnlich eingebunden werden wie die Guards und werden im Routing-Vorgang nach den Guards ausgeführt. Die bisher klassenbasierten Resolver und Guards werden nun standardmäßig als funktionale Resolver bzw. Guards generiert. Dies entspricht dem neuen Standard, den wir uns unten im Angular-Teil noch etwas genauer widmen werden. Das alte Verhalten der Angular Schematics steht bis auf weiteres noch zur Verfügung, dazu ist als zusätzlicher Schalter --no-functional anzugeben. Die klassenbasierte Implementierung ist als deprecated markiert, insofern sollten Entwickler:innen sich bereits jetzt mit dem Thema beschäftigen und ggf. umstellen. Weiterhin wurden verschiedene Konfigurations-Parameter der angular.json entfernt, nachdem diese in vorherigen Versionen bereits deprecated wurden. Dies betrifft defaultProject, mit dem im Angular-CLI-Workspace das “Standardprojekt” konfiguriert werden konnte. 'Default' hat in diesem Fall bedeutet, dass die CLI-Befehle (ng serve, ng test, …) im Standard für das Default-Projekt ausgeführt wurden, wenn dem nicht explizit ein anderer Projektname mitgegeben wurde. Dieses Verhalten ist aber mittlerweile nicht mehr Teil des Angular-CLI, stattdessen wird seit einigen Versionen einfach das Projekt als “Standard” gesetzt, in dessen Unterordner der jeweilige Befehl ausgeführt wird. Auch die defaultCollection zur Einstellung der Collection, die beim Ausführen von\n'slidetext': ''\n'from': 'index'\n'score': 128.18927001953125\n'normalizedScore': 1.2818927001953124\n'beforeDatePenaltyScore': 1.2818927001953124\n\n'documentId': '64ace3828d8056484c3534ab'\n'chunk_id': '687814c4bed6dcd41a99b01d'\n'access': 'granted'\n'part_number': 5\n'total_parts': 21\n'contentType': 'READ'\n'title': Angular 16 released - Alles zu neuen Features und Breaking Changes\n'parentName': iJS Magazin Band 27\n'language': 'DE'\n'date': '2023-04-06T00:00:00.000Z'\n'abstract': Wir geben einen Überblick zu allen wichtigen Infos zum Release von Angular 16. Alles zu Signals, der Angular-CLI und TypeScript in Angular 16 erfahren Sie hier.\n'parentId': '5093fc7a779ccfe852d8fe7b'\n'parentDescription': Kaum ein Softwareprojekt, das nicht in wesentlichen Teilen auf der JavaScript-Technologie basiert. Eine breite Unterstützung sowie, leistungsfähige Programmiersprachen, die Vielzahl moderner Tools, sowie ausgereifte Frameworks wie Angular, React, Vue.js oder Node.js machen den JavaScript-Werkzeugkasten zu einem Alleskönner. Das iJS Magazin informiert aktuell und umfassend über die wichtige und innovative Entwicklungen im JavaScript-Universum und bietet handfeste Praxisinformationen für Softwareentwickler und -architekten.\n'indexBrandName': ''\n'indexSeriesName': ''\n'author': 'Karsten Sitterberg'\n'chunkSource': 'text'\n'text': erweitert. Außerdem kann der esbuild-DevServer nun z.B. SSL nutzen. Die Einbindung erfolgt, wie mit dem bestehenden Setup, per ng serve --ssl. Weiterhin können auch zusätzliche Scripte in den Build einbezogen werden. Das ist zum Beispiel bei der Einbindung von globalen Scripten wie dem Google Tag Manager praktisch. Auch für das bestehende Buildsystem wurden einige Erweiterungen vorgenommen: So können neue Anwendungen als Standalone-Anwendungen (also ohne @NgModules) generiert werden. Dazu wird bei der Generierung der Anwendung das Flag --standalone mitgegeben. Um die Funktionalität von Standalone-Anwendungen an die Funktionalität von bisherigen Angular-Anwendungen anzugleichen, ist es nun auch möglich, Service-Worker und App-Shells für Standalone-Anwendungen per Schematics zu generieren. Breaking Changes in Angular-CLI 16 Mit der neuen Major-Version des Angular-CLI gibt es natürlich auch einige Breaking Changes: So wurde der Support für TypeScript 4.8 und Node.js 14 entfernt. Stattdessen wird als Standard TypeScript 5 verwendet, Node.js sollte in Version 16, 18 oder neuer vorliegen. Auch in Angular-CLI 16 werden einige veraltete oder überhole Zöpfe abgeschnitten: So wird der Angular-Compatibility-Compiler NGCC mit Angular-CLI 16 entfernt. NGCC war dafür zuständig, alte, noch auf der View-Engine beruhende Libraries so zu transformieren, dass diese kompatibel mit dem neuen Ivy-Compiler werden. Da die View-Engine schon seit Angular 12 deprecated ist, geht das Angular-Team davon aus, dass alle wesentlichen Libraries bereits entsprechend so angepasst sind, dass sie Ivy-kompatibel zur Verfügung gestellt werden. Das bedeutet, dass Projekte, die noch Libraries verwenden, die lediglich für die View-Engine gebaut sind, nicht auf Angular 16 umstellen können, solange die Libraries nicht angepasst wurden. Handelt es sich dabei um transitive Abhängigkeiten, ist einem dieses potentielle Problem unter Umständen gar nicht bewusst. Um eine Library für Ivy kompatibel zu machen, sollte die jeweilige Library auf eine aktuellere Angular-Version umgestellt werden (mindestens 12) und in der tsconfig.lib.prod.json der Compiler-Modus auf partial gestellt werden, siehe Listing 6. Da dadurch in der Regel keine negativen Auswirkungen entstehen, sollte dieser Modus definitiv aktiviert werden. Mit dieser Änderung ist die Transition von der alten View-Engine endgültig abgeschlossen. Durch den so wegfallenden Code\n'slidetext': ''\n'from': 'index'\n'score': 128.09193420410156\n'normalizedScore': 1.2809193420410157\n'beforeDatePenaltyScore': 1.2809193420410157\n\n'documentId': '64ace3828d8056484c3534ab'\n'chunk_id': '687814c4bed6dcd41a99b01c'\n'access': 'granted'\n'part_number': 4\n'total_parts': 21\n'contentType': 'READ'\n'title': Angular 16 released - Alles zu neuen Features und Breaking Changes\n'parentName': iJS Magazin Band 27\n'language': 'DE'\n'date': '2023-04-06T00:00:00.000Z'\n'abstract': Wir geben einen Überblick zu allen wichtigen Infos zum Release von Angular 16. Alles zu Signals, der Angular-CLI und TypeScript in Angular 16 erfahren Sie hier.\n'parentId': '5093fc7a779ccfe852d8fe7b'\n'parentDescription': Kaum ein Softwareprojekt, das nicht in wesentlichen Teilen auf der JavaScript-Technologie basiert. Eine breite Unterstützung sowie, leistungsfähige Programmiersprachen, die Vielzahl moderner Tools, sowie ausgereifte Frameworks wie Angular, React, Vue.js oder Node.js machen den JavaScript-Werkzeugkasten zu einem Alleskönner. Das iJS Magazin informiert aktuell und umfassend über die wichtige und innovative Entwicklungen im JavaScript-Universum und bietet handfeste Praxisinformationen für Softwareentwickler und -architekten.\n'indexBrandName': ''\n'indexSeriesName': ''\n'author': 'Karsten Sitterberg'\n'chunkSource': 'text'\n'text': erkennt TypeScript, dass ein solcher Zugriff abgesichert und damit erlaubt ist. Listing 4: Type-Narrowing durch Type-Guard interface Cow { giveMilk(): void; } interface Bird { layEggs(): void; } function doItWithObjects(value: Cow | Bird) { if ('layEggs' in value) { value.layEggs(); // value is vom Typ 'Bird' } } Listing 5: Type-Narrowing bei unbekannten Typen function tryGetDataContent(data: unknown): string | undefined { if (data && typeof data === 'object') { if ('content' in data && typeof data.content === 'string') { // ^ Bisher: TypeError return data.content; } } return undefined; } Mehr zum Thema Angular © gdainti/Shutterstock.com Change Detection performanter und leichtgewichtiger mit Signals Sarah Drasner, die als Director of Engineering bei Googleu. a. auch dem Angular-Team vorsteht, hat auf Twitter von einer Angular-Renaissance gesprochen. Das trifft es ziemlich gut, denn in den letzten Releases gab es tatsächlich einige Neuerungen, die Angular äußert attraktiv machen. Die wohl wichtigsten sind Standalone Components und Standalone APIs. Angulars neues Standalone API Die neuen Standalone Components ermöglichen Angular-Entwicklung ohne Ng-Modules. Wir zeigen, was das für eine bestehende Architektur heißt. Die neuesten Innovationen im Angular-Umfeld In den letzten Monaten hat Angular einige neue Features erhalten, die es ermöglichen, das Framework auf eine frische und leichtgewichtige Weise zu verwenden. Dieser Artikel zeigt, wie diese Neuerungen dazu beitragen, unsere Lösungen wartbarer zu gestalten. Angular-CLI Fast alle Angular-Projekte werden mit Angular-CLI aufgesetzt und gebaut. Angular-CLI bietet dabei eine Abstraktion über das zugrundeliegende Buildsystem. So konnte in der Vergangenheit zum Beispiel die Umstellung von SystemJS auf Webpack als Implementierungsdetail verborgen werden. Aktuell werden als Nachfolger von Webpack sowohl Vite aus dem Vue-Umfeld als auch esbuild untersucht. Bis zur tatsächlichen Umstellung ist es aber sicherlich noch mindestens ein Release hin. Doch auch in Angular-CLI 16 gibt es einige Neuerungen, einige davon betreffen auch die bereits angesprochenen Experimente. So wird der bestehende Support für das esbuild-basierte Build-Setup um Progress-Ausgaben erweitert. Außerdem kann der esbuild-DevServer nun z.B. SSL nutzen. Die Einbindung erfolgt, wie mit dem bestehenden Setup, per ng serve --ssl. Weiterhin können auch zusätzliche Scripte in den Build einbezogen werden. Das\n'slidetext': ''\n'from': 'index'\n'score': 127.52802276611328\n'normalizedScore': 1.2752802276611328\n'beforeDatePenaltyScore': 1.2752802276611328\n\n'documentId': '64ace3828d8056484c3534ab'\n'chunk_id': '687814c4bed6dcd41a99b019'\n'access': 'granted'\n'part_number': 1\n'total_parts': 21\n'contentType': 'READ'\n'title': Angular 16 released - Alles zu neuen Features und Breaking Changes\n'parentName': iJS Magazin Band 27\n'language': 'DE'\n'date': '2023-04-06T00:00:00.000Z'\n'abstract': Wir geben einen Überblick zu allen wichtigen Infos zum Release von Angular 16. Alles zu Signals, der Angular-CLI und TypeScript in Angular 16 erfahren Sie hier.\n'parentId': '5093fc7a779ccfe852d8fe7b'\n'parentDescription': Kaum ein Softwareprojekt, das nicht in wesentlichen Teilen auf der JavaScript-Technologie basiert. Eine breite Unterstützung sowie, leistungsfähige Programmiersprachen, die Vielzahl moderner Tools, sowie ausgereifte Frameworks wie Angular, React, Vue.js oder Node.js machen den JavaScript-Werkzeugkasten zu einem Alleskönner. Das iJS Magazin informiert aktuell und umfassend über die wichtige und innovative Entwicklungen im JavaScript-Universum und bietet handfeste Praxisinformationen für Softwareentwickler und -architekten.\n'indexBrandName': ''\n'indexSeriesName': ''\n'author': 'Karsten Sitterberg'\n'chunkSource': 'text'\n'text': Angular 16 released Alles zu neuen Features und Breaking Changes Wir geben einen Überblick zu allen wichtigen Infos zum Release von Angular 16. Alles zu Signals, der Angular-CLI und TypeScript in Angular 16 erfahren Sie hier. Angular 16 setzt in vielerlei Hinsicht neue Akzente. Das wird nicht jedem gefallen. Ob das Angular-Team - und dahinter Google - hier kluge Entscheidungen trifft, wird vermutlich erst die Zeit zeigen. Um sich selbst ein Bild zu machen, betrachten wir alle wichtigen Änderungen zu TypeScript in Angular, die Angular-CLI und besonders Signals von Angular 16 im folgenden Beitrag. Angular hat besonders da einen guten Ruf, wo es um langlebige Anwendungen geht, bei denen Investitutionsschutz ein sehr wichtiges Kriterium ist. Selbst bei sehr kritischen Umbaumaßnahmen, wie der Umstellung der Renderingengine auf Ivy hat das Angular-Team stets extrem gutes Fingerspitzengefühl bewiesen. Durch kontinuierliche Verbesserungen von ng-upgrade und gutes Engineering bedeuteten notwendige Migrationen für Entwickler immer weniger Aufwand. Zumal viele der Änderungen im Laufe mehrerer Versionen schrittweise umgesetzt wurden und oft sogar die API-Oberfläche für typische Anwendungen stabil gehalten werden konnte. TypeScript und Angular 16 Angular legt auch mit diesem Release ein Augenmerk darauf, seine eigenen Abhängigkeiten aktuell zu halten. So muss mit Angular 16 TypeScript in Version 4.9 oder 5.0 vorliegen. Daher schauen wir uns die wichtigsten Neuerungen in TypeScript 4.9 hier zunächst an. Die weiteren Neuerungen von TypeScript 5 können in folgenden Artikel nachgelesen werden: TypeScript 5: Neuerungen und Breaking Changes. Auch mit TypeScript 4.9 kamen einige Neuerungen: So gibt es etwa Verbesserungen bei der Build-Performance oder beim File-Watching durch den Dev-Server. Außerdem wurde ein “Auto-Accessor”-Keyword eingeführt (Verwendungsbeispiel: public accessor name: string;), das automatisch sowohl einen set- als auch einen get-Accessor für das Property name erzeugt. Es wurde auch ein Compiler-Hinweis eingefügt, der einen Fehler ausgibt, sobald ein Vergleich mit NaN ausgeführt wird, da diese Vergleiche eigentlich immer ein Fehler sind (NaN !== x ist immer true, selbst wenn x=NaN, während NaN === x immer false zurück liefert). Stattdessen sollte die Funktion Number.isNaN(someValue) verwendet werden. Es wurde auch ein\n'slidetext': ''\n'from': 'index'\n'score': 127.39582061767578\n'normalizedScore': 1.2739582061767578\n'beforeDatePenaltyScore': 1.2739582061767578\n\n'documentId': '64ace3828d8056484c3534ab'\n'chunk_id': '687814c5bed6dcd41a99b021'\n'access': 'granted'\n'part_number': 9\n'total_parts': 21\n'contentType': 'READ'\n'title': Angular 16 released - Alles zu neuen Features und Breaking Changes\n'parentName': iJS Magazin Band 27\n'language': 'DE'\n'date': '2023-04-06T00:00:00.000Z'\n'abstract': Wir geben einen Überblick zu allen wichtigen Infos zum Release von Angular 16. Alles zu Signals, der Angular-CLI und TypeScript in Angular 16 erfahren Sie hier.\n'parentId': '5093fc7a779ccfe852d8fe7b'\n'parentDescription': Kaum ein Softwareprojekt, das nicht in wesentlichen Teilen auf der JavaScript-Technologie basiert. Eine breite Unterstützung sowie, leistungsfähige Programmiersprachen, die Vielzahl moderner Tools, sowie ausgereifte Frameworks wie Angular, React, Vue.js oder Node.js machen den JavaScript-Werkzeugkasten zu einem Alleskönner. Das iJS Magazin informiert aktuell und umfassend über die wichtige und innovative Entwicklungen im JavaScript-Universum und bietet handfeste Praxisinformationen für Softwareentwickler und -architekten.\n'indexBrandName': ''\n'indexSeriesName': ''\n'author': 'Karsten Sitterberg'\n'chunkSource': 'text'\n'text': ablösen sollen. Angular nutzt die TypeScript Decorators, um damit Metainformationen, unter anderem für das Dependency-Injection-System, bereitzustellen. Die Informationen können für Klassen, aber auch Methodenparameter oder den Konstruktor hinterlegt werden. Die finalen Decorators werden jedoch nur an Typen unterstützt, damit können @Component, @Directive, @Pipe, @Injectable und @NgModule mit dem neuen Standard umgesetzt werden. Konstruktor-Parameter-Decorators, wie z.B. @Inject(), @Host(), @Optional() und dergleichen, die zur Konfiguration der Dependency-Injection genutzt werden können, sind mit der neuen Spezifikation noch nicht möglich. Da es noch nicht sicher ist, ob Parameter-Decorators in die ECMAScript- und TypeScript-Spezifikation aufgenommen werden, nutzt Angular im Standard weiterhin die experimentalDecorators. Wenn sowohl die TypeScript 5-Decorators als auch die DI-Konfigurationen genutzt werden sollen, so muss die mit Angular 14 eingeführte inject()-Funktion genutzt werden, beispielhaft in Listing 9 dargestellt. Listing 9: inject()-Funktion mit Flags @Component({}) class DemoComponent { readonly demoService = inject(DemoService, { optional: true, host: true }); } Wie bereits oben erwähnt, sind die Router-Guard- und -Resolver-Interfaces deprecated. Daher werden alle Referenzen auf diese Interfaces beim Upgrade auf Angular 16 durch eine automatische Migration gelöscht. Der Guard als solches kann aber zunächst weiter wie gewohnt verwendet werden, da TypeScript nun die Signatur der Guard-Funktion selbst prüft. Beispielhaft wird in Listing 10 ein CanActivate-Guard gezeigt. Dessen canActivate()-Methode muss mit dem Typen CanActivateFn übereinstimmen, damit der Guard als ein CanActivate-Guard verwendet werden kann. In Listing 10 ist außerdem auch gezeigt, wie ein funktionaler CanActivate-Guard im Prinzip aussieht. Hier ist zu beachten, dass es auch in funktionalen Guards möglich ist, Services zu injecten. Dazu wird aber die inject()-Funktion verwendet werden müssen, siehe ebenfalls Listing 10. In Zukunft sollen Guards nur noch funktional geschrieben werden, allerdings bleibt es auch möglich, Guards und Resolver klassenbasiert zu schreiben. Dann muss allerdings in zukünftigen Versionen von Angular dieser Guard umgewandelt werden. Diese Umwandlung kann in der Routen-Definition selbst geschehen, die Umwandlungsfunktionen stellt Angular zur Verfügung. In Listing 11 ist beispielhaft die Umwandlungsfunktion mapToCanActivate() dargestellt, mit der ein Array von klassenbasierten CanActivate-Guards in funktionale\n'slidetext': ''\n'from': 'index'\n'score': 127.15082550048828\n'normalizedScore': 1.2715082550048828\n'beforeDatePenaltyScore': 1.2715082550048828\n\n'documentId': '64ace3828d8056484c3534ab'\n'chunk_id': '687814c5bed6dcd41a99b027'\n'access': 'granted'\n'part_number': 15\n'total_parts': 21\n'contentType': 'READ'\n'title': Angular 16 released - Alles zu neuen Features und Breaking Changes\n'parentName': iJS Magazin Band 27\n'language': 'DE'\n'date': '2023-04-06T00:00:00.000Z'\n'abstract': Wir geben einen Überblick zu allen wichtigen Infos zum Release von Angular 16. Alles zu Signals, der Angular-CLI und TypeScript in Angular 16 erfahren Sie hier.\n'parentId': '5093fc7a779ccfe852d8fe7b'\n'parentDescription': Kaum ein Softwareprojekt, das nicht in wesentlichen Teilen auf der JavaScript-Technologie basiert. Eine breite Unterstützung sowie, leistungsfähige Programmiersprachen, die Vielzahl moderner Tools, sowie ausgereifte Frameworks wie Angular, React, Vue.js oder Node.js machen den JavaScript-Werkzeugkasten zu einem Alleskönner. Das iJS Magazin informiert aktuell und umfassend über die wichtige und innovative Entwicklungen im JavaScript-Universum und bietet handfeste Praxisinformationen für Softwareentwickler und -architekten.\n'indexBrandName': ''\n'indexSeriesName': ''\n'author': 'Karsten Sitterberg'\n'chunkSource': 'text'\n'text': die technische, aber auch die konzeptionelle Komplexität reduziert werden. Gleichzeitig hat das Thema auch etwas Beigeschmack: Die offiziellen Diskussionen wurden erst ca. drei Wochen vor Verabschiedung des ersten Release-Candidate von Angular 16 öffentlich gestartet. Bei einer Entwicklungszeit von sechs Monaten und den potenziell immensen Konsequenzen einer solchen Designänderung wirkt das schon sehr kurzfristig. Kritische Kommentare in den RFC Diskussionen wurden zudem sehr diplomatisch abgetan, es wirkt, als sei sowieso alles intern durch das Angular-Team und Google entschieden worden. Assoziationen mit Paris 2016 sind dabei nicht ganz unbegründet. So ein Vorgehen stellt ein ernstzunehmendes Risiko für die Angular-Community dar. Ob Angular damit wirklich konzeptionell simpler wird, solange der mitgelieferte HttpClient RxJS verwendet, darf auch bezweifelt werden. Schließlich kommen Entwickler so zwangsläufig mit beiden Konzepten in Kontakt. Aber vielleicht wird ja auch drei Wochen vor dem ersten Release Candidate von Angular 17 der HttpClient mit demselben Argument abgekündigt. Auch wenn es sich also um vielversprechende Visionen und fast schon eine neue Generation Angular handelt - etwas mehr Fingerspitzengefühl und Transparenz wären hier wünschenswert. Technisch handelt es sich bei den Signals um eine Reactivity-Engine, mit der Änderungen am Zustand von speziellen Daten-Objekten zu Updates der zugehörigen DOM-Elemente führen. Anders als Promises und RxJS-Observable sind Aktionen auf “Signals” stets synchron. Da Webanwendungen inhärent durch Events getrieben sind, passt RxJS prinzipiell sehr gut. Daher gibt es zur Transformation zwischen Signals und Observables das neue Paket @angular/rxjs-interop, das Transformations-APIs wie ‘toObservable()’ und ‘toSignal()’ zur Verfügung stellt. Ein Signal kann einfach erzeugt werden, indem die neue Funktion signal() aufgerufen wird. Der Typ-Parameter T steht dabei für den Datentypen, der von diesem Signal “verwaltet” werden soll. In Listing 19 ist anhand des Signal counter zu sehen, dass der Typ eines Signal auch durch Definition eines Initialwertes, hier die Zahl 0, festlegen kann. Ausgelesen wird das Signal dann, indem es wie eine Funktion aufgerufen wird. Das ist beispielsweise im Template der Komponente aus Listing 19 gezeigt. Normalerweise sollte bei Ausgaben in Templates\n'slidetext': ''\n'from': 'index'\n'score': 126.57209777832031\n'normalizedScore': 1.265720977783203\n'beforeDatePenaltyScore': 1.265720977783203\n\n'documentId': '64ace3828d8056484c3534ab'\n'chunk_id': '687814c6bed6dcd41a99b02b'\n'access': 'granted'\n'part_number': 19\n'total_parts': 21\n'contentType': 'READ'\n'title': Angular 16 released - Alles zu neuen Features und Breaking Changes\n'parentName': iJS Magazin Band 27\n'language': 'DE'\n'date': '2023-04-06T00:00:00.000Z'\n'abstract': Wir geben einen Überblick zu allen wichtigen Infos zum Release von Angular 16. Alles zu Signals, der Angular-CLI und TypeScript in Angular 16 erfahren Sie hier.\n'parentId': '5093fc7a779ccfe852d8fe7b'\n'parentDescription': Kaum ein Softwareprojekt, das nicht in wesentlichen Teilen auf der JavaScript-Technologie basiert. Eine breite Unterstützung sowie, leistungsfähige Programmiersprachen, die Vielzahl moderner Tools, sowie ausgereifte Frameworks wie Angular, React, Vue.js oder Node.js machen den JavaScript-Werkzeugkasten zu einem Alleskönner. Das iJS Magazin informiert aktuell und umfassend über die wichtige und innovative Entwicklungen im JavaScript-Universum und bietet handfeste Praxisinformationen für Softwareentwickler und -architekten.\n'indexBrandName': ''\n'indexSeriesName': ''\n'author': 'Karsten Sitterberg'\n'chunkSource': 'text'\n'text': sich die Auswirkungen für den Großteil der Nutzer sicherlich im Rahmen. So haben sich die Versionsanforderungen der verwendeten Werkzeuge und Frameworks geändert. Zunächst wird als TypeScript-Version mindestens 4.9 verlangt. Node.js muss mindestens in Version 16 vorliegen, denn Node.js 14 hat als End-of-Life Datum den 30.3.2023. Zone.js in Versionen unter 0.12 wird nicht mehr unterstützt. Der ReflectiveInjector als altes und bereits als deprecated markiertes Konstrukt ist entfallen. Bei Bedarf kann als Ersatz Injector.create verwendet werden. Bereits mit Angular 14 war das BrowserTransferStateModule leer, es entfällt in diesem Release. Die TransferState-Klasse kann ohne das Modul direkt injiziert werden. Im BrowserModule ist die Methode withServerTransition als deprecated markiert worden. Diese wurde im Falle von SSR genutzt, um der App eine App-ID zu setzen. Um nun eine App-ID zu vergeben, kann das Injection-Token APP_ID verwendet werden. Wenn mehrere Angular-Anwendungen auf derselben Seite platziert werden, ist es nötig, die APP-ID pro Anwendung auf einen individuellen Wert zu setzen. Falls nur eine App verwendet wird, kann auf die Konfiguration der APP-ID verzichtet werden. Im Router wurden alle Referenzen auf den ComponentFactoryResolver entfernt, der früher u.a. für das Lazy-Loading zuständig war. Seit Angular 13 wird der ComponentFactoryResolver dafür jedoch nicht mehr benötigt und ist generell als 'Deprecated' markiert. Neben dem Einsatz im Router konnte man mit dem ComponentFactoryResolver auch manuell Komponenten erzeugen. Um Komponenten heute manuell zu erzeugen, reicht jedoch einfach eine Referenz auf die Komponenten-Klasse. Diese kann dann zusammen mit einer ViewContainerRef genutzt werden, um eine Komponente per viewContainerRef.createComponent() zu erzeugen. Vor allem in Kombination mit Standalone-Komponenten ist es so auch einfach möglich, Komponenten unabhängig vom Router lazy nachzuladen. Fazit Dem Angular-Framework ist anzusehen, dass es einem enormen Wettbewerb ausgesetzt ist. React und zunehmend Vue sind bei Einsteigern beliebt. Sicherlich nicht zuletzt, weil die gefühlte Lernkurve flacher ist und inzwischen das Ökosystem auch bei den anderen Frameworks immens umfangreich ist. Auf der anderen Seite stehen neue Entwicklungen, wie Qwik, das von Ex-Angular Entwicklern mitgegründet wurde. Was die wirklichen Gründe hinter allen\n'slidetext': ''\n'from': 'index'\n'score': 126.52411651611328\n'normalizedScore': 1.2652411651611328\n'beforeDatePenaltyScore': 1.2652411651611328\n\n'documentId': '64ace3828d8056484c3534ab'\n'chunk_id': '687814c5bed6dcd41a99b026'\n'access': 'granted'\n'part_number': 14\n'total_parts': 21\n'contentType': 'READ'\n'title': Angular 16 released - Alles zu neuen Features und Breaking Changes\n'parentName': iJS Magazin Band 27\n'language': 'DE'\n'date': '2023-04-06T00:00:00.000Z'\n'abstract': Wir geben einen Überblick zu allen wichtigen Infos zum Release von Angular 16. Alles zu Signals, der Angular-CLI und TypeScript in Angular 16 erfahren Sie hier.\n'parentId': '5093fc7a779ccfe852d8fe7b'\n'parentDescription': Kaum ein Softwareprojekt, das nicht in wesentlichen Teilen auf der JavaScript-Technologie basiert. Eine breite Unterstützung sowie, leistungsfähige Programmiersprachen, die Vielzahl moderner Tools, sowie ausgereifte Frameworks wie Angular, React, Vue.js oder Node.js machen den JavaScript-Werkzeugkasten zu einem Alleskönner. Das iJS Magazin informiert aktuell und umfassend über die wichtige und innovative Entwicklungen im JavaScript-Universum und bietet handfeste Praxisinformationen für Softwareentwickler und -architekten.\n'indexBrandName': ''\n'indexSeriesName': ''\n'author': 'Karsten Sitterberg'\n'chunkSource': 'text'\n'text': kann die unregisterFn() aufgerufen werden. Dann würde in diesem Beispiel doSomethingOnDestroy() nicht mehr aufgerufen. Neben der DestroyRef wurde noch ein neues Paket @angular/rxjs-interop eingeführt, das vor allem mit den neuen Signals verwendet wird. Zusätzlich bietet dieses Paket aber auch noch die Funktion takeUntilDestroyed() an. Diese Funktion ist ein Pipeable rxjs-Operator und kann verwendet werden, um Observables zu beenden, sobald die zugehörige Komponente destroyed wurde. Unter der Haube verwendet dieser neue Operator eine DestroyRef. In Listing 18 wird gezeigt, wie man den Operator nutzen kann, um ein Intervall-Observable zu beenden, sobald die Komponente abgeräumt wird. In diesem Fall wird dem takeUntilDestroyed-Operator explizit eine DestroyRef mitgegeben. Dieser Schritt kann allerdings auch weggelassen werden, dann besorgt sich der Operator die DestroyRef selbst per inject()-Funktion. Das hätte dann hier aber zur Folge, dass der Operator - oder das ganze Observable - im Konstruktor erzeugt werden muss, da der inject()-Mechanismus den Konstruktor-Kontext benötigt. Listing 18: Beispiel zur Verwendung der DestroyRef constructor(private destroyRef: DestroyRef) { const unregisterFn = destroyRef.onDestroy(() => doSomethingOnDestroy() ); // unregisterFn(); // Nimmt onDestroy-Logik zurück } ngOnInit(): void { interval(1000) .pipe(takeUntilDestroyed(this.destroyRef)) .subscribe(val => console.log('value:', val)) } Signals in Angular 16 - Hört die Signale… In Angular 16 hält ein neues und gleichzeitig so wegweisendes Konzept Einzug, das dem eine eigene Überschrift zu widmen ist. Die Rede ist von den “Signals”, einem Konzept, das sicherlich nicht zuletzt von Vue inspiriert wurde. Langfristiges Ziel ist es dabei, ohne “Zone.js” auszukommen und die Change-Detection mit anderen Mitteln abbilden zu können. Das ist sicherlich wichtig, um Standalone-Anwendungen zu verschlanken und vielleicht sogar die Möglichkeiten zu eröffnen, einzelne Elemente mit Angular umzusetzen, vergleichbar mit React und Vue. Als Motivation wurde angegeben, dass Angular-Anwendungen auf diese Weise einfacher werden, da die Verwendung von RxJS nicht mehr zwingend nötig ist. Damit soll die technische, aber auch die konzeptionelle Komplexität reduziert werden. Gleichzeitig hat das Thema auch etwas Beigeschmack: Die offiziellen Diskussionen wurden erst ca. drei Wochen vor Verabschiedung des ersten Release-Candidate\n'slidetext': ''\n'from': 'index'\n'score': 126.3797607421875\n'normalizedScore': 1.263797607421875\n'beforeDatePenaltyScore': 1.263797607421875\n\n'documentId': '64ace3828d8056484c3534ab'\n'chunk_id': '687814c6bed6dcd41a99b02d'\n'access': 'granted'\n'part_number': 21\n'total_parts': 21\n'contentType': 'READ'\n'title': Angular 16 released - Alles zu neuen Features und Breaking Changes\n'parentName': iJS Magazin Band 27\n'language': 'DE'\n'date': '2023-04-06T00:00:00.000Z'\n'abstract': Wir geben einen Überblick zu allen wichtigen Infos zum Release von Angular 16. Alles zu Signals, der Angular-CLI und TypeScript in Angular 16 erfahren Sie hier.\n'parentId': '5093fc7a779ccfe852d8fe7b'\n'parentDescription': Kaum ein Softwareprojekt, das nicht in wesentlichen Teilen auf der JavaScript-Technologie basiert. Eine breite Unterstützung sowie, leistungsfähige Programmiersprachen, die Vielzahl moderner Tools, sowie ausgereifte Frameworks wie Angular, React, Vue.js oder Node.js machen den JavaScript-Werkzeugkasten zu einem Alleskönner. Das iJS Magazin informiert aktuell und umfassend über die wichtige und innovative Entwicklungen im JavaScript-Universum und bietet handfeste Praxisinformationen für Softwareentwickler und -architekten.\n'indexBrandName': ''\n'indexSeriesName': ''\n'author': 'Karsten Sitterberg'\n'chunkSource': 'text'\n'text': Davon abgesehen wirken die großen Schritte in Richtung Signal-API und Zone.js als optionale Implementierung der Change Detection zukunftsweisend, fast schon wie die heimliche Vision einer neuen Generation Angular. Dasselbe gilt auch für das Modulsystem, das als optionales Mittel eingesetzt werden kann, große Anwendungen gut zu strukturieren und damit wartbar zu halten, ohne für Einsteiger oder bei kleinen Anwendungen ungerechtfertigte Komplexität zu erzwingen. Entwickler:innen sollten hier unbedingt am Ball bleiben - und auch die Zukunft Angulars aktiv mitgestalten. Angular-Tutorial und mehr Für Angular-Entwickler:innen und alle die es werden wollen, empfehlen wir unsere sechsteilige Tutorialserie Angular für Einsteiger:innen. Weitere Artikel, Serien und Kolumnen zu Angular finden Sie in unserer Übersicht zu Angular.\n'slidetext': ''\n'from': 'index'\n'score': 126.07147216796875\n'normalizedScore': 1.2607147216796875\n'beforeDatePenaltyScore': 1.2607147216796875\n\n'documentId': '64ace3828d8056484c3534ab'\n'chunk_id': '687814c6bed6dcd41a99b02c'\n'access': 'granted'\n'part_number': 20\n'total_parts': 21\n'contentType': 'READ'\n'title': Angular 16 released - Alles zu neuen Features und Breaking Changes\n'parentName': iJS Magazin Band 27\n'language': 'DE'\n'date': '2023-04-06T00:00:00.000Z'\n'abstract': Wir geben einen Überblick zu allen wichtigen Infos zum Release von Angular 16. Alles zu Signals, der Angular-CLI und TypeScript in Angular 16 erfahren Sie hier.\n'parentId': '5093fc7a779ccfe852d8fe7b'\n'parentDescription': Kaum ein Softwareprojekt, das nicht in wesentlichen Teilen auf der JavaScript-Technologie basiert. Eine breite Unterstützung sowie, leistungsfähige Programmiersprachen, die Vielzahl moderner Tools, sowie ausgereifte Frameworks wie Angular, React, Vue.js oder Node.js machen den JavaScript-Werkzeugkasten zu einem Alleskönner. Das iJS Magazin informiert aktuell und umfassend über die wichtige und innovative Entwicklungen im JavaScript-Universum und bietet handfeste Praxisinformationen für Softwareentwickler und -architekten.\n'indexBrandName': ''\n'indexSeriesName': ''\n'author': 'Karsten Sitterberg'\n'chunkSource': 'text'\n'text': das Ökosystem auch bei den anderen Frameworks immens umfangreich ist. Auf der anderen Seite stehen neue Entwicklungen, wie Qwik, das von Ex-Angular Entwicklern mitgegründet wurde. Was die wirklichen Gründe hinter allen Entscheidungen sind, kann man nur spekulieren. Da die Bi-Weekly-Notes September 2022 eingestellt wurden, scheint die Motivation für Transparenz auch nicht mehr auf dem höchsten Stand zu sein. Ehrlicherweise muss man jedoch auch sagen, dass der Informationsgehalt zunehmend verschwindend gering wurde. Doch auch die RFC-Diskussionen wirken ein wenig wie diplomatisches Taktieren: Weniger als drei Wochen vor dem ersten Release Candidate von Angular 16 wurden die RFC-Diskussionen zur Signal-API erst gestartet, Kritik wurde “aufmerksam beobachtet”. (https://github.com/angular/angular/discussions/49989) Vorher gab es entsprechende interne Diskussionen um Design, allerdings stellt sich dann die Frage, wieso dies nicht transparent umgesetzt wurde. Es erscheint insgesamt so, dass Angular sich dem politischen Druck von aufstrebenden Frameworks ausgesetzt sieht. Aus ähnlichem Grund ist auch eine Investition in Server-side Rendering erkennbar. Sicherlich auch, um bei den Google-Lighthouse-Metriken gut dazustehen. Auf der anderen Seite möchte man neue Nutzer gewinnen und den Einstieg leichter machen. Angular glänzte bisher als Fullstack-Framework für absehbar komplexe und große Anwendungen mit hervorragender Wartbarkeit. Es bleibt zu hoffen, dass nicht gerade diese Kerngruppe von Enterprise-Entwickler:innen durch massiven Aufwand bei Migrationen auf neuere Angular Versionen so vor den Kopf gestoßen wird, dass auch diese sich überlegen, neue Projekte nicht mehr mit Angular umzusetzen. Was Migrationen auf neue Versionen angeht, müssen Aufwand und Nutzen im richtigen Verhältnis stehen. Ein Blick auf Dinge wie IPv6, Python 3 und die vielen Firmen, die noch Java 11, oder sogar darunter einsetzen, zeigt noch einmal, wie hervorragend Angular in der Vergangenheit da stand. Es bleibt zu hoffen, dass Angular den Blick auch auf diese Zielgruppe gerichtet hält und den Fokus nicht verliert. Davon abgesehen wirken die großen Schritte in Richtung Signal-API und Zone.js als optionale Implementierung der Change Detection zukunftsweisend, fast schon wie die heimliche Vision einer neuen Generation Angular. Dasselbe gilt auch für das\n'slidetext': ''\n'from': 'index'\n'score': 125.98657989501953\n'normalizedScore': 1.2598657989501953\n'beforeDatePenaltyScore': 1.2598657989501953\n\n'documentId': 'bb97d9e8205e4d23e8d34081'\n'chunk_id': '687814d2bed6dcd41a99b06b'\n'access': 'granted'\n'part_number': 9\n'total_parts': 13\n'contentType': 'READ'\n'title': Angular 15: New Features and Breaking Changes - Angular strongly focuses on standalone components\n'parentName': JavaScript Magazine Volume 7\n'language': 'EN'\n'date': '2022-11-04T02:00:00.000Z'\n'abstract': Angular 15 is here! In this tutorial, we take a closer look at the new features and enhancements for the JavaScript framework and provide guidance on dealing with incompatible changes in Angular 15.\n'parentId': '1c6fbd6381a62df9f43c9b0b'\n'parentDescription': Broaden your knowledge and expand your JavaScript techniques and practices. From Angular, React, and WebAssembly, to the best JavaScript IDEs, open source tools and more, you’ll learn insights on everything JS from seasoned experts in their field. Keep up with JavaScript news, tips, and advice with interviews, tutorials, and in-depth articles.\n'indexBrandName': ''\n'indexSeriesName': ''\n'author': 'Karsten Sitterberg'\n'chunkSource': 'text'\n'text': was a transition period afterwards, where you could switch back and forth between the old view engine and Ivy. There was the compiler flag “enableIvy” for this. But since the old view engine no longer exists, this flag has now been removed. To remove old APIs that are no longer recommended for subsequent Angular versions, Angular 15 also includes some deprecations. For example, it was previously possible to bind services to a module by assigning that module to the “providedIn” option of an “@Injectable” decorator. An example of this can be seen in Listing 11. This should make the services treeshakeable, but still bind them tightly to a module. Since this variant was hardly used—and sometimes incorrectly too—this feature is now deprecated. Instead, the service should now either be marked as “providedIn: 'root'” or defined as a provider in the corresponding module. In addition to the module variant, the “providedIn: 'any'” syntax was also deprecated, since the any option was essentially only used internally in the framework and was also misleading. Listing 11: Assigning modules to providedIn is now deprecated. @Injectable({ providedIn: MyModule }) export class MyService {} For the date pipe, the Angular team combined a new feature with a deprecation. Previously, there was the injection token “DATE_PIPE_DEFAULT_TIMEZONE”, which could be used to set the date pipe’s time zone to a default value app-wide. This token is now deprecated and you should use the “DATE_PIPE_DEFAULT_OPTIONS” token instead. This can be used to set the default date format app-wide, or module-wide, as well as the default time zone. Listing 12 shows how to use the new token to configure the format “'shortDate'” as the default value for formatting date values and the time zone “-0200”, corresponding to Azores’ time zone. Listing 12: Set defaults for the DatePipe providers: [ { provide: DATE_PIPE_DEFAULT_OPTIONS, useValue: { dateFormat: 'shortDate', timezone: '-0200' } } ] In Angular, navigation operations in the app are started with the router’s help. There is both imperative routing by calling the router from the TypeScript code, and declarative routing from Angular templates. For the latter, the “[routerLink]” directive can be used. Previously, these were technically two different directives. For HTML anchor elements, there was the “RouterLinkWithHref” directive, which can also be seen in Listing 13, while all other elements used the RouterLink directive. To avoid code duplication, these directives have now been unified and “RouterLinkWithHref” is just an alias for the actual RouterLink. Therefore, the “RouterLink” can now simply be used for anchor elements too. This only has an effect\n'slidetext': ''\n'from': 'index'\n'score': 125.91600036621094\n'normalizedScore': 1.2591600036621093\n'beforeDatePenaltyScore': 1.2591600036621093\n\n'documentId': 'a980d2604065cad105b1bfaa'\n'chunk_id': '687abc062be886398c2b0218'\n'access': 'granted'\n'part_number': 1\n'total_parts': 9\n'contentType': 'READ'\n'title': Sweet 16 - Java auf dem Weg zur nächsten LTS-Version\n'parentName': Java Magazin 5.2021\n'language': 'DE'\n'date': '2021-04-07T00:00:00.000Z'\n'abstract': 14, 15 oder doch schon 16? Da kann man schon mal durcheinanderkommen. Durch die mittlerweile halbjährlichen Major-Releases von Java fällt es gar nicht so leicht, die aktuelle Version richtig zu benennen. Vor Kurzem hat man sich in einem Vortrag noch über die Neuerungen des JDK 14 informiert, und wenig später wurden in einem Artikel bereits die Features von Version 15 näher beleuchtet. Und da sich die Welt bekanntlich schnell weiterdreht, ist nun im März 2021 bereits das OpenJDK 16 herausgekommen.\n'parentId': 'b3c6f33294fba41d508316c1'\n'parentDescription': Über neun Millionen Software-Entwickler weltweit sorgen dafür, dass die Java-Technologie in allen Geschäftsfeldern und in allen Branchen eine zentrale Rolle spielt. Zudem ist das Java-Ökosystem der wichtigste Takt- und Impulsgeber für die gesamte Software-Industrie, wenn es um technische Innovationen geht. Das Java Magazin begleitet seit über 20 Jahren alle wesentlichen Entwicklungen der Java-Welt aktuell, kritisch und mit großer praktischer Relevanz. Software-Architekten, Entwickler und Projektleiter vertrauen auf die anerkannte Kompetenz der Redaktion verbunden mit ihrem Experten-Netzwerk bekannter Fachautoren.\n'indexBrandName': ''\n'indexSeriesName': ''\n'author': 'Falk Sippach'\n'chunkSource': 'text'\n'text': Sweet 16 Java auf dem Weg zur nächsten LTS-Version 14, 15 oder doch schon 16? Da kann man schon mal durcheinanderkommen. Durch die mittlerweile halbjährlichen Major-Releases von Java fällt es gar nicht so leicht, die aktuelle Version richtig zu benennen. Vor Kurzem hat man sich in einem Vortrag noch über die Neuerungen des JDK 14 informiert, und wenig später wurden in einem Artikel bereits die Features von Version 15 näher beleuchtet. Und da sich die Welt bekanntlich schnell weiterdreht, ist nun im März 2021 bereits das OpenJDK 16 herausgekommen. 14, 15 oder doch schon 16? Da kann man schon mal durcheinanderkommen. Durch die mittlerweile halbjährlichen Major-Releases von Java fällt es gar nicht so leicht, die aktuelle Version richtig zu benennen. Vor Kurzem hat man sich in einem Vortrag noch über die Neuerungen des JDK 14 informiert, und wenig später wurden in einem Artikel bereits die Features von Version 15 näher beleuchtet. Und da sich die Welt bekanntlich schnell weiterdreht, ist nun im März 2021 bereits das OpenJDK 16 herausgekommen. Um die Verwirrung komplettzumachen, kann man sich natürlich auch nur auf die sogenannten Long-Term-Support-Versionen (LTS) konzentrieren, die alle drei Jahre erscheinen. Das ist im Moment Java 11, wobei in der freien Wildbahn die Version 8 ebenfalls noch sehr weit verbreitet ist. Im September 2021 wird nun mit dem JDK 17 das nächste LTS-Release erscheinen. Dort werden die Neuerungen der vergangenen drei Jahre (Java 12 bis 16) finalisiert, um bis zur darauffolgenden LTS-Version (JDK 23) gut dazustehen. In den vergangenen „Zwischen“-Releases wurden die diversen, teilweise auch größeren Änderungen häufig als Previews veröffentlicht. Dadurch konnte frühzeitig Feedback eingesammelt und bereits im nächsten Release eingearbeitet werden. (Nicht ganz so) neue Features Die Liste der für das OpenJDK 16 umgesetzten JEPs (Java Enhancement Proposals) sieht auf den ersten Blick wieder relativ lang aus [1]: - 338: Vector API (Incubator) - 347: Enable C++14 Language Features - 357: Migrate from Mercurial to Git - 369: Migrate to GitHub - 376: ZGC: Concurrent Thread-Stack Processing - 380: Unix-Domain Socket Channels - 386: Alpine Linux Port - 387: Elastic Metaspace - 388:\n'slidetext': ''\n'from': 'index'\n'score': 125.76042938232422\n'normalizedScore': 1.2576042938232421\n'beforeDatePenaltyScore': 1.2576042938232421\n\n'documentId': '64ace3828d8056484c3534ab'\n'chunk_id': '687814c6bed6dcd41a99b02a'\n'access': 'granted'\n'part_number': 18\n'total_parts': 21\n'contentType': 'READ'\n'title': Angular 16 released - Alles zu neuen Features und Breaking Changes\n'parentName': iJS Magazin Band 27\n'language': 'DE'\n'date': '2023-04-06T00:00:00.000Z'\n'abstract': Wir geben einen Überblick zu allen wichtigen Infos zum Release von Angular 16. Alles zu Signals, der Angular-CLI und TypeScript in Angular 16 erfahren Sie hier.\n'parentId': '5093fc7a779ccfe852d8fe7b'\n'parentDescription': Kaum ein Softwareprojekt, das nicht in wesentlichen Teilen auf der JavaScript-Technologie basiert. Eine breite Unterstützung sowie, leistungsfähige Programmiersprachen, die Vielzahl moderner Tools, sowie ausgereifte Frameworks wie Angular, React, Vue.js oder Node.js machen den JavaScript-Werkzeugkasten zu einem Alleskönner. Das iJS Magazin informiert aktuell und umfassend über die wichtige und innovative Entwicklungen im JavaScript-Universum und bietet handfeste Praxisinformationen für Softwareentwickler und -architekten.\n'indexBrandName': ''\n'indexSeriesName': ''\n'author': 'Karsten Sitterberg'\n'chunkSource': 'text'\n'text': Vermeidung von Endlosschleifen Signals immer nur gelesen, nie geschrieben werden. Dies wird auch durch die Signal-API überprüft und dann ggf. ein Fehler geworfen. Listing 21: Beispiel für Logging als Signal-Effect constructor() { effect(() => { console.log(this.invoice()) }) } Signals sollen perspektivisch auch selbst - unabhängig von Zone.js - die Change-Detection in Komponenten steuern können. Dieses Verhalten ist noch nicht Teil von Angular 16, soll aber aktiviert werden können, indem signals: true in die Komponenten-Metadaten aufgenommen wird. In dem Fall werden die Inputs einer Komponente auch als Signals statt als veränderliche Objekte ausgeprägt. Allerdings ändert sich auch die Syntax, mit der man @Input, @Output und dergleichen schreibt: All diese Angular-Konzepte sind dann keine @-Decorators mehr, sondern spezielle Signals-Funktionen. Beispielsweise werden Inputs dann zu input()- und Outputs zu output()-Signals. Das passt dann gut dazu, dass die TypeScript Standard-Decorators nicht für Parameter, sondern nur für Typen funktionieren. Ähnlich verhält es sich mit Queries für ‘viewChild/ren’ und ‘contentChild/ren’, auch diese werden dann als Signal bereitgestellt. Im Lifecycle verändert sich die API bei Signal Komponenten ebenfalls: Mit ‘afterNextRender’ wird eine Funktion nach Beendigung des nächsten DOM-Update-Zyklus ausgeführt. Das ist in etwa wie bisher ein ‘ngAfterViewInit’, wird allerdings öfter aufgerufen. Mit ‘afterRender’ wird nach jeder DOM-Aktualisierung der angegebene Callback aufgerufen. Schließlich gibt es noch ‘afterRenderEffect’, der einen ‘effect’ mit jedem ‘afterRender’ aufruft. Insgesamt wirkt das Design bereits jetzt sehr vielversprechend und zukunftsweisend. Einzig die Frage nach der Einheitlichkeit der APIs in Anbetracht der RxJS Verwendung bleibt offen. Hier könnte sich aber auch ein sinnvolles Hybridkonzept etablieren. Aktuell sind Signals noch eine Preview-API und die weitere Entwicklung wird sicherlich auch vom Feedback der Community abhängen. Breaking Changes in Angular 16 Bei Major Releases ist gemäß Semantic-Versioning Konventionen auch stets mit inkompatiblen Änderungen zu rechnen. Das hält auch Angular 16 so, doch halten sich die Auswirkungen für den Großteil der Nutzer sicherlich im Rahmen. So haben sich die Versionsanforderungen der verwendeten Werkzeuge und Frameworks geändert. Zunächst wird als TypeScript-Version mindestens 4.9 verlangt.\n'slidetext': ''\n'from': 'index'\n'score': 125.7179946899414\n'normalizedScore': 1.257179946899414\n'beforeDatePenaltyScore': 1.257179946899414\n\n'documentId': '64ace3828d8056484c3534ab'\n'chunk_id': '687814c5bed6dcd41a99b020'\n'access': 'granted'\n'part_number': 8\n'total_parts': 21\n'contentType': 'READ'\n'title': Angular 16 released - Alles zu neuen Features und Breaking Changes\n'parentName': iJS Magazin Band 27\n'language': 'DE'\n'date': '2023-04-06T00:00:00.000Z'\n'abstract': Wir geben einen Überblick zu allen wichtigen Infos zum Release von Angular 16. Alles zu Signals, der Angular-CLI und TypeScript in Angular 16 erfahren Sie hier.\n'parentId': '5093fc7a779ccfe852d8fe7b'\n'parentDescription': Kaum ein Softwareprojekt, das nicht in wesentlichen Teilen auf der JavaScript-Technologie basiert. Eine breite Unterstützung sowie, leistungsfähige Programmiersprachen, die Vielzahl moderner Tools, sowie ausgereifte Frameworks wie Angular, React, Vue.js oder Node.js machen den JavaScript-Werkzeugkasten zu einem Alleskönner. Das iJS Magazin informiert aktuell und umfassend über die wichtige und innovative Entwicklungen im JavaScript-Universum und bietet handfeste Praxisinformationen für Softwareentwickler und -architekten.\n'indexBrandName': ''\n'indexSeriesName': ''\n'author': 'Karsten Sitterberg'\n'chunkSource': 'text'\n'text': gibt es in der Regel noch “separat” angezeigte Komponenten wie Modale Dialoge, Popups oder auch Toasts. Mit der alten View-Engine war es nötig, diese separaten Komponenten im entryComponents-Property eines @NgModule (oder einer @Component) anzukündigen. Dies ist mit Ivy nicht mehr notwendig, daher ist das Property seit Angular 9 deprecated. Mit Angular 16 wird das entryComponents-Property nun entfernt, da es seit Ivy ohnehin keinen Effekt mehr hatte. Daneben wurde das moduleId-Property des @NgModule deprecated. Dies stammt noch aus der Anfangszeit von Angular, in der die Anwendungen mit SystemJS gebaut wurden. Auch dieses Property hat seit vielen Versionen keine Funktion mehr. Um Daten an Kind-Komponenten weiterzugeben, können @Input()-Bindings verwendet werden. Es war schon immer möglich, dem Input-Decorator einen String-Parameter zu übergeben, durch den der Input nach außen hin unter einem Alias zur Verfügung gestellt wurde. Dieses Input-Renaming ist allerdings nur in speziellen Konstellationen zu empfehlen und sollte nicht übermäßig genutzt werden. Mit Angular 16 wurde nun eine weitere Konfigurationsoption für den @Input()-Decorator hinzugefügt. Denn ab der neuen Version können Inputs auf required gesetzt werden. Dazu wurde ein neues Flag eingeführt, das man dem Input-Decorator per Config-Objekt mitgeben kann. In Listing 8 sind Beispielhaft 3 Varianten gezeigt: Oben die bisherige Input-Renaming-Variante, die auch weiterhin funktioniert. Darunter ein barVal-Property, das den Alias barAlias erhält und außerdem als required markiert wird. Ganz unten wird ein Property nur als required markiert. Wenn ein Property als required markiert ist, dann muss dieses Property auf alle Fälle von außen gesetzt werden. Falls die äußere Komponente ein solches Property nicht auf einen bestimmten Wert setzt, wirft Angular einen Compiler-Fehler. Listing 8: @Input-Config-Paramter @Input('fooAlias') fooVal = ''; @Input({alias: 'barAlias', required: true}) barVal = ''; @Input({required: true}) bazVal = ''; Mit TypeScript-Version 5 wurden in TypeScript Decorators, analog zur ECMAScript-Decorators-Spezifikation, eingeführt, die langfristig die bisherigen, experimentellen Decorators ablösen sollen. Angular nutzt die TypeScript Decorators, um damit Metainformationen, unter anderem für das Dependency-Injection-System, bereitzustellen. Die Informationen können für Klassen, aber auch Methodenparameter oder den Konstruktor hinterlegt werden. Die\n'slidetext': ''\n'from': 'index'\n'score': 125.64087677001953\n'normalizedScore': 1.2564087677001954\n'beforeDatePenaltyScore': 1.2564087677001954\n\n'documentId': '64ace3828d8056484c3534ab'\n'chunk_id': '687814c5bed6dcd41a99b023'\n'access': 'granted'\n'part_number': 11\n'total_parts': 21\n'contentType': 'READ'\n'title': Angular 16 released - Alles zu neuen Features und Breaking Changes\n'parentName': iJS Magazin Band 27\n'language': 'DE'\n'date': '2023-04-06T00:00:00.000Z'\n'abstract': Wir geben einen Überblick zu allen wichtigen Infos zum Release von Angular 16. Alles zu Signals, der Angular-CLI und TypeScript in Angular 16 erfahren Sie hier.\n'parentId': '5093fc7a779ccfe852d8fe7b'\n'parentDescription': Kaum ein Softwareprojekt, das nicht in wesentlichen Teilen auf der JavaScript-Technologie basiert. Eine breite Unterstützung sowie, leistungsfähige Programmiersprachen, die Vielzahl moderner Tools, sowie ausgereifte Frameworks wie Angular, React, Vue.js oder Node.js machen den JavaScript-Werkzeugkasten zu einem Alleskönner. Das iJS Magazin informiert aktuell und umfassend über die wichtige und innovative Entwicklungen im JavaScript-Universum und bietet handfeste Praxisinformationen für Softwareentwickler und -architekten.\n'indexBrandName': ''\n'indexSeriesName': ''\n'author': 'Karsten Sitterberg'\n'chunkSource': 'text'\n'text': von provideRouter() die Funktion _withComponentInputBinding()- mitgegeben wird, siehe unten in Listing 13. Falls noch nicht die neue Syntax zum Erzeugen des Routers verwendet wird, sondern das RouterModule, kann im RouterModule.forRoot() das Flag bindToComponentInputs: true gesetzt werden. In Listing 14 ist beispielhaft gezeigt, welche Werte die Komponenten-Inputs annehmen, wenn in der Anwendung die Route /demo?language=french aufgerufen wird. Wichtig ist hierbei anzumerken, dass sogar die Query-Parameter (und die der Route zugeordneten Matrix-Parameter) über diesen Mechanismus gebunden werden können, was das Leben der Entwickler:innen an diesen Stellen erheblich vereinfachen dürfte. Die zu bindenden Query-Parameter müssen dann wieder genauso heißen, wie die zu bindende Input-Variable. Falls es zu Namenskollisionen zwischen den einzelnen Datenquellen kommt, so haben die Daten aus dem Resolver die höchste Priorität. Danach werden die statischen Daten aus der Routenkonfiguration herangezogen, dann folgen die Matrixparameter. Nur wenn das Property in keiner dieser Quellen gefunden wird, werden die Daten aus den Query-Params extrahiert. Listing 12: Komponente mit Input @Component({ template: '' }) export class DemoComponent { @Input() language?: string; @Input() demoResolved?: string; @Input() demoData?: string; } Listing 13: Routen-Konfiguration const routes = [{ path: 'demo', component: DemoComponent, data: {'demoData': 'My static data'}, resolve: {'demoResolved': () => 'My resolved data'}, }]; // inside AppModule/app-config provideRouter(routes, withComponentInputBinding()) Listing 14: Komponenten-Properties zur Laufzeit router.navigateByUrl('/demo?language=french') // component.language === 'french'; // component.demoData === 'My static data'; // component.demoResolved === 'My resolved data' Ein sehr wichtiges Thema in diesem Release ist die Fähigkeit von Angular, die Browseranwendung auf der Serverseite dynamisch zu rendern (Server-side Rendering, SSR) und das Ergebnis an den Browser zu senden. Dadurch können die Seiteninhalte nach Übertragung an den Client direkt dargestellt werden, ohne den App-Start abwarten zu müssen. Dies ist vor allem interessant, wenn die initiale Ladezeit der Anwendung hohe Priorität hat oder die Anwendung im freien Internet verfügbar ist und SEO (Search Engine Optimization) für die App relevant ist. Bisher kam es allerdings immer, wenn nach dem initialen Page-Load die Angular-App geladen war, zu einem kurzen Flackern, da die gerade gestartete App einmal den kompletten DOM neu gezeichnet hat. Nun gibt\n'slidetext': ''\n'from': 'index'\n'score': 125.50701141357422\n'normalizedScore': 1.255070114135742\n'beforeDatePenaltyScore': 1.255070114135742\n\n'documentId': '64ace3828d8056484c3534ab'\n'chunk_id': '687814c5bed6dcd41a99b01f'\n'access': 'granted'\n'part_number': 7\n'total_parts': 21\n'contentType': 'READ'\n'title': Angular 16 released - Alles zu neuen Features und Breaking Changes\n'parentName': iJS Magazin Band 27\n'language': 'DE'\n'date': '2023-04-06T00:00:00.000Z'\n'abstract': Wir geben einen Überblick zu allen wichtigen Infos zum Release von Angular 16. Alles zu Signals, der Angular-CLI und TypeScript in Angular 16 erfahren Sie hier.\n'parentId': '5093fc7a779ccfe852d8fe7b'\n'parentDescription': Kaum ein Softwareprojekt, das nicht in wesentlichen Teilen auf der JavaScript-Technologie basiert. Eine breite Unterstützung sowie, leistungsfähige Programmiersprachen, die Vielzahl moderner Tools, sowie ausgereifte Frameworks wie Angular, React, Vue.js oder Node.js machen den JavaScript-Werkzeugkasten zu einem Alleskönner. Das iJS Magazin informiert aktuell und umfassend über die wichtige und innovative Entwicklungen im JavaScript-Universum und bietet handfeste Praxisinformationen für Softwareentwickler und -architekten.\n'indexBrandName': ''\n'indexSeriesName': ''\n'author': 'Karsten Sitterberg'\n'chunkSource': 'text'\n'text': stattdessen wird seit einigen Versionen einfach das Projekt als “Standard” gesetzt, in dessen Unterordner der jeweilige Befehl ausgeführt wird. Auch die defaultCollection zur Einstellung der Collection, die beim Ausführen von Schematics-Befehlen (ng generate xyz) wurde entfernt. Stattdessen gibt es nun als Ersatz das Property schematicCollections, dem man ein Array verschiedener Schematic-Collection-Namen übergeben kann, siehe Listing 7. Listing 7: Alte und neue Spezifikation der Schematic-Collections // Bisher 'defaultCollection': '@angular/material' // Jetzt 'schematicCollections': ['@angular/material'] Angular Auch im Framework selbst hat sich vieles getan. Einiges davon ist als Vorbereitung für weitere geplante Designänderungen und Umbaumaßnahmen zu sehen. Im Fokus stehen dabei aktuell die Möglichkeiten für Server-side Rendering, also die Angular-Anwendung dynamisch durch den Server auszuführen und das Ergebnis als fertigen HTML-Quellcode an den Client zu senden. Damit ist eine schnellere Darstellung der ersten Ansicht zu realisieren, was im Rahmen der Core Web Vitals gemessen werden kann. Eine höhere Nutzerzufriedenheit und Ranking in Suchmaschinen sollen sich daraus ergeben. Wechselt man nicht häufig zwischen verschiedenen Angular-Anwendungen und ist sogar im Enterprise-Umfeld unterwegs, in dem lediglich selten interne Anwendungen gestartet werden, sind das zugegebenermaßen keine Ziele, die hohe Priorität genießen. Für Anwendungen für Endnutzer im Internet können genau das jedoch wesentliche Erfolgskriterien sein, da es hier oft zum Wechsel von Webseiten kommt. Weiterhin gibt es das Bestreben, Angular-Anwendungen ohne das Angular-Modulsystem erstellen zu können. Dies soll die Lernkurve verringern und weniger Komplexität, gerade zum Einstieg, ermöglichen. Da gerade das Angular-Modulsystem eine nicht zu unterschätzende Stärke für größere und komplexere Projekte darstellt, bleibt zu hoffen, dass es sich bei dem Modulsystem auch zukünftig um ein langfristig weiterhin unterstütztes, wenn auch optionales, Feature handeln wird. Und genau danach sieht es aktuell auch aus. Neben den Komponenten, die im “normalen” Komponentenbaum aufgebaut werden, gibt es in der Regel noch “separat” angezeigte Komponenten wie Modale Dialoge, Popups oder auch Toasts. Mit der alten View-Engine war es nötig, diese separaten Komponenten im entryComponents-Property eines @NgModule (oder einer\n'slidetext': ''\n'from': 'index'\n'score': 125.47245788574219\n'normalizedScore': 1.254724578857422\n'beforeDatePenaltyScore': 1.254724578857422\n\n\nTop Vectors:\n'documentId': '169cb8b4177f542b161210ec'\n'chunk_id': '69037b9752f58e0014b29c22'\n'access': 'granted'\n'part_number': 10\n'total_parts': 19\n'contentType': 'RHEINGOLD'\n'title': Supercharge your Apps with Incremental Hydration\n'parentName': International JavaScript Conference Munich 2025\n'language': 'EN'\n'date': '2025-10-30T11:00:00.000Z'\n'abstract': Discover how Server-Side Rendering (SSR) can boost the performance and user experience of your Angular applications. In this talk, I'll guide you through @angular/ssr, a modern SSR solution that has evolved significantly in recent years to deliver faster initial loads. We'll explore Static Site Generation (SSG, aka Prerendering) during the build process and the features Full-App Hydration (since v16), Deferrable Views (v17) Event Replay (v18), and Hybrid Rendering (v19). The spotlight will be on Incremental Hydration (since v19, stable in v20) – the cutting-edge evolution of @defer blocks combined with SSG. I'll explain how this technique works, highlight its potential, and demonstrate its application with selected examples. The session is aimed at both Angular developers who are just getting started with SSR and experienced Angular pros looking to get to know the latest SSR capabilities. slug: angular-ssr-incremental-hydration\n'parentId': 'd9a5c0715a7cff50bbb51e14'\n'parentDescription': \n'indexBrandName': 'InternationalJavaScriptCon'\n'indexSeriesName': 'Munich'\n'author': 'Alexander Thalhammer'\n'chunkSource': 'text'\n'text': click will be repeated. So for the user it seems like uh everything is just working while, uh, he has clicked on a button without a function, so that's pretty cool. And that's needed for for incremental hydration, but I will come back to that later. Another interesting feature is hybrid rendering, which is also usable from Angola 19, and this is where you can select the render mode for each route. So we already talked about client side rendering, server side rendering, static side generation, and in Angular it's called pre-render, server, and client. So you can specify for each route in your server routes. It's a little bit, um, yeah, boilerplatey in my opinion. Because now you have app routes and you and you additionally have app server routes, I hope, um, Or broad server, I hope in the future they they might merge these, uh, two configs together, these, these two rout arrays together, but yeah, let's see. It's pretty new, so there might be some improvements in the near future. Another feature we get with Angle and 19 is, uh, or with hybrid rendering is you can now, uh, on the server create redirects. And uh for 4 pages. Which previously you couldn't and um yeah that's pretty cool because you enter a URL on your browser and then on on the server you will be already redirected so you don't have to uh because uh in the old let's say version you would have had to download and bootstrap the application and to be redirected one once the application has already bootstrapped and all the JavaScript, uh, has been, uh, parsed and executed. So this is of course also um much faster for the for the redirect. Another, uh, the final ingredient that we need for, uh, incremental hydration are standalone components. Future is standalone. I had to remember this, uh, image from the blog post, uh, a few years ago. So of course, uh, you should be using standalone components to avoid this issue which I regularly, uh, encounter in my, uh, trainings and consultings with, uh, the performance topic because most teams, uh, have worked like this. They had, uh, lazy loading implemented, but, um, yeah, they had this huge shared module with all shared dependencies with the design system, the component framework, the chart library and the table library and, and so on and so forth. And everything was put into the shared module which has 90 or 95% of the bundle size, and then that shared model is used in every feature model, so, uh, you basically ruin your lazy loading completely. How did\n'slidetext': ''\n'from': 'vector'\n'score': 0.9099029302597046\n'normalizedScore': 0.9092903348341592\n'beforeDatePenaltyScore': 0.9099029302597046\n\n'documentId': 'ac8bcbad20150e9773f7400b'\n'chunk_id': '69021a60a5de460012a1af2b'\n'access': 'granted'\n'part_number': 11\n'total_parts': 11\n'contentType': 'RHEINGOLD'\n'title': Getting the most out of Angular DevTools\n'parentName': International JavaScript Conference Munich 2025\n'language': 'EN'\n'date': '2025-10-29T09:15:00.000Z'\n'abstract': In this session, we’ll dive into Angular DevTools and how it can enhance your development experience. From getting started with installation and setup to exploring the interface, you'll learn how to quickly get it running and connected to your Angular app. We’ll cover debugging techniques using the component tree, tracking state changes, and spotting binding issues. You’ll also get hands-on with performance profiling, learn how to identify rendering bottlenecks, and understand what the timeline panel is really telling you. A dedicated section on inspecting injectors will help demystify Angular’s dependency injection. Finally, we’ll wrap up with tips and hidden gems to help you get the most value from DevTools day to day. Whether you're new to Angular or a seasoned developer, this session will give you practical, actionable ways to make Angular DevTools an essential part of your workflow.\n'parentId': 'd9a5c0715a7cff50bbb51e14'\n'parentDescription': \n'indexBrandName': 'InternationalJavaScriptCon'\n'indexSeriesName': 'Munich'\n'author': 'Sam Vloeberghs'\n'chunkSource': 'text'\n'text': the signal graph, yeah. Yeah, so I had to repeat for, for the audience online, the question was if there uh. Is a, uh, if you're using a signal store, will it uh allow, will the angular dev tools allow you to uh click through to the sources of the um of the signal stores signal store directly. Yeah. Any other questions? If you're shy and don't want to ask your question in public, you can always uh ask me privately as well. Um. And uh yeah, please um provide your feedback uh in the uh conference application afterwards. Thank you. There are some Questions from the audience as well. Let me see. There's a question from the audience. Uh, I do not have the router tree tap. Uh, is my angular De Tools an old version? It could be, um, it could be that you're using an older version of your, uh, in your angular application as well. But the uh router tree. Uh, let me see. Is a feature that you need to enable explicitly. So it's not enabled by default. You can use the top level, um, let me. Share my full screen. So the router tree is a feature that you'll need to explicitly enable. All right. Thank you.\n'slidetext': ''\n'from': 'vector'\n'score': 0.908271074295044\n'normalizedScore': 0.9075996889145265\n'beforeDatePenaltyScore': 0.908271074295044\n\n'documentId': '0747f0655ef3790a97eba95b'\n'chunk_id': '68f24b683134c10012c3d12d'\n'access': 'restricted'\n'part_number': 2\n'total_parts': 16\n'contentType': 'RHEINGOLD'\n'title': How to architect Angular apps in 2025\n'parentName': International JavaScript New York 2025\n'language': 'EN'\n'date': '2025-10-01T08:15:00.000Z'\n'abstract': In this talk, Alain showcases several architecture concepts he uses to optimize apps for performance, readability, and scalability in 2025 and beyond. We’ll touch on using Signals as state in our services, how to control access to such Signals, using the new resource API, and more!\n'parentId': '9f97d5cdc68d72a05f834df4'\n'parentDescription': The JavaScript Fullstack Conference - Angular, Node.js, React and more\n'indexBrandName': 'InternationalJavaScriptCon'\n'indexSeriesName': 'NewYork'\n'author': 'Alain Chautard'\n'chunkSource': 'text'\n'text': done all continents except Antarctica because that's, that's tricky to, to find an audience there, but that's okay. So as I told you earlier, angular, and as you probably know, there's been a lot of things changing lately in the past two, three years, even more. It really started with signals version 16, and then everything kind of became crazy and faster in terms of pace of change. So I listed some of the main things that changed here. Uh, starting at V 14. We got standalone components 16, angular signals 17, the new control flow blocks, uh, 19 HTP resource V 20 is on as is stable. And V 21 coming soon, we we're gonna have signal forms. So that's a lot. And you can write Angular code today that looks nothing like what it would look like five years ago. Well, you, you'll still recognize things, but you can do things in a way that's completely different. So we'll see why these changes are happening, what's the motivation behind this and what the impact on our code and on, you know, what we, what we're supposed to do with this. So the main idea of the Angular team was really to make Angular easier to learn, easier to understand, easier to maintain. 'cause the thing is, this is an Angular talk. If you go to a React talk, there's gonna be more people. And the fact of the matter is, is that React has always advertised itself as the easier option, right? Easier to learn. It's fast. It's like jQuery, just add something, you can use it, blah, blah, blah. So Angular lasts a lot of audience to react because of that, mostly on kind of reputation I would say. But, um, and so that perceived difficulty is something that the Angular team is trying to fight against and say, no, angular is not that difficult. And so all of the things that's changed since V 14 are really going into that idea of, well, angular is actually easy to learn. We don't need to know that much about RXJS. You don't need to know about all of these extra things. You can start with the basics. So one of the things that started in the 14 was NG modules, right? Angular modules. It's one of the things that if you come into the Angular world, you're like, why do we have that? React doesn't have that view, doesn't have that. Why do we have NG modules in Angular? So standalone fixes that we remove NG modules pretty much, and you can just do your thing like you would do with other\n'slidetext': ''\n'from': 'vector'\n'score': 0.9085772037506104\n'normalizedScore': 0.9063692886897275\n'beforeDatePenaltyScore': 0.9085772037506104\n\n'documentId': '5047e9550eef9d941aaa1376'\n'chunk_id': '690347ae52f58e0014b29b95'\n'access': 'granted'\n'part_number': 10\n'total_parts': 22\n'contentType': 'RHEINGOLD'\n'title': AI-powered Angular Apps\n'parentName': International JavaScript Conference Munich 2025\n'language': 'EN'\n'date': '2025-10-30T08:00:00.000Z'\n'abstract': Artificial intelligence is increasingly becoming part of our daily lives. For software developers, this opens up new opportunities — from writing source code to refactoring it. In this talk, we focus on how AI can enhance Angular frontends at runtime. How can a new micro-frontend be discovered and integrated with the help of AI? How can routing be extended using natural language, and how can the navigation bar be updated accordingly? How can new views be seamlessly integrated into an existing application? The combination of generic programming, micro-frontend architectures, and large language models (LLMs) paves the way for a new era of software development — enabling applications to be extended in specific areas without requiring deep technical expertise. This talk is aimed at software developers, architects, and technical managers who want to learn more about the interplay between artificial intelligence and web-based enterprise UIs.\n'parentId': 'd9a5c0715a7cff50bbb51e14'\n'parentDescription': \n'indexBrandName': 'InternationalJavaScriptCon'\n'indexSeriesName': 'Munich'\n'author': 'Michael Egger-Zikes'\n'chunkSource': 'text'\n'text': was available, so full lazy loading support. That's important here. Somewhere you need to have those, uh, dynamic imports referenced because that's the only way that the compiler, uh, can split off the bundles and basically create different bundles for booking, checking, and boarding, right? And even. Uh, Additional bundles if they have common dependencies and so on, so the, the normal chunking process of Angular, but this time not in the routing configuration. So I can just look up this constant here and then, uh, by, uh, choosing the name booking, uh, I have a function available that I can then use in a dynamically generated routing object and that's basically what's happening here. I created a provide dynamic navigation function that you already saw here in the app config so that was the sync. That I showed you before where we pointed to the to the Jason file could also be your API. I pass in the app route without the booking check-in information and I pass in my dictionary with the lazy with the lazy features basically making all of that available. Uh, we first of all provide the navigation service so that we can use this for state management for a sidebar, and then I have just an app initializer logic so it waits, um, as the angular application bootstraps until, um, everything is available, meaning in this case the configuration file was loaded so that it can use its state. To configure the route, yeah, so basically it it's use the HTTPPI and um it connects to the back end API um through that path that uh passed in here and then it does a little bit of object array transformations to filter out um those uh items that's uh that are part of the um of the navigation sidebar but maybe not part of the of the lazy configuration. Uh, here in the lazy features, so for example the home component, right, so if we look inside them. Maybe let's put this here side by side. Then you can see we have here configuration for home for booking at the moment in the initial conflict and home is uh for example not part of the of the lazy loading uh configuration. So I have a logic applied here inside. Um, that, that can basically, uh, figure this out if there's no, um, lazy loading logic available then just, um, skip that and, and, uh, do not add it to the maybe to the sidebar but not, um, to the routing configuration because the home route is already available here hard coded in the, in the routing definition, yeah, um, what else is possible? I, um, tell my. Uh, implementation here to, um, also,\n'slidetext': ''\n'from': 'vector'\n'score': 0.9066430330276489\n'normalizedScore': 0.9060235882857667\n'beforeDatePenaltyScore': 0.9066430330276489\n\n'documentId': '5047e9550eef9d941aaa1376'\n'chunk_id': '690347ad52f58e0014b29b8e'\n'access': 'granted'\n'part_number': 3\n'total_parts': 22\n'contentType': 'RHEINGOLD'\n'title': AI-powered Angular Apps\n'parentName': International JavaScript Conference Munich 2025\n'language': 'EN'\n'date': '2025-10-30T08:00:00.000Z'\n'abstract': Artificial intelligence is increasingly becoming part of our daily lives. For software developers, this opens up new opportunities — from writing source code to refactoring it. In this talk, we focus on how AI can enhance Angular frontends at runtime. How can a new micro-frontend be discovered and integrated with the help of AI? How can routing be extended using natural language, and how can the navigation bar be updated accordingly? How can new views be seamlessly integrated into an existing application? The combination of generic programming, micro-frontend architectures, and large language models (LLMs) paves the way for a new era of software development — enabling applications to be extended in specific areas without requiring deep technical expertise. This talk is aimed at software developers, architects, and technical managers who want to learn more about the interplay between artificial intelligence and web-based enterprise UIs.\n'parentId': 'd9a5c0715a7cff50bbb51e14'\n'parentDescription': \n'indexBrandName': 'InternationalJavaScriptCon'\n'indexSeriesName': 'Munich'\n'author': 'Michael Egger-Zikes'\n'chunkSource': 'text'\n'text': other social networks where you, uh, find some nice angular communities to connect and discuss all the new APIs. Um, we also offer workshops, so feel free to visit our, our website or join our workshop tomorrow here at the IAS conference. Uh, first of all, I would like to start directly with a demonstration. So, um, my demonstration is, uh, typically application that we normally use for training and consulting purpose. It's our flat application and it typically looks like that ready-made, uh, maybe in some. Um, implementations of this code base we have a hard coded sidebar with hard coded navigation links. In others, uh, I have already dynamic, uh, navigation links, but you can see it here, it claims to be a modern angular application, um, that teaches a bit about architecture, signal, signal forms, enterprise data management, and all the other stuff today also AI. Um, we can link on the site links here, uh, click on the sideper links here, uh, like, um, booking, check-in, boarding, all of that is possible, and of course the router then, um, does the router navigation. Some lazy loading happens behind the covers and so on. So that's, uh, typical application like you would, um. Uh Likely also implemented in in your own code base. Um, now let's take a bit, uh, deeper look into how the navigation structure looks like, and for that I have my shell application here. Uh, I love to have just a thin application layer, um, without subfolders, and everything that is then connected with the application is part of the library folder, uh, not necessarily always that fine grained like in an X repositories, but per feature group, per domain, however you would call it. Um, it's, it's quite nice to put this with a clear public API into the LIS folder, uh, but architecture is not the, the, the main topic, uh, for today. We have here our app routes, and as you can see here I will find, uh, uh. Default redirect for the empty pass, a home component, an admin component for an AI console that we will use later on, and the wildcat rod, but interestingly. I also have a booking, a check-in and the boarding navigation here and you can even see that's quite tiny here on the screen, um, but, uh, boarding departures or if I click on booking, uh, booking flight search for example, yeah, so the routing functionality works somehow but surprisingly those uh router objects do not exist in this routing configuration so um already um in this. Um, version of the application, there are some\n'slidetext': ''\n'from': 'vector'\n'score': 0.9064753651618958\n'normalizedScore': 0.9058559204200135\n'beforeDatePenaltyScore': 0.9064753651618958\n\n'documentId': '5047e9550eef9d941aaa1376'\n'chunk_id': '690347ae52f58e0014b29b92'\n'access': 'granted'\n'part_number': 7\n'total_parts': 22\n'contentType': 'RHEINGOLD'\n'title': AI-powered Angular Apps\n'parentName': International JavaScript Conference Munich 2025\n'language': 'EN'\n'date': '2025-10-30T08:00:00.000Z'\n'abstract': Artificial intelligence is increasingly becoming part of our daily lives. For software developers, this opens up new opportunities — from writing source code to refactoring it. In this talk, we focus on how AI can enhance Angular frontends at runtime. How can a new micro-frontend be discovered and integrated with the help of AI? How can routing be extended using natural language, and how can the navigation bar be updated accordingly? How can new views be seamlessly integrated into an existing application? The combination of generic programming, micro-frontend architectures, and large language models (LLMs) paves the way for a new era of software development — enabling applications to be extended in specific areas without requiring deep technical expertise. This talk is aimed at software developers, architects, and technical managers who want to learn more about the interplay between artificial intelligence and web-based enterprise UIs.\n'parentId': 'd9a5c0715a7cff50bbb51e14'\n'parentDescription': \n'indexBrandName': 'InternationalJavaScriptCon'\n'indexSeriesName': 'Munich'\n'author': 'Michael Egger-Zikes'\n'chunkSource': 'text'\n'text': because it's, it's not that funny to always copy over the one feature to the next subfolder and just change, uh, two or three names. Uh, sometimes generic programming, of course, affords, um. More knowledge about the framework, quite often more knowledge about angulars dependency injection, but on the other hand it's really nice if you write a generic API because uh having such an implementation that you can configure. Um, with just this chasing structure is quite something that can save a lot of time for the future, yeah, so if you have similar use cases, uh, like adding links over time in this case, um, changing, uh, form definitions, uh, during the run time, and many other things, uh, all of that is possible with quite similar approaches. Um, this time as mentioned dynamic navigation and routing, um, basically, uh, we build, uh, uh, implementation here that that supports exactly this some parts of the of the angular router, some custom services, um, provider functions that can configure your angular application that way. Um, I have a chasing-based configuration you already saw that, um, in, uh, this case for the, for the initial configuration part of the asset folder could also be a real API, yeah, then of course the, the form. Uh, not the form structure, navigation structure that that was basically generated with help of the large language model can then also be written back to the server. That means after reload you have already the, uh, the updated, uh, configuration in my case, in case it's, um, at the moment for simplicity reasons just a simple, uh, JSON file, but of course you could use your own back end written in any language that you like, uh, returning such a JSN structure. Um, we have some dynamic router features applied here. We have a dynamic sidebar implementation. So those, those are the two, generic implementations that we use here. On one hand, a custom component, um, that knows nothing about the navigation links, about your domains, about the features, um, it just, uh, offers you a way, um, to display links in the sidebar. So it's basically a combination of a generic component and a service that provides a state that can be configured over time, yeah, either by loading the initial uh chasten definition or later on uh by using the um result what the large language model actually returned. Um, we have a loading configuration for that, so some loaders you can decide what you need actually. Um, don't overengineer your applications if you say it's, uh, ask for my use cases that I have this declarative structure made available\n'slidetext': ''\n'from': 'vector'\n'score': 0.906197726726532\n'normalizedScore': 0.9055782819846497\n'beforeDatePenaltyScore': 0.906197726726532\n\n'documentId': '918dc8a09612c28c04090931'\n'chunk_id': '68f25086d754e200146e6f0a'\n'access': 'restricted'\n'part_number': 16\n'total_parts': 16\n'contentType': 'RHEINGOLD'\n'title': Scaling Node.js Applications with NestJS: Patterns for Clean Architecture and High Performance\n'parentName': International JavaScript New York 2025\n'language': 'EN'\n'date': '2025-09-30T15:15:00.000Z'\n'abstract': NestJS is changing how we build scalable, maintainable Node.js applications. This session explores how its modular architecture, dependency injection, and declarative programming style simplify complex systems. Learn proven patterns for clean architecture and performance gains, plus how these practices naturally enable smoother AI-assisted development workflows.\n'parentId': '9f97d5cdc68d72a05f834df4'\n'parentDescription': The JavaScript Fullstack Conference - Angular, Node.js, React and more\n'indexBrandName': 'InternationalJavaScriptCon'\n'indexSeriesName': 'NewYork'\n'author': 'Tyler Steck'\n'chunkSource': 'text'\n'text': all the benefits that we were getting there, that they wanted a node framework that was just as similar to Angular on how to orchestrate that. And the dependency injection yeah, is definitely, um, a lot to be wanted there. I don't know if they are or are not. I don't know the specifics on that of the future of dependency injection with following angulars foot track footstep. Any other questions? All right. Was this helpful? Good. Actually, today, that was rough. Hey, that's, that's all right. You gotta do it for the people for watch it later, you know? Yes. My first question.\n'slidetext': ''\n'from': 'vector'\n'score': 0.907709002494812\n'normalizedScore': 0.9054622746485411\n'beforeDatePenaltyScore': 0.907709002494812\n\n'documentId': '74929d5c8003451930366f98'\n'chunk_id': '6903455752f58e0014b29b84'\n'access': 'granted'\n'part_number': 10\n'total_parts': 16\n'contentType': 'RHEINGOLD'\n'title': The Supreme Discipline of Micro Frontends: Multi-Version and Multi-Framework Scenarios\n'parentName': International JavaScript Conference Munich 2025\n'language': 'EN'\n'date': '2025-10-29T14:15:00.000Z'\n'abstract': Micro frontends are especially appealing for large enterprise solutions, as they grant individual teams more autonomy — bringing the agility of small, fast-moving teams to even the most complex projects. Things get truly challenging, however, when different versions and frameworks need to coexist. In this session, we’ll explore the key challenges and present practical solutions, with a strong emphasis on using web standards to ensure long-term maintainability. By the end of this talk, you’ll understand how to combine different versions and frameworks in your micro frontend architecture, what implications this has, and how to overcome the associated challenges.\n'parentId': 'd9a5c0715a7cff50bbb51e14'\n'parentDescription': \n'indexBrandName': 'InternationalJavaScriptCon'\n'indexSeriesName': 'Munich'\n'author': 'Manfred Steyer'\n'chunkSource': 'text'\n'text': we don't do this lightly. There are some challenges that are solvable, but there are some challenges we need to think of. For instance, when we are using Angular, there is the zone chairs, and if you really have a fine-grained integration. Between your web components, then you need to make sure you only instantiate Sojas ones. This is doable. Sharingone shares via the global name space is doable. Then we just have it once. And you know, if I'm saying global name space, I'm referring to the window object, yeah. We can do the same with the platform object if not going with standalone components in Angular. We just need to implement or not implement to instantiate a platform object like browser platform, server platform, and there is a limitation in there. We can only instantiate the platform object once per version. And also this means once instantiated we need to share it somehow, for instance, also here via the global name space. That means when bootstrapping the application we need to check is already a platform object in place. If yes, take it. If no, create another one, use it, and put it into the global name space. And as discussed before, for combining several routers, we need to tweak the routers a bit, we need to tell the router, well, please only look at those segments and you only look at the further segments. Yeah, Angola is a bit special in there, but I have a good message for you. With more than angular, option 1 and option 2 is gone, because with more than angular, since angular 20.2, we are zone less by default. Zone less is stable meanwhile, and when we go with standalone components, we don't need to deal with this platform object anymore. So this is really a beautiful addition to Angular that really, really helps us here in the space of micro front ends. We still need to deal with the meta routing, with configuring all the routers, and this is regardless whether we are using Angular or React or Few or Svelt or something else. OK, so this is a solution that works quite well in a lot of huge companies we are supporting companies with let's say 80 teams around the globe, 100 teams around the globe, and larger. However, there are some alternatives. There are always alternatives, and the nice part of this, and this really brings us to the core of what software architecture is, all the alternatives have their very own advantages and disadvantages. There are always trade-offs here, and so we need to find out which trade-offs are more or less suitable for our goals.\n'slidetext': ''\n'from': 'vector'\n'score': 0.9060550928115845\n'normalizedScore': 0.9053951229555469\n'beforeDatePenaltyScore': 0.9060550928115845\n\n'documentId': '1fed2c6361980d606789e315'\n'chunk_id': '68c26fcc0a53cd001394ab93'\n'access': 'granted'\n'part_number': 3\n'total_parts': 8\n'contentType': 'READ'\n'title': Manfred Steyer on Angular 20: Signals, Dynamic Components, AI, and What’s Next - Exploring selectorless components, signal-based forms, and other features in Angular\n'parentName': iJS Magazine Volume 19\n'language': 'EN'\n'date': '2025-06-24T22:00:00.000Z'\n'abstract': In this interview, GDE Manfred Steyer highlights Angular’s journey towards a more reactive future. We discuss the framework’s strengths, challenges, and what’s ahead with the release of Angular 20.\n'parentId': 'a1269c65e87d5b8ebcde4b28'\n'parentDescription': Broaden your knowledge and expand your JavaScript techniques and practices. From Angular, React, and WebAssembly, to the best JavaScript IDEs, open source tools and more, you’ll learn insights on everything JS from seasoned experts in their field. Keep up with JavaScript news, tips, and advice with interviews, tutorials, and in-depth articles.\n'indexBrandName': ''\n'indexSeriesName': ''\n'author': 'Manfred Steyer'\n'chunkSource': 'text'\n'text': beta stages. Around that time, I also began consulting companies on adopting Angular 2. Ines Chargui: How would you describe the Angular journey? After everything that the framework went through, is it on the right track? Does it disappoint sometimes? Manfred Steyer: I think it's really on the right track. The Angular team has consistently proven that the underlying philosophy and the whole architecture pay off. It allows Angular to reinvent itself underneath the covers. We don't see a lot of those reinventions, but Angular manages to keep up with all of the innovations out there, at least all the ones important for single-page applications or web applications in general. Just one example: several years ago, they switched out the whole rendering engine for the new Ivy engine. That happened largely behind the scenes, with no major breaking changes, effectively giving us a modernized framework without the usual migration pain. Now, Angular is doing it again. NgModules are optional, zones are becoming optional, and we’re getting a new set of reactivity primitives with Signals. All of this works without breaking changes. Existing code continues to work, which is very important in enterprise environments, where applications are expected to be maintained for years or even decades. Reinvention without disruption is the theme behind Angular, and so far, it’s proven it can deliver on that promise. Ines Chargui: With the upcoming release of Angular 20 on May 28, 2025, what features or improvements are you most excited about exploring? Manfred Steyer: Well, the Signal story will evolve. Many building blocks, such as effects or the RxJS interop will become stable. The Resource API that fetches data within the reactive Signal-based flow will transition to developer preview. The same is the case for Incremental Hydration, Hybrid Routing, and Zone-less Change Detection. Ines Chargui: What do you think about these features in developer preview? Have you experimented with any of these? Manfred Steyer: Absolutely. I was an early adopter of the reactivity features like the Resource API and linked signals. For me, they have always been necessary, even though they were experimental, because they were filling a gap in Angular’s reactivity story. Without them, when working only with Signals, for instance, there is no way to do data fetching as part of the reactive flow. For this, we need resources and a brand new HTTP resource; the linked signal gives us a local working copy. For example, this is necessary when binding read-only data from a store into a template-driven form. Since forms need to update values, and read-only signals can’t be changed directly, linked\n'slidetext': ''\n'from': 'vector'\n'score': 0.9096366763114929\n'normalizedScore': 0.9020354964104275\n'beforeDatePenaltyScore': 0.9096366763114929\n\n'documentId': '57ca0d48729b52fa55c618a2'\n'chunk_id': '68baebf1c846ad0013b2721b'\n'access': 'restricted'\n'part_number': 12\n'total_parts': 19\n'contentType': 'RHEINGOLD'\n'title': The Art of Testing\n'parentName': International JavaScript Conference London 2025\n'language': 'EN'\n'date': '2025-05-14T08:30:00.000Z'\n'abstract': The question of how to test effectively often sparks debate. Many of us are familiar with the testing pyramid, where the emphasis traditionally falls on unit tests because they are fast and efficient. However, with advances in technology and lessons learned from experience, the industry seems to have reached a consensus: the days of the testing pyramid are behind us. The focus has shifted more toward the middle of the pyramid. In this talk, I’ll explore the reasoning behind this shift with objective insights and a live-coding demo to illustrate the practical implications.\n'parentId': 'a1b41ab44fd3e90faf564397'\n'parentDescription': The JavaScript Fullstack Conference - Angular, Node.js, React and more\n'indexBrandName': 'InternationalJavaScriptCon'\n'indexSeriesName': 'London'\n'author': 'Rainer Hahnekamp'\n'chunkSource': 'text'\n'text': should load, it needs to go to the route to the URL. And in the URL there is always an ID available. So you see this, um, here it says quiz for holiday ID 16. And um, I say okay, if the ID comes from the URL, then I don't want to again work around the URL or or around the routing service. I'm just going to set up here a particular URL where the routing configuration. And then I hope again that angular provides me something which allows me to um, deal with this routing stuff very easily, which Anglia is doing. So you don't see here anything in terms of I'm overriding the template, I leave the imports as they are. I also don't do anything with the quiz store. I just leave it. I say all these things should be included and then I want to have the component. But I'm not saying here create component because I say I want to navigate to this component. And here Angular provides us something which is called the router testing harness. So it says, given the routing configuration that you have, if you say router testing, harness create, I'm simulating for you. So I have something in my testing framework which says I can simulate the behavior of a routing navigation together with the way how it works with a component exactly as it would be in the application. It is very important that Angular provides this because they know how the routing system works. If we write this, then we could make very quickly errors 'cause we don't know all the details, but in this case, angular says if you use the router testing harness, you can be sure your component behaves like in real life. So I say here I wanna navigate to quiz one, then the first thing that my quiz component should do is that it should start to request data for my quiz. And then again, we have here another fake, in this case it's testing controller, meaning the end in angular. You just, you, these are the main two things. We see them already right here. And with the testing controller, I can say expect one. So I'm expecting that this request happens and then I wanna return here this data. So I'm not really caring about what the quiz store is doing. Again, I'm just saying this is the response when somebody, uh, requests the data and then I say again, angular now has to do some work. There might be some asynchronous tasks which have been executed. I don't know, to be honest, I don't even care. I just say angular. You do know whatever you think you have to do. And if\n'slidetext': ''\n'from': 'vector'\n'score': 0.9094759821891785\n'normalizedScore': 0.899597405027839\n'beforeDatePenaltyScore': 0.9094759821891785\n\n'documentId': '73a55b4bbeecf374b233deaf'\n'chunk_id': '687a299f2491ed518a3f0cf6'\n'access': 'restricted'\n'part_number': 1\n'total_parts': 1\n'contentType': 'RHEINGOLD'\n'title': Angular’s New Era: Unveiling the Most Exciting Features Yet\n'parentName': International JavaScript Conference Singapore 2024\n'language': 'EN'\n'date': '2024-11-27T09:15:00.000Z'\n'abstract': In this session, we'll explore the groundbreaking features of Angular that are transforming the way we build modern web applications. From a simplified developer experience for creating new apps to standalone components that improve modularity, Angular is stepping up its game. We’ll dive into lazy loading for routes and components, optimizing performance and load times, and explore the power of control flow for dynamic, responsive UIs. Discover the magic of deferrable views that help you prioritize critical content, and get an inside look at signals—a new, reactive paradigm for managing state and change detection. We’ll also uncover the potential of zoneless Angular, offering maximum performance by reducing overhead, and take a peek into some of the forthcoming features that promise to shape the future of Angular development. Join us to discover how these game-changing features can take your Angular apps to the next level.\n'parentId': 'gdaJCohaAMyedJZCT'\n'parentDescription': The JavaScript Fullstack Conference - Angular, Node.js, React and more\n'indexBrandName': 'InternationalJavaScriptCon'\n'indexSeriesName': 'Singapore'\n'author': 'Pankaj Parkar'\n'chunkSource': 'text'\n'text': Angular’s New Era: Unveiling the Most Exciting Features Yet In this session, we'll explore the groundbreaking features of Angular that are transforming the way we build modern web applications. From a simplified developer experience for creating new apps to standalone components that improve modularity, Angular is stepping up its game. We’ll dive into lazy loading for routes and components, optimizing performance and load times, and explore the power of control flow for dynamic, responsive UIs. Discover the magic of deferrable views that help you prioritize critical content, and get an inside look at signals—a new, reactive paradigm for managing state and change detection. We’ll also uncover the potential of zoneless Angular, offering maximum performance by reducing overhead, and take a peek into some of the forthcoming features that promise to shape the future of Angular development. Join us to discover how these game-changing features can take your Angular apps to the next level.\n'slidetext': ''\n'from': 'vector'\n'score': 0.9106927514076233\n'normalizedScore': 0.8916104071236304\n'beforeDatePenaltyScore': 0.9106927514076233\n\n'documentId': '5ca564ac8c4557f4f949b660'\n'chunk_id': '687a2b82495b49563aa87acd'\n'access': 'restricted'\n'part_number': 1\n'total_parts': 9\n'contentType': 'RHEINGOLD'\n'title': Level-up your Angular Codebase with Cutting-Edge APIs\n'parentName': International JavaScript Conference Munich 2024\n'language': 'EN'\n'date': '2024-11-13T10:45:00.000Z'\n'abstract': The Angular team is propelling the enterprise frontend framework into a promising future with new, robust APIs. Modern concepts, validated in the JavaScript ecosystem, such as enhanced server-side rendering support, the new Control Flow syntax, Standalone APIs instead of NgModules, and optional RxJS, as well as Zone.js, are paving the way for a brighter future with an easier-to-manage codebase and an excellent developer experience. But how does this impact your current codebase? What refactoring strategy strikes the ideal balance between future-proofing and budget constraints? The reassuring news is that backward compatibility remains paramount. The pace at which you refactor your codebase to leverage the latest framework features is entirely your choice. Join my talk for a practical session where we explore these new APIs and discuss strategies to transform your code into a future-proof application.\n'parentId': 'R8y8tP2vbKi3twHpf'\n'parentDescription': The JavaScript Fullstack Conference - Angular, Node.js, React and more\n'indexBrandName': 'InternationalJavaScriptCon'\n'indexSeriesName': 'Munich'\n'author': 'Michael Egger-Zikes'\n'chunkSource': 'text'\n'text': Level-up your Angular Codebase with Cutting-Edge APIs The Angular team is propelling the enterprise frontend framework into a promising future with new, robust APIs. Modern concepts, validated in the JavaScript ecosystem, such as enhanced server-side rendering support, the new Control Flow syntax, Standalone APIs instead of NgModules, and optional RxJS, as well as Zone.js, are paving the way for a brighter future with an easier-to-manage codebase and an excellent developer experience. But how does this impact your current codebase? What refactoring strategy strikes the ideal balance between future-proofing and budget constraints? The reassuring news is that backward compatibility remains paramount. The pace at which you refactor your codebase to leverage the latest framework features is entirely your choice. Join my talk for a practical session where we explore these new APIs and discuss strategies to transform your code into a future-proof application. Um, I'm giving you a talk today about Angola again, quite nice, and we, the architects mantra already gave him No, we are not talking about shell symbolize a little bit older, tiny, nice, the new wave of features started actually, um, refactoring, uh, the rendering engine Ivy, you know. to make this compatible also internally for Google. It's like a, a surgery on the open heart, right? So they really learned out of the, I would might even say, The whole community was angry about that. to do this completely in a different way, So not the Angular bubble, only and maybe only with Angola. and the React people are thinking the same. So JavaScript experts and how the Angular team is meanwhile, um, trying, Uh, this is actually part of my presentation today. which new feature was added. Uh, people are not sure which APIs they need to implement one of the APIs that we're currently working and of course, questions are always welcomed. then feel free to ask. to the table that we can use right now So with Angular 13, they also did a quite important change, So Angular is a modern framework, As their, uh, support for Internet Explorer dropped out, um, of polyfils, although there was already a possible solution separately compiled. but, um, it, it turned out to be a good one. they introduced Atmos script models for the browser. Uh, if there are Atmos script models The CLI is managing quite a bunch of things for us. Um, and that's basically a thing that that helps us So with, uh, Angola 14, they introduced, um, having a new API that works, again, compatible side by side, in, uh,\n'slidetext': ''\n'from': 'vector'\n'score': 0.9100843667984009\n'normalizedScore': 0.890238323884271\n'beforeDatePenaltyScore': 0.9100843667984009\n\n'documentId': 'hzv9J8cq9SXBKG4bM'\n'chunk_id': '687a3240ca798166d3ba4f14'\n'access': 'restricted'\n'part_number': 1\n'total_parts': 1\n'contentType': 'FLEX_CAMP'\n'title': Lektion 6: Routing | verfügbar bis 01.12.2024\n'parentName': Angular Camp - Flexible Basic Camp November 2024 | online\n'language': 'DE'\n'date': '2024-11-18T07:00:00.000Z'\n'abstract': Der Router ist der Dreh-und-Angelpunkt der meisten Angular-Anwendungen. Er simuliert Seiten innerhalb einer Single-Page-Application und erlaubt Deep-Linking.\n'parentId': 'gum8pjxG5By6f2Fqv'\n'parentDescription': Das Angular Training für Einsteiger:innen mit Manfred Steyer im zeitlich flexiblen Online-Format\n'indexBrandName': 'AngularCamp'\n'indexSeriesName': 'FlexibleBasicCamp'\n'author': 'Manfred Steyer'\n'chunkSource': 'text'\n'text': Lektion 6: Routing | verfügbar bis 01.12.2024 Der Router ist der Dreh-und-Angelpunkt der meisten Angular-Anwendungen. Er simuliert Seiten innerhalb einer Single-Page-Application und erlaubt Deep-Linking.\n'slidetext': ''\n'from': 'vector'\n'score': 0.9090287685394287\n'normalizedScore': 0.8894481365835687\n'beforeDatePenaltyScore': 0.9090287685394287\n\n'documentId': '5ca564ac8c4557f4f949b660'\n'chunk_id': '687a2b82495b49563aa87ace'\n'access': 'restricted'\n'part_number': 2\n'total_parts': 9\n'contentType': 'RHEINGOLD'\n'title': Level-up your Angular Codebase with Cutting-Edge APIs\n'parentName': International JavaScript Conference Munich 2024\n'language': 'EN'\n'date': '2024-11-13T10:45:00.000Z'\n'abstract': The Angular team is propelling the enterprise frontend framework into a promising future with new, robust APIs. Modern concepts, validated in the JavaScript ecosystem, such as enhanced server-side rendering support, the new Control Flow syntax, Standalone APIs instead of NgModules, and optional RxJS, as well as Zone.js, are paving the way for a brighter future with an easier-to-manage codebase and an excellent developer experience. But how does this impact your current codebase? What refactoring strategy strikes the ideal balance between future-proofing and budget constraints? The reassuring news is that backward compatibility remains paramount. The pace at which you refactor your codebase to leverage the latest framework features is entirely your choice. Join my talk for a practical session where we explore these new APIs and discuss strategies to transform your code into a future-proof application.\n'parentId': 'R8y8tP2vbKi3twHpf'\n'parentDescription': The JavaScript Fullstack Conference - Angular, Node.js, React and more\n'indexBrandName': 'InternationalJavaScriptCon'\n'indexSeriesName': 'Munich'\n'author': 'Michael Egger-Zikes'\n'chunkSource': 'text'\n'text': managing quite a bunch of things for us. Um, and that's basically a thing that that helps us So with, uh, Angola 14, they introduced, um, having a new API that works, again, compatible side by side, in, uh, NG modules. Uh, control flow is an API that, uh, makes, uh, with Angola 16, um, as a, as a first version, um, Not all the parts or the APIs are stable right now. and hydration, that's, uh, moved much closer, uh, Does everyone need server-side rendering? So also as, uh, a feature that, um, they worked on introducing a new build tool with the that dramatic breaking changes. Um, but at the end, um, a lot but it was also a quite solid story or is still one. for signals like supporting data access scenarios, um, Uh, what's the news about about that? what you should work on right now I'm working in the Angular to pronounce for in almost every language, including German. and I'm happy to speak at conference conferences like this. and always happy to help with other, um, customers in, or have, they will call it in future. to discussions on social media platforms. you know, platform effect So if you like, um, my talks, then maybe one a new format using the new APIs. Uh, so let's get back to the topic. to the Angular team, um, a company enterprise, uh, with quite a, uh, quite a bunch to stay backwards compatible, in the other direction. That means if they would try to keep it but keep everything as it is, likely there would be a threat there's more going on in the React ecosystem, to a different tech stack, let's do that On the other hand, if you do innovation, different concepts found a really nice sweet spot in between of innovating, Engine modules, no signals, RXGS usage. Yeah. that you never need to, to upgrade your applications to upgrade your code base in future. of your companies, um, need to be aware of. That's also one thing that we as a developer, uh, need for the company, uh, possible as well. So if they say, no, we don't, we don't like the, They also have breaking changes. Same for you. Yeah. Fine. clearly set a replacement for engine modules. And this will change with Angola 19. You might argue. Now that's not good Um, don't worry about that just add standalone falls to your other, uh, So the, the concept of angular working with the CLI that this is really nothing to worry. NG module, uh,\n'slidetext': ''\n'from': 'vector'\n'score': 0.9087773561477661\n'normalizedScore': 0.888931313233002\n'beforeDatePenaltyScore': 0.9087773561477661\n\n'documentId': '04d78d5f018fc264533778bd'\n'chunk_id': '687a2114a98d5a30b3a341b0'\n'access': 'restricted'\n'part_number': 3\n'total_parts': 9\n'contentType': 'RHEINGOLD'\n'title': The Power of Angular’s Dependency Injection and Directives\n'parentName': International JavaScript Conference Munich 2024\n'language': 'EN'\n'date': '2024-11-12T13:15:00.000Z'\n'abstract': The Angular framework's built-in Dependency Injection (DI) mechanism has been integral since its inception, earning praise from the JavaScript ecosystem. While DI is commonly used for root-scoped services, its versatility extends beyond this. In this in-depth talk, developers will gain practical insights to unlock Angular's DI system fully.From understanding provider hierarchies to utilizing Dependency Injection for customizing your application, attendees will enhance their personal Angular toolbox. Additionally, we'll demystify the Injection tree, clarifying Injector node lifecycles and utilization. Directives are seamlessly integrated to imbue your Components with a generic, reusable approach by locally adding Providers.Join me as we explore Angular's Dependency Injection system practically to streamline your development workflows for greater efficiency.\n'parentId': 'R8y8tP2vbKi3twHpf'\n'parentDescription': The JavaScript Fullstack Conference - Angular, Node.js, React and more\n'indexBrandName': 'InternationalJavaScriptCon'\n'indexSeriesName': 'Munich'\n'author': 'Michael Egger-Zikes'\n'chunkSource': 'text'\n'text': CP client. I can even say disable my initial navigation. Yeah. Um, so basically we can tell the router, Hey, to specify some config. and is then automatically configured. we have quite a bunch of demos. because of all of those demos we have. zoom out a little bit Is this fine or Yeah, let's see. I turn my application quite small Then I just reload my application and then we are fine. and we can already see the dome structure here angular implementations, right? So why is there a list item? because that directive creates an injector node, added, um, to the dome. and components that are visibly. Give me a second. We have the whole the environment injector hierarchy, We had this on the previous slide, right? and if I further zoom out so that we can see the, dynamic tree changes. that it, yeah, it moves to the right. Yeah, those are the nodes So, um, but really zooming in again, we can see there is, otherwise we cannot grab the correct nodes. Like once again, I guess I, I hit one of the nodes and Yeah, it seems maybe it's a back in the, There's a router outlet, and that's really annoying. Yeah, I can't actually, I picked one of the last notes. move in the right direction. We have a, a engine style note here. structural directive, um, uh, components, uh, everything Be aware that part here, the element in chapter three, the one that stays in the do. therefore the injector node for the respective on a component level can lead on one hand again, it's recreated. to be loaded twice, with the very same configuration. the libraries back then, um, we are not, uh, that they were not correctly implemented. um, that back then you just never added a module Today we use providers instead of the od. providers array of the component. So they introduced typing the, so-called, uh, environment, can only be used for environment injector node. or in a lazy engine module. So it would just give you the feedback. Yeah, so those are the environment so-called NI injector as well. Give me a second. Um, so basically same again. it has a root node, then, um, then the, Uh, and then we have the platform scope. angular platform specific stuff. and then inside that platform, one I'm a hundred percent sure you all know that injector node, If you forget to provide a dependency service is never provided. then you receive the Nile injector So the top most is responsible only for throwing the errors. then it goes one level up, next\n'slidetext': ''\n'from': 'vector'\n'score': 0.9068311452865601\n'normalizedScore': 0.8869360156131709\n'beforeDatePenaltyScore': 0.9068311452865601\n\n'documentId': 'XE4Euthn2BEnPwhbr'\n'chunk_id': '687a2eed9bbcb45d2a11fb63'\n'access': 'restricted'\n'part_number': 1\n'total_parts': 1\n'contentType': 'FLEX_CAMP'\n'title': Lektion 6: Routing | verfügbar bis 06.10.2024\n'parentName': Angular Camp - Flexible Basic Camp September 2024 | online\n'language': 'DE'\n'date': '2024-09-23T06:00:00.000Z'\n'abstract': Der Router ist der Dreh-und-Angelpunkt der meisten Angular-Anwendungen. Er simuliert Seiten innerhalb einer Single-Page-Application und erlaubt Deep-Linking.\n'parentId': 'xBQz8C6wGGBZCG99t'\n'parentDescription': Das Angular Training für Einsteiger:innen mit Manfred Steyer im zeitlich flexiblen Online-Format\n'indexBrandName': 'AngularCamp'\n'indexSeriesName': 'FlexibleBasicCamp'\n'author': 'Manfred Steyer'\n'chunkSource': 'text'\n'text': Lektion 6: Routing | verfügbar bis 06.10.2024 Der Router ist der Dreh-und-Angelpunkt der meisten Angular-Anwendungen. Er simuliert Seiten innerhalb einer Single-Page-Application und erlaubt Deep-Linking.\n'slidetext': ''\n'from': 'vector'\n'score': 0.9090116620063782\n'normalizedScore': 0.8863602537948104\n'beforeDatePenaltyScore': 0.9090116620063782\n\n'documentId': 'N9G6dCb5BArvu6cbr'\n'chunk_id': '687a2d549bbcb45d2a11eac1'\n'access': 'restricted'\n'part_number': 14\n'total_parts': 23\n'contentType': 'RHEINGOLD'\n'title': Renovate your Angular App!\n'parentName': International JavaScript Conference San Diego 2024\n'language': 'EN'\n'date': '2024-05-21T12:30:00.000Z'\n'abstract': The Angular Team is currently pushing the popular enterprise frontend framework into a bright future. New APIs proved to be solid in the JavaScript ecosystem and quicker start-up time introduced more advanced server-side rendering support. Combined with the new Control Flow syntax, it feels like a perfect joint venture between Svelte and .NET. The Standalone APIs make NgModules optional too. RxJS and Zone.js won't be a mandatory dependency in the future anymore. But what does this mean for your current codebase? Which refactoring strategy is the best compromise between good preparation for the future and tight project budgets? The good news is that all of this comes with backward compatibility in mind. It is your decision which pace to use to refactor your codebase to the latest framework features. In a practical session, we'll discuss those new APIs and discover ways to transform your code into a future-proof application.\n'parentId': 'BYZWRge2q657D9ZYR'\n'parentDescription': The Fullstack Conference for JS Development\n'indexBrandName': 'InternationalJavaScriptCon'\n'indexSeriesName': 'SanDiego'\n'author': 'Michael Egger-Zikes'\n'chunkSource': 'text'\n'text': implemented with normal APIs as we use them before angular, even 14 maybe. Uh, and the rest of the application or the child component can be implemented with signals. Also, the other ways allow them internally using input output decorators in the parent and, uh, signals suppose is fine. Okay, so let's turn back to the slides. Uh, what about the route integration? Um, we can use, um, uh, a route of configuration. Um, and, uh, instead of the feature module, we are using an array right now. Um, that means, um, often not that much to refactor because, uh, if you already generated your feature modules, feature routing modules, um, with the Angular CLI, so, uh, NG generate module minus, minus routing, then it already created a feature routing module and had already, uh, a rooting constant for your arrays. So in this case, you just need to get rid of the module part and can reuse the array that is already present and provide the, um, array through lazy loading. And on the root level, we are using provide router, so provide router to, uh, actually hand over the, um, configuration on the root scope. Um, we can also use the Ford exports. So that's basically a nice thing to get rid of the, um, of the dense statements in your lazy loading load children configuration or load component configuration. Um, and, uh, we can also use a quiet nice, a really loved feature component input bindings, that's a feature for the angular router. Um, in the past, uh, without, uh, that feature, we needed to, uh, inject the activated route to get access to UL parameters or also, um, resolver data or static root data. All of that was only present through the activated route and we needed to inject it and subscribe to observers and all that stuff. Um, this time we can really use, um, the route to map, um, all those parts. So there are specific priority order on query parameters, dynamic parameters of the UL data block in the routing configuration and resolver data. Uh, and basically, um, if the route finds something with that name, with that respective name, for example, I'm interested in the id, then I have an ID input binding, and it works with input decorators, but also with input signal functions, both this, um, supported by the feature. So if someone, if the root of finds a respective property in the target component and there's something in the URL or in the rooting configuration that matches the exact name, then it automatically sets the input. So in the past, it was not very helpful to have input properties for root able\n'slidetext': ''\n'from': 'vector'\n'score': 0.9156763553619385\n'normalizedScore': 0.8861904722683311\n'beforeDatePenaltyScore': 0.9156763553619385\n\n'documentId': '5ca564ac8c4557f4f949b660'\n'chunk_id': '687a2b82495b49563aa87acf'\n'access': 'restricted'\n'part_number': 3\n'total_parts': 9\n'contentType': 'RHEINGOLD'\n'title': Level-up your Angular Codebase with Cutting-Edge APIs\n'parentName': International JavaScript Conference Munich 2024\n'language': 'EN'\n'date': '2024-11-13T10:45:00.000Z'\n'abstract': The Angular team is propelling the enterprise frontend framework into a promising future with new, robust APIs. Modern concepts, validated in the JavaScript ecosystem, such as enhanced server-side rendering support, the new Control Flow syntax, Standalone APIs instead of NgModules, and optional RxJS, as well as Zone.js, are paving the way for a brighter future with an easier-to-manage codebase and an excellent developer experience. But how does this impact your current codebase? What refactoring strategy strikes the ideal balance between future-proofing and budget constraints? The reassuring news is that backward compatibility remains paramount. The pace at which you refactor your codebase to leverage the latest framework features is entirely your choice. Join my talk for a practical session where we explore these new APIs and discuss strategies to transform your code into a future-proof application.\n'parentId': 'R8y8tP2vbKi3twHpf'\n'parentDescription': The JavaScript Fullstack Conference - Angular, Node.js, React and more\n'indexBrandName': 'InternationalJavaScriptCon'\n'indexSeriesName': 'Munich'\n'author': 'Michael Egger-Zikes'\n'chunkSource': 'text'\n'text': 19. You might argue. Now that's not good Um, don't worry about that just add standalone falls to your other, uh, So the, the concept of angular working with the CLI that this is really nothing to worry. NG module, uh, based, uh, implementations uh, standalone APIs. uh, of a smart component. The smart component is engine module based, variables in general is all of them. This was, at the beginning at least, everyone expected components, but it turned out that we have right now, no matter whether or do already require the standalone API, so especially of your ad component decorator. if you want to switch your routing configuration, uh, and not, uh, engine modules anymore, they again, need to be standalone, Um, one day that they will come, clear guidance from the angular team, Uh, so we are, they will ask the community whether, uh, yet, but of course, we can expect one day in future, uh, so many years now. Um, so yes, definitely it will be necessary, um, uh, angular 15. or already, uh, production support for standalone. How can you do so? I will answer this in a moment. Um, Standalone features, uh, from existing engine modules by, uh, using, sorry, to implement new features, that's the point here. Don't, um, uh, use engine modules So try to, to implement new features already where, you know, that's an existing feature, Then consider, uh, turning that into, uh, support of migration? You cannot one So it's really a nice assistance, uh, compared at angular core standalone command. The first step is, um, of your repository you want to change. Yeah. So if you have a repository with several apps to generate the component in or the service in then you will find it's not the It's this time at angular core. Um, so that's also the reason why we typically choose the migration code, right? that would be the equivalent and you just tell the CLI, which package to use for that. And as mentioned, it's not a project like the project flag. to turn the whole repository with all apps or you want to dig deeper that application or only one feature of that application. to turn components, directives, pipes, um, where the module is currently located. And basically that's the thing that the CLI helps you with. uh, for you directly. So turning your, uh, feature based feature modules But this can be done quite easily manually, So whether it is safe to remove the feature module We have here repository So we have normal, uh, ENG modules, um, a boarding, g\n'slidetext': ''\n'from': 'vector'\n'score': 0.9060287475585938\n'normalizedScore': 0.8861827046431955\n'beforeDatePenaltyScore': 0.9060287475585938\n\n'documentId': 'ec8de39dac90e93f9fd00a92'\n'chunk_id': '687a312cca798166d3ba43b5'\n'access': 'restricted'\n'part_number': 11\n'total_parts': 12\n'contentType': 'RHEINGOLD'\n'title': Optimizing Angular Applications - Techniques for Performance Excellence\n'parentName': International JavaScript New York 2024\n'language': 'EN'\n'date': '2024-10-09T14:15:00.000Z'\n'abstract': In today’s fast-paced digital landscape, delivering high-performance applications is crucial for a seamless user experience. This presentation dives deep into proven strategies and best practices for optimizing Angular applications. We will explore advanced techniques such as lazy loading, change detection strategies, signal-based state management, and leveraging NgOptimizedImage for better load times. Attendees will gain insights into optimizing bundle sizes, efficient HTTP communication, tree-shaking, and more. Whether you're dealing with large-scale apps or looking to enhance performance in smaller projects, this session provides actionable takeaways to improve your Angular application's speed and efficiency.\n'parentId': 'xhXxg9ohmYPxSZtL6'\n'parentDescription': The JavaScript Fullstack Conference - Angular, Node.js, React and more\n'indexBrandName': 'InternationalJavaScriptCon'\n'indexSeriesName': 'NewYork'\n'author': 'Sonu Kapoor'\n'chunkSource': 'text'\n'text': significant performance when implemented correctly. So in order to implement this, you need to add the, provide experimental zones, change detection during the application bootstrap rep. You also need to remove zone js from your polyfil and make sure that you're using at least angular version 18. So before you enable zone less in your application, keep in mind that this API is currently experimental, so anything can change at any time. Uh, regardless of that, here is a snippet of how you could try this out and if you run into any issues, I suggest that you open a ticket in the GitHub angular repo so that the Angular team is aware of it. And that's it. I hope these tips were helpful and as always, please connect with me over LinkedIn or Twitter. Um, and again, the repo with all the amazing animations I did, um, are here in the GitHub repo. Any questions? Yeah, go ahead please. I think you refer something incorrect there actually on post, we'll check double three, not just confidence that changes. Okay. Right. So from what I remember, I think it's just the, the component and its ancestors, right? No, it checks the all three, but what does constantly checking, Okay, just When we say okay, check now. Yeah, change on input on observable. Yeah, asy observable and things like that. Yeah. Yes, but it'll select complete not only the company, what's changed that year is the signoffs. With signoffs we can, uh, use our push to as a way to be stable. Um, constant tracking and Okay, I was under the impression that it only checks the component, uh, and not the entire tree because then what's the difference between? Difference Is that it's not automatically changing. Uh, every time you plate changes you on complex, you can use use or push and you decide when all the updates finish. Mm-Hmm. Then you will call the, I don't remember the directive buyer, but force the check You Okay. Will Happen on the complete. Yeah. So you don't, you don't actually have to force it. Um, so if you have on push set up and any of your input references change, then it will automatically trigger the change detection. And also when you have async operations right, then it will also automatically do that. Um, yeah. But thank you. Any other questions? I think you had one. Yeah. Um, lazy loading, first part From the routing. Yeah. Seems so easy to implement. Is there, uh, any reason you wouldn't wanna implement that application? Um, that's a good question. I mean, it should be the default I think, right? Um,\n'slidetext': ''\n'from': 'vector'\n'score': 0.9078865051269531\n'normalizedScore': 0.8861306448605909\n'beforeDatePenaltyScore': 0.9078865051269531\n\n'documentId': 'xrng8DfDqckoEKvMr'\n'chunk_id': '687a30f3ca798166d3ba4157'\n'access': 'restricted'\n'part_number': 4\n'total_parts': 30\n'contentType': 'RHEINGOLD'\n'title': Angular 18: Neue Features optimal nutzen und Bestandsprojekte effizient migrieren\n'parentName': BASTA! Herbst 2024\n'language': 'DE'\n'date': '2024-09-18T13:30:00.000Z'\n'abstract': Seit Angular 16 hat Google umfassende Änderungen an seinem SPA-Framework vorgenommen, um es in das nächste Jahrzehnt der Webentwicklung zu führen. Damit einher geht eine nachhaltige Veränderung der Gestalt von Angular-Anwendungen: Es setzen sich zunehmend funktionale Schnittstellen durch, die die alten objektorientierten APIs sowie TypeScript-Dekoratoren ersetzen. Signals breiten sich Stück für Stück im Framework aus, sodass reaktive Programmierung immer wichtiger wird. Standalone-Komponenten und -APIs sind längst zum Standard geworden und die neue Kontrollfluss-Syntax vereinfacht häufige Anwendungsfälle im Template erheblich. Nicht zuletzt ist auch Server-Side Rendering nun zentraler Bestandteil des Frameworks geworden und . Christian Liebel stellt in dieser Session die Neuerungen in Angular 18 vor und gibt eine Einschätzung, ob, wann und wie Entwickler auf die neuen Features umsteigen sollen. Kommen Sie vorbei und bringen Sie Ihr Angular-Wissen auf den neusten Stand!\n'parentId': 'Hm6SdzajQWSYS6foi'\n'parentDescription': Die Konferenz für .NET, Windows & Open Innovation\n'indexBrandName': 'BASTA!'\n'indexSeriesName': 'Herbst'\n'author': 'Christian Liebel'\n'chunkSource': 'text'\n'text': eine andere Route gehen. Das hat man auch davor schon bauen können. Mit einem Guard hätte man es zum Beispiel implementieren können. Kann man jetzt einfach per Funktion machen und auf diese Art hinterlegen. Auch hier wieder eine kleine praktische Weiterentwicklung. Dann habt ihr vielleicht ng-content im Einsatz. Hier gibt es die Möglichkeit mithilfe des Select-Attributs sich ein spezielles einen speziellen Node zu ziehen, der dann in meinem Content als Komponente enthalten ist. Was bisher nicht ging, ist zu sagen, wenn ich dieses spezielle Ding nicht finde, dann einen Fallback anzuzeigen. Hier in dem konkreten Fall geht es also darum, plötzlich eine Begrüßung anzuzeigen, wenn es innerhalb des Contents von AppProfile einen Dom-Knoten gab, der auf die Klasse Greeting hört und wenn der nicht da ist, dann will ich einen Fallback anzeigen. Das war davor möglich, aber es war sehr hässlich. Das zu implementieren geht jetzt ganz einfach, indem man dann einen ng-content hinzufügt, das dann quasi keinen Select hat. Das würde dann angezeigt, wenn es eben keins mit Greeting davor gab. Das ist Fallback-Content, das ist sehr praktisch und eine gute Sache. Dann haben wir in Angular Material jetzt die Unterstützung für Material 3. Vielleicht habt ihr das im Einsatz und es sieht wunderschön aus, ja wie man sehen kann. Das letzte setzt eben die Stilvorgaben von Material 3 um. Dann haben wir TypeScript 5.4. Bei Angular Release werden ja die Dependencies quasi mit hochgezogen. Jetzt haben wir Unterstützung für TypeScript 5.4. Wenn man also dort spezielle Features aus diesem TypeScript Release braucht, kann man die mit Angular 18 einsetzen. Das sind einige der Neuerungen, die jetzt gekommen sind mit Angular 18. Wie gesagt, kleinere Dinge, die das Leben besser machen, aber für mich persönlich eben noch nicht so die richtig großen Knaller. Das sind nämlich vier andere Themen. Das sind zum einen Signals. Nichts Neues an und für sich. Signals werfen bereits seit längerem ihre Schatten voraus, was das Angular-Framework anbelangt. sind ein neuer reaktiver Basis-Datentyp, den man verwenden kann, der Reactive Primitive, wie man es nennt, und die Sie jetzt immer weiter im Framework ausbreiten. Das\n'slidetext': ''\n'from': 'vector'\n'score': 0.9071764945983887\n'normalizedScore': 0.8842682370717524\n'beforeDatePenaltyScore': 0.9071764945983887\n\n\n Dieser Content von  ist in deiner Sprache nicht verfügbar. Zurück zur Antwort"
}