{
  "test_id": "test_015_explore_en",
  "query": "How does useMemo work in React?",
  "endpoint": "reader_explore_text",
  "user": {
    "tier": "elevate",
    "language": "en"
  },
  "prompt": "main",
  "actual_response": "arrow_forward_iosDeine Suchergebnisse:  The real cost of React re-renders in 2025 Emīls PļavenieksFrontmania 2025 Formulare mit React: Gut in Form Nils HartmanniJS Magazin 5.2025 Essential React Tips: A Developer's Cheat S... Jaime GarciaiJS Magazine Volume 19 React-Grundlagen Nils HartmannModern React: von Null auf Full-Stack Das React-Ökosystem: ein Tag mit dem TanSta... Sebastian SpringerJavaScript Days München und online 2025 React 19.2 Explained: Updates, Impact, and ... Faris AziziJS Magazine Volume 22 Mastering React: 5 Antipatterns and How to ... Jonas HerrmannsdörferMastering React: Best Practices for Optimized Performance Scaling and Optimizing React Applications: ... Ahmed MegahdMastering React: Best Practices for Optimized Performance Managing Complex State in React Mary ShawInternational JavaScript New York 2025 React 2026 - Neue Features im Praxis-Check Nils HartmannW-JAX 2025 Caching, Payloads, and Other Dark Arts: A F... Faris AzizInternational JavaScript Conference Munich 2025 State Management in React Sebastian SpringeriJS Magazine Volume 20 React 19 – Die neuesten Features Sebastian SpringerEntwickler Magazin 6.2024 Mastering React: 5 Antipatterns and How to ... Jonas HerrmannsdörferInternational JavaScript Conference Munich 2024 Modern React Clientside SPAs with TanStack ... Nils HartmannInternational JavaScript Conference Munich 2024 React: Ein Blick zurück und nach vorne Nils HartmannW-JAX 2024 Hooked on Hooks in React Erin ZimmerInternational JavaScript New York SolidJS: The World Beyond Components Ryan CarniatoInternational JavaScript New YorkHow does useMemo work in React?gpt-4.1-mini keyword: {\n  'phrase_out': 'useMemo React',\n  'primary_version_array': [],\n  'secondary_version_array': [],\n  'year_array': ['2025','2026'],\n  'issue_array': []\n} \nThe useMemo hook in React is designed to optimize performance by memoizing the result of an expensive calculation so that it only recomputes when its dependencies change. This helps avoid unnecessary recalculations on every render, which can improve efficiency especially in complex or large-scale applications.\nKey concepts about useMemo in React include:\n\nuseMemo takes two arguments: a function that returns a computed value, and a dependency array. React will only recompute the memoized value if one of the dependencies has changed since the last render.\n\nOn the initial render, the function passed to useMemo runs and its result is stored. On subsequent renders, if dependencies are unchanged, React returns the cached value without running the function again.\n\nThis hook is particularly useful for expensive calculations or transformations that do not need to be recalculated on every render unless relevant inputs change. For example, sorting a large list or performing complex data filtering  [1.].\n\nuseMemo differs from useEffect in that it returns a memoized value during rendering, whereas useEffect is for side effects and runs after rendering. The dependency array in useMemo is required to control when recalculation happens.\n\nOverusing useMemo can complicate code and sometimes cause premature optimization. It is recommended to measure performance impact before applying it, as many calculations are inexpensive enough to run on every render without issue [1.].\n\nuseMemo is often paired with useCallback (which memoizes functions) and React.memo (which memoizes components) to optimize rendering behavior and avoid unnecessary re-renders [2.].\n\nWith the introduction of the React Compiler in React 19, some manual memoization with useMemo and useCallback may become less necessary, as the compiler automates many optimizations internally [2.].\n\n\nIn summary, useMemo is a React hook that caches the result of a computation and recalculates it only when specified dependencies change, helping to optimize rendering performance by avoiding redundant expensive calculations  [1.].\nIf you want to dive deeper into practical usage and performance considerations of useMemo and related hooks in React 19 and beyond, there are advanced talks and courses available that cover these topics with real-world examples and best practices.\n\nSources\n\nMastering React: 5 Antipatterns and How to Fix Them This seminar lesson examines common React antipatterns, their real-world impact, and practical strategies for improving code quality and performance. ✅ This content is included with your elevate membership.\n\nReact 19 – Die neuesten Features - Alles, was Sie wissen müssen This article examines the major new features and improvements introduced in React 19, including changes to APIs, performance, and developer experience. ✅ This content is included with your elevate membership.\n\n\n\nMore on this Topic\n\nScaling and Optimizing React Applications: Advanced Techniques for Large-Scale Projects This seminar lesson examines advanced strategies for scaling and optimizing React applications, including architecture, performance, and the use of meta frameworks. ✅ This content is included with your elevate membership.\n\nMastering React: 5 Antipatterns and How to Fix Them This conference talk examines five common React antipatterns, their real-world impact, and practical solutions for improving application performance. ℹ️ This talk of International JavaScript Conference Munich 2024 was part of a past event. Booking is no longer available, but you can discover the current edition right here on the platform.\n\nHooked on Hooks in React This conference talk explains how React hooks work under the covers, covering useRef, useState, useEffect, useMemo, and useCallback to build mental models and custom hooks. ℹ️ This talk of International JavaScript New York was part of a past event. Booking is no longer available, but you can discover the current edition right here on the platform.\n\n\nReference:\n{\n  'translated_headers': {\n    'sources': 'Sources',\n    'more_on_this_topic': 'More on this Topic'\n  },\n  'sources': [],\n  'more_on_this_topic': [\n    {\n      'doc_id': 'dce2e7fce63ba63cdf7ee57a'\n    },\n    {\n      'doc_id': '1afc9b7c648711b8f9bea5bc'\n    },\n    {\n      'doc_id': '1ae09fdefb18f120d737740a'\n    },\n    {\n      'doc_id': 'a0fdc76247703b13b691d244'\n    },\n    {\n      'doc_id': 'pPYMrzCiTznFHbfj7'\n    }\n  ]\n}\n\nChunks:\n'documentId': 'pPYMrzCiTznFHbfj7'\n'chunk_id': '687ad858eb1b160a4cabf323'\n'access': 'restricted'\n'part_number': 17\n'total_parts': 21\n'contentType': 'RHEINGOLD'\n'title': Hooked on Hooks in React\n'parentName': International JavaScript New York\n'language': 'EN'\n'date': '2023-09-28T08:30:00.000Z'\n'abstract': If you're using React, there's a good chance you've been writing functional components with hooks for a while now. And I think most of us would agree that hooks make our components cleaner and more elegant. But hooks have a dark side too - they can be confusing and make code more difficult to reason about. And what's going on with the Rules of Hooks? Why can I only use hooks inside component functions? And why can't I call them conditionally? To find out, we're going to have a look at how hooks work under the covers. We can then use this information to better understand what's going on in the hooks we use and help us to write our own custom hooks.\n'parentId': '7xbLG2AYJB4BSzpe9'\n'parentDescription': \n'indexBrandName': 'InternationalJavaScriptCon'\n'indexSeriesName': 'NewYork'\n'author': 'Erin Zimmer'\n'chunkSource': 'text'\n'text': our component. So we need to add it to our dependencies array. And when we do that, yes, link gets mad. So the consumer item function makes the dependencies of user effect change on every render, which is true, it does. 'cause every time this component renders we're creating a new function, right? This it, it looks the same, but it is actually a new object, which means that the dependencies array for the user effect has changed, which means that the effect is gonna run on every single render. In this particular case, it's not actually a problem, it just means it's gonna remove the, the listener and then add it again. Every, every render, which is like a bit wasteful, but it's not gonna break anything. But there are plenty of situations where this absolutely will break something. So what we need to do is we need to find a way to make this consumer item not be recreated unless it needs to be. Um, and it needs to be recreated only when items or set items change. Luckily we already have a hook for that, right? We can just use use memo. So this will work fine. This is great. Um, everything's fine except this. This is a bit ugly, isn't it? This whole like error functions that return error functions. I don't really like it. And it turns out the React team doesn't like it either so much that they created a whole hook just so that we don't have to do that. So we use callback, it's just use memo, but for functions and the way that it works is instead of using memo like this, uh, we can use use callback like this. And instead of passing in a function that returns a function, we just pass in the function. All right? This is my much nicer, much easier. Okay, cool. So that was all the hooks we got through them. I don't know what time we were supposed to finish this. I guess we got through them in time. Um, the things that we learned are that hooks are just erase inside closures. I mean they're a little bit witchcraft because closures are a little bit witchcraft, but I promise there is an underlying logic there. Use ref and you state store data between renders, but you state is better 'cause it triggers reruns. User effect is an escape hatch. So we use it for things that React doesn't understand, um, and use memo and use scroll back, unsurprisingly memorize things. Uh, Eve you would like to learn more about this stuff. Uh, I would recommend Switch's. He's got both a blog post and a\n'slidetext': ''\n'from': 'vector'\n'score': 0.9224843978881836\n'normalizedScore': 0.8800581368309791\n'beforeDatePenaltyScore': 0.9224843978881836\n\n'documentId': 'vKZKb8Mydxax9XAGi'\n'chunk_id': '687b43402b0a1813a73e47c6'\n'access': 'restricted'\n'part_number': 3\n'total_parts': 19\n'contentType': 'RHEINGOLD'\n'title': SolidJS: The World Beyond Components\n'parentName': International JavaScript New York\n'language': 'EN'\n'date': '2023-09-28T12:45:00.000Z'\n'abstract': Components have been the foundation of how we've built web applications for almost a decade now. They've defined not only how we organize our code but how it runs. In this talk, Ryan, author of SolidJS, will look at what comes after the component model. Driven by the need for more granularity, and empowered by compilation, reactivity is becoming the universal language of user interfaces.\n'parentId': '7xbLG2AYJB4BSzpe9'\n'parentDescription': \n'indexBrandName': 'InternationalJavaScriptCon'\n'indexSeriesName': 'NewYork'\n'author': 'Ryan Carniato'\n'chunkSource': 'text'\n'text': like this. Uh, hopefully you can do that. Um, you declare some state, you kind of wire it up to some kind of handler, you know, map over that data and then um, you know, it all kind of updates 'cause it just run runs. Again. Every time you change something, that thing that changes might not even be the list. You could change some unrelated piece of state, but as long as that state owned by that component updates, we're gonna re-render it. But it's okay, we got a virtual dorm. Um, and make sure that this is not particularly expensive. Re rendering means creating a new virtual dorm. It doesn't mean actually updating anything in the dawn, but you still might wanna optimize. So as your program grows, um, maybe you start passing some props in different kind of, you know, you got a filter theming, whatnot. Um, you start adding those and then you add like some memos to and react memo to memorize your component. And you do all these updates, some dependency arrays here I think, and your app works properly. Um, right, but it's kind of a departure from, from where we started right here to here. Okay, so what else can we do? Well, we can compile it, right? Uh, this meme is comparing react as felt floated around about two years ago, I guess now, maybe three years ago. I definitely felt the lack of dependency array envy from some circles. I mean, after all, when it just be better to express our intent with less code. Um, let's hold that thought. We're gonna get back to it. Now. I've thrown up way too much code for you to read. I wouldn't expect you to ever write this code yourself. This is what our to-do app might look like if we compile it in our memorization. This is not what you write, but what the compiler outputs. This is pseudo code from that same talk, um, where they're introducing react. Forget the re the React compiler, but it isn't all that different than what a framework likes felt, would be doing a bunch of shallow checks at every decision point that we run. When your component is marked as needing an update, common ground is user or event update state. We mark the component as dirty and we rerun it. We check against these memoed values, which I think are sitting in a memo, cache, uh, array that you see like throughout. And um, then, you know, we just update the path that that need to. The common ground though is that regardless when the user updates that state\n'slidetext': ''\n'from': 'vector'\n'score': 0.9233285784721375\n'normalizedScore': 0.88091202061128\n'beforeDatePenaltyScore': 0.9233285784721375\n\n'documentId': 'pPYMrzCiTznFHbfj7'\n'chunk_id': '687ad858eb1b160a4cabf31b'\n'access': 'restricted'\n'part_number': 15\n'total_parts': 21\n'contentType': 'RHEINGOLD'\n'title': Hooked on Hooks in React\n'parentName': International JavaScript New York\n'language': 'EN'\n'date': '2023-09-28T08:30:00.000Z'\n'abstract': If you're using React, there's a good chance you've been writing functional components with hooks for a while now. And I think most of us would agree that hooks make our components cleaner and more elegant. But hooks have a dark side too - they can be confusing and make code more difficult to reason about. And what's going on with the Rules of Hooks? Why can I only use hooks inside component functions? And why can't I call them conditionally? To find out, we're going to have a look at how hooks work under the covers. We can then use this information to better understand what's going on in the hooks we use and help us to write our own custom hooks.\n'parentId': '7xbLG2AYJB4BSzpe9'\n'parentDescription': \n'indexBrandName': 'InternationalJavaScriptCon'\n'indexSeriesName': 'NewYork'\n'author': 'Erin Zimmer'\n'chunkSource': 'text'\n'text': just a function and it takes two arguments. The first argument is another function, which whatever value is returned from this function is what use memo is gonna return. And the second item is a list of dependencies and it's just like use effect. If these dependencies change, then we'll re recalculate the value. And unlike use effect, this dependencies rate is required. Okay, so what does that look like in code? Well we've got a list of memos and our index to keep track of them. Um, we've got our component which has got uh, the items prop, it also has a set items prop, but uh, it's not important so we're gonna ignore it. And this time our items have the numbers on them so that we can see how many we have. So we can see when we re-sort them. All right? So we're gonna cause call you state and get our sort by uh, it starts off as undefined so there's nothing there. Then we're gonna call use memo and we're gonna pass in this calculator function that's gonna do the sorting and we're gonna pass in the list of dependencies, which is gonna point to our sort by value and our list of items. Then inside use memo, we're gonna grab the first item outta the memo array, which is undefined and we're gonna check if it needs updating. So to see if it needs updating, we're gonna say does it have a dependencies list? 'cause it's undefined, it doesn't have a dependencies list, so it needs to be updated. Then we are gonna actually do the calculation. It needs updating. So we'll calculate the sorted array and we'll put it in our memo object here. It's probably worth noting that that value array in inside the memo looks like the same arrays, the items array, but they're actually two separate objects. They're not the same, they're not the same. Um, object at all. Okay. Oh, where's the code going? All right, and then we're just gonna grab our return value and increment current index. Uh, that's a bit hard to read, okay? Uh, and our return value there is the sorted items that have come outta the value prop. Then we finish rendering our component. Everything's great reset current index. Okay? So now imagine if something changed inside some ancestor component and the ancestor had re-render and it caused all of its children to re-render, but it wasn't something that affected our things directly, right? So items and sought by are still the same. We're gonna call a component's gonna re-render. We're gonna call sort, uh, used memo and we're gonna\n'slidetext': ''\n'from': 'vector'\n'score': 0.9244632720947266\n'normalizedScore': 0.8820370110375221\n'beforeDatePenaltyScore': 0.9244632720947266\n\n'documentId': 'pPYMrzCiTznFHbfj7'\n'chunk_id': '687ad857eb1b160a4cabf317'\n'access': 'restricted'\n'part_number': 14\n'total_parts': 21\n'contentType': 'RHEINGOLD'\n'title': Hooked on Hooks in React\n'parentName': International JavaScript New York\n'language': 'EN'\n'date': '2023-09-28T08:30:00.000Z'\n'abstract': If you're using React, there's a good chance you've been writing functional components with hooks for a while now. And I think most of us would agree that hooks make our components cleaner and more elegant. But hooks have a dark side too - they can be confusing and make code more difficult to reason about. And what's going on with the Rules of Hooks? Why can I only use hooks inside component functions? And why can't I call them conditionally? To find out, we're going to have a look at how hooks work under the covers. We can then use this information to better understand what's going on in the hooks we use and help us to write our own custom hooks.\n'parentId': '7xbLG2AYJB4BSzpe9'\n'parentDescription': \n'indexBrandName': 'InternationalJavaScriptCon'\n'indexSeriesName': 'NewYork'\n'author': 'Erin Zimmer'\n'chunkSource': 'text'\n'text': a mechanism for reacting to props because React is a mechanism for reacting to props. That's, that's why it's called React. It's there in the name. Um, so as an example of what I'm talking about, uh, what we shouldn't do, uh, imagine we've added this sort functionality. Now we can sort by name or we can sort by how many we have and we might be tempted to write this code like this. So we might be tempted to add a bit of state that stores the list of sorted items and we might be tempted to add an effect that watches the list of items and watches the thing that we're sorted by and updates the sorted items when they change. And this, this is not the way to write this, this is not how React is intended to work. We look in the docs, they say don't use effects to transform data. If you can calculate some information from the component's props or its existing state variables during rendering, you should not put that information into that component state, which means you also don't need an effect to update it. So the way that we should write this code, um, we can calculate the sorted items from the items prop plus the sort by state. So we can just do it like this. We can just calculate it every time the component renders. This is, this is how this is intended to be written. This is the best way to write this. You can see it's quicker, it's easier to understand, but I'm sure someone's gonna say, but what my calculation is really expensive and I don't wanna run it every time the component renders. And I would say first check, is it really expensive? Is it really causing a problem? Go out and do some performance testing, whatever. We don't wanna optimize things prematurely. So for instance, our list of 10 items that we were just sorting, it's not gonna cause a problem, but maybe you know, you're sorting a list of 10,000 items or maybe you're calculating a Fitbit Nazi sequence. Has anybody ever done that outside a job interview? No. No. Okay, but let's say we're doing something expensive, right? So we need a hook for that. And the hook we can use is use memo. So the use memo hook memorizes a value. Um, what that means is that it's gonna calculate the value and it's gonna store that calculated value and it's only gonna recalculate it if it needs to. So we can memorize our sorted items here by wrapping them in used memo. So again, it's just\n'slidetext': ''\n'from': 'vector'\n'score': 0.9251991510391235\n'normalizedScore': 0.882772889981919\n'beforeDatePenaltyScore': 0.9251991510391235\n\n'documentId': 'a0fdc76247703b13b691d244'\n'chunk_id': '687a47b16b250430a47836e3'\n'access': 'granted'\n'part_number': 5\n'total_parts': 16\n'contentType': 'READ'\n'title': React 19 – Die neuesten Features - Alles, was Sie wissen müssen\n'parentName': Entwickler Magazin 6.2024\n'language': 'DE'\n'date': '2024-07-24T22:00:00.000Z'\n'abstract': 2024 ist das Jahr von React 19. Warum ist das so besonders? Weil das Team hinter der populären Bibliothek ein ziemliches Geheimnis um das nächste Release macht. Das neueste React-Release verspricht Verbesserungen sowohl an den APIs von React als auch an der Developer Experience sowie an der Performance von Applikationen. Was genau in React 19 auf Sie wartet, und ob sich das Update lohnt, erfahren Sie in diesem Artikel.\n'parentId': '88a1b1cb2d1279f2ae33dd83'\n'parentDescription': Das Entwickler Magazin bietet Software-Entwicklern Einblicke und Orientierung in einem Markt an Entwicklungstechnologien, -tools und -ansätzen, der stets komplexer wird. Mit seiner Kompetenz in einer breiten Palette an Programmiersprachen, Tools, Plattformen und Engineering-Techniken liefert es einen fundierten Marktüberblick und bietet technische Entscheidungshilfen für Entwickler, Projektleiter und Manager.\n'indexBrandName': ''\n'indexSeriesName': ''\n'author': 'Sebastian Springer'\n'chunkSource': 'text'\n'text': besser vermeiden sollten. Generell erschweren die Memoisierungsfunktionen die Lesbarkeit des Codes. Fällt das weg, ist es auf jeden Fall ein Gewinn für Lesbarkeit und Performance. Der React-Compiler wurde während der Entwicklung auch als React-Forget-Compiler bezeichnet, da Sie alles, was Sie bisher über Memoisierung wissen mussten, mit der Einführung des Compilers vergessen können. Rules of React Damit der Compiler seine Arbeit verrichten kann, muss Ihr Code einige Anforderungen erfüllen. Dafür gibt es die Rules of React. Wenn Ihnen das von den Rules of Hooks bekannt vorkommt, kommt das nicht von ungefähr – die Rules of Hooks sind Bestandteil der Rules of React. Auch wenn Sie den Compiler nicht verwenden möchten, sollten Sie sich dennoch an die Rules of React halten. Diese Regeln sind im Einzelnen: - Pure Komponenten und Hooks: Diese Regeln sorgen dafür, dass der Code verständlich, einfach zu debuggen und vor allem gut zu optimieren ist. Komponenten müssen idempotent sein: Bei gleichen Props, State und Context liefern Komponenten das gleiche Resultat. Seiteneffekte müssen außerhalb des Renderns ausgeführt werden: Seiteneffekte dürfen nicht direkt in der Komponentenfunktion gestartet werden, sondern müssen in useEffect gekapselt werden. Props und State sind immutable: Props und State sollten niemals manuell verändert werden. Rückgabewerte und Argumente von Hooks sind immutable: Was für Props und State einer Komponente gilt, gilt auch für Rückgabewerte und Argumente von Hooks. Werte sind immutable, sobald sie an JSX übergeben werden. - Komponenten müssen idempotent sein: Bei gleichen Props, State und Context liefern Komponenten das gleiche Resultat. - Seiteneffekte müssen außerhalb des Renderns ausgeführt werden: Seiteneffekte dürfen nicht direkt in der Komponentenfunktion gestartet werden, sondern müssen in useEffect gekapselt werden. - Props und State sind immutable: Props und State sollten niemals manuell verändert werden. - Rückgabewerte und Argumente von Hooks sind immutable: Was für Props und State einer Komponente gilt, gilt auch für Rückgabewerte und Argumente von Hooks. - Werte sind immutable, sobald sie an JSX übergeben werden. - React ruft Komponenten und Hooks auf: Der deklarative Ansatz sieht vor, dass Sie React das gewünschte Ergebnis beschreiben. Den Aufruf der zugehörigen\n'slidetext': ''\n'from': 'vector'\n'score': 0.911232054233551\n'normalizedScore': 0.8852749712585384\n'beforeDatePenaltyScore': 0.911232054233551\n\n'documentId': 'q4q3W4BHrY6ZxJKGc'\n'chunk_id': '687a353aca798166d3ba5ca8'\n'access': 'restricted'\n'part_number': 15\n'total_parts': 33\n'contentType': 'RHEINGOLD'\n'title': React: Ein Blick zurück und nach vorne\n'parentName': W-JAX 2024\n'language': 'DE'\n'date': '2024-11-07T11:00:00.000Z'\n'abstract': Das zurückliegende Jahr 2024 hat uns nach langer Zeit wieder ein neues React-Release beschert: Die Version 19 mit neuen Hooks, neuen Komponenten und neuen APIs. Dazu kamen interessante Neuerungen im React-Ökosystem, Fullstack-Ansätze, typsicheres Routing und neue Wege zum Arbeiten mit asynchronem Code und serverseitigen Daten. In diesem Vortrag möchte ich einen Blick zurückwerfen und euch die wichtigsten Neuerungen vorstellen, sodass ihr einen Überblick bekommt, welche neuen Möglichkeiten React für uns bereithält, um effizient Anwendungen zu bauen. Dabei werde ich euch mit viel Live Coding praktische Beispiele zeigen, sodass ihr einen realistischen Eindruck bekommt, wie sich zeitgemäßer React Code 2024 anfühlt bzw. 2025 möglicherweise anfühlen wird.\n'parentId': 'njpWcsL9nEXhCdjFG'\n'parentDescription': Die Konferenz für Java, Architektur- und Software-Innovation\n'indexBrandName': 'JAX'\n'indexSeriesName': 'W-JAX'\n'author': 'Nils Hartmann'\n'chunkSource': 'text'\n'text': ganz ganz aktuell gewesen. Da kommt das her,. Genau, also Compiler, im Optimalfall muss man es nur einschalten und dann hat man automatisch eine bessere Performance. Und was ich vor allen Dingen auch sehr gut daran finde, ist dass man mit diesem useCallback und useMemo und Memo-Komponenten nicht mehr rumhampeln muss. Die sind ja doch immer sehr, schreibt man doch viel Code und der ist auch fehleranfällig und so. Und hier kriegt man es jetzt einfach quasi Geschenkt. Gute Frage, also die Frage war, ich wiederhole das immer noch mal auch für die Leute nicht dabei sind hier vor Ort, wenn man jetzt Code hat, wo man schon useMemo und useCallback und sowas verwendet, ob das dann weiter funktioniert. Tatsächlich ist das so also es funktioniert weiterhin, ihr könnt die Sachen drin lassen, ihr könnt sie dann peu a peu einfach ausbauen. Das ist ziemlich ziemlich gut gemacht. Und man kann auch theoretisch dem Compiler sagen, optimiere mal diese Dateien oder nimm diese von der Optimierung raus. Wenn man feststellt, an irgendwelchen Stellen gibt es vielleicht doch auch Probleme im Verhalten. Sollte nicht sein, aber kann ja immer mal sein. Und es gibt zwei, drei Bibliotheken tatsächlich, die auch mit dem Compiler nicht nicht kompatibel sind. Das kann man vorher prüfen. Dann gibt es ein Tool, mit dem kann man das auschecken lassen. Und wenn man die Bibliotheken nicht benutzt, kann man das sozusagen dann so Schritt für Schritt Einführen. Wollen wir mal zum nächsten Thema. Genau. Was auch in React 19 jetzt neu ist, ist die sogenannte Use-Funktion. Da ist schon der Name irgendwie grenzwertig, weil wir normalerweise ja wissen, dass UseState, UseThis, UseJenes eigentlich Hook-Funktion sind, die gewissen Regeln unterworfen sind. Zum Beispiel, dass die nicht in einer If-Abfrage in der Vorschleife zu benutzen darf. Use ist tatsächlich eine Funktion, die hat mit Hooks gar nichts zu tun Die kann ich überall benutzen. Warum auch immer man auf den Namen dann gekommen ist. Für Leute, die versuchen, Wissen irgendwie bei React weiterzugeben, ist es für ihn ein Traum. Auf jeden Fall kann ich mit dieser\n'slidetext': ''\n'from': 'vector'\n'score': 0.91096431016922\n'normalizedScore': 0.8907903322170383\n'beforeDatePenaltyScore': 0.91096431016922\n\n'documentId': '7GNG8wNaXKkQxrpKH'\n'chunk_id': '687a2292d92aed38f5a4ab17'\n'access': 'restricted'\n'part_number': 8\n'total_parts': 8\n'contentType': 'RHEINGOLD'\n'title': Modern React Clientside SPAs with TanStack Query and TanStack Router\n'parentName': International JavaScript Conference Munich 2024\n'language': 'EN'\n'date': '2024-11-12T11:00:00.000Z'\n'abstract': In the React world, a lot is happening around the topic of full-stack applications, for example with Next.js or Remix. Luckily, however, the development of client-side single-page applications is not standing still in their shade. TanStack Query and TanStack Router are two interesting libraries that support us when working with typical use cases: working with (async) data and routing. The two libraries offer many features to fulfill even advanced requirements: Caching, type safety, file-based routing, support for React Suspense and Transitions, etc. In this talk, I would like to introduce you to the two libraries, which you can use independently of each other. I will use many code examples and live coding to give a practical impression of how these libraries work. Among others, we will see to what extent TanStack Query makes the use of useEffect superfluous and in which cases the new router can be a replacement for the classic React router.\n'parentId': 'R8y8tP2vbKi3twHpf'\n'parentDescription': The JavaScript Fullstack Conference - Angular, Node.js, React and more\n'indexBrandName': 'InternationalJavaScriptCon'\n'indexSeriesName': 'Munich'\n'author': 'Nils Hartmann'\n'chunkSource': 'text'\n'text': think the idea normally is that this and can be executed, um, a couple of times without problems. where the Js X code is constructed It's just the same in Redux. I think, or you have to build something, I think this is always synchronous. I have another Question. Yeah. Um, I think, um, we do not have next thing. I will just give you a very short example of the cache, um, and there is a thing, um, hopeful. and React, uh, router 10, stack Router, So here's this nice island button. and we see that the books are already in the cache. but you see the cache is populated. and it's getting, it's very fast information whether the data is stale or not. puts it in the cache and marks it immediately re fetching the data or not. but it's still visible. If I, um, wouldn't have, um, disabled all this, uh, actually I'm not sure if I, uh, have disabled it. Um, you normally, if you don't disable that, um, and in the background it re fetches the data your component is re rendered. For example, after a mutation, You can directly interact with the cache. Um, uh, things like that, that's quite advanced. Also, per can say every second, Um, unfortunately the lunchtime is also a powerful thing I hope you liked it. And if you have any questions,\n'slidetext': ''\n'from': 'vector'\n'score': 0.911057710647583\n'normalizedScore': 0.8911577052981411\n'beforeDatePenaltyScore': 0.911057710647583\n\n'documentId': '1ae09fdefb18f120d737740a'\n'chunk_id': '687a20f8a98d5a30b3a34096'\n'access': 'restricted'\n'part_number': 6\n'total_parts': 7\n'contentType': 'RHEINGOLD'\n'title': Mastering React: 5 Antipatterns and How to Fix Them\n'parentName': International JavaScript Conference Munich 2024\n'language': 'EN'\n'date': '2024-11-14T08:00:00.000Z'\n'abstract': This presentation unveils five critical antipatterns that have significantly slowed down our React application. Each section delves into a specific mistake, examining the challenges it created and the solutions implemented to address these issues. By analyzing real-world examples, this session offers invaluable insights and practical strategies for avoiding similar pitfalls in your development projects. Join us to gain the expertise needed to enhance performance and efficiency, driving your applications to new heights.\n'parentId': 'R8y8tP2vbKi3twHpf'\n'parentDescription': The JavaScript Fullstack Conference - Angular, Node.js, React and more\n'indexBrandName': 'InternationalJavaScriptCon'\n'indexSeriesName': 'Munich'\n'author': 'Jonas Herrmannsdörfer'\n'chunkSource': 'text'\n'text': it in state when it can be calculated during rendering. I mean it's probably not noticeable to the user but well it's one less update that we have simpler because you remove that use effect, we remove well it's quite easy to introduce some bugs So yeah, a lot of advantages Yeah, just do it. for cash and expensive calculations. Um, then we have a new to-do state This runs whenever the to-do changes or the filter changes But when we look at this, well it's the same thing again, and use effect and just do it during rendering. and we just can just render that so simple as that. But in this case, So if it is the case that the um, for expensive calculations. and the first render just runs the um, the code inside whenever the to-dos But if they don't change and doesn't have to rerun that get filter to-DOS function. otherwise it just used to memorize value But what is important first is well when is the And most of the time in the front end the calculations transforming a little bit of data that is not high-end device without any problems. and doing wild transformations. but that's something you have to discuss in, you should only do an optimization if you notice beforehand because your code just gets more complicated in because well no one will notice it anyway. what functions are really taking that that long of the time when my application had performance problems, 'cause I was asking for too much data and filter function or something like that. and GraphQL and react. Maybe some of you are using craft QL Um, yeah to recap that, well first and if it is expensive, well you should use use memo instead that one is actually happening quite often or have any other event. And additionally when someone else is reading that code, that is well happening from an event, to share when you should use uh, an uh, an event handler. The handle by click function, this adds a product and navigates to the checkout. Hmm. So we are doing that in use effect. and if that product is in the cart, we want Well okay why? Oops, why is that problematic? depending on what you do, maybe you store it in local that product is still in the card Well every time you refresh and your user gets kind of confused So when should it be in effect because the component was displayed Um, and in our case, well that shouldn't be run So how can we do that? We add a new function by product. We use that in the handle by click We also do that navigation to the checkout page. Well\n'slidetext': ''\n'from': 'vector'\n'score': 0.911060094833374\n'normalizedScore': 0.8912628292099595\n'beforeDatePenaltyScore': 0.911060094833374\n\n'documentId': 'dce2e7fce63ba63cdf7ee57a'\n'chunk_id': '6876df237899910dd58c0eab'\n'access': 'granted'\n'part_number': 8\n'total_parts': 22\n'contentType': 'COURSE'\n'title': Mastering React: 5 Antipatterns and How to Fix Them\n'parentName': Mastering React: Best Practices for Optimized Performance\n'language': 'EN'\n'date': '2025-02-25T14:36:13.000Z'\n'abstract': This presentation unveils five critical antipatterns that have significantly slowed down our React application. Each section delves into a specific mistake, examining the challenges it created and the solutions implemented to address these issues. By analyzing real-world examples, this session offers invaluable insights and practical strategies for avoiding similar pitfalls in your development projects. Join us to gain the expertise needed to enhance performance and efficiency, driving your applications to new heights.\n'parentId': '159bcfd9af1467befd4bbe7b'\n'parentDescription': According to the 2024 JavaScript survey, React remains the top frontend framework, solidifying its dominance in web development. Unlock the full potential of React.js with this course designed for developers looking to optimize, scale, and modernize their React applications. From avoiding common antipatterns to implementing server components, you will gain hands-on experience with the latest React innovations and dive deep into real-world projects.\n'indexBrandName': 'InternationalJavaScriptCon'\n'indexSeriesName': ''\n'author': 'Jonas Herrmannsdörfer'\n'chunkSource': 'text'\n'text': also pass the move down and move up function. And what will now happen is, well we will get a warning that child enlist should have a unique key. You probably read that in your console as well sometime, but why does react even need keys? So um, an example that on the React documentation, why react uh, need keys is about files. So imagine you have a file system on your MacBook for example like here and you don't have names for that file system. Uh, you just have the order of the file. So the red file we can see here, well that's named first file, the green file, the second file, and the yellow file. Well it's the third file and I guess we can get used to that. It's a bit well confusing because we are just have the information about the order. But I mean it should work. But what is happening if we are removing a file, so say for example here we removed the first file, what is now happening, the names are changing because now what was the second file beforehand is now the first file, it was the third file, it's now the second file. Okay? And it is similar for um, react. If you just use an index, well it kind of gets confusing or react itself because it can't identify what um, element via rendering there. So what React is doing, it needs these keys to identify the items itself and to make some changes on what to render or well not render. And in our example, well we did the same thing. Um, we split this mistake and we used index as a key. So in this case, same situation with the files, everything is just named from the index. And well, when the order changes it might get a bit confusing. And in our case when we have our application, so we are rendering our to-dos for each to-do we have a button where we can move to to-do up or down? Well then it kind of gets messy. We click down and we click up and this selected element from the button, well it just stays below so it doesn't move up with this uh, with the row itself. So this is not what we want. So how can we fix that? Well, we can fix that by using a unique key that helps react identify what element should be shown where, um, and stays the same when we are changing the order of our array. But where should we get our key? Well the most obvious solution and the solution I use in 99% of the cases we should use a database key because they are unique by nature.\n'slidetext': ''\n'from': 'vector'\n'score': 0.9063214063644409\n'normalizedScore': 0.8921830530951613\n'beforeDatePenaltyScore': 0.9063214063644409\n\n'documentId': 'a0fdc76247703b13b691d244'\n'chunk_id': '687a47b16b250430a47836e2'\n'access': 'granted'\n'part_number': 4\n'total_parts': 16\n'contentType': 'READ'\n'title': React 19 – Die neuesten Features - Alles, was Sie wissen müssen\n'parentName': Entwickler Magazin 6.2024\n'language': 'DE'\n'date': '2024-07-24T22:00:00.000Z'\n'abstract': 2024 ist das Jahr von React 19. Warum ist das so besonders? Weil das Team hinter der populären Bibliothek ein ziemliches Geheimnis um das nächste Release macht. Das neueste React-Release verspricht Verbesserungen sowohl an den APIs von React als auch an der Developer Experience sowie an der Performance von Applikationen. Was genau in React 19 auf Sie wartet, und ob sich das Update lohnt, erfahren Sie in diesem Artikel.\n'parentId': '88a1b1cb2d1279f2ae33dd83'\n'parentDescription': Das Entwickler Magazin bietet Software-Entwicklern Einblicke und Orientierung in einem Markt an Entwicklungstechnologien, -tools und -ansätzen, der stets komplexer wird. Mit seiner Kompetenz in einer breiten Palette an Programmiersprachen, Tools, Plattformen und Engineering-Techniken liefert es einen fundierten Marktüberblick und bietet technische Entscheidungshilfen für Entwickler, Projektleiter und Manager.\n'indexBrandName': ''\n'indexSeriesName': ''\n'author': 'Sebastian Springer'\n'chunkSource': 'text'\n'text': erfüllen kann. Doch zunächst sollten wir die Frage klären: Warum brauchen wir ein weiteres Werkzeug für React? Der Compiler optimiert den Code Ihrer Applikation zur Build-Zeit. Die wichtigste Aufgabe des Compilers ist die Memoisierung von Strukturen. Das Thema Memoisierung gibt es in React schon deutlich länger als die Überlegung für den Compiler. Die folgenden Funktionen können Sie bereits jetzt für die Memoisierung von Komponenten, Funktionen und Objekten verwenden: - memo: Mit dieser Funktion können Sie Komponenten memoisieren. Die Komponenten, die Sie dieser Funktion übergeben, rendert React nur neu, wenn sich ihre Props ändern. Dazu vergleicht React die Prop-Werte zwischen den Render-Zyklen. Sie können die Standardvergleichsfunktion durch Ihre eigene Implementierung ersetzen. Allerdings besitzt die Memoisierung mit der memo-Funktion für React lediglich einen Vorschlagscharakter. Die Bibliothek entscheidet in letzter Instanz immer selbst, ob eine Komponente neu gerendert wird. Sie sollten memo also nur zur Verbesserung der Performance und nicht zum Steuern von Render-Zyklen verwenden. - useMemo: Die memo-Funktion arbeitet mit ganzen Komponenten. Wollen Sie innerhalb einer Komponente den Wert einer Berechnung speichern, sodass er beim Neurendern nicht wieder berechnet werden muss, können Sie useMemo verwenden. Dieser Funktion übergeben Sie eine Callback-Funktion, die einen Wert berechnet, und ein Array von Abhängigkeiten. Sobald sich eine der Abhängigkeiten ändert, wird der Wert erneut berechnet, ansonsten arbeitet React mit dem zwischengespeicherten Wert. - useCallback: In React arbeiten Sie sehr häufig mit Callback-Funktionen. Auch diese können Sie mit useMemo memoisieren, damit die Funktionsobjekte nicht bei jedem Render-Zyklus neu erzeugt werden. useCallback ist eine Hilfsfunktion, deren Funktionalität Sie mit etwas mehr Aufwand auch mit useMemo nachbilden können. Der React-Compiler macht diese Funktionen überflüssig und erlaubt Ihnen vor allem, sich keine Gedanken mehr machen zu müssen, wann Sie die Funktionen einsetzen und wann Sie sie besser vermeiden sollten. Generell erschweren die Memoisierungsfunktionen die Lesbarkeit des Codes. Fällt das weg, ist es auf jeden Fall ein Gewinn für Lesbarkeit und Performance. Der React-Compiler wurde während der Entwicklung\n'slidetext': ''\n'from': 'vector'\n'score': 0.9205667972564697\n'normalizedScore': 0.8946097142814571\n'beforeDatePenaltyScore': 0.9205667972564697\n\n'documentId': '1afc9b7c648711b8f9bea5bc'\n'chunk_id': '6876cd0c225e92fc1ac78a4e'\n'access': 'granted'\n'part_number': 15\n'total_parts': 15\n'contentType': 'COURSE'\n'title': Scaling and Optimizing React Applications: Advanced Techniques for Large-Scale Projects\n'parentName': Mastering React: Best Practices for Optimized Performance\n'language': 'EN'\n'date': '2025-02-25T14:36:13.000Z'\n'abstract': In this session, we'll explore critical strategies for scaling and optimizing React applications to ensure top performance as your projects grow. Learn how to structure large applications for long-term scalability, manage complex state efficiently, and handle large data sets without sacrificing speed. We’ll cover advanced techniques like code splitting, lazy loading, and component rendering optimizations, as well as methods to streamline build times in CI/CD pipelines. Whether you’re scaling a fast-growing app or managing a large enterprise project, this session provides actionable insights to future-proof your React applications for continued success.\n'parentId': '159bcfd9af1467befd4bbe7b'\n'parentDescription': According to the 2024 JavaScript survey, React remains the top frontend framework, solidifying its dominance in web development. Unlock the full potential of React.js with this course designed for developers looking to optimize, scale, and modernize their React applications. From avoiding common antipatterns to implementing server components, you will gain hands-on experience with the latest React innovations and dive deep into real-world projects.\n'indexBrandName': 'InternationalJavaScriptCon'\n'indexSeriesName': ''\n'author': 'Ahmed Megahd'\n'chunkSource': 'text'\n'text': the one who is responsible for deciding which, what we are, what exactly you need. Yeah, I think we, we finish here. Maybe feel free to con contact with me and maybe, um, we have more questions. Otherwise, we, we are done. Could we take any questions? Uh, no it, you just do it if you don't expect the slide Here, for example, we, we, if we are using, uh, a component that use filter, filter items is if the, when you, uh, is a parent component, have a props with the items and have another things, but the items is wasn't updated. So it doesn't make sense that we, when you run or re-render that you run everything and reload, uh, and co uh, and make the process of filtering the items again. So if the items didn't change, you try to use reacted memo. Uh, so it doesn't make the process again or render the item, uh, the components or the child component if it's not required. Mm-hmm, yes. But if it's, it's even, even it's more complex filter or maybe it could be a simple filter, but the items is a lot. But the easier, the easier example could be the user card that you, once you keep going, scrolling, navigating your data didn't change or prof data profile didn't change. So it doesn't, uh, doesn't make sense to keep re rendering this component. Anything else? Yeah, which part exactly? Yeah, what exactly? No, I, um, no, but I'm, I'm not sure as, as well how much it'll be able to do it because in general, act by default try to opt, optimize or automatically do a lot of things for you. But you, you know more about what you are doing in your project and when it's possible you could specify, uh, the cases or explain for the act how to build your project. That, so I don't know exactly the result for it. Anything else? Okay, so you could end the session. Thank you. You, I.\n'slidetext': ''\n'from': 'vector'\n'score': 0.9092563390731812\n'normalizedScore': 0.8951179858039016\n'beforeDatePenaltyScore': 0.9092563390731812\n\n'documentId': '11aa4ab6eae82f7b6df75323'\n'chunk_id': '68c26fc50a53cd001394ab8f'\n'access': 'granted'\n'part_number': 2\n'total_parts': 3\n'contentType': 'READ'\n'title': Essential React Tips: A Developer's Cheat Sheet - React 19's Must-Know Concepts\n'parentName': iJS Magazine Volume 19\n'language': 'EN'\n'date': '2025-06-24T22:00:00.000Z'\n'abstract': This cheat sheet offers a quick reference guide to key features and commands in React, helping developers streamline their workflow and accelerate development.\n'parentId': 'a1269c65e87d5b8ebcde4b28'\n'parentDescription': Broaden your knowledge and expand your JavaScript techniques and practices. From Angular, React, and WebAssembly, to the best JavaScript IDEs, open source tools and more, you’ll learn insights on everything JS from seasoned experts in their field. Keep up with JavaScript news, tips, and advice with interviews, tutorials, and in-depth articles.\n'indexBrandName': ''\n'indexSeriesName': ''\n'author': 'Jaime Garcia'\n'chunkSource': 'text'\n'text': Parent {children}  ); }  Child  Key Takeaway children is a special parameter in React that holds the elements inside a component. In the snippet above, children is equal to < h2 >Child. One important thing to remember is that React requires a root component. If you have multiple elements at the same level, you can wrap them using a Fragment to avoid unnecessary HTML wrappers. useEffect import { useEffect, useState } from 'react'; function Timer() { const [seconds, setSeconds] = useState(0); useEffect(() => { const interval = setInterval(() => { setSeconds((s) => s + 1); }, 1_000); return () => clearInterval(interval); // Cleanup }, []); return \n\nSeconds: {seconds}; } Remember useEffect runs on the client, not the server. The function passed to useEffect executes when the component is added to the DOM or when any of its dependencies (the second argument, an array) change. Additionally, an optional cleanup function can be defined, which React will run when the component is removed from the DOM. Rendering Arrays function TodoList() { const todo = [ 'Create project', 'Write code for the module A', 'Deploy the app' ]; return (  Todo List \n\n- {item}  ); } Insight The key to rendering an array in React is to iterate through it and build a JSX element. The most common method for this is .map(). It's also important to set a unique key for each element in the list. React uses this key to track and update nodes efficiently, improving performance when the list changes. Controlled Elements import { useState } from 'react'; function ControlledElements() { const [value, setValue] = useState(''); return (  setValue(event.target.value)} /> ); } Remember Controlled Elements rely on a state variable, allowing you to access the value as the user types. This is useful for validations or triggering side effects. Notice how the onChange listener receives a DOM event, which holds the value the user just entered. Conditional and Short-Circuit import Greeting from '../greeting'; import Counter from '../counter'; function Component() { const showGreeting = true const shortCircuit = true return (  Conditionals {showGreeting ?  : } {shortCircuit && \n\nShort-circuiting}  ); } Remember Conditional rendering and short-circuit evaluation are useful for toggling components. In the snippet above, the flag is\n'slidetext': ''\n'from': 'vector'\n'score': 0.9084420204162598\n'normalizedScore': 0.9008411018248087\n'beforeDatePenaltyScore': 0.9084420204162598\n\n'documentId': 'dce2e7fce63ba63cdf7ee57a'\n'chunk_id': '6876df237899910dd58c0eb3'\n'access': 'granted'\n'part_number': 16\n'total_parts': 22\n'contentType': 'COURSE'\n'title': Mastering React: 5 Antipatterns and How to Fix Them\n'parentName': Mastering React: Best Practices for Optimized Performance\n'language': 'EN'\n'date': '2025-02-25T14:36:13.000Z'\n'abstract': This presentation unveils five critical antipatterns that have significantly slowed down our React application. Each section delves into a specific mistake, examining the challenges it created and the solutions implemented to address these issues. By analyzing real-world examples, this session offers invaluable insights and practical strategies for avoiding similar pitfalls in your development projects. Join us to gain the expertise needed to enhance performance and efficiency, driving your applications to new heights.\n'parentId': '159bcfd9af1467befd4bbe7b'\n'parentDescription': According to the 2024 JavaScript survey, React remains the top frontend framework, solidifying its dominance in web development. Unlock the full potential of React.js with this course designed for developers looking to optimize, scale, and modernize their React applications. From avoiding common antipatterns to implementing server components, you will gain hands-on experience with the latest React innovations and dive deep into real-world projects.\n'indexBrandName': 'InternationalJavaScriptCon'\n'indexSeriesName': ''\n'author': 'Jonas Herrmannsdörfer'\n'chunkSource': 'text'\n'text': of code that looked very complicated and it's the same thing in the end. So to recap that because that was really simple, well don't put it in state when it can be calculated from existing props in state. What you should instead is just calculate it during rendering. And why is this good to do it? Well first of all you have faster code. I mean it's probably not noticeable to the user because it's just one extra update and it's not really expensive this calculation but well it's one less update that we have so already good and it was quite easy. And more important for me is the code gets a lot more simpler because you remove that use effect, we remove that use state, it's just easier to read. And additionally, if you add more logic in that use effect, well it's quite easy to introduce some bugs because the state is kind of getting out of sync in this use effect. So yeah, a lot of advantages and also it's not meant to well do it like that and not use use effect for it. Yeah, just do it. Um, during the rendering, the transformation. And now our next example where we shouldn't use use effect for cash and expensive calculations. What are we doing in this case? Well we have a to-do list again. Um, then we have a new to-do state and then we also have all the visible to-dos as state. And then we have another use effect. This runs whenever the to-do changes or the filter changes and well then in this set visible to-do we are also doing some filtering. But when we look at this, well it's the same thing again, it's just a transformation of some data. So well we can just um, avoid this redundant state and use effect and just do it during rendering. So we just use the get filter todos and we have all visible todos um, variable and we just can just render that so simple as that. But this is only the the case if this get filter todos is a normal function, nothing expensive is happening there. But in this case, I mean we are talking about expensive calculations so maybe there's something expensive in there. So if it is the case that this get filter todos is a very slow function, what can we do instead of using use effect But for that the um, yeah react has another hook which is called use memo. And that is actually or should be used for expensive calculations. What is use memo doing? Use memo first and the first render just runs the um, the code inside of the use memo function and just\n'slidetext': ''\n'from': 'vector'\n'score': 0.9154788255691528\n'normalizedScore': 0.9013404722998732\n'beforeDatePenaltyScore': 0.9154788255691528\n\n'documentId': '09c1d40fca67448b12b69d10'\n'chunk_id': '68ecc3644ddebd0013afffa9'\n'access': 'granted'\n'part_number': 6\n'total_parts': 12\n'contentType': 'READ'\n'title': State Management in React - Comparing lightweight approaches\n'parentName': iJS Magazine Volume 20\n'language': 'EN'\n'date': '2025-08-26T22:00:00.000Z'\n'abstract': Let’s examine several state management approaches and use cases in React, focusing on lightweight solutions with a low overhead and a limited impact on the overall application.\n'parentId': '5a3a6ad9da8f235bfee3bd9f'\n'parentDescription': Broaden your knowledge and expand your JavaScript techniques and practices. From Angular, React, and WebAssembly, to the best JavaScript IDEs, open source tools and more, you’ll learn insights on everything JS from seasoned experts in their field. Keep up with JavaScript news, tips, and advice with interviews, tutorials, and in-depth articles.\n'indexBrandName': ''\n'indexSeriesName': ''\n'author': 'Sebastian Springer'\n'chunkSource': 'text'\n'text': and free of side effects. This means that the same inputs always result in the same outputs and the current state is only changed based on the action provided. If you stick to this rule, your code will be clearer and better structured, and error handling is easier. You’ll also be more flexible when it comes to future software extensions. Listing 4 shows an implementation of state management with the useReducer hook. Listing 4: Using the useReducer-Hooks import { createContext, Dispatch, FC, ReactNode, useContext, useEffect, useReducer, } from 'react'; import { Cart, CartItem } from './types/Cart'; const SET_CART = 'setCart'; const ADD_TO_CART = 'addToCartAsync'; const FETCH_CART = 'fetchCart'; type FetchCartAction = { type: typeof FETCH_CART; }; type SetCartAction = { type: typeof SET_CART; payload: Cart; }; type AddToCartAsyncAction = { type: typeof ADD_TO_CART; payload: CartItem; }; type CartAction = FetchCartAction | SetCartAction | AddToCartAsyncAction; type CartContextType = [Cart, Dispatch]; const CartContext = createContext(null); type CartProviderProps = { children: ReactNode; }; function cartReducer(state: Cart, action: CartAction): Cart { switch (action.type) { case SET_CART: return action.payload; default: throw new Error(`Unhandled action type: ${action.type}`); } } function cartMiddleware(dispatch: Dispatch, cart: Cart) { return async function (action: CartAction) { switch (action.type) { case FETCH_CART: { const response = await fetch('http://localhost:3001/cart'); const data = await response.json(); dispatch({ type: SET_CART, payload: data }); break; } case ADD_TO_CART: { const response = await fetch('http://localhost:3001/cart', { method: 'PUT', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ items: [...cart.items, action.payload], }), }); const updatedCart = await response.json(); dispatch({ type: SET_CART, payload: updatedCart }); break; } default: dispatch(action); } }; } export const CartProvider: FC = ({ children }) => { const [cart, dispatch] = useReducer(cartReducer, { items: [] }); const enhancedDispatch = cartMiddleware(dispatch, cart); useEffect(() => { enhancedDispatch({ type: FETCH_CART }); }, []); return (  {children}  ); }; export function useCart() { const context = useContext(CartContext); if (!context) { throw new Error('useCart must be used within a CartProvider'); } return context; } export function useAddToCart() { const [, dispatch] = useCart(); const addToCart = (item: CartItem) => { dispatch({ type: ADD_TO_CART, payload: item }); }; return addToCart; } The CartProvider component is the starting point for implementation. It holds the context and creates the\n'slidetext': ''\n'from': 'vector'\n'score': 0.9077728986740112\n'normalizedScore': 0.9036240348770808\n'beforeDatePenaltyScore': 0.9077728986740112\n\n'documentId': '4ebfb70f9a681ab244108b0f'\n'chunk_id': '68f24f6fd754e200146e6e98'\n'access': 'restricted'\n'part_number': 11\n'total_parts': 16\n'contentType': 'RHEINGOLD'\n'title': Managing Complex State in React\n'parentName': International JavaScript New York 2025\n'language': 'EN'\n'date': '2025-09-30T15:15:00.000Z'\n'abstract': As React applications grow and succeed, managing state becomes increasingly complex—and expensive if left unchecked. But complexity doesn’t have to mean chaos. In this session, we’ll explore why thoughtful state management is critical for maintainability and performance. You’ll learn how to leverage powerful built-in React features and proven techniques to organize your state, reduce bugs, and keep your codebase scalable. Whether you're dealing with deeply nested components or asynchronous data flows, you'll leave with practical strategies to make your apps more robust and easier to evolve.\n'parentId': '9f97d5cdc68d72a05f834df4'\n'parentDescription': The JavaScript Fullstack Conference - Angular, Node.js, React and more\n'indexBrandName': 'InternationalJavaScriptCon'\n'indexSeriesName': 'NewYork'\n'author': 'Mary Shaw'\n'chunkSource': 'text'\n'text': choose. There's libraries, like I said, like Redux or um, or your network cache. A lot of people forget about your network cache. Like you're, you're, you're in your browser. HATP was built to cache the things that matter. And so sometimes you don't have to build an extra local storage layer right on top of it does does the exact same thing as your network because it's already there. Composition is bringing it all together and just organizing all the same bits in a way that makes sense for you and for everyone who comes after you after you get that promotion. 'cause you're such a good coder. Um, so the building blocks that I think for com composition is important. So I will have components that basically are display components. They don't do anything else. I'll have components that are context components that have the custom hooks. I'll have the custom hooks and a display component might have call a custom hook or two. Um, and then I'll have functions that aren't part of React that will make network calls and do all those things. And so the way you organize this matters for how that component, that app is going to be maintained over time, right? And uh, anytime if there's something new, for example, that search results search form search results, we built it in polymer and we, we built the historical record search form and built it and it was all finished and looked great and it was like, oh, let's add this to a different type of data to this, um, a different type of records that we're keeping. And so we had a different kind of a form for that. And so we had to start over. We had, it was gonna take twice as long basically to shoehorn the new one into the old one in polymer and then React came along and we didn't have to do it in polymer. And so, but the first thing we did in React was instead of writing a search form only for historical historical records, we wrote it for both historical records in our other genealogy data store. And because we did that and all the unit tests checked both 'cause I, we knew that this was gonna happen, right? And we'd already kind of seen the effects. We were able to write unit tests for both systems. And so when we had finished the historical records and they were like, oh, let's apply it to the other one, is that gonna take twice as much time? And I was like, no, I was done in a week because I'd already done it and I'd made sure it was set up this way.\n'slidetext': ''\n'from': 'vector'\n'score': 0.9060242176055908\n'normalizedScore': 0.9037777510689343\n'beforeDatePenaltyScore': 0.9060242176055908\n\n'documentId': '004c178a34c278c75190f756'\n'chunk_id': '6903813a52f58e0014b29c42'\n'access': 'granted'\n'part_number': 23\n'total_parts': 26\n'contentType': 'RHEINGOLD'\n'title': Caching, Payloads, and Other Dark Arts: A Frontend Engineer’s Journey\n'parentName': International JavaScript Conference Munich 2025\n'language': 'EN'\n'date': '2025-10-30T11:00:00.000Z'\n'abstract': This talk breaks down how we rescued a near-unusable frontend dashboard that was constrained by a rigid, third-party API and strict compliance requirements. The usual frontend performance tricks didn’t work, so we had to dig deeper. We started by diagnosing real usage issues through profiling and UX bottleneck analysis, which surfaced unexpected insights that reshaped our strategy. To regain control, we built a Backend-for-Frontend (BFF) layer using Next.js API routes. This let us shrink payloads, merge calls, and customize data delivery to suit the UI. On the frontend, we implemented caching strategies using TanStack Query, though the principles apply beyond that stack, to keep critical financial data accurate and reactive without overwhelming the UI. We handled lifecycle-sensitive updates, stale data, and render minimization under tight constraints. Throughout the journey, we navigated tradeoffs between compliance, performance, and UX, making conscious decisions on what to optimize and where to compromise. The session wraps with a live demo showcasing real implementation patterns and measurable before-and-after performance improvements.\n'parentId': 'd9a5c0715a7cff50bbb51e14'\n'parentDescription': \n'indexBrandName': 'InternationalJavaScriptCon'\n'indexSeriesName': 'Munich'\n'author': 'Faris Aziz'\n'chunkSource': 'text'\n'text': that timeout to 500 milliseconds, which it's most likely that the request on the server won't resolve, what happens is the timeout triggers on the server, it bails, the client starts to load and it's like, I don't have the dehydrated state, so I'm gonna make the request on the client's side, and it starts to reconcile between the server, uh, and the client to see what data it managed to fetch and what data it didn't manage to fetch. And so this way you've also got another layer of reser um resilience. Question at the end of the day is now, Faris, did we have to go through all this jumping of engineering loops and couldn't the back end have just made the diamond point? Um, it's not the point. The point is sometimes we can be pragmatic, sometimes we can, um, but sometimes we can be pragmatic, but we also want to be curious, and we also want to be creative with our solutions. And this solution that was put in place at the startup that I was working at previously actually lasted 2 years. It's probably still there today, because it allowed to unblock work for uh uh the back end to be able to work on more important things. You're able to actually drive a lot of the effort from a product perspective to work on the things that are actually important for the client or the end user. So yeah, sometimes you have to be creative. Now, I've got 9 minutes, so I'm going to actually go into a little bit of a teaser uh with what I had mentioned a little bit in the, The, the, the second half of the talk, which is, how can the data returned from my BFF actually improve react reconciliation? So, uh, react the way that it reconciles typically is that, um, it uses, you know, something called object dot is under the hood to be able to see if any dependencies or props have changed. And the easiest way to reconcile is actually with primitive types. So comparing strings, comparing numbers, so on and so forth. It's a little bit more complicated to reconcile. Reference based uh reference based types, so objects and arrays, that's why we tend to use use memo, because references aren't compared, it's you references are compared, you're not going to now go and look at every single key value pair in an object and see if that's the same, and then reconcile as a result of that. React is pragmatic, it's like the effort to check every single key value pair is probably more than just re-rendering the whole thing,\n'slidetext': ''\n'from': 'vector'\n'score': 0.9063405990600586\n'normalizedScore': 0.9057282649434933\n'beforeDatePenaltyScore': 0.9063405990600586\n\n'documentId': 'c7561d4953f0e9be339434dc'\n'chunk_id': '690e04350f4b7700138eb911'\n'access': 'granted'\n'part_number': 9\n'total_parts': 28\n'contentType': 'RHEINGOLD'\n'title': React 2026 - Neue Features im Praxis-Check\n'parentName': W-JAX 2025\n'language': 'DE'\n'date': '2025-11-06T11:00:00.000Z'\n'abstract': Seit der W-JAX vor einem Jahr sind gleich mehrere neue React-Releases erschienen, die eine Reihe von neuen Features mitbringen, um unsere Anwendungen flüssiger und schneller zu machen. Dazu gehören Activities, Fragment Refs, optimistische Updates und einiges mehr. Auch den React Compiler gibt es in einer 1.0-Version und auf der diesjährigen React 'Hauskonferenz' im Oktober wurde mit 'Async React' sogar eine ganz neue Strategie ausgegeben.  In diesem Live-Coding-Vortrag möchte ich euch die wichtigsten Neuerungen vorstellen, so dass ihr danach einen Überblick habt, was es an Neuigkeiten gibt und entscheiden könnt, welche davon für euch relevant sind.\n'parentId': '26c78c073b722105116a13de'\n'parentDescription': Die Konferenz für Java, Architektur- und Software-Innovation\n'indexBrandName': 'JAX'\n'indexSeriesName': ''\n'author': 'Nils Hartmann'\n'chunkSource': 'text'\n'text': Property nicht kennt. Aber nehmen wir mal an, wir hätten hier so eine leere Liste, die wir übergeben wollen. Dann wäre in dem Moment dieser Servings Chooser, wenn ich den mit Memo umschlossen hätte, würde der auch wieder jedes Mal neu gerändert werden, weil das hier eine neue Referenz auf ein leeres Array ist, sieht harmlos aus, führt aber tatsächlich dazu, dass wir diesen Memo- Effekt wieder ausgeschaltet haben. Und da kommt man vom 100. ins 1000. hier würde ich das vielleicht noch sehen. Ach ja, was habe ich denn da gemacht? Vielleicht habe ich dieses Array aber auch von der Oberkomponente übergeben. Und die erzeugen das nicht richtig und so weiter und so fort. Also schönes Thema ist ist es nicht. Und jetzt kommt endlich der React Compiler ins Spiel. Der verspricht uns nämlich, diesen ganzen Youth Callback und Memo und Usememo Kram und so für uns zu machen, für uns selber zu machen. Und damit wir das richtig schön sehen, mache ich jetzt mal hier meine. mache ich jetzt hier mal meine mühevoll implementierten Optimierungen wieder zurück. Das können wir hier einmal kopieren, das ist einmal vorher nachher sehen. So, Kolberg weg. Nein, bis daher. So. Und dann müssen wir einmal hier kurz die Memos entfernen. Kurz ist gut. So. also der Nachteil finde ich an diesem Ansatz, den ich jetzt gerade gewählt habe oder den wir bislang ja wählen mussten an diesem manuellen ist einerseits eben, was ich gerade bei H Callback gesagt habe. Man vergisst da irgendwie so eine Abhängigkeit hinzuschreiben oder auch bei den Properties. Also das ist fehleranfällig plus, wie wir hier auch sehen, finde ich, es macht den Code auch nicht unbedingt lesbarer. also eigentlich macht macht ihn schon schneller unter Umständen, aber eben nicht im eigentlichen Sinne besser. Also ich habe jetzt alles unsere Optimierung wieder zurückgängig gemacht. Und wenn wir jetzt hier neu rendern, dann sind wir wieder bei unseren 23. Natürlich. Und jetzt, meine Damen und Herren, habe ich in diesem Projekt den React Compiler installiert. Das ist ein Babel Plug-in. Und wenn ihr Vat benutzt, den Vat- Bild Server. Dann ist\n'slidetext': ''\n'from': 'vector'\n'score': 0.9073342680931091\n'normalizedScore': 0.9071054956203796\n'beforeDatePenaltyScore': 0.9073342680931091\n\n'documentId': 'c7561d4953f0e9be339434dc'\n'chunk_id': '690e04350f4b7700138eb912'\n'access': 'granted'\n'part_number': 9\n'total_parts': 28\n'contentType': 'RHEINGOLD'\n'title': React 2026 - Neue Features im Praxis-Check\n'parentName': W-JAX 2025\n'language': 'DE'\n'date': '2025-11-06T11:00:00.000Z'\n'abstract': Seit der W-JAX vor einem Jahr sind gleich mehrere neue React-Releases erschienen, die eine Reihe von neuen Features mitbringen, um unsere Anwendungen flüssiger und schneller zu machen. Dazu gehören Activities, Fragment Refs, optimistische Updates und einiges mehr. Auch den React Compiler gibt es in einer 1.0-Version und auf der diesjährigen React 'Hauskonferenz' im Oktober wurde mit 'Async React' sogar eine ganz neue Strategie ausgegeben.  In diesem Live-Coding-Vortrag möchte ich euch die wichtigsten Neuerungen vorstellen, so dass ihr danach einen Überblick habt, was es an Neuigkeiten gibt und entscheiden könnt, welche davon für euch relevant sind.\n'parentId': '26c78c073b722105116a13de'\n'parentDescription': Die Konferenz für Java, Architektur- und Software-Innovation\n'indexBrandName': 'JAX'\n'indexSeriesName': ''\n'author': 'Nils Hartmann'\n'chunkSource': 'text'\n'text': Property nicht kennt. Aber nehmen wir mal an, wir hätten hier so eine leere Liste, die wir übergeben wollen. Dann wäre in dem Moment dieser Servings Chooser, wenn ich den mit Memo umschlossen hätte, würde der auch wieder jedes Mal neu gerändert werden, weil das hier eine neue Referenz auf ein leeres Array ist, sieht harmlos aus, führt aber tatsächlich dazu, dass wir diesen Memo- Effekt wieder ausgeschaltet haben. Und da kommt man vom 100. ins 1000. hier würde ich das vielleicht noch sehen. Ach ja, was habe ich denn da gemacht? Vielleicht habe ich dieses Array aber auch von der Oberkomponente übergeben. Und die erzeugen das nicht richtig und so weiter und so fort. Also schönes Thema ist ist es nicht. Und jetzt kommt endlich der React Compiler ins Spiel. Der verspricht uns nämlich, diesen ganzen Youth Callback und Memo und Usememo Kram und so für uns zu machen, für uns selber zu machen. Und damit wir das richtig schön sehen, mache ich jetzt mal hier meine. mache ich jetzt hier mal meine mühevoll implementierten Optimierungen wieder zurück. Das können wir hier einmal kopieren, das ist einmal vorher nachher sehen. So, Kolberg weg. Nein, bis daher. So. Und dann müssen wir einmal hier kurz die Memos entfernen. Kurz ist gut. So. also der Nachteil finde ich an diesem Ansatz, den ich jetzt gerade gewählt habe oder den wir bislang ja wählen mussten an diesem manuellen ist einerseits eben, was ich gerade bei H Callback gesagt habe. Man vergisst da irgendwie so eine Abhängigkeit hinzuschreiben oder auch bei den Properties. Also das ist fehleranfällig plus, wie wir hier auch sehen, finde ich, es macht den Code auch nicht unbedingt lesbarer. also eigentlich macht macht ihn schon schneller unter Umständen, aber eben nicht im eigentlichen Sinne besser. Also ich habe jetzt alles unsere Optimierung wieder zurückgängig gemacht. Und wenn wir jetzt hier neu rendern, dann sind wir wieder bei unseren 23. Natürlich. Und jetzt, meine Damen und Herren, habe ich in diesem Projekt den React Compiler installiert. Das ist ein Babel Plug-in. Und wenn ihr Vat benutzt, den Vat- Bild Server. Dann ist\n'slidetext': ''\n'from': 'vector'\n'score': 0.9073342680931091\n'normalizedScore': 0.9071054956203796\n'beforeDatePenaltyScore': 0.9073342680931091\n\n'documentId': 'f8465c38d514d23af45f3eb0'\n'chunk_id': '690373b89669850016afad7a'\n'access': 'restricted'\n'part_number': 1\n'total_parts': 16\n'contentType': 'RHEINGOLD'\n'title': The real cost of React re-renders in 2025\n'parentName': Frontmania 2025\n'language': 'EN'\n'date': '2025-10-08T12:30:00.000Z'\n'abstract': Modern React makes it deceptively easy to write code that looks performant, but hides costly re-renders, hydration mismatches, and subtle CPU bottlenecks. As applications scale and ship to users on slower devices or flaky networks, these problems compound into real-world slowdowns. In this talk, I'll dive deep into profiling React applications in 2025, leveraging the latest React DevTools, flamegraphs, and field metrics to uncover unexpected re-render patterns. I'll compare how React 18 cooperative scheduling and batching stacks up against React 19 new compiler-backed partial signals and smarter diffing, showing side-by-side examples of how seemingly harmless hooks can differ dramatically in cost. Also will touch React Forget and what it will bring. Aside code examples it should also form a structure for a team how to properly test the performance of applications.\n'parentId': '501ad2dcdca77f2683bdde34'\n'parentDescription': \n'indexBrandName': ''\n'indexSeriesName': ''\n'author': 'Emīls Pļavenieks'\n'chunkSource': 'text'\n'text': The real cost of React re-renders in 2025 Modern React makes it deceptively easy to write code that looks performant, but hides costly re-renders, hydration mismatches, and subtle CPU bottlenecks. As applications scale and ship to users on slower devices or flaky networks, these problems compound into real-world slowdowns. In this talk, I'll dive deep into profiling React applications in 2025, leveraging the latest React DevTools, flamegraphs, and field metrics to uncover unexpected re-render patterns. I'll compare how React 18 cooperative scheduling and batching stacks up against React 19 new compiler-backed partial signals and smarter diffing, showing side-by-side examples of how seemingly harmless hooks can differ dramatically in cost. Also will touch React Forget and what it will bring. Aside code examples it should also form a structure for a team how to properly test the performance of applications. So, yeah, again, I, I hope you have, you're having a good time here because there have been uh quite a lot of good talks, and uh this will be about react, react and the re-renders and what's actually happening underneath to better understand of where we should seek for these performance improvements. So with that, we will start with a bit of React history. Like back in the wild wild west, uh there was this simple to understand reconciliation process, which was synchronous, yet it was blocking. Meaning that whatever we started to do, it had to be finished before we can do another interaction. For example, we clicked somewhere and we needed to wait until, let's say it was a list of and the filter input and we started to type something and we can see that what we're typing is that like lagging behind. And the list is slowly updating, and this is because it started to do this process and for the next input, like the browser did. Combine all of these events after and only then pushed it to React, so it was blocking and in the world of modern web apps, it was not good. So after that React offered us Weber and this was like. They told us that we have hope. We have hope to build something better. The main key difference was that it introduced the concurrent mode for the reconciliation process, meaning that all of these tasks that needed to be run were split into smaller pieces called fibers. Like they have their own attributes and like actions and rules they follow. However, the main thing was that it could have been that these smaller bits of fibers could be paused. In order for a higher priority task to be done. For example, if we\n'slidetext': ''\n'from': 'vector'\n'score': 0.9102048873901367\n'normalizedScore': 0.908390498479051\n'beforeDatePenaltyScore': 0.9102048873901367\n\n'documentId': '4ebfb70f9a681ab244108b0f'\n'chunk_id': '68f24f70d754e200146e6e9a'\n'access': 'restricted'\n'part_number': 13\n'total_parts': 16\n'contentType': 'RHEINGOLD'\n'title': Managing Complex State in React\n'parentName': International JavaScript New York 2025\n'language': 'EN'\n'date': '2025-09-30T15:15:00.000Z'\n'abstract': As React applications grow and succeed, managing state becomes increasingly complex—and expensive if left unchecked. But complexity doesn’t have to mean chaos. In this session, we’ll explore why thoughtful state management is critical for maintainability and performance. You’ll learn how to leverage powerful built-in React features and proven techniques to organize your state, reduce bugs, and keep your codebase scalable. Whether you're dealing with deeply nested components or asynchronous data flows, you'll leave with practical strategies to make your apps more robust and easier to evolve.\n'parentId': '9f97d5cdc68d72a05f834df4'\n'parentDescription': The JavaScript Fullstack Conference - Angular, Node.js, React and more\n'indexBrandName': 'InternationalJavaScriptCon'\n'indexSeriesName': 'NewYork'\n'author': 'Mary Shaw'\n'chunkSource': 'text'\n'text': would it That's a good com. That's a good question. So like in our, in our uh, my example of a reducer where I had that diagram with like 10 things on them, I could have put all the logic for all of those inside the switch statement and had a 3000 line file. But instead, like each one I just called a function. And so that function became, it didn't know about React, it didn't need to know about React 'cause it put put in input and it brought out output and it, so it's just a JavaScript function. It is supporting the React library, but it's just a function. Yeah, thanks for asking. Um, and so yeah, like I said, you just unit test each function. One of the things that's I think really helpful with React is they have this single source of truth principle. React has one source data has one source of truth and data only flows down. The thing on the, the most small child's component cannot change the upper component, but you can pass a function from a context down there and then you can call it to get that thing up to change. And that seems simple, but there are some engineers my org that just, it doesn't make sense to them. And so, and so they have certain problems with their, their code because they're like, well, we're setting this here and we're setting it again down there. Um, and then yeah, you, there are some engineers who have done some really interesting things because, um, they were trying to solve this, but they weren't tru truly understanding how to kind of organize it with a composition by putting it in the context and then sending it down and then passing the function and then you calling the function to set it up high again and then everything will just re-render. And it's, it won't be expensive if they, things that are expensive, call use memo, you can re-render a whole lot of things, but they don't actually re-render if their, their input doesn't change. So, so it's actually a lot faster than you think it might be. So we talked about the easy block combining the easy to, and we talked about breaking up the hard problem, but sometimes people just wanna know, how do I start, I'm starting, how do I make sure it's good? Um, and so the first thing I do, like when I'm starting a brand new app that's, I know it's gonna be really complicated. I just start with, um, betting the data, then I create a provider 'cause I know it's gonna have a lot of\n'slidetext': ''\n'from': 'vector'\n'score': 0.9107722043991089\n'normalizedScore': 0.9085257378624524\n'beforeDatePenaltyScore': 0.9107722043991089\n\n'documentId': '1afc9b7c648711b8f9bea5bc'\n'chunk_id': '6876cd0a225e92fc1ac78a44'\n'access': 'granted'\n'part_number': 5\n'total_parts': 15\n'contentType': 'COURSE'\n'title': Scaling and Optimizing React Applications: Advanced Techniques for Large-Scale Projects\n'parentName': Mastering React: Best Practices for Optimized Performance\n'language': 'EN'\n'date': '2025-02-25T14:36:13.000Z'\n'abstract': In this session, we'll explore critical strategies for scaling and optimizing React applications to ensure top performance as your projects grow. Learn how to structure large applications for long-term scalability, manage complex state efficiently, and handle large data sets without sacrificing speed. We’ll cover advanced techniques like code splitting, lazy loading, and component rendering optimizations, as well as methods to streamline build times in CI/CD pipelines. Whether you’re scaling a fast-growing app or managing a large enterprise project, this session provides actionable insights to future-proof your React applications for continued success.\n'parentId': '159bcfd9af1467befd4bbe7b'\n'parentDescription': According to the 2024 JavaScript survey, React remains the top frontend framework, solidifying its dominance in web development. Unlock the full potential of React.js with this course designed for developers looking to optimize, scale, and modernize their React applications. From avoiding common antipatterns to implementing server components, you will gain hands-on experience with the latest React innovations and dive deep into real-world projects.\n'indexBrandName': 'InternationalJavaScriptCon'\n'indexSeriesName': ''\n'author': 'Ahmed Megahd'\n'chunkSource': 'text'\n'text': you need. Same for the lazy, uh, lazy loading. If you don't need this now, you could, uh, load it later. Especially for example, if you, if you have a form and you have some imports, but you will use this import when you submit the form, so you don't need to, to import it from the beginning. Same way we could talk about React memo and use memo as well and use Quebec about, uh, preventing unnecessary update to the component. So here we have a user card and we have burned component that, uh, have props as a users take pro parameter as users and user card. We're using it as a child component. And inside it we use the user data. What's happened here that we, if the parent component was updated, this means the user card will be also updated. Uh, but what if we don't, uh, if the user data wasn't changed, but we have a lot of component inside and the user data wasn't changed, we, in this case, we don't use, we don't want to re-render the user card if it was rendered before, and I don't need it. Don't need, uh, to load it. Imagine if you have a dashboard or Facebook or LinkedIn or any website and you have your user details, that is al always a static in the header. It didn't change. So I don't need to re-render all this header every time that I refresh the page. So if you are linked in, normally the header is still static and you just, uh, render the site inside. So if you think that your, um, this component is not required to render, you could use, uh, react memo, which is help you, uh, to to store the, the case and track the user data. If it changed, it'll render. If not, it'll stay the same. Same for filter items. If you, if you have data, if you have a components that have a lot of calculations, and let's say we are doing a filtering for, for a, for a table. If the data didn't, if we rerender the form and the data didn't change, so doesn't make sense that we relearn the, uh, or re learned or make the calculation again. So if you using use memo, it'll memorize if this items was changed or not. If it changed, it'll make the filter process again. But if it didn't change, we don't have to to, to refilter and recalculate how the state of the data, again, same as for using callback. And this is, uh, similar, similar from rear-ending part. If you had parent\n'slidetext': ''\n'from': 'vector'\n'score': 0.9227443337440491\n'normalizedScore': 0.9086059804747695\n'beforeDatePenaltyScore': 0.9227443337440491\n\n'documentId': 'dce2e7fce63ba63cdf7ee57a'\n'chunk_id': '6876df247899910dd58c0eb4'\n'access': 'granted'\n'part_number': 17\n'total_parts': 22\n'contentType': 'COURSE'\n'title': Mastering React: 5 Antipatterns and How to Fix Them\n'parentName': Mastering React: Best Practices for Optimized Performance\n'language': 'EN'\n'date': '2025-02-25T14:36:13.000Z'\n'abstract': This presentation unveils five critical antipatterns that have significantly slowed down our React application. Each section delves into a specific mistake, examining the challenges it created and the solutions implemented to address these issues. By analyzing real-world examples, this session offers invaluable insights and practical strategies for avoiding similar pitfalls in your development projects. Join us to gain the expertise needed to enhance performance and efficiency, driving your applications to new heights.\n'parentId': '159bcfd9af1467befd4bbe7b'\n'parentDescription': According to the 2024 JavaScript survey, React remains the top frontend framework, solidifying its dominance in web development. Unlock the full potential of React.js with this course designed for developers looking to optimize, scale, and modernize their React applications. From avoiding common antipatterns to implementing server components, you will gain hands-on experience with the latest React innovations and dive deep into real-world projects.\n'indexBrandName': 'InternationalJavaScriptCon'\n'indexSeriesName': ''\n'author': 'Jonas Herrmannsdörfer'\n'chunkSource': 'text'\n'text': has another hook which is called use memo. And that is actually or should be used for expensive calculations. What is use memo doing? Use memo first and the first render just runs the um, the code inside of the use memo function and just returns these to-dos and then it memorizes these values and whenever the to-dos or filter change in the future it rerun that code and memorize it again. But if they don't change and you have a rerender, well then it just used to memorize value and doesn't have to rerun that get filter to-DOS function. So in this case, whenever the to-dos or filter change it reruns it, otherwise it just used to memorize value and you don't have any problems of this expensive calculation. But what is important first is well when is the calculation really expensive? Do we even need to use use memo? And most of the time in the front end the calculations are not that expensive. So we are just doing some sim simple things, transforming a little bit of data while maybe filtering something out and it runs on every normal smartphone that is not high-end device without any problems. So most of the time you don't have to do any optimization unless you're looping over thousands of objects and doing wild transformations. But then maybe you should think about doing that in the backend and not in the front end maybe, but that's something you have to discuss in, in your special use case. But to summarize that, you should only do an optimization if you notice performance problems. You don't should, you shouldn't do any optimizations beforehand because your code just gets more complicated in the end and no one else will understand it and it doesn't have any benefits because well no one will notice it anyway. And when you notice some performance problems, but you should do this, you should measure what functions are really taking that that long or are slow in the end. Because what I noticed most of the time when my application had performance problems, mostly the problem was in the communication with the backend. 'cause I was asking for too much data and because of that it took very long to load but not because I just run a simple filter function or something like that. But yeah, a little bit of advertisement there as well. There's one talk for me on YouTube about antipas and GraphQL and react. It's about things like that, about over fetching and under fetching. Maybe some of you are using craft QL and I will talk a little about a bit about problems and how you can do optimizations there. Um, yeah to recap\n'slidetext': ''\n'from': 'vector'\n'score': 0.9258149862289429\n'normalizedScore': 0.9116766329602976\n'beforeDatePenaltyScore': 0.9258149862289429\n\n'documentId': '98f008c2694c3d36e48d5bcf'\n'chunk_id': '69118b0a0f4b7700138ebd96'\n'access': 'granted'\n'part_number': 4\n'total_parts': 7\n'contentType': 'READ'\n'title': React 19.2 Explained: Updates, Impact, and What to Watch For - A practical walkthrough of React’s latest improvements and fresh performance insights\n'parentName': iJS Magazine Volume 22\n'language': 'EN'\n'date': '2025-12-16T23:00:00.000Z'\n'abstract': React 19.2 brings targeted improvements to performance, rendering, and overall developer experience. Key highlights include updates to the core library and optimizations in React DOM for faster, more efficient UI rendering. Let’s take a closer look at what’s new.\n'parentId': 'b6ef74991ae60010a55b93d4'\n'parentDescription': Broaden your knowledge and expand your JavaScript techniques and practices. From Angular, React, and WebAssembly, to the best JavaScript IDEs, open source tools and more, you’ll learn insights on everything JS from seasoned experts in their field. Keep up with JavaScript news, tips, and advice with interviews, tutorials, and in-depth articles.\n'indexBrandName': ''\n'indexSeriesName': ''\n'author': 'Faris Aziz'\n'chunkSource': 'text'\n'text': rule, which may leave you in the dark as the dependencies continue to grow and evolve. Take this great example from the React Docs: you’re building a chat app, and when a user joins a new room, you want to show a notification once the connection is ready: function ChatRoom({ roomId, theme }) { useEffect(() => { const connection = createConnection(serverUrl, roomId); connection.on('connected', () => { showNotification('Connected!', theme); }); connection.connect(); return () => connection.disconnect(); }, [roomId, theme]); } This looks fine, but there’s a subtle issue. If the user switches between light and dark themes while the chat is connected, the entire effect re-runs, disconnecting and reconnecting the socket, just to show the notification with the right color. It’s probably not what you were going for. The connection should only reset when roomId changes, not because of theming. What most would do in this case is remove the theme from the dependency array. However, that results in a linter warning, and you ultimately will have to disable it with a comment. This is where useEffectEvent shines. It lets you separate the “event reaction” logic from the “effect setup” logic, so React can handle updates to values like theme without forcing a teardown and reconnect. Here’s the same example rewritten: function ChatRoom({ roomId, theme }) { const onConnected = useEffectEvent(() => { showNotification('Connected!', theme); }); useEffect(() => { const connection = createConnection(serverUrl, roomId); connection.on('connected', () => onConnected()); connection.connect(); return () => connection.disconnect(); }, [roomId]); // ✅ Effect runs only when roomId changes } The key difference is that the onConnected callback always “sees” the latest theme, but the effect itself remains stable because the event handler’s identity never changes. React treats useEffectEvent callbacks as stable by design, meaning they don’t need to appear in dependency arrays. This pattern is incredibly useful in real apps. Think about analytics events, WebSocket subscriptions, or integrations with browser APIs. You often need to respond to events (connection open, visibility change, playback start, etc.) without tearing down your entire effect tree every time an unrelated prop changes. So if you’ve been in the habit of sprinkling eslint-disable-next-line react-hooks/exhaustive-deps above every useEffect that listens to external events, this new addition to React’s collection of hooks finally makes that unnecessary. Just make sure to upgrade your eslint-plugin-react-hooks to latest. Improving cache management with cacheSignal in React Server Components The cache() function, used exclusively with React Server Components (RSCs), allows you to memoize the results of data fetching or expensive computations across requests. Starting with React 19.2, the core\n'slidetext': ''\n'from': 'vector'\n'score': 0.9119709134101868\n'normalizedScore': 0.9139613190196489\n'beforeDatePenaltyScore': 0.9119709134101868\n\n'documentId': 'f8465c38d514d23af45f3eb0'\n'chunk_id': '690373b89669850016afad7c'\n'access': 'restricted'\n'part_number': 3\n'total_parts': 16\n'contentType': 'RHEINGOLD'\n'title': The real cost of React re-renders in 2025\n'parentName': Frontmania 2025\n'language': 'EN'\n'date': '2025-10-08T12:30:00.000Z'\n'abstract': Modern React makes it deceptively easy to write code that looks performant, but hides costly re-renders, hydration mismatches, and subtle CPU bottlenecks. As applications scale and ship to users on slower devices or flaky networks, these problems compound into real-world slowdowns. In this talk, I'll dive deep into profiling React applications in 2025, leveraging the latest React DevTools, flamegraphs, and field metrics to uncover unexpected re-render patterns. I'll compare how React 18 cooperative scheduling and batching stacks up against React 19 new compiler-backed partial signals and smarter diffing, showing side-by-side examples of how seemingly harmless hooks can differ dramatically in cost. Also will touch React Forget and what it will bring. Aside code examples it should also form a structure for a team how to properly test the performance of applications.\n'parentId': '501ad2dcdca77f2683bdde34'\n'parentDescription': \n'indexBrandName': ''\n'indexSeriesName': ''\n'author': 'Emīls Pļavenieks'\n'chunkSource': 'text'\n'text': after. So, the first thing is that react component will render if the state changes. This is easy to understand. If we use the US state in some component on any interaction or any other side effect, we change it, the component will re-render. The second thing is when a parent component re-renders, it will trigger, like propagate the re-renders down to the children and descendants of them. Gradually down until we hit some blocker that can stop that. Whoops. Third reason I was clicking with the reasons. Yeah. So 3rd reason is if the context changes. So if we have instantiated the context in our application and use the provider and we have some components using this context, whenever we change it, it will also trigger a render for this component. And the fourth option is hook, hooks. So for the hooks. Like in the hooks, we can do some complex calculations, some slow loading. Also calculations, variables, some data fetching, and whenever we update the states of these hooks, the components that use these hooks will also re-render. And can you raise your hands if you were thinking about something more? OK, there are a few, uh, and this brings us to one of the most common myths I think in the world of React, is that components will be rendered if the props changed, right? Uh, but it's not necessarily true because change in the props doesn't trigger anything. And for these props to be changed, the parent component needs to be re-rendered, so it has some side effects within it that passes the props down, but natively, the propagation of the children causes the children to render. And that leads to the first illusion, the misuse of memorization. As we know, React provides us with the utility hooks like use memo and use callback. To save references or save on complex calculations. There's also a react. memo where we can wrap the whole component within, and this is the place where this myth about the properties could come up because the react memo does a shallow comparison of all the props the component receives in order to decide to propagate further down or no. However, if we use this, like if we wrap everything within the memorization hooks or the dot memo, it doesn't always solve all of our issues. It could actually sometimes like give an overhead for the application to just do the same thing it was doing before, but now it does more calculations because it compares the memoized references and everything. And also like within these hooks, like use memo and use callback, we have the dependency arrays, right? And I'm sure a lot of you\n'slidetext': ''\n'from': 'vector'\n'score': 0.9202862977981567\n'normalizedScore': 0.918471908887071\n'beforeDatePenaltyScore': 0.9202862977981567\n\n'documentId': '1eed7659c187283042e70e2a'\n'chunk_id': '6876cd4b225e92fc1ac78ba0'\n'access': 'restricted'\n'part_number': 1\n'total_parts': 1\n'contentType': 'RHEINGOLD'\n'title': Das React-Ökosystem: ein Tag mit dem TanStack, React Router und vielem mehr\n'parentName': JavaScript Days München und online 2025\n'language': 'DE'\n'date': '2025-03-20T12:30:00.000Z'\n'abstract': Lerne das umfangreiche Ökosystem von React kennen. Es gibt kaum ein Problem, für das es keine Lösung in Form eines Pakets gibt. Dieser Workshop bietet dir die Möglichkeit, einen umfassenden Überblick über verschiedene React-Bibliotheken zu erhalten und praktische Erfahrungen im Einsatz dieser Tools zu sammeln. Der Fokus liegt auf spezialisierten Bibliotheken wie dem TanStack, React Router und react-hook-form, um typische Herausforderungen in der Entwicklung von React-Applikationen zu meistern, wie Serverkommunikation, Navigation und Formularhandling. Im Workshop wird vor allem hands-on gearbeitet. Du lernst durch praktische Übungen und das Schreiben von Code, den du direkt in deinen realen Anwendungen verwenden kannst. Der Workshop vermittelt Techniken für das Formularhandling mit react-hook-form, zeigt, wie Daten mit TanStack Query effektiv geladen werden, und erklärt die Implementierung komplexer Navigationsstrukturen mit React Router und dem TanStack Router. Nach dem Workshop hast du ein tiefes Verständnis für den Einsatz dieser Bibliotheken und kannst sie effektiv in deinen Projekten nutzen. Zusätzlich erhältst du Zugang zu einem GitHub-Repository mit allen Beispielen und Lösungen der Übungen, um das Gelernte nachhaltig zu festigen.\n'parentId': 'efd4ff41c4b9e889b50854b8'\n'parentDescription': 40 Workshops zu JavaScript, Angular, React, HTML & CSS und KI\n'indexBrandName': 'JavaScriptDays'\n'indexSeriesName': 'Munich'\n'author': 'Sebastian Springer'\n'chunkSource': 'text'\n'text': Das React-Ökosystem: ein Tag mit dem TanStack, React Router und vielem mehr Lerne das umfangreiche Ökosystem von React kennen. Es gibt kaum ein Problem, für das es keine Lösung in Form eines Pakets gibt. Dieser Workshop bietet dir die Möglichkeit, einen umfassenden Überblick über verschiedene React-Bibliotheken zu erhalten und praktische Erfahrungen im Einsatz dieser Tools zu sammeln. Der Fokus liegt auf spezialisierten Bibliotheken wie dem TanStack, React Router und react-hook-form, um typische Herausforderungen in der Entwicklung von React-Applikationen zu meistern, wie Serverkommunikation, Navigation und Formularhandling. Im Workshop wird vor allem hands-on gearbeitet. Du lernst durch praktische Übungen und das Schreiben von Code, den du direkt in deinen realen Anwendungen verwenden kannst. Der Workshop vermittelt Techniken für das Formularhandling mit react-hook-form, zeigt, wie Daten mit TanStack Query effektiv geladen werden, und erklärt die Implementierung komplexer Navigationsstrukturen mit React Router und dem TanStack Router. Nach dem Workshop hast du ein tiefes Verständnis für den Einsatz dieser Bibliotheken und kannst sie effektiv in deinen Projekten nutzen. Zusätzlich erhältst du Zugang zu einem GitHub-Repository mit allen Beispielen und Lösungen der Übungen, um das Gelernte nachhaltig zu festigen.\n'slidetext': ''\n'from': 'index'\n'score': 60.96226501464844\n'normalizedScore': 0.6096226501464844\n'beforeDatePenaltyScore': 0.6096226501464844\n\n'documentId': 'f8465c38d514d23af45f3eb0'\n'chunk_id': '690373b99669850016afad85'\n'access': 'restricted'\n'part_number': 12\n'total_parts': 16\n'contentType': 'RHEINGOLD'\n'title': The real cost of React re-renders in 2025\n'parentName': Frontmania 2025\n'language': 'EN'\n'date': '2025-10-08T12:30:00.000Z'\n'abstract': Modern React makes it deceptively easy to write code that looks performant, but hides costly re-renders, hydration mismatches, and subtle CPU bottlenecks. As applications scale and ship to users on slower devices or flaky networks, these problems compound into real-world slowdowns. In this talk, I'll dive deep into profiling React applications in 2025, leveraging the latest React DevTools, flamegraphs, and field metrics to uncover unexpected re-render patterns. I'll compare how React 18 cooperative scheduling and batching stacks up against React 19 new compiler-backed partial signals and smarter diffing, showing side-by-side examples of how seemingly harmless hooks can differ dramatically in cost. Also will touch React Forget and what it will bring. Aside code examples it should also form a structure for a team how to properly test the performance of applications.\n'parentId': '501ad2dcdca77f2683bdde34'\n'parentDescription': \n'indexBrandName': ''\n'indexSeriesName': ''\n'author': 'Emīls Pļavenieks'\n'chunkSource': 'text'\n'text': not a component. We return everything within this component. But if we, like we, as I said, we had this react counter, re-render counter for the whole component component and we had it for the title. And if we re-enable the highlighting for it. Like, we will go back to it just in a second, but this allows, this is what the smarter din means that it automatically tries to separate, separate out what, what is returned. And what it will separate in the compiler as like a magic component, let's say, that is not actually in our code. And as usually in all the presentations, everything works on the simple examples, and this was also true for the past Ract compiler, like talks, presentations, articles, everything, like all the simplest cases worked fine, but then like in real world applications we we have much more complex. Components, it started to not do the job properly, but Then like It came to the state where it kind of forced us to intervene within, like with the what's actually happening in the compiler, in a way that we had to work together with the compiler. For example, if we enabled it and it saved us a bunch of re-renders, but some part kept re-rendering, it was a good indicator that there's something wrong there, and we were not following the rules of react. And for the compiler to actually work, we are strictly need to remember the rules of react. You can read up on them on the React documentation. So, the state of the RAC compiler today is that it's bundled in, in the version 19. Uh, but yeah, like version 19, I'm not sure how many of you use version 19 in production, at least from all the people I have talked to, it's not much. A lot of are still on version 1718, or there are a few enterprises even still on version 16 because it just works for them, and the migrating upwards is uh far less of, A thing for them But we can install like. Additional dependencies for the version 17 and 18. And uh there's a small like written article in the React documentation as well, how to actually do it, and it also brings us the ESL2 link for that. So let's quickly do that. For example, here. Uh, it was here, so React compiler, this is the article they have, and in order to install it, it also provides what additional library you need to install. With the latest release, uh, that happened one week ago, 19.2, they simplified the installing and adding this to your existing projects if you're not using\n'slidetext': ''\n'from': 'index'\n'score': 60.056663513183594\n'normalizedScore': 0.600566635131836\n'beforeDatePenaltyScore': 0.600566635131836\n\n'documentId': '50c03dd02cf9b7c2ff4480f2'\n'chunk_id': '68b55eac33a5bf00132cb68e'\n'access': 'granted'\n'part_number': 13\n'total_parts': 47\n'contentType': 'TUTORIAL'\n'title': React-Grundlagen\n'parentName': Modern React: von Null auf Full-Stack\n'language': 'DE'\n'date': '2025-08-27T09:53:51.000Z'\n'abstract': In der ersten Lesson lernst du, was React ist und wie es funktioniert. Anhand einer Beispielanwendung schauen wir uns den Projektaufbau und den Workspace an. Du erfährst, wie Komponenten aufgebaut sind, wie man mit Props, Listen und State arbeitet und wie Interaktionen in React abgebildet werden.\n'parentId': 'b2c71c7c41dfe8eab4593f02'\n'parentDescription': In diesem Videotutorial lernst du React von Grund auf – bis hin zur Full-Stack-Entwicklung mit Next.js. Du baust Single Page Applications, verwaltest State, entwickelst moderne Formulare, arbeitest mit serverseitigen Daten und setzt Routing effizient um. Zum Abschluss bekommst du eine Einführung in React Server Components und Next.js. Benötigte Vorkenntnisse: JavaScript-Grundlagen, TypeScript ist hilfreich, aber nicht zwingend nötig. Nach dem Tutorial bist du bereit, eigene client- und serverseitige Anwendungen mit React umzusetzen.\n'indexBrandName': 'InternationalJavaScriptCon'\n'indexSeriesName': ''\n'author': 'Nils Hartmann'\n'chunkSource': 'text'\n'text': das sieht aus wie HTML Code, obwohl wir in einer JavaScript beziehungsweise TypeScript Datei oder Modul unterwegs sind. Dieser Code den ich hier hinschreibe, der wird in React JSX genannt. Deswegen heißt meine TypeScript Endung hier auch TSX und nicht nur TS. Es gibt soweit ich weiß, keine offizielle Erklärung, was JSX heißt, also wofür das steht. Vielleicht steht es nur für JSX. Einige sagen auch es steht für JavaScript XML, weil das hier so eine XML Syntax ist. Wie auch immer wir können das hier einfach so reinschreiben. Dieser Code, den wir hinschreiben, der sieht aus wie HTML beziehungsweise wie XML eigentlich auch. Und das ist unterm Strich nur in Anführungsstrichen sowas wie Syntaktischer Zucker für eine JavaScript API, die React uns zur Verfügung stellt und die unter der Haube dann aufgerufen wird. Wenn mal eine Anwendung gestartet wird, beziehungsweise mein Bildtool genauer gesagt, dann werden aus diesem Code JavaScript Funktionsaufrufe von React Apis. Das heißt, Laufzeit ist dieser ganze Code weg, zur Laufzeit sind das normale React Apis. Deswegen sagt man auch das ist nur Syntaktischer Zucker. Offiziell wird da auch nicht von Templatesprache gesprochen, obwohl ich denke, das ist natürlich eine Art natürlich auch von Templatesprache. Aber im Gegensatz zu Angular beispielsweise oder im Gegensatz auch zu sowas wie JSP oder sowas, ja wirklich Templatesprachen sind beziehungsweise Templatesprache mitbringen, haben wir hier um diesen Template Block sage ich mal herum, normales JavaScript. Und wir werden auch sehen dass wir dieses Template auch mit normalem JavaScript bearbeiten können. Das war sozusagen eine Grundidee auch von React, keine neue Templatesprache zu erfinden, sondern eine bestehende Sprache zu nehmen, JavaScript, und die für eine Komponentenbibliothek fehlenden Features wie ein Template Ausdruck hinzuzufügen. Ich persönlich finde das eigentlich ganz charmant, auch wenn ich da am Anfang bisschen skeptisch war, mache ich diesen Anlass doch mittlerweile ganz gerne. Wie auch immer, wir geben jetzt also diesen JSX Code zurück, der wird im Bildprozess ein bisschen verarbeitet, sodass da Funktionsaufrufe zurückkommen und diese Funktionsaufrufe sagen React dann\n'slidetext': ''\n'from': 'index'\n'score': 62.371219635009766\n'normalizedScore': 0.6237121963500977\n'beforeDatePenaltyScore': 0.6237121963500977\n\n'documentId': '50c03dd02cf9b7c2ff4480f2'\n'chunk_id': '68b55eb633a5bf00132cb6a8'\n'access': 'granted'\n'part_number': 39\n'total_parts': 47\n'contentType': 'TUTORIAL'\n'title': React-Grundlagen\n'parentName': Modern React: von Null auf Full-Stack\n'language': 'DE'\n'date': '2025-08-27T09:53:51.000Z'\n'abstract': In der ersten Lesson lernst du, was React ist und wie es funktioniert. Anhand einer Beispielanwendung schauen wir uns den Projektaufbau und den Workspace an. Du erfährst, wie Komponenten aufgebaut sind, wie man mit Props, Listen und State arbeitet und wie Interaktionen in React abgebildet werden.\n'parentId': 'b2c71c7c41dfe8eab4593f02'\n'parentDescription': In diesem Videotutorial lernst du React von Grund auf – bis hin zur Full-Stack-Entwicklung mit Next.js. Du baust Single Page Applications, verwaltest State, entwickelst moderne Formulare, arbeitest mit serverseitigen Daten und setzt Routing effizient um. Zum Abschluss bekommst du eine Einführung in React Server Components und Next.js. Benötigte Vorkenntnisse: JavaScript-Grundlagen, TypeScript ist hilfreich, aber nicht zwingend nötig. Nach dem Tutorial bist du bereit, eigene client- und serverseitige Anwendungen mit React umzusetzen.\n'indexBrandName': 'InternationalJavaScriptCon'\n'indexSeriesName': ''\n'author': 'Nils Hartmann'\n'chunkSource': 'text'\n'text': benutzen, also darauf kommt es nicht an. Wichtig ist nur, ist in der Liste eindeutig und zwar nur in der Liste muss es eindeutig sein. Global muss es nicht eindeutig sein. Schauen wir nochmal. Liste, kein Fehler. Wir haben hier unsere Keys, die einzelnen Einträge hier und im Prinzip haben wir damit unsere Listen Komponente abgeschlossen. Wir haben jetzt unsere Liste von diesen Bildern und was wir machen möchten, ist diese Liste auswählbar zu machen. Das heißt, ich klicke hier drauf und dann kriege ich auch ein visuelles Feedback, dass ich dieses Bild jetzt ausgewählt habe. Denn nochmal zum Hintergrund wir wollen die Liste später ja in unserem Formular verwenden, wo ich eben ein Bild für ein Gericht auswählen soll. Dazu brauchen wir noch ein weiteres Konzept und das ist auch ganz ganz wichtig in React. Das ist der sogenannte Zustand von einer Komponente, in React auch State genannt. Der State sind quasi interne Daten einer Komponente, die die Komponente selber auch verändern darf. Wir erinnern uns, wir haben diese Properties, was ja auch Daten einer Komponente sind, aber die Properties die hat mir jemand übergeben. Wenn ich jetzt eine Komponente bin, dann hat mir jemand die Properties übergeben, aber ich kann natürlich auch eigene Daten haben, die ich selber verwalte und diese Daten werden in React State genannt. In anderen Frameworks wäre das vielleicht sowas wie das Modell. React aber wie gesagt State oder auf Deutsch Zustand genannt. Und um jetzt diese Daten in einer Komponente oder um eigene Daten in einer Komponente zu verwalten, zu verwenden, muss ich dazu eine Funktion aufrufen, die mir diese Daten quasi erzeugt. Und das machen wir mal. Die Idee ist jetzt, ich habe meinen Image Selektor, ich habe eine Liste von Bildern und ich möchte mir merken, welches Bild wurde eigentlich ausgewählt. Dazu brauche ich eine Funktion, die nennt sich in React Use State. Und das ist quasi eine Art Factory Funktion, die mir ein Modell für meine Komponente erzeugt. Da kann ich beliebige Daten reinschreiben. Das mache ich gleich, also das ist so noch nicht fertig. Da kann ich beliebige Daten reinschreiben.\n'slidetext': ''\n'from': 'index'\n'score': 62.28546905517578\n'normalizedScore': 0.6228546905517578\n'beforeDatePenaltyScore': 0.6228546905517578\n\n'documentId': '50c03dd02cf9b7c2ff4480f2'\n'chunk_id': '68b55eb733a5bf00132cb6ae'\n'access': 'granted'\n'part_number': 45\n'total_parts': 47\n'contentType': 'TUTORIAL'\n'title': React-Grundlagen\n'parentName': Modern React: von Null auf Full-Stack\n'language': 'DE'\n'date': '2025-08-27T09:53:51.000Z'\n'abstract': In der ersten Lesson lernst du, was React ist und wie es funktioniert. Anhand einer Beispielanwendung schauen wir uns den Projektaufbau und den Workspace an. Du erfährst, wie Komponenten aufgebaut sind, wie man mit Props, Listen und State arbeitet und wie Interaktionen in React abgebildet werden.\n'parentId': 'b2c71c7c41dfe8eab4593f02'\n'parentDescription': In diesem Videotutorial lernst du React von Grund auf – bis hin zur Full-Stack-Entwicklung mit Next.js. Du baust Single Page Applications, verwaltest State, entwickelst moderne Formulare, arbeitest mit serverseitigen Daten und setzt Routing effizient um. Zum Abschluss bekommst du eine Einführung in React Server Components und Next.js. Benötigte Vorkenntnisse: JavaScript-Grundlagen, TypeScript ist hilfreich, aber nicht zwingend nötig. Nach dem Tutorial bist du bereit, eigene client- und serverseitige Anwendungen mit React umzusetzen.\n'indexBrandName': 'InternationalJavaScriptCon'\n'indexSeriesName': ''\n'author': 'Nils Hartmann'\n'chunkSource': 'text'\n'text': hier drauf klicke, dieses ausgewählt und so weiter und so fort. Also wir können jetzt hier beliebig auswählen. So, was jetzt hier im Hintergrund passiert, ist ganz spannend und das muss man glaube ich einmal, da müssen wir jetzt einmal durchwählen Wenn React diese Komponente hier rendert, allererste Mal, also unsere Anwendung wird gestartet in unserem Fall, die App-Komponente wird gerendert, die Image-Selektor-Komponente wird gerendert, dann erzeugt React für uns ein Modell, das belegt es vor, also React belegt das Modell vor mit diesem ersten Image und legt dieses Modell bzw. Den Inhalt dieses Modells für uns irgendwo ab. Dann haben wir dieses Modell, den Wert, den Inhalt von diesem Modell hier als überall operieren, insbesondere hier in unserem Fall gucken, welches Bild ausgewählt ist. Viel mehr machen wir damit ja jetzt aktuell gar nicht. Da das eine normale JavaScript-Variable ist, kann ich die aber überall verwenden. Ich kann damit alles Mögliche machen, was ich möchte. Ich könnte zum Beispiel dieses auch nehmen und sagen, ich gebe hier mal, wenn es denn gesetzt ist, den Titel hier aus, ausgewähltes Bild. Nur mal als Beispiel, dass wirklich dieses Modell eine ganz normale JavaScript-Variable ist. kann damit alles machen, ich möchte. Wenn wir jetzt hier mal gucken, seht ihr ausgewähltes Bild, wenn ich hier umspringen, wird nicht nur sozusagen hier unten dieser Teil aktualisiert, sondern eben auch dieser Teil hier aktualisiert. Das ermöglicht uns eben dieser State sozusagen. Das ist jetzt das allererste Rendern aber nur gewesen. Ich starte die Anwendung nochmal neu. Ausgewähltes Bild ist Penne. Hier ist angehakt die Penne, weil wir das als initialen Zustand in unserem Modell gesetzt haben. Mit dieser Variable können wir jetzt eben alles machen was wir mit Variable machen können. Und wenn wir jetzt diesen Wert ändern, indem wir diese Setter-Funktion hier aufrufen, dann guckt React quasi in sein internes Modell von dieser Komponente. Also wie gesagt, der State, den bewahrt React für uns auf, irgendwo außerhalb von unserer Komponente. Und wenn wir die Setter-Funktion aufrufen, dann übergeben\n'slidetext': ''\n'from': 'index'\n'score': 62.28546905517578\n'normalizedScore': 0.6228546905517578\n'beforeDatePenaltyScore': 0.6228546905517578\n\n'documentId': '11aa4ab6eae82f7b6df75323'\n'chunk_id': '68c26fc50a53cd001394ab8e'\n'access': 'granted'\n'part_number': 1\n'total_parts': 3\n'contentType': 'READ'\n'title': Essential React Tips: A Developer's Cheat Sheet - React 19's Must-Know Concepts\n'parentName': iJS Magazine Volume 19\n'language': 'EN'\n'date': '2025-06-24T22:00:00.000Z'\n'abstract': This cheat sheet offers a quick reference guide to key features and commands in React, helping developers streamline their workflow and accelerate development.\n'parentId': 'a1269c65e87d5b8ebcde4b28'\n'parentDescription': Broaden your knowledge and expand your JavaScript techniques and practices. From Angular, React, and WebAssembly, to the best JavaScript IDEs, open source tools and more, you’ll learn insights on everything JS from seasoned experts in their field. Keep up with JavaScript news, tips, and advice with interviews, tutorials, and in-depth articles.\n'indexBrandName': ''\n'indexSeriesName': ''\n'author': 'Jaime Garcia'\n'chunkSource': 'text'\n'text': Essential React Tips: A Developer's Cheat Sheet React 19's Must-Know Concepts This cheat sheet offers a quick reference guide to key features and commands in React, helping developers streamline their workflow and accelerate development. Function Component function Hello() { return (  Hello, world!  ); }; Insight As you can see, it's a regular JavaScript function that returns JSX, which React converts into HTML. In React, you can use either Function Components or Class Components. Since I started using Function Components, I’ve never found a reason to switch to Class Components, so I recommend sticking with Function Components. Props function Greeting(props) { const { name = 'world' } = props; return (  Hello, {name}!  ); } ; ; Remember In React, a component is a simple JavaScript function that returns JSX. This function takes a parameter, usually called props, which is an object where each key represents a property passed to the component. If no properties are passed, props will be an empty object. Notice how a default value is defined, if the name property isn’t set, it defaults to 'world'. State import { useState } from 'react'; function Counter() { const [count, setCount] = useState(0); return (  \n\nCount: {count}  setCount(count + 1)}> Increment   ); } Remember In React, useState is a hook that lets you define three things: - A default value: In the snippet above, the default value is 0. - A variable that holds the value: count. - A setter function, setCount, which updates the variable. Something else to keep in mind: Every time a setter is called, it triggers a rerender of the component, allowing the UI to reflect the updated value. One last thing: useState runs on the client, not on the server, and you can have as many state variables as needed. Nesting import Greeting from '../greeting'; import Counter from '../counter'; export default function NestingComponent() { return ( <>   ); } Remember Just like regular HTML, React components can be nested. Most React applications are a mix of HTML and React components. One thing to note in the snippet above is the use of Fragments (<> ... ). Fragments tell React not to render an extra HTML wrapper element, which is useful when the parent component already provides one. While Fragments reduce the number of HTML nodes, this doesn’t necessarily improve performance. The main reason to use them is when dealing with styling or lists. Children function ChildrenComponent({ children }) { return (\n'slidetext': ''\n'from': 'index'\n'score': 64.46342468261719\n'normalizedScore': 0.6446342468261719\n'beforeDatePenaltyScore': 0.6446342468261719\n\n'documentId': '11aa4ab6eae82f7b6df75323'\n'chunk_id': '68c26fc50a53cd001394ab8f'\n'access': 'granted'\n'part_number': 2\n'total_parts': 3\n'contentType': 'READ'\n'title': Essential React Tips: A Developer's Cheat Sheet - React 19's Must-Know Concepts\n'parentName': iJS Magazine Volume 19\n'language': 'EN'\n'date': '2025-06-24T22:00:00.000Z'\n'abstract': This cheat sheet offers a quick reference guide to key features and commands in React, helping developers streamline their workflow and accelerate development.\n'parentId': 'a1269c65e87d5b8ebcde4b28'\n'parentDescription': Broaden your knowledge and expand your JavaScript techniques and practices. From Angular, React, and WebAssembly, to the best JavaScript IDEs, open source tools and more, you’ll learn insights on everything JS from seasoned experts in their field. Keep up with JavaScript news, tips, and advice with interviews, tutorials, and in-depth articles.\n'indexBrandName': ''\n'indexSeriesName': ''\n'author': 'Jaime Garcia'\n'chunkSource': 'text'\n'text': Parent {children}  ); }  Child  Key Takeaway children is a special parameter in React that holds the elements inside a component. In the snippet above, children is equal to < h2 >Child. One important thing to remember is that React requires a root component. If you have multiple elements at the same level, you can wrap them using a Fragment to avoid unnecessary HTML wrappers. useEffect import { useEffect, useState } from 'react'; function Timer() { const [seconds, setSeconds] = useState(0); useEffect(() => { const interval = setInterval(() => { setSeconds((s) => s + 1); }, 1_000); return () => clearInterval(interval); // Cleanup }, []); return \n\nSeconds: {seconds}; } Remember useEffect runs on the client, not the server. The function passed to useEffect executes when the component is added to the DOM or when any of its dependencies (the second argument, an array) change. Additionally, an optional cleanup function can be defined, which React will run when the component is removed from the DOM. Rendering Arrays function TodoList() { const todo = [ 'Create project', 'Write code for the module A', 'Deploy the app' ]; return (  Todo List \n\n- {item}  ); } Insight The key to rendering an array in React is to iterate through it and build a JSX element. The most common method for this is .map(). It's also important to set a unique key for each element in the list. React uses this key to track and update nodes efficiently, improving performance when the list changes. Controlled Elements import { useState } from 'react'; function ControlledElements() { const [value, setValue] = useState(''); return (  setValue(event.target.value)} /> ); } Remember Controlled Elements rely on a state variable, allowing you to access the value as the user types. This is useful for validations or triggering side effects. Notice how the onChange listener receives a DOM event, which holds the value the user just entered. Conditional and Short-Circuit import Greeting from '../greeting'; import Counter from '../counter'; function Component() { const showGreeting = true const shortCircuit = true return (  Conditionals {showGreeting ?  : } {shortCircuit && \n\nShort-circuiting}  ); } Remember Conditional rendering and short-circuit evaluation are useful for toggling components. In the snippet above, the flag is\n'slidetext': ''\n'from': 'index'\n'score': 64.26167297363281\n'normalizedScore': 0.6426167297363281\n'beforeDatePenaltyScore': 0.6426167297363281\n\n'documentId': '11aa4ab6eae82f7b6df75323'\n'chunk_id': '68c26fc50a53cd001394ab90'\n'access': 'granted'\n'part_number': 3\n'total_parts': 3\n'contentType': 'READ'\n'title': Essential React Tips: A Developer's Cheat Sheet - React 19's Must-Know Concepts\n'parentName': iJS Magazine Volume 19\n'language': 'EN'\n'date': '2025-06-24T22:00:00.000Z'\n'abstract': This cheat sheet offers a quick reference guide to key features and commands in React, helping developers streamline their workflow and accelerate development.\n'parentId': 'a1269c65e87d5b8ebcde4b28'\n'parentDescription': Broaden your knowledge and expand your JavaScript techniques and practices. From Angular, React, and WebAssembly, to the best JavaScript IDEs, open source tools and more, you’ll learn insights on everything JS from seasoned experts in their field. Keep up with JavaScript news, tips, and advice with interviews, tutorials, and in-depth articles.\n'indexBrandName': ''\n'indexSeriesName': ''\n'author': 'Jaime Garcia'\n'chunkSource': 'text'\n'text': is fixed, so the output is always the same. However, in a real application, this flag would likely be a state variable, allowing the UI to update dynamically. Forms import { useState } from 'react'; function Form() { const [value, setValue] = useState(''); const handleSubmit = (event) => { event.preventDefault(); alert(value) }; return (   setValue(event.target.value)} />  Submit   ); } Key takeaway Forms don’t mean much in React. In the above example, the onSubmit handler is used to trigger the handleSubmit function. However, handleSubmit could have been called from an onClick handler instead. Since the input fields are controlled, there’s really no need for the < form > element. That said, for clarity and readability, it's better to use < form > even when it’s not strictly necessary. It makes the code easier and more natural to understand. Context import { createContext, useContext, useState } from 'react'; const ThemeContext = createContext(); const ThemeProvider = ({ children }) => { const [theme, setTheme] = useState('light'); return (  {children}  ); }; const ThemedComponent = () => { const { theme, setTheme } = useContext(ThemeContext); return (  \n\nCurrent theme: {theme}  setTheme(theme === 'light' ? 'dark' : 'light')}> Toggle Theme   ); }; function ThemedPage() { return (    ); } Remember There are times when you’ll need to share data (variables or functions) between components. A common approach is using Props, but this can easily lead to Prop Drilling, where props are passed through multiple components. One way to solve this is by using Context. By wrapping any component that needs access to the context with the Provider, the component can then access and use the context’s values (whether variables or functions).\n'slidetext': ''\n'from': 'index'\n'score': 63.900291442871094\n'normalizedScore': 0.6390029144287109\n'beforeDatePenaltyScore': 0.6390029144287109\n\n'documentId': '6f5764d4aae6fe7d53d79d62'\n'chunk_id': '68da368fe61fb6001259ad8c'\n'access': 'granted'\n'part_number': 10\n'total_parts': 13\n'contentType': 'READ'\n'title': Formulare mit React: Gut in Form - Wie die Bibliothek react-hook-form hilft, komplexe Formulare zu entwickeln\n'parentName': iJS Magazin 5.2025\n'language': 'DE'\n'date': '2025-09-23T22:00:00.000Z'\n'abstract': Formulare sind aus den meisten Webanwendungen nicht wegzudenken. Die Entwicklung benutzerfreundlicher Formulare ist aber gar nicht so einfach und wird ohne Hilfsmittel schnell komplex und fehleranfällig. Die Bibliothek react-hook-form soll Abhilfe schaffen.\n'parentId': 'c2c5ea3e478bff04fc898402'\n'parentDescription': Kaum ein Softwareprojekt, das nicht in wesentlichen Teilen auf der JavaScript-Technologie basiert. Eine breite Unterstützung sowie, leistungsfähige Programmiersprachen, die Vielzahl moderner Tools, sowie ausgereifte Frameworks wie Angular, React, Vue.js oder Node.js machen den JavaScript-Werkzeugkasten zu einem Alleskönner. Das iJS Magazin informiert aktuell und umfassend über die wichtige und innovative Entwicklungen im JavaScript-Universum und bietet handfeste Praxisinformationen für Softwareentwickler und -architekten.\n'indexBrandName': ''\n'indexSeriesName': ''\n'author': 'Nils Hartmann'\n'chunkSource': 'text'\n'text': entsprechende Property heißt hier – etwas verwirrend – fields. Ein Eintrag in fields entspricht einem Eintrag in der Liste, erweitert um eine eindeutige ID, die von react-hook-form vergeben und verwaltet wird. Der Zugriff auf die Fehler erfolgt analog zu den Nicht-Array-Feldern, nur dass hier bei den Namen auch der jeweilige Index in der Liste angegeben werden muss. Übrigens ist TypeScript trotz dieses dynamischen Namens in der Lage, sicherzustellen, dass die Namen korrekt angegeben werden. Mit den insert- und remove-Methoden sind wir in der Lage, neue Einträge in die Liste einzufügen bzw. zu entfernen. Listing 8: Mit useFieldArray werden dynamische Listen in einem Formular verwaltet const DrinkOrder = z.object({ amount: z.number().min(1), name: z.string().nonempty(), }); const ReservationFormState = z.object({ // ... drinkOrders: DrinkOrder.array(), }); export default function ReservationForm() { const form = useForm(/* ... */); const drinkOrders = useFieldArray({ control: form.control, name: 'drinkOrders', }); // ... return (  Order your drinks {drinkOrders.fields.map((drinkField, ix) => { return (    {form.formState.errors.drinkOrders?.[ix]?.amount?.message}  {/* Fehlerdarstellung analog zu oben, deswegen hier ausgelassen */}   drinkOrders.remove(ix)}> Remove   ); })}  drinkOrders.append({ amount: 0, name: '', }) } > Add   ); } Auf Veränderungen im Formular reagieren react-hook-form arbeitet mit unkontrollierten React-Komponenten (Kasten: „Kontrollierte und unkontrollierte Komponenten“). Dadurch wird eine Komponente, die ein Formular enthält (in unserem Beispiel ReservationForm), nicht bei jeder Änderung im Formular neu gerendert. Die Komponente wird nur dann neu gerendert, wenn sich der sogenannte formState verändert. Das ist z. B. die Information, ob das Formular verändert wurde (isDirty), ob alle Eingaben gültig sind (isValid) oder die Liste mit Fehlern (errors). Diese Informationen ändern sich nur selten, sodass bei deren Änderung das erneute Rendern der Komponente in Kauf genommen wird. Bei Änderungen am Inhalt des Formulars\n'slidetext': ''\n'from': 'index'\n'score': 63.787601470947266\n'normalizedScore': 0.6378760147094726\n'beforeDatePenaltyScore': 0.6378760147094726\n\n'documentId': '6f5764d4aae6fe7d53d79d62'\n'chunk_id': '68da368fe61fb6001259ad88'\n'access': 'granted'\n'part_number': 6\n'total_parts': 13\n'contentType': 'READ'\n'title': Formulare mit React: Gut in Form - Wie die Bibliothek react-hook-form hilft, komplexe Formulare zu entwickeln\n'parentName': iJS Magazin 5.2025\n'language': 'DE'\n'date': '2025-09-23T22:00:00.000Z'\n'abstract': Formulare sind aus den meisten Webanwendungen nicht wegzudenken. Die Entwicklung benutzerfreundlicher Formulare ist aber gar nicht so einfach und wird ohne Hilfsmittel schnell komplex und fehleranfällig. Die Bibliothek react-hook-form soll Abhilfe schaffen.\n'parentId': 'c2c5ea3e478bff04fc898402'\n'parentDescription': Kaum ein Softwareprojekt, das nicht in wesentlichen Teilen auf der JavaScript-Technologie basiert. Eine breite Unterstützung sowie, leistungsfähige Programmiersprachen, die Vielzahl moderner Tools, sowie ausgereifte Frameworks wie Angular, React, Vue.js oder Node.js machen den JavaScript-Werkzeugkasten zu einem Alleskönner. Das iJS Magazin informiert aktuell und umfassend über die wichtige und innovative Entwicklungen im JavaScript-Universum und bietet handfeste Praxisinformationen für Softwareentwickler und -architekten.\n'indexBrandName': ''\n'indexSeriesName': ''\n'author': 'Nils Hartmann'\n'chunkSource': 'text'\n'text': zod zur Validierung eingesetzt, entspricht die message der Default- oder explizit gesetzten Fehlermeldung aus der zod-Beschreibung eines Feldes. Gibt es zu einem Feld keinen Fehler, weil die Validierung noch nicht ausgeführt wurde oder die Eingabe gültig ist, enthält das errors-Objekt keinen Eintrag für das Feld. Listing 4 zeigt die Angabe eigener Fehlermeldungen mit Zod und exemplarisch deren Darstellung für die ersten beiden Felder im Formular. Außerdem wird neben dem Submit-Button ein allgemeiner Hinweis ausgegeben, wenn das Formular submittet wurde und es dabei mindestens einen Fehler im Formular gibt. Der neue Clear-Button verwendet die reset-Funktion von react-hook-form, um das Formular inklusive aller (Fehler-)Zustände zurückzusetzen. Ein Beispiel für die Darstellung der Fehlermeldungen ist in Abbildung 4 zu sehen. Listing 4: Darstellung von Fehlermeldungen const ReservationFormState = z.object({ firstName: z.string().optional(), lastName: z.string().nonempty('Please enter your last name'), foodTruck: z.string().nonempty('Please select your favourite food truck'), guests: z.number().min(5, 'The minimum number of guests is 5'), }); function ReservationForm() { const form = useForm({ /* ... */ }); return (  First name  {form.formState.errors.firstName?.message} Last name  {form.formState.errors.lastName?.message} { /* ... */ } {form.formState.isSubmitted && !form.formState.isValid && Please correct your input}} Submit  form.reset()}> Clear   ); } Abb. 4: Im Formular werden Fehlermeldungen angezeigt Damit haben wir die Grundzüge von react-hook-form gesehen. Wir haben mit zod beschrieben, welche Felder es in unserem Formular gibt und welche Bedingungen es für die Felder gibt. Mit useForm haben wir unsere Form konfiguriert und ein Objekt erhalten, das unter anderem aktuelle Informationen über unser Formular enthält (Fehlermeldungen, Dirty-Zustände etc.) und Funktionen bereitstellt, mit denen wir unsere eigenen UI-Komponenten mit dem Formularzustand verknüpfen können, sodass react-hook-form in der Lage ist, deren Inhalte zu steuern und zu validieren. Arbeiten mit den Formulardaten Auf die aktuell eingegebenen Inhalte im Formular haben wir – abgesehen von der handleFormSubmit-Funktion – noch\n'slidetext': ''\n'from': 'index'\n'score': 63.74568176269531\n'normalizedScore': 0.6374568176269532\n'beforeDatePenaltyScore': 0.6374568176269532\n\n'documentId': '6f5764d4aae6fe7d53d79d62'\n'chunk_id': '68da368fe61fb6001259ad8e'\n'access': 'granted'\n'part_number': 12\n'total_parts': 13\n'contentType': 'READ'\n'title': Formulare mit React: Gut in Form - Wie die Bibliothek react-hook-form hilft, komplexe Formulare zu entwickeln\n'parentName': iJS Magazin 5.2025\n'language': 'DE'\n'date': '2025-09-23T22:00:00.000Z'\n'abstract': Formulare sind aus den meisten Webanwendungen nicht wegzudenken. Die Entwicklung benutzerfreundlicher Formulare ist aber gar nicht so einfach und wird ohne Hilfsmittel schnell komplex und fehleranfällig. Die Bibliothek react-hook-form soll Abhilfe schaffen.\n'parentId': 'c2c5ea3e478bff04fc898402'\n'parentDescription': Kaum ein Softwareprojekt, das nicht in wesentlichen Teilen auf der JavaScript-Technologie basiert. Eine breite Unterstützung sowie, leistungsfähige Programmiersprachen, die Vielzahl moderner Tools, sowie ausgereifte Frameworks wie Angular, React, Vue.js oder Node.js machen den JavaScript-Werkzeugkasten zu einem Alleskönner. Das iJS Magazin informiert aktuell und umfassend über die wichtige und innovative Entwicklungen im JavaScript-Universum und bietet handfeste Praxisinformationen für Softwareentwickler und -architekten.\n'indexBrandName': ''\n'indexSeriesName': ''\n'author': 'Nils Hartmann'\n'chunkSource': 'text'\n'text': die Werte von reservationPeriod und guests ab und berechnen (fiktiv) einen Preis. Listing 9: Mit der watch-Funktion wird auf Veränderungen im Formular reagiert function ReservationForm() { const form = useForm({ /* ... */ }) const [start, end, guests] = form.watch([ 'reservationPeriod.start', 'reservationPeriod.end', 'guests', ]); // fiktive Funktion, die den Preis berechnet const price = calculatePrice(start, end, guests); return (  { /* ... */ }  Estimated price {price} €   ); } Der Einsatz von watch führt wie beschrieben nun dazu, dass sich die ReservationForm-Komponente immer neu rendert, wenn sich einer dieser Werte ändert. So ist sichergestellt, dass wir immer aktuelle Werte haben und einen aktuellen Preis berechnen können. Ein möglicher Nachteil ist, dass die Performance des Formulars leiden kann, denn das ganze Formular wird ja nun jedes Mal neu gerendet, wenn sich der Reservierungszeitraum oder die Anzahl der Gäste ändert. Das ist in unserem Beispiel sicherlich verschmerzbar, denn das Formular ist insgesamt nicht sehr komplex. Als Ausblick, wie Formulare alternativ mit react-hook-form strukturiert werden sollen, passen wir die Logik aber zum Abschluss noch einmal an und verschieben den Code zum Berechnen und Ausgeben des Preises in die neue Unterkomponente PriceCalculator (Listing 10). Dazu wird die control-Eigenschaft des Formulars an die Unterkomponente weitergegeben, sodass diese nun auch Zugriff auf das Formular hat. (Eine mögliche Alternative dazu wäre der FormContext. Dieser ist vor allem dann sinnvoll, wenn man das Formular in Unterkomponenten aufteilen möchte, in denen auch Felder registriert werden). In der PriceCalculator-Komponente verwenden wir den useWatch Hook, der ähnlich funktioniert wie die watch-Funktion. Hiermit wird allerdings sichergestellt, dass sich wirklich nur die verwendete Komponente (PriceCalculator) und nicht das gesamte Formular (ReservationForm) neu rendert. Listing 10: Aufteilung des Formulars in zwei Komponenten function ReservationForm() { const form = useForm({ /* ... */ }) // hier kein watch mehr return (  \n\n ); } type PriceCalculatorProps = { control: Control; }; function PriceCalculator({ control }: PriceCalculatorProps) { const [start, end, guests] = useWatch({ control, name: ['reservationPeriod.start', 'reservationPeriod.end',\n'slidetext': ''\n'from': 'index'\n'score': 62.956764221191406\n'normalizedScore': 0.6295676422119141\n'beforeDatePenaltyScore': 0.6295676422119141\n\n'documentId': 'f8465c38d514d23af45f3eb0'\n'chunk_id': '690373b89669850016afad7d'\n'access': 'restricted'\n'part_number': 4\n'total_parts': 16\n'contentType': 'RHEINGOLD'\n'title': The real cost of React re-renders in 2025\n'parentName': Frontmania 2025\n'language': 'EN'\n'date': '2025-10-08T12:30:00.000Z'\n'abstract': Modern React makes it deceptively easy to write code that looks performant, but hides costly re-renders, hydration mismatches, and subtle CPU bottlenecks. As applications scale and ship to users on slower devices or flaky networks, these problems compound into real-world slowdowns. In this talk, I'll dive deep into profiling React applications in 2025, leveraging the latest React DevTools, flamegraphs, and field metrics to uncover unexpected re-render patterns. I'll compare how React 18 cooperative scheduling and batching stacks up against React 19 new compiler-backed partial signals and smarter diffing, showing side-by-side examples of how seemingly harmless hooks can differ dramatically in cost. Also will touch React Forget and what it will bring. Aside code examples it should also form a structure for a team how to properly test the performance of applications.\n'parentId': '501ad2dcdca77f2683bdde34'\n'parentDescription': \n'indexBrandName': ''\n'indexSeriesName': ''\n'author': 'Emīls Pļavenieks'\n'chunkSource': 'text'\n'text': you have seen where we get into this situation where like we received something from the parent component, we have props or some other hook, then we use this data within some use memo, and then within, from this use memo we use something within the use callback and then we pass it down, but it's actually not, it's not used further down. And we get these always still like these always changing dependencies. Or let's say if we wrapped everything, everything in the memorization utilities, it still re-renders because of those 1st 4, rules of why the components re-renders. So if we are doing all of this, it basically leads to a premature optimization where we try to optimize things that we don't necessarily need to at the time, and this can quickly backfire because, as I said, it basically adds additional overhead and we can get some side effects from it. And another thing is that if there are server side rendering, we really need, need to make sure that whatever we render there. Matches whatever UI would render for the first phase. Because if, if it doesn't, then these hydration mismatches actually are very costly. And also in pure components. Impure components are like necessarily to follow, like to follow the rules of react basically. If we are following them, we should be good. If we're not, we are slowly getting into some issues that could arise from that, and it's starting to cost us more. So let's step a bit back. What's actually happening in these re-render phases? Like whenever we trigger or react based on those four things triggers the component to re-render, there are two phases happening. The first is the render phase, and the second is the cometit phase. The render phase is basically a recursive process that starts from one node that wanted to re-render for any of the four reasons, and if it returns another component, it will try to render that component. And if that component renders something else, it will just gradually move towards down until it reaches a point when there's no components returned. And then the reactor will be able to build all of this tree inside the virtual dome. So on the first render, what happens, we have nothing, right? So it starts from the top, from the root, and then it goes down and it starts to create like all of this tree within the virtual dome. For the following rear renders, it basically tries to find the smallest changes it needed to make in order to. Like showcase what, what we want to do with these components, but all of this information is currently stored\n'slidetext': ''\n'from': 'vector'\n'score': 0.9233784079551697\n'normalizedScore': 0.9215640190440839\n'beforeDatePenaltyScore': 0.9233784079551697\n\n\nReferenceChunks:\n'documentId': 'f8465c38d514d23af45f3eb0'\n'chunk_id': '690373b89669850016afad7d'\n'access': 'restricted'\n'part_number': 4\n'total_parts': 16\n'poc_summary': 'This conference talk examines the hidden performance costs of React re-renders in 2025 and strategies for profiling and optimizing modern applications.'\n'chunk_summary': 'It describes the render and commit phases in React, emphasizing that costly operations occur during the commit phase.'\n'access_message': 'ℹ️ This talk of Frontmania 2025 was part of a past event. Booking is no longer available, but you can discover the current edition right here on the platform.'\n\n'documentId': '6f5764d4aae6fe7d53d79d62'\n'chunk_id': '68da368fe61fb6001259ad8e'\n'access': 'granted'\n'part_number': 12\n'total_parts': 13\n'poc_summary': 'This article examines how react-hook-form and zod enable robust, type-safe, and user-friendly form development in React applications.'\n'chunk_summary': 'It demonstrates splitting logic into subcomponents and using useWatch for efficient updates.'\n'access_message': '✅ This content is included with your elevate membership.'\n\n'documentId': '11aa4ab6eae82f7b6df75323'\n'chunk_id': '68c26fc50a53cd001394ab90'\n'access': 'granted'\n'part_number': 3\n'total_parts': 3\n'poc_summary': 'This article provides a concise cheat sheet of essential React 19 concepts and practical coding patterns for developers.'\n'chunk_summary': 'It discusses form handling in React and demonstrates how Context helps avoid prop drilling.'\n'access_message': '✅ This content is included with your elevate membership.'\n\n'documentId': '50c03dd02cf9b7c2ff4480f2'\n'chunk_id': '68b55eb733a5bf00132cb6ae'\n'access': 'granted'\n'part_number': 45\n'total_parts': 47\n'poc_summary': 'This tutorial lesson introduces React fundamentals by building interactive components, managing state, and handling lists in a practical recipe application.'\n'chunk_summary': 'It explains how state changes trigger re-rendering and how UI stays consistent with the current state.'\n'access_message': '✅ This content is included with your elevate membership.'\n\n'documentId': '1eed7659c187283042e70e2a'\n'chunk_id': '6876cd4b225e92fc1ac78ba0'\n'access': 'restricted'\n'part_number': 1\n'total_parts': 1\n'poc_summary': 'This conference talk provides a practical overview of key React libraries like TanStack, React Router, and react-hook-form.'\n'chunk_summary': 'It highlights hands-on exercises for form handling, data fetching, and navigation using these libraries.'\n'access_message': 'ℹ️ This talk of JavaScript Days München und online 2025 was part of a past event. Booking is no longer available, but you can discover the current edition right here on the platform.'\n\n'documentId': '98f008c2694c3d36e48d5bcf'\n'chunk_id': '69118b0a0f4b7700138ebd96'\n'access': 'granted'\n'part_number': 4\n'total_parts': 7\n'poc_summary': 'This article provides a practical walkthrough of React 19.2’s new features, performance enhancements, and their impact on modern development.'\n'chunk_summary': 'It introduces the useEffectEvent hook, which separates event logic from effect setup to avoid unnecessary reruns.'\n'access_message': '✅ This content is included with your elevate membership.'\n\n'documentId': 'dce2e7fce63ba63cdf7ee57a'\n'chunk_id': '6876df247899910dd58c0eb4'\n'access': 'granted'\n'part_number': 17\n'total_parts': 22\n'poc_summary': 'This seminar lesson examines common React antipatterns, their real-world impact, and practical strategies for improving code quality and performance.'\n'chunk_summary': 'It introduces useMemo as the preferred hook for caching expensive calculations instead of useEffect.'\n'access_message': '✅ This content is included with your elevate membership.'\n\n'documentId': '1afc9b7c648711b8f9bea5bc'\n'chunk_id': '6876cd0a225e92fc1ac78a44'\n'access': 'granted'\n'part_number': 5\n'total_parts': 15\n'poc_summary': 'This seminar lesson examines advanced strategies for scaling and optimizing React applications, including architecture, performance, and the use of meta frameworks.'\n'chunk_summary': 'It demonstrates the use of React.memo and useMemo to prevent unnecessary component re-renders.'\n'access_message': '✅ This content is included with your elevate membership.'\n\n'documentId': '4ebfb70f9a681ab244108b0f'\n'chunk_id': '68f24f70d754e200146e6e9a'\n'access': 'restricted'\n'part_number': 13\n'total_parts': 16\n'poc_summary': 'This conference talk discusses practical strategies for managing complex state in React applications to improve maintainability and scalability.'\n'chunk_summary': 'It explains React’s single source of truth principle and how data flows down through components using contexts and functions.'\n'access_message': 'ℹ️ This talk of International JavaScript New York 2025 was part of a past event. Booking is no longer available, but you can discover the current edition right here on the platform.'\n\n'documentId': 'c7561d4953f0e9be339434dc'\n'chunk_id': '690e04350f4b7700138eb912'\n'access': 'granted'\n'part_number': 9\n'total_parts': 28\n'poc_summary': 'This conference talk presents and evaluates new React features like the React Compiler, transitions, Suspense, and Activities for improving app performance and user experience.'\n'chunk_summary': 'The talk introduces the React Compiler as a tool to automate these optimizations and reduce manual code changes.'\n'access_message': '✅ You still have access to the recordings for this talk of W-JAX 2025 until 2026-05-05. Unfortunately, recordings are not available for workshops, but you can still access the slides and your certificate. Dive back in anytime!'\n\n'documentId': '004c178a34c278c75190f756'\n'chunk_id': '6903813a52f58e0014b29c42'\n'access': 'granted'\n'part_number': 23\n'total_parts': 26\n'poc_summary': 'This conference talk examines creative frontend performance solutions under API and compliance constraints, focusing on caching, payload optimization, and backend-for-frontend patterns.'\n'chunk_summary': 'It discusses fallback strategies when server-side timeouts occur, allowing the client to reconcile and fetch missing data.'\n'access_message': '✅ You still have access to the recordings for this talk of International JavaScript Conference Munich 2025 until 2026-04-28. Unfortunately, recordings are not available for workshops, but you can still access the slides and your certificate. Dive back in anytime!'\n\n'documentId': '09c1d40fca67448b12b69d10'\n'chunk_id': '68ecc3644ddebd0013afffa9'\n'access': 'granted'\n'part_number': 6\n'total_parts': 12\n'poc_summary': 'This article examines lightweight state management strategies in React, comparing built-in tools with libraries like Zustand and Jotai.'\n'chunk_summary': 'It outlines a reducer and middleware pattern to handle both synchronous and asynchronous cart actions in React.'\n'access_message': '✅ This content is included with your elevate membership.'\n\n'documentId': 'a0fdc76247703b13b691d244'\n'chunk_id': '687a47b16b250430a47836e2'\n'access': 'granted'\n'part_number': 4\n'total_parts': 16\n'poc_summary': 'This article examines the major new features and improvements introduced in React 19, including changes to APIs, performance, and developer experience.'\n'chunk_summary': 'It details how the compiler makes manual memoization with memo, useMemo, and useCallback obsolete for most cases.'\n'access_message': '✅ This content is included with your elevate membership.'\n\n'documentId': '1ae09fdefb18f120d737740a'\n'chunk_id': '687a20f8a98d5a30b3a34096'\n'access': 'restricted'\n'part_number': 6\n'total_parts': 7\n'poc_summary': 'This conference talk examines five common React antipatterns, their real-world impact, and practical solutions for improving application performance.'\n'chunk_summary': 'It demonstrates when to use useMemo for expensive calculations and the trade-offs of premature optimization.'\n'access_message': 'ℹ️ This talk of International JavaScript Conference Munich 2024 was part of a past event. Booking is no longer available, but you can discover the current edition right here on the platform.'\n\n'documentId': '7GNG8wNaXKkQxrpKH'\n'chunk_id': '687a2292d92aed38f5a4ab17'\n'access': 'restricted'\n'part_number': 8\n'total_parts': 8\n'poc_summary': 'This conference talk introduces TanStack Query and TanStack Router for building modern, type-safe React single-page applications with advanced data and routing features.'\n'chunk_summary': 'It provides an example of direct cache interaction and background data refetching with TanStack Query.'\n'access_message': 'ℹ️ This talk of International JavaScript Conference Munich 2024 was part of a past event. Booking is no longer available, but you can discover the current edition right here on the platform.'\n\n'documentId': 'q4q3W4BHrY6ZxJKGc'\n'chunk_id': '687a353aca798166d3ba5ca8'\n'access': 'restricted'\n'part_number': 15\n'total_parts': 33\n'poc_summary': 'This conference talk reviews React 19’s new features, practical migration tips, and evolving patterns for efficient single-page applications.'\n'chunk_summary': 'It introduces the new use function, which allows resource access beyond traditional hooks.'\n'access_message': 'ℹ️ This talk of W-JAX 2024 was part of a past event. Booking is no longer available, but you can discover the current edition right here on the platform.'\n\n'documentId': 'pPYMrzCiTznFHbfj7'\n'chunk_id': '687ad857eb1b160a4cabf317'\n'access': 'restricted'\n'part_number': 14\n'total_parts': 21\n'poc_summary': 'This conference talk explains how React hooks work under the covers, covering useRef, useState, useEffect, useMemo, and useCallback to build mental models and custom hooks.'\n'chunk_summary': 'It warns against using useEffect for data transformations and advocates deriving data during rendering.'\n'access_message': 'ℹ️ This talk of International JavaScript New York was part of a past event. Booking is no longer available, but you can discover the current edition right here on the platform.'\n\n'documentId': 'vKZKb8Mydxax9XAGi'\n'chunk_id': '687b43402b0a1813a73e47c6'\n'access': 'restricted'\n'part_number': 3\n'total_parts': 19\n'poc_summary': 'This conference talk examines how SolidJS leverages fine-grained reactivity and compilation to move beyond the component model for more granular, efficient user interfaces.'\n'chunk_summary': 'It describes how component re-renders on any state change, causing virtual DOM diffing.'\n'access_message': 'ℹ️ This talk of International JavaScript New York was part of a past event. Booking is no longer available, but you can discover the current edition right here on the platform.'\n\n\nTop Atlas:\n'documentId': '11aa4ab6eae82f7b6df75323'\n'chunk_id': '68c26fc50a53cd001394ab8e'\n'access': 'granted'\n'part_number': 1\n'total_parts': 3\n'contentType': 'READ'\n'title': Essential React Tips: A Developer's Cheat Sheet - React 19's Must-Know Concepts\n'parentName': iJS Magazine Volume 19\n'language': 'EN'\n'date': '2025-06-24T22:00:00.000Z'\n'abstract': This cheat sheet offers a quick reference guide to key features and commands in React, helping developers streamline their workflow and accelerate development.\n'parentId': 'a1269c65e87d5b8ebcde4b28'\n'parentDescription': Broaden your knowledge and expand your JavaScript techniques and practices. From Angular, React, and WebAssembly, to the best JavaScript IDEs, open source tools and more, you’ll learn insights on everything JS from seasoned experts in their field. Keep up with JavaScript news, tips, and advice with interviews, tutorials, and in-depth articles.\n'indexBrandName': ''\n'indexSeriesName': ''\n'author': 'Jaime Garcia'\n'chunkSource': 'text'\n'text': Essential React Tips: A Developer's Cheat Sheet React 19's Must-Know Concepts This cheat sheet offers a quick reference guide to key features and commands in React, helping developers streamline their workflow and accelerate development. Function Component function Hello() { return (  Hello, world!  ); }; Insight As you can see, it's a regular JavaScript function that returns JSX, which React converts into HTML. In React, you can use either Function Components or Class Components. Since I started using Function Components, I’ve never found a reason to switch to Class Components, so I recommend sticking with Function Components. Props function Greeting(props) { const { name = 'world' } = props; return (  Hello, {name}!  ); } ; ; Remember In React, a component is a simple JavaScript function that returns JSX. This function takes a parameter, usually called props, which is an object where each key represents a property passed to the component. If no properties are passed, props will be an empty object. Notice how a default value is defined, if the name property isn’t set, it defaults to 'world'. State import { useState } from 'react'; function Counter() { const [count, setCount] = useState(0); return (  \n\nCount: {count}  setCount(count + 1)}> Increment   ); } Remember In React, useState is a hook that lets you define three things: - A default value: In the snippet above, the default value is 0. - A variable that holds the value: count. - A setter function, setCount, which updates the variable. Something else to keep in mind: Every time a setter is called, it triggers a rerender of the component, allowing the UI to reflect the updated value. One last thing: useState runs on the client, not on the server, and you can have as many state variables as needed. Nesting import Greeting from '../greeting'; import Counter from '../counter'; export default function NestingComponent() { return ( <>   ); } Remember Just like regular HTML, React components can be nested. Most React applications are a mix of HTML and React components. One thing to note in the snippet above is the use of Fragments (<> ... ). Fragments tell React not to render an extra HTML wrapper element, which is useful when the parent component already provides one. While Fragments reduce the number of HTML nodes, this doesn’t necessarily improve performance. The main reason to use them is when dealing with styling or lists. Children function ChildrenComponent({ children }) { return (\n'slidetext': ''\n'from': 'index'\n'score': 64.46342468261719\n'normalizedScore': 0.6446342468261719\n'beforeDatePenaltyScore': 0.6446342468261719\n\n'documentId': '6f5764d4aae6fe7d53d79d62'\n'chunk_id': '68da368ee61fb6001259ad83'\n'access': 'granted'\n'part_number': 1\n'total_parts': 13\n'contentType': 'READ'\n'title': Formulare mit React: Gut in Form - Wie die Bibliothek react-hook-form hilft, komplexe Formulare zu entwickeln\n'parentName': iJS Magazin 5.2025\n'language': 'DE'\n'date': '2025-09-23T22:00:00.000Z'\n'abstract': Formulare sind aus den meisten Webanwendungen nicht wegzudenken. Die Entwicklung benutzerfreundlicher Formulare ist aber gar nicht so einfach und wird ohne Hilfsmittel schnell komplex und fehleranfällig. Die Bibliothek react-hook-form soll Abhilfe schaffen.\n'parentId': 'c2c5ea3e478bff04fc898402'\n'parentDescription': Kaum ein Softwareprojekt, das nicht in wesentlichen Teilen auf der JavaScript-Technologie basiert. Eine breite Unterstützung sowie, leistungsfähige Programmiersprachen, die Vielzahl moderner Tools, sowie ausgereifte Frameworks wie Angular, React, Vue.js oder Node.js machen den JavaScript-Werkzeugkasten zu einem Alleskönner. Das iJS Magazin informiert aktuell und umfassend über die wichtige und innovative Entwicklungen im JavaScript-Universum und bietet handfeste Praxisinformationen für Softwareentwickler und -architekten.\n'indexBrandName': ''\n'indexSeriesName': ''\n'author': 'Nils Hartmann'\n'chunkSource': 'text'\n'text': Formulare mit React: Gut in Form Wie die Bibliothek react-hook-form hilft, komplexe Formulare zu entwickeln Formulare sind aus den meisten Webanwendungen nicht wegzudenken. Die Entwicklung benutzerfreundlicher Formulare ist aber gar nicht so einfach und wird ohne Hilfsmittel schnell komplex und fehleranfällig. Die Bibliothek react-hook-form soll Abhilfe schaffen. Formulare sind aus den meisten Webanwendungen nicht wegzudenken. Die Entwicklung benutzerfreundlicher Formulare ist aber gar nicht so einfach und wird ohne Hilfsmittel schnell komplex und fehleranfällig. Die Bibliothek react-hook-form soll Abhilfe schaffen. Die Bibliothek react-hook-form [1] unterstützt bei der Entwicklung komplexer Formulare, indem sie sich um die Verwaltung von deren Zustand kümmert. Dabei geht es nicht nur um die eingegebenen Daten eines Formulars, sondern auch um Informationen wie die Frage, ob ein Feld verändert wurde („dirty“) oder ob es einen Fehler enthält. Zusätzlich bietet react-hook-form die Möglichkeit, die Daten des Formulars zu validieren, indem es etwa Validierungsbibliotheken wie zod [2] oder yup [3] integriert. Die Bibliothek kümmert sich dabei nicht um das UI, sondern stellt ein API zur Verfügung, mit dem eigene Komponenten mit react-hook-form integriert werden können. Das funktioniert natürlich auch mit Komponenten aus einer Bibliothek wie MUI [4] oder Shadcn [5]. Zur Demonstration von react-hook-form soll im Folgenden ein Formular gebaut werden, mit dem Benutzer einen Food Truck reservieren können. Dazu müssen der eigene Name und die Anzahl der erwarteten Gäste eingegeben und der gewünschte Foodtruck aus einer Liste ausgewählt werden. Außerdem müssen die Reservierungsdauer und die gewünschten Getränke angegeben werden. Für die einzelnen Daten gibt es dabei jeweils einige Bedingungen, die direkt im Formular überprüft werden sollen. So muss zum Beispiel zwingend der eigene Nachname eingegeben werden, der Reservierungszeitraum muss in der Zukunft liegen und die Anzahl der Gäste mehr als fünf betragen. Zur Kontrolle der Kosten soll direkt im Formular der Preis angezeigt werden, der sich aus der Reservierungsdauer und der Anzahl der Gäste zusammensetzt. Abbildung 1 zeigt das fertige Formular. Der fertige Source Code steht unter [6] zur\n'slidetext': ''\n'from': 'index'\n'score': 64.34918975830078\n'normalizedScore': 0.6434918975830078\n'beforeDatePenaltyScore': 0.6434918975830078\n\n'documentId': '11aa4ab6eae82f7b6df75323'\n'chunk_id': '68c26fc50a53cd001394ab8f'\n'access': 'granted'\n'part_number': 2\n'total_parts': 3\n'contentType': 'READ'\n'title': Essential React Tips: A Developer's Cheat Sheet - React 19's Must-Know Concepts\n'parentName': iJS Magazine Volume 19\n'language': 'EN'\n'date': '2025-06-24T22:00:00.000Z'\n'abstract': This cheat sheet offers a quick reference guide to key features and commands in React, helping developers streamline their workflow and accelerate development.\n'parentId': 'a1269c65e87d5b8ebcde4b28'\n'parentDescription': Broaden your knowledge and expand your JavaScript techniques and practices. From Angular, React, and WebAssembly, to the best JavaScript IDEs, open source tools and more, you’ll learn insights on everything JS from seasoned experts in their field. Keep up with JavaScript news, tips, and advice with interviews, tutorials, and in-depth articles.\n'indexBrandName': ''\n'indexSeriesName': ''\n'author': 'Jaime Garcia'\n'chunkSource': 'text'\n'text': Parent {children}  ); }  Child  Key Takeaway children is a special parameter in React that holds the elements inside a component. In the snippet above, children is equal to < h2 >Child. One important thing to remember is that React requires a root component. If you have multiple elements at the same level, you can wrap them using a Fragment to avoid unnecessary HTML wrappers. useEffect import { useEffect, useState } from 'react'; function Timer() { const [seconds, setSeconds] = useState(0); useEffect(() => { const interval = setInterval(() => { setSeconds((s) => s + 1); }, 1_000); return () => clearInterval(interval); // Cleanup }, []); return \n\nSeconds: {seconds}; } Remember useEffect runs on the client, not the server. The function passed to useEffect executes when the component is added to the DOM or when any of its dependencies (the second argument, an array) change. Additionally, an optional cleanup function can be defined, which React will run when the component is removed from the DOM. Rendering Arrays function TodoList() { const todo = [ 'Create project', 'Write code for the module A', 'Deploy the app' ]; return (  Todo List \n\n- {item}  ); } Insight The key to rendering an array in React is to iterate through it and build a JSX element. The most common method for this is .map(). It's also important to set a unique key for each element in the list. React uses this key to track and update nodes efficiently, improving performance when the list changes. Controlled Elements import { useState } from 'react'; function ControlledElements() { const [value, setValue] = useState(''); return (  setValue(event.target.value)} /> ); } Remember Controlled Elements rely on a state variable, allowing you to access the value as the user types. This is useful for validations or triggering side effects. Notice how the onChange listener receives a DOM event, which holds the value the user just entered. Conditional and Short-Circuit import Greeting from '../greeting'; import Counter from '../counter'; function Component() { const showGreeting = true const shortCircuit = true return (  Conditionals {showGreeting ?  : } {shortCircuit && \n\nShort-circuiting}  ); } Remember Conditional rendering and short-circuit evaluation are useful for toggling components. In the snippet above, the flag is\n'slidetext': ''\n'from': 'index'\n'score': 64.26167297363281\n'normalizedScore': 0.6426167297363281\n'beforeDatePenaltyScore': 0.6426167297363281\n\n'documentId': '6f5764d4aae6fe7d53d79d62'\n'chunk_id': '68da368ee61fb6001259ad86'\n'access': 'granted'\n'part_number': 4\n'total_parts': 13\n'contentType': 'READ'\n'title': Formulare mit React: Gut in Form - Wie die Bibliothek react-hook-form hilft, komplexe Formulare zu entwickeln\n'parentName': iJS Magazin 5.2025\n'language': 'DE'\n'date': '2025-09-23T22:00:00.000Z'\n'abstract': Formulare sind aus den meisten Webanwendungen nicht wegzudenken. Die Entwicklung benutzerfreundlicher Formulare ist aber gar nicht so einfach und wird ohne Hilfsmittel schnell komplex und fehleranfällig. Die Bibliothek react-hook-form soll Abhilfe schaffen.\n'parentId': 'c2c5ea3e478bff04fc898402'\n'parentDescription': Kaum ein Softwareprojekt, das nicht in wesentlichen Teilen auf der JavaScript-Technologie basiert. Eine breite Unterstützung sowie, leistungsfähige Programmiersprachen, die Vielzahl moderner Tools, sowie ausgereifte Frameworks wie Angular, React, Vue.js oder Node.js machen den JavaScript-Werkzeugkasten zu einem Alleskönner. Das iJS Magazin informiert aktuell und umfassend über die wichtige und innovative Entwicklungen im JavaScript-Universum und bietet handfeste Praxisinformationen für Softwareentwickler und -architekten.\n'indexBrandName': ''\n'indexSeriesName': ''\n'author': 'Nils Hartmann'\n'chunkSource': 'text'\n'text': das valueAsNumber-Attribut, um den String-Wert, der im guests-Eingabefeld steht, vor der Validierung in eine Zahl zu konvertieren (auch in einem input-Feld mit type='number' ist der Wert immer ein String, deswegen ist diese Konvertierung hier notwendig). Dank der Typsicherheit von react-hook-form kann TypeScript die Namen der Felder per Code Completion vorschlagen und überprüfen (Abb. 2). Die Funktion liefert dann ein Objekt mit Properties wie value, onBlur oder onChange zurück, die direkt an das UI-Element weitergegeben werden. Darüber kommuniziert react-hook-form dann mit dem verknüpften Element. Listing 2 zeigt die erste Variante des Formulars mit den Eingabefeldern für Namen und Anzahl der Gäste und einer Select-Komponente zur Auswahl eines Food Trucks. Damit das Listing möglichst einfach bleibt, wird auf die Angabe von CSS-Klassen und anderen Attributen (insbesondere für die Barrierefreiheit) verzichtet (das gilt für alle Listings). Listing 2: Erste Version des Formulars function ReservationForm() { const form = useForm({ resolver: zodResolver(ReservationFormState), }); return (  Make your reservation First name  Last name  Foodtruck   Burger Beast Curry Cruiser Pizza Palace Tasty Tacos  Expected guests   ); } Formular absenden In dieser ersten Version des Formulars haben wir die Eingabefelder mit der Zustandsverwaltung von react-hook-form verknüpft, allerdings verwenden wir die verwalteten Daten noch nicht. Zu jedem Feld (und dem Formular als Ganzem) speichert die Bibliothek eine Reihe von Informationen – etwa ob ein Feld besucht oder ob es verändert wurde und ob es gemäß den Validierungsregeln gültig ist. Die Informationen können mit den Developer-Tools der react-hook-form-Bibliothek angezeigt werden (Abb. 3). Dabei handelt es sich um eine React-Komponente, die in die eigene Form eingebunden werden kann. Die dargestellten Informationen sind zum Verständnis der Bibliothek und des Formulars sehr hilfreich. Die eingegebenen Daten im Formular werden von react-hook-form zu definierten Zeitpunkten bzw. nach definierten Events validiert. Per Default geschieht das, wenn das\n'slidetext': ''\n'from': 'index'\n'score': 64.169921875\n'normalizedScore': 0.64169921875\n'beforeDatePenaltyScore': 0.64169921875\n\n'documentId': '6f5764d4aae6fe7d53d79d62'\n'chunk_id': '68da368ee61fb6001259ad85'\n'access': 'granted'\n'part_number': 3\n'total_parts': 13\n'contentType': 'READ'\n'title': Formulare mit React: Gut in Form - Wie die Bibliothek react-hook-form hilft, komplexe Formulare zu entwickeln\n'parentName': iJS Magazin 5.2025\n'language': 'DE'\n'date': '2025-09-23T22:00:00.000Z'\n'abstract': Formulare sind aus den meisten Webanwendungen nicht wegzudenken. Die Entwicklung benutzerfreundlicher Formulare ist aber gar nicht so einfach und wird ohne Hilfsmittel schnell komplex und fehleranfällig. Die Bibliothek react-hook-form soll Abhilfe schaffen.\n'parentId': 'c2c5ea3e478bff04fc898402'\n'parentDescription': Kaum ein Softwareprojekt, das nicht in wesentlichen Teilen auf der JavaScript-Technologie basiert. Eine breite Unterstützung sowie, leistungsfähige Programmiersprachen, die Vielzahl moderner Tools, sowie ausgereifte Frameworks wie Angular, React, Vue.js oder Node.js machen den JavaScript-Werkzeugkasten zu einem Alleskönner. Das iJS Magazin informiert aktuell und umfassend über die wichtige und innovative Entwicklungen im JavaScript-Universum und bietet handfeste Praxisinformationen für Softwareentwickler und -architekten.\n'indexBrandName': ''\n'indexSeriesName': ''\n'author': 'Nils Hartmann'\n'chunkSource': 'text'\n'text': parse-Methode verwendet werden. Sie liefert das validierte Objekt zurück oder wirft einen Fehler, wenn es nicht den erwarteten Bedingungen entspricht. Neben dem Laufzeitverhalten von zod ist die TypeScript-Integration besonders spannend. Mit dem Aufruf z.infer wird aus der zod-Beschreibung ein TypeScript-Typ abgeleitet, der zum Beispiel in Funktionssignaturen und Variablendeklarationen verwendet werden kann. Somit kommt es nicht zu Inkonsistenzen zwischen der zod-Beschreibung und TypeScript. Zudem liefert auch die parse-Funktion Informationen für TypeScript zurück. Der zurückgelieferte Typescript-Typ entspricht auch hier dem beschriebenen zod-Typ. const Reservation = z.object({ firstName: z.string().optional(), lastName: z.string().nonempty(), foodTruck: z.string().nonempty(), guests: z.coerce.number().min(5), reservervationBegin: z.iso.date().refine( val => dayjs(val).isAfter(dayjs()), 'ReservationBegin must be a future date' ), }); type IReservation = z.infer; function editReservation(r: Reservation) { /* ... */ } const reservation = Reservation.parse(/* beliebiges Objekt hier */) // hier wissen wir, dass reservation gültig ist // TypeScript kennt außerdem automatisch den Typ // von reservation, sodass der folgende Aufruf funktioniert: editReservation(reservation); Das zentrale API von react-hook-form ist der useForm Hook, mit dem ein Formular konfiguriert wird. Der Hook nimmt unter anderem die Beschreibung entgegen, welche Felder es gibt, und liefert eine Reihe von Informationen und Funktionen zurück, die verwendet werden, um das UI mit dem von react-hook-form verwalteten Zustand des Formulars zu verknüpfen. Die Felder und deren Typen sind für unser Formular im gezeigten Zod-Schema beschrieben, das mit dem zodResolver von react-hook-form an useForm übergeben wird. Damit weiß react-hook-form, welche Felder es zur Laufzeit gibt, stellt diese Information aber schon zur Entwicklungszeit für TypeScript zur Verfügung, sodass Referenzen auf Felder über deren Namen überall im react-hook-form API für unser Formular typsicher sind. Abb. 2: TypeScript unterstützt bei der Formularentwicklung mit Code Completion Der useForm Hook liefert unter anderem die register-Funktion zurück, mit der UI-Elemente, zum Beispiel input-Felder, mit dem Formular-State verknüpft werden können. Dazu wird der Name eines zu verknüpfenden Felds übergeben. Zusätzlich können weitere Optionen angegeben werden. In unserem Beispiel verwenden wir das\n'slidetext': ''\n'from': 'index'\n'score': 64.07320404052734\n'normalizedScore': 0.6407320404052734\n'beforeDatePenaltyScore': 0.6407320404052734\n\n'documentId': '6f5764d4aae6fe7d53d79d62'\n'chunk_id': '68da368fe61fb6001259ad8d'\n'access': 'granted'\n'part_number': 11\n'total_parts': 13\n'contentType': 'READ'\n'title': Formulare mit React: Gut in Form - Wie die Bibliothek react-hook-form hilft, komplexe Formulare zu entwickeln\n'parentName': iJS Magazin 5.2025\n'language': 'DE'\n'date': '2025-09-23T22:00:00.000Z'\n'abstract': Formulare sind aus den meisten Webanwendungen nicht wegzudenken. Die Entwicklung benutzerfreundlicher Formulare ist aber gar nicht so einfach und wird ohne Hilfsmittel schnell komplex und fehleranfällig. Die Bibliothek react-hook-form soll Abhilfe schaffen.\n'parentId': 'c2c5ea3e478bff04fc898402'\n'parentDescription': Kaum ein Softwareprojekt, das nicht in wesentlichen Teilen auf der JavaScript-Technologie basiert. Eine breite Unterstützung sowie, leistungsfähige Programmiersprachen, die Vielzahl moderner Tools, sowie ausgereifte Frameworks wie Angular, React, Vue.js oder Node.js machen den JavaScript-Werkzeugkasten zu einem Alleskönner. Das iJS Magazin informiert aktuell und umfassend über die wichtige und innovative Entwicklungen im JavaScript-Universum und bietet handfeste Praxisinformationen für Softwareentwickler und -architekten.\n'indexBrandName': ''\n'indexSeriesName': ''\n'author': 'Nils Hartmann'\n'chunkSource': 'text'\n'text': Formulars wird aber zur Verbesserung der Performance auf das Neurendern verzichtet. Das bedeutet aber auch, dass wir nicht ohne Weiteres jederzeit Zugriff auf die aktuellen Werte haben. Kontrollierte und unkontrollierte Komponenten in React React unterscheidet zwischen „kontrollierten“ (controlled) und „unkontrollierten“ (uncontrolled) Komponenten. Bei kontrollierten Komponenten werden deren Daten in der Anwendung gehalten und verwaltet. Das geschieht in der Regel durch einen State in einer äußeren Komponente, der zum Beispiel per value-Property an ein input-Feld weitergegeben wird. Die äußere Komponente lauscht gleichzeitig auf Events der input-Komponente (onChange), um daraufhin ihren State zu ändern und den aktualisierten State der input-Komponente zur Verfügung zu stellen. Damit kontrolliert die äußere Komponente die Daten des input-Felds: welche Daten dargestellt und wie und wann sie verändert werden sollen. Bei einer unkontrollierten Komponente bleiben die Daten ausschließlich im DOM. Die Komponente kann dann z. B. über eine native Referenz auf das input-Feld zugreifen, um den aktuellen Inhalt abzufragen. Im Gegensatz zu einer kontrollierten Komponente wird dabei die Komponente nicht jedes Mal neu gerendert, wenn sich etwas ändert. Das ist auch der Grund, warum die react-hook-form-Bibliothek auf unkontrollierte Komponenten setzt. So muss ein (komplexes) Formular nicht bei jeder Zeicheneingabe komplett neu gerendert werden. Mit getValues haben wir ein Beispiel gesehen, das uns zwar aktuelle Werte zurückliefert, allerdings wird diese Funktion infolge eines Events aufgerufen. Sie selbst führt nicht dazu, dass das Formular neu gerendert wird. Wenn wir also auf Änderungen direkt reagieren wollen, brauchen wir einen anderen Weg. Diesen Weg stellt uns react-hook-form mit der watch-Funktion zur Verfügung. Ihr können wir eine Liste von Feldern übergeben. Ändert sich einer der Werte, wird die Komponente neu gerendert und die watch-Funktion liefert dann die jeweils aktuellen Werte zurück. In unserem Formular wollen wir diese Funktion benutzen, um die Berechnung der Reservierungskosten durchzuführen (Listing 9). Die Kosten sollen automatisch immer neu berechnet werden, wenn sich der Reservierungszeitraum oder die Anzahl der Gäste ändert. Dazu fragen wir mit der watch-Funktion die\n'slidetext': ''\n'from': 'index'\n'score': 64.01477813720703\n'normalizedScore': 0.6401477813720703\n'beforeDatePenaltyScore': 0.6401477813720703\n\n'documentId': '11aa4ab6eae82f7b6df75323'\n'chunk_id': '68c26fc50a53cd001394ab90'\n'access': 'granted'\n'part_number': 3\n'total_parts': 3\n'contentType': 'READ'\n'title': Essential React Tips: A Developer's Cheat Sheet - React 19's Must-Know Concepts\n'parentName': iJS Magazine Volume 19\n'language': 'EN'\n'date': '2025-06-24T22:00:00.000Z'\n'abstract': This cheat sheet offers a quick reference guide to key features and commands in React, helping developers streamline their workflow and accelerate development.\n'parentId': 'a1269c65e87d5b8ebcde4b28'\n'parentDescription': Broaden your knowledge and expand your JavaScript techniques and practices. From Angular, React, and WebAssembly, to the best JavaScript IDEs, open source tools and more, you’ll learn insights on everything JS from seasoned experts in their field. Keep up with JavaScript news, tips, and advice with interviews, tutorials, and in-depth articles.\n'indexBrandName': ''\n'indexSeriesName': ''\n'author': 'Jaime Garcia'\n'chunkSource': 'text'\n'text': is fixed, so the output is always the same. However, in a real application, this flag would likely be a state variable, allowing the UI to update dynamically. Forms import { useState } from 'react'; function Form() { const [value, setValue] = useState(''); const handleSubmit = (event) => { event.preventDefault(); alert(value) }; return (   setValue(event.target.value)} />  Submit   ); } Key takeaway Forms don’t mean much in React. In the above example, the onSubmit handler is used to trigger the handleSubmit function. However, handleSubmit could have been called from an onClick handler instead. Since the input fields are controlled, there’s really no need for the < form > element. That said, for clarity and readability, it's better to use < form > even when it’s not strictly necessary. It makes the code easier and more natural to understand. Context import { createContext, useContext, useState } from 'react'; const ThemeContext = createContext(); const ThemeProvider = ({ children }) => { const [theme, setTheme] = useState('light'); return (  {children}  ); }; const ThemedComponent = () => { const { theme, setTheme } = useContext(ThemeContext); return (  \n\nCurrent theme: {theme}  setTheme(theme === 'light' ? 'dark' : 'light')}> Toggle Theme   ); }; function ThemedPage() { return (    ); } Remember There are times when you’ll need to share data (variables or functions) between components. A common approach is using Props, but this can easily lead to Prop Drilling, where props are passed through multiple components. One way to solve this is by using Context. By wrapping any component that needs access to the context with the Provider, the component can then access and use the context’s values (whether variables or functions).\n'slidetext': ''\n'from': 'index'\n'score': 63.900291442871094\n'normalizedScore': 0.6390029144287109\n'beforeDatePenaltyScore': 0.6390029144287109\n\n'documentId': '6f5764d4aae6fe7d53d79d62'\n'chunk_id': '68da368fe61fb6001259ad8f'\n'access': 'granted'\n'part_number': 13\n'total_parts': 13\n'contentType': 'READ'\n'title': Formulare mit React: Gut in Form - Wie die Bibliothek react-hook-form hilft, komplexe Formulare zu entwickeln\n'parentName': iJS Magazin 5.2025\n'language': 'DE'\n'date': '2025-09-23T22:00:00.000Z'\n'abstract': Formulare sind aus den meisten Webanwendungen nicht wegzudenken. Die Entwicklung benutzerfreundlicher Formulare ist aber gar nicht so einfach und wird ohne Hilfsmittel schnell komplex und fehleranfällig. Die Bibliothek react-hook-form soll Abhilfe schaffen.\n'parentId': 'c2c5ea3e478bff04fc898402'\n'parentDescription': Kaum ein Softwareprojekt, das nicht in wesentlichen Teilen auf der JavaScript-Technologie basiert. Eine breite Unterstützung sowie, leistungsfähige Programmiersprachen, die Vielzahl moderner Tools, sowie ausgereifte Frameworks wie Angular, React, Vue.js oder Node.js machen den JavaScript-Werkzeugkasten zu einem Alleskönner. Das iJS Magazin informiert aktuell und umfassend über die wichtige und innovative Entwicklungen im JavaScript-Universum und bietet handfeste Praxisinformationen für Softwareentwickler und -architekten.\n'indexBrandName': ''\n'indexSeriesName': ''\n'author': 'Nils Hartmann'\n'chunkSource': 'text'\n'text': 'reservationPeriod.end', 'guests'], }); const price = calculatePrice(start, end, guests); return (  Estimated price {price} €  ); } Damit ist unser Formular fertig. Es enthält zahlreiche Anforderungen, die auch in echten Anwendungen immer wieder vorkommen. Bei der Umsetzung hilft uns react-hook-form auf vielfältige Weise. Zum einen stellt es die korrekte Verwendung der Felder im Code durch eine hohe Typsicherheit sicher. Zum anderen – und das ist viel wichtiger – stellt es zahlreiche APIs zur Verfügung, mit denen benutzerfreundliche Formulare entwickelt werden können, etwa die Validierung der Inhalte. Im Zusammenspiel mit zod bietet das sehr mächtige Möglichkeiten. Gleichzeitig sorgt die Bibliothek für eine hohe Performance auch bei großen Formularen. Links & Literatur [1] https://www.react-hook-form.com [2] https://zod.dev [3] https://github.com/jquense/yup [4] https://mui.com [5] https://www.shadcn.io [6] https://github.com/nilshartmann/react-hook-form-example [7] https://day.js.org\n'slidetext': ''\n'from': 'index'\n'score': 63.85466384887695\n'normalizedScore': 0.6385466384887696\n'beforeDatePenaltyScore': 0.6385466384887696\n\n'documentId': '6f5764d4aae6fe7d53d79d62'\n'chunk_id': '68da368fe61fb6001259ad8c'\n'access': 'granted'\n'part_number': 10\n'total_parts': 13\n'contentType': 'READ'\n'title': Formulare mit React: Gut in Form - Wie die Bibliothek react-hook-form hilft, komplexe Formulare zu entwickeln\n'parentName': iJS Magazin 5.2025\n'language': 'DE'\n'date': '2025-09-23T22:00:00.000Z'\n'abstract': Formulare sind aus den meisten Webanwendungen nicht wegzudenken. Die Entwicklung benutzerfreundlicher Formulare ist aber gar nicht so einfach und wird ohne Hilfsmittel schnell komplex und fehleranfällig. Die Bibliothek react-hook-form soll Abhilfe schaffen.\n'parentId': 'c2c5ea3e478bff04fc898402'\n'parentDescription': Kaum ein Softwareprojekt, das nicht in wesentlichen Teilen auf der JavaScript-Technologie basiert. Eine breite Unterstützung sowie, leistungsfähige Programmiersprachen, die Vielzahl moderner Tools, sowie ausgereifte Frameworks wie Angular, React, Vue.js oder Node.js machen den JavaScript-Werkzeugkasten zu einem Alleskönner. Das iJS Magazin informiert aktuell und umfassend über die wichtige und innovative Entwicklungen im JavaScript-Universum und bietet handfeste Praxisinformationen für Softwareentwickler und -architekten.\n'indexBrandName': ''\n'indexSeriesName': ''\n'author': 'Nils Hartmann'\n'chunkSource': 'text'\n'text': entsprechende Property heißt hier – etwas verwirrend – fields. Ein Eintrag in fields entspricht einem Eintrag in der Liste, erweitert um eine eindeutige ID, die von react-hook-form vergeben und verwaltet wird. Der Zugriff auf die Fehler erfolgt analog zu den Nicht-Array-Feldern, nur dass hier bei den Namen auch der jeweilige Index in der Liste angegeben werden muss. Übrigens ist TypeScript trotz dieses dynamischen Namens in der Lage, sicherzustellen, dass die Namen korrekt angegeben werden. Mit den insert- und remove-Methoden sind wir in der Lage, neue Einträge in die Liste einzufügen bzw. zu entfernen. Listing 8: Mit useFieldArray werden dynamische Listen in einem Formular verwaltet const DrinkOrder = z.object({ amount: z.number().min(1), name: z.string().nonempty(), }); const ReservationFormState = z.object({ // ... drinkOrders: DrinkOrder.array(), }); export default function ReservationForm() { const form = useForm(/* ... */); const drinkOrders = useFieldArray({ control: form.control, name: 'drinkOrders', }); // ... return (  Order your drinks {drinkOrders.fields.map((drinkField, ix) => { return (    {form.formState.errors.drinkOrders?.[ix]?.amount?.message}  {/* Fehlerdarstellung analog zu oben, deswegen hier ausgelassen */}   drinkOrders.remove(ix)}> Remove   ); })}  drinkOrders.append({ amount: 0, name: '', }) } > Add   ); } Auf Veränderungen im Formular reagieren react-hook-form arbeitet mit unkontrollierten React-Komponenten (Kasten: „Kontrollierte und unkontrollierte Komponenten“). Dadurch wird eine Komponente, die ein Formular enthält (in unserem Beispiel ReservationForm), nicht bei jeder Änderung im Formular neu gerendert. Die Komponente wird nur dann neu gerendert, wenn sich der sogenannte formState verändert. Das ist z. B. die Information, ob das Formular verändert wurde (isDirty), ob alle Eingaben gültig sind (isValid) oder die Liste mit Fehlern (errors). Diese Informationen ändern sich nur selten, sodass bei deren Änderung das erneute Rendern der Komponente in Kauf genommen wird. Bei Änderungen am Inhalt des Formulars\n'slidetext': ''\n'from': 'index'\n'score': 63.787601470947266\n'normalizedScore': 0.6378760147094726\n'beforeDatePenaltyScore': 0.6378760147094726\n\n'documentId': '6f5764d4aae6fe7d53d79d62'\n'chunk_id': '68da368fe61fb6001259ad8a'\n'access': 'granted'\n'part_number': 8\n'total_parts': 13\n'contentType': 'READ'\n'title': Formulare mit React: Gut in Form - Wie die Bibliothek react-hook-form hilft, komplexe Formulare zu entwickeln\n'parentName': iJS Magazin 5.2025\n'language': 'DE'\n'date': '2025-09-23T22:00:00.000Z'\n'abstract': Formulare sind aus den meisten Webanwendungen nicht wegzudenken. Die Entwicklung benutzerfreundlicher Formulare ist aber gar nicht so einfach und wird ohne Hilfsmittel schnell komplex und fehleranfällig. Die Bibliothek react-hook-form soll Abhilfe schaffen.\n'parentId': 'c2c5ea3e478bff04fc898402'\n'parentDescription': Kaum ein Softwareprojekt, das nicht in wesentlichen Teilen auf der JavaScript-Technologie basiert. Eine breite Unterstützung sowie, leistungsfähige Programmiersprachen, die Vielzahl moderner Tools, sowie ausgereifte Frameworks wie Angular, React, Vue.js oder Node.js machen den JavaScript-Werkzeugkasten zu einem Alleskönner. Das iJS Magazin informiert aktuell und umfassend über die wichtige und innovative Entwicklungen im JavaScript-Universum und bietet handfeste Praxisinformationen für Softwareentwickler und -architekten.\n'indexBrandName': ''\n'indexSeriesName': ''\n'author': 'Nils Hartmann'\n'chunkSource': 'text'\n'text': dass der Reservierungsbeginn in der Zukunft und das Reservierungsende mindestens einen Tag nach Reservierungsstart liegt. Listing 6 zeigt die erweiterten zod-Definitionen. Listing 6: Erweitern des Formulars um den Reservierungszeitraum mit eigenen Validierungsregeln const ReservationPeriod = z .object({ start: z.iso .date() .refine( (val) => dayjs(val).isAfter(dayjs()), 'Reservation start date must be in the future.', ), end: z.iso.date(), }) .refine((val) => dayjs(val.end).isAfter(val.start), { message: 'Reservation end date must be after the start date.', // Der Fehler soll dem 'end'-Feld zugeordnet werden path: ['end'], }); const ReservationFormState = z.object({ // ... reservationPeriod: ReservationPeriod, }); Zum Eingeben des Start- und Enddatums erweitern wir das Formular jeweils um ein input-Feld vom Typ date und verknüpfen die beiden Felder mit der register-Funktion mit reservationPeriod.start bzw. reservationPeriod.end aus unseren Formulardaten (Listing 7). Dabei sehen wir auch, dass wir mit react-hook-form Unterobjekte (reservationPeriod) verwenden und darauf ebenfalls typsicher zugreifen können, denn die Angaben reservationPeriod.start und reservationPeriod.end sind ebenfalls durch TypeScript abgesichert. Als Ausfüllhilfe für das Startdatum soll das Formular einen Button bekommen, mit dem man das Datum auf „morgen“ setzen kann. Um den Wert eines Feldes von außen zu setzen, kommt die setValue-Funktion zum Einsatz. Dieser gibt man den Namen eines Feldes und den neuen Wert für das Feld an. Natürlich ist auch hier der Feldname wieder typsicher. React-hook-form setzt den Wert dann in das entsprechende Feld im Formular. Damit der Wert auch gleich validiert wird, wird außerdem die Option shouldValidate gesetzt. Andernfalls kann es passieren, dass das Formular ungültig bleibt, wenn zuvor ein ungültiger Wert in dem Feld stand (z. B. leeres Datum). Auch zum Ausfüllen des Enddatums soll es eine Hilfe geben, mit der das Datum auf einen bzw. zwei Tage nach dem Startdatum gesetzt werden soll. Das Setzen des Werts geschieht auch hier mit setValue. Allerdings muss dafür der Wert des Startdatums bekannt sein. Zum Zugriff auf den Wert eines oder mehrerer Felder stellt react-hook-form die Funktion getValues zur Verfügung. Ihr werden ein oder mehrere Feldnamen übergeben, deren aktuelle Werte zurückgeliefert werden. In unserem Fall lesen wir damit\n'slidetext': ''\n'from': 'index'\n'score': 63.787601470947266\n'normalizedScore': 0.6378760147094726\n'beforeDatePenaltyScore': 0.6378760147094726\n\n'documentId': '6f5764d4aae6fe7d53d79d62'\n'chunk_id': '68da368fe61fb6001259ad88'\n'access': 'granted'\n'part_number': 6\n'total_parts': 13\n'contentType': 'READ'\n'title': Formulare mit React: Gut in Form - Wie die Bibliothek react-hook-form hilft, komplexe Formulare zu entwickeln\n'parentName': iJS Magazin 5.2025\n'language': 'DE'\n'date': '2025-09-23T22:00:00.000Z'\n'abstract': Formulare sind aus den meisten Webanwendungen nicht wegzudenken. Die Entwicklung benutzerfreundlicher Formulare ist aber gar nicht so einfach und wird ohne Hilfsmittel schnell komplex und fehleranfällig. Die Bibliothek react-hook-form soll Abhilfe schaffen.\n'parentId': 'c2c5ea3e478bff04fc898402'\n'parentDescription': Kaum ein Softwareprojekt, das nicht in wesentlichen Teilen auf der JavaScript-Technologie basiert. Eine breite Unterstützung sowie, leistungsfähige Programmiersprachen, die Vielzahl moderner Tools, sowie ausgereifte Frameworks wie Angular, React, Vue.js oder Node.js machen den JavaScript-Werkzeugkasten zu einem Alleskönner. Das iJS Magazin informiert aktuell und umfassend über die wichtige und innovative Entwicklungen im JavaScript-Universum und bietet handfeste Praxisinformationen für Softwareentwickler und -architekten.\n'indexBrandName': ''\n'indexSeriesName': ''\n'author': 'Nils Hartmann'\n'chunkSource': 'text'\n'text': zod zur Validierung eingesetzt, entspricht die message der Default- oder explizit gesetzten Fehlermeldung aus der zod-Beschreibung eines Feldes. Gibt es zu einem Feld keinen Fehler, weil die Validierung noch nicht ausgeführt wurde oder die Eingabe gültig ist, enthält das errors-Objekt keinen Eintrag für das Feld. Listing 4 zeigt die Angabe eigener Fehlermeldungen mit Zod und exemplarisch deren Darstellung für die ersten beiden Felder im Formular. Außerdem wird neben dem Submit-Button ein allgemeiner Hinweis ausgegeben, wenn das Formular submittet wurde und es dabei mindestens einen Fehler im Formular gibt. Der neue Clear-Button verwendet die reset-Funktion von react-hook-form, um das Formular inklusive aller (Fehler-)Zustände zurückzusetzen. Ein Beispiel für die Darstellung der Fehlermeldungen ist in Abbildung 4 zu sehen. Listing 4: Darstellung von Fehlermeldungen const ReservationFormState = z.object({ firstName: z.string().optional(), lastName: z.string().nonempty('Please enter your last name'), foodTruck: z.string().nonempty('Please select your favourite food truck'), guests: z.number().min(5, 'The minimum number of guests is 5'), }); function ReservationForm() { const form = useForm({ /* ... */ }); return (  First name  {form.formState.errors.firstName?.message} Last name  {form.formState.errors.lastName?.message} { /* ... */ } {form.formState.isSubmitted && !form.formState.isValid && Please correct your input}} Submit  form.reset()}> Clear   ); } Abb. 4: Im Formular werden Fehlermeldungen angezeigt Damit haben wir die Grundzüge von react-hook-form gesehen. Wir haben mit zod beschrieben, welche Felder es in unserem Formular gibt und welche Bedingungen es für die Felder gibt. Mit useForm haben wir unsere Form konfiguriert und ein Objekt erhalten, das unter anderem aktuelle Informationen über unser Formular enthält (Fehlermeldungen, Dirty-Zustände etc.) und Funktionen bereitstellt, mit denen wir unsere eigenen UI-Komponenten mit dem Formularzustand verknüpfen können, sodass react-hook-form in der Lage ist, deren Inhalte zu steuern und zu validieren. Arbeiten mit den Formulardaten Auf die aktuell eingegebenen Inhalte im Formular haben wir – abgesehen von der handleFormSubmit-Funktion – noch\n'slidetext': ''\n'from': 'index'\n'score': 63.74568176269531\n'normalizedScore': 0.6374568176269532\n'beforeDatePenaltyScore': 0.6374568176269532\n\n'documentId': '6f5764d4aae6fe7d53d79d62'\n'chunk_id': '68da368fe61fb6001259ad8e'\n'access': 'granted'\n'part_number': 12\n'total_parts': 13\n'contentType': 'READ'\n'title': Formulare mit React: Gut in Form - Wie die Bibliothek react-hook-form hilft, komplexe Formulare zu entwickeln\n'parentName': iJS Magazin 5.2025\n'language': 'DE'\n'date': '2025-09-23T22:00:00.000Z'\n'abstract': Formulare sind aus den meisten Webanwendungen nicht wegzudenken. Die Entwicklung benutzerfreundlicher Formulare ist aber gar nicht so einfach und wird ohne Hilfsmittel schnell komplex und fehleranfällig. Die Bibliothek react-hook-form soll Abhilfe schaffen.\n'parentId': 'c2c5ea3e478bff04fc898402'\n'parentDescription': Kaum ein Softwareprojekt, das nicht in wesentlichen Teilen auf der JavaScript-Technologie basiert. Eine breite Unterstützung sowie, leistungsfähige Programmiersprachen, die Vielzahl moderner Tools, sowie ausgereifte Frameworks wie Angular, React, Vue.js oder Node.js machen den JavaScript-Werkzeugkasten zu einem Alleskönner. Das iJS Magazin informiert aktuell und umfassend über die wichtige und innovative Entwicklungen im JavaScript-Universum und bietet handfeste Praxisinformationen für Softwareentwickler und -architekten.\n'indexBrandName': ''\n'indexSeriesName': ''\n'author': 'Nils Hartmann'\n'chunkSource': 'text'\n'text': die Werte von reservationPeriod und guests ab und berechnen (fiktiv) einen Preis. Listing 9: Mit der watch-Funktion wird auf Veränderungen im Formular reagiert function ReservationForm() { const form = useForm({ /* ... */ }) const [start, end, guests] = form.watch([ 'reservationPeriod.start', 'reservationPeriod.end', 'guests', ]); // fiktive Funktion, die den Preis berechnet const price = calculatePrice(start, end, guests); return (  { /* ... */ }  Estimated price {price} €   ); } Der Einsatz von watch führt wie beschrieben nun dazu, dass sich die ReservationForm-Komponente immer neu rendert, wenn sich einer dieser Werte ändert. So ist sichergestellt, dass wir immer aktuelle Werte haben und einen aktuellen Preis berechnen können. Ein möglicher Nachteil ist, dass die Performance des Formulars leiden kann, denn das ganze Formular wird ja nun jedes Mal neu gerendet, wenn sich der Reservierungszeitraum oder die Anzahl der Gäste ändert. Das ist in unserem Beispiel sicherlich verschmerzbar, denn das Formular ist insgesamt nicht sehr komplex. Als Ausblick, wie Formulare alternativ mit react-hook-form strukturiert werden sollen, passen wir die Logik aber zum Abschluss noch einmal an und verschieben den Code zum Berechnen und Ausgeben des Preises in die neue Unterkomponente PriceCalculator (Listing 10). Dazu wird die control-Eigenschaft des Formulars an die Unterkomponente weitergegeben, sodass diese nun auch Zugriff auf das Formular hat. (Eine mögliche Alternative dazu wäre der FormContext. Dieser ist vor allem dann sinnvoll, wenn man das Formular in Unterkomponenten aufteilen möchte, in denen auch Felder registriert werden). In der PriceCalculator-Komponente verwenden wir den useWatch Hook, der ähnlich funktioniert wie die watch-Funktion. Hiermit wird allerdings sichergestellt, dass sich wirklich nur die verwendete Komponente (PriceCalculator) und nicht das gesamte Formular (ReservationForm) neu rendert. Listing 10: Aufteilung des Formulars in zwei Komponenten function ReservationForm() { const form = useForm({ /* ... */ }) // hier kein watch mehr return (  \n\n ); } type PriceCalculatorProps = { control: Control; }; function PriceCalculator({ control }: PriceCalculatorProps) { const [start, end, guests] = useWatch({ control, name: ['reservationPeriod.start', 'reservationPeriod.end',\n'slidetext': ''\n'from': 'index'\n'score': 62.956764221191406\n'normalizedScore': 0.6295676422119141\n'beforeDatePenaltyScore': 0.6295676422119141\n\n'documentId': '6f5764d4aae6fe7d53d79d62'\n'chunk_id': '68da368fe61fb6001259ad87'\n'access': 'granted'\n'part_number': 5\n'total_parts': 13\n'contentType': 'READ'\n'title': Formulare mit React: Gut in Form - Wie die Bibliothek react-hook-form hilft, komplexe Formulare zu entwickeln\n'parentName': iJS Magazin 5.2025\n'language': 'DE'\n'date': '2025-09-23T22:00:00.000Z'\n'abstract': Formulare sind aus den meisten Webanwendungen nicht wegzudenken. Die Entwicklung benutzerfreundlicher Formulare ist aber gar nicht so einfach und wird ohne Hilfsmittel schnell komplex und fehleranfällig. Die Bibliothek react-hook-form soll Abhilfe schaffen.\n'parentId': 'c2c5ea3e478bff04fc898402'\n'parentDescription': Kaum ein Softwareprojekt, das nicht in wesentlichen Teilen auf der JavaScript-Technologie basiert. Eine breite Unterstützung sowie, leistungsfähige Programmiersprachen, die Vielzahl moderner Tools, sowie ausgereifte Frameworks wie Angular, React, Vue.js oder Node.js machen den JavaScript-Werkzeugkasten zu einem Alleskönner. Das iJS Magazin informiert aktuell und umfassend über die wichtige und innovative Entwicklungen im JavaScript-Universum und bietet handfeste Praxisinformationen für Softwareentwickler und -architekten.\n'indexBrandName': ''\n'indexSeriesName': ''\n'author': 'Nils Hartmann'\n'chunkSource': 'text'\n'text': das Formular submittet wird. Alternativ kann die Validierung zum Beispiel auch beim Verlassen eines Felds (onBlur) oder nach jeder Änderung (onChange) ausgeführt werden. Dazu wird die Option mode beim Aufruf von useForm verwendet. Damit ein Formular submittet werden kann, wird mit der Funktion handleSubmit eine Callback-Funktion angegeben, der beim Submit die validierten Daten des Formulars übergeben werden. Für den Fall, dass die Daten nicht erfolgreich validiert werden konnten, wird eine zweite Funktion hinterlegt, die mit den Fehlern aufgerufen wird, die beim Validieren aufgetreten sind. Listing 3 zeigt diese beiden Funktionen (handleFormSubmit und handleFormError) und ihre Verwendung in der Form. Im Beispiel geben sie das Ergebnis jeweils zur Demonstration nur auf der Konsole aus. In einem echten Formular könnten die Formulardaten in handleFormSubmit zum Beispiel im Backend gespeichert werden. Die Fehler, die in handleFormError ausgegeben werden, werden wir im zweiten Schritt direkt im Formular anzeigen. Damit das Formular submittet werden kann, ist außerdem ein entsprechender Button mit dem Type submit im Formular ergänzt. Listing 3: Callback-Funktionen für das Submitten des Formulars function ReservationForm() { const form = useForm({ resolver: zodResolver(ReservationFormState), // 'onSubmit' ist default. // Alternative z.B. 'onBlur' oder 'onChange' mode: 'onSubmit', }); const handleFormSubmit = (data: ReservationFormState) => { console.log('Valid date on form submit:', data); }; const handleFormError = (err: FieldErrors) => { console.log('Errors on form submit:', err); }; return (  { /* ...wie bisher ... */ } Submit  ); } Abb. 3: Die Developer-Tools zeigen den State der Form und der Felder Validierung und Fehlermeldungen Wird das Formular nun mit dem entsprechenden Button submittet, validiert react-hook-form die eingegebenen Daten und ruft eine der beiden Callback-Funktionen auf. Gleichzeitig rendert die Bibliothek das Formular neu und stellt die Fehler pro Feld unter formState.errors zur Verfügung. Auch das errors-Objekt ist typsicher und enthält nur Einträge, die den Feldnamen des Formulars entsprechen. Wie ein Eintrag in dem Objekt aussieht, hängt auch von der verwendeten Validierungsbibliothek ab. Es gibt allerdings immer eine Eigenschaft mit dem Namen message, die eine Fehlermeldung zur Ausgabe auf der Oberfläche enthält. Wird zod\n'slidetext': ''\n'from': 'index'\n'score': 62.90426254272461\n'normalizedScore': 0.6290426254272461\n'beforeDatePenaltyScore': 0.6290426254272461\n\n'documentId': '6f5764d4aae6fe7d53d79d62'\n'chunk_id': '68da368fe61fb6001259ad8b'\n'access': 'granted'\n'part_number': 9\n'total_parts': 13\n'contentType': 'READ'\n'title': Formulare mit React: Gut in Form - Wie die Bibliothek react-hook-form hilft, komplexe Formulare zu entwickeln\n'parentName': iJS Magazin 5.2025\n'language': 'DE'\n'date': '2025-09-23T22:00:00.000Z'\n'abstract': Formulare sind aus den meisten Webanwendungen nicht wegzudenken. Die Entwicklung benutzerfreundlicher Formulare ist aber gar nicht so einfach und wird ohne Hilfsmittel schnell komplex und fehleranfällig. Die Bibliothek react-hook-form soll Abhilfe schaffen.\n'parentId': 'c2c5ea3e478bff04fc898402'\n'parentDescription': Kaum ein Softwareprojekt, das nicht in wesentlichen Teilen auf der JavaScript-Technologie basiert. Eine breite Unterstützung sowie, leistungsfähige Programmiersprachen, die Vielzahl moderner Tools, sowie ausgereifte Frameworks wie Angular, React, Vue.js oder Node.js machen den JavaScript-Werkzeugkasten zu einem Alleskönner. Das iJS Magazin informiert aktuell und umfassend über die wichtige und innovative Entwicklungen im JavaScript-Universum und bietet handfeste Praxisinformationen für Softwareentwickler und -architekten.\n'indexBrandName': ''\n'indexSeriesName': ''\n'author': 'Nils Hartmann'\n'chunkSource': 'text'\n'text': damit den Wert für das Startdatum aus, berechnen auf dessen Grundlage das neue Enddatum und setzten es mit setValue, wobei wir den Wert ebenfalls direkt validieren lassen. In Listing 7 wird mit getValues und setValues auf die Werte eines Formulars zugegriffen. Die Darstellung der Fehlermeldungen erfolgt anlog zu den bisherigen Beispielen und wurde der Übersicht wegen im Listing ausgelassen. Listing 7 function ReservationForm({ existingReservation, }: ReservationFormProps) { // ... const handleStartTomorrow = () => { const value = dayjs().add(1, 'day').format('YYYY-MM-DD'); form.setValue('reservationPeriod.start', value, { shouldValidate: true }); }; const handleEndInDays = (days: number) => { const startDate = form.getValues('reservationPeriod.start'); const endDate = dayjs(startDate).add(days, 'day').format('YYYY-MM-DD'); form.setValue('reservationPeriod.end', endDate, { shouldValidate: true }); }; return (  { /* ... */ } Start   Tomorrow  End   handleEndInDays(1)} > One day   handleEndInDays(2)} > Two days   ); } Dynamische Listen In unserem Formular sollen Benutzer zu einer Reservierung eine Liste von Getränkebestellungen aufgeben können. Eine einzelne Bestellung (DrinkOrder) ist ein eigenständiges Objekt, das nur aus zwei Eigenschaften besteht, um das Beispiel einfach zu halten: der gewünschten Menge und dem Namen des Getränks. Auch dazu wird ein eigener zod-Typ definiert. Dem Formularschema wird dieses Objekt als Array hinzugefügt. Listing 8 zeigt das erweiterte Formular. Da die Bestellungen variabel sind, muss das Formular in der Lage sein, einzelne der Liste hinzuzufügen bzw. auf Wunsch wieder zu entfernen. Für solche dynamischen Listen stellt react-hook-form den Hook useFieldArray zur Verfügung. Ihm wird die control-Eigenschaft des Formulars übergeben, über die der Hook mit dem Formular kommunizieren kann und dessen Typinformationen übernimmt. Als weiterer Parameter wird der Name des dynamischen Felds übergeben, in unserem Fall drinkOrders. Auch hier hilft TypeScript bei der Angabe des Namens, es werden nämlich nur Felder vorgeschlagen, die im Formularschema ein Array sind. Über den Rückgabewert von useFieldArray erhält man Zugriff auf den aktuellen Inhalt der Liste, die entsprechende\n'slidetext': ''\n'from': 'index'\n'score': 62.855194091796875\n'normalizedScore': 0.6285519409179687\n'beforeDatePenaltyScore': 0.6285519409179687\n\n'documentId': '50c03dd02cf9b7c2ff4480f2'\n'chunk_id': '68b55eab33a5bf00132cb682'\n'access': 'granted'\n'part_number': 1\n'total_parts': 47\n'contentType': 'TUTORIAL'\n'title': React-Grundlagen\n'parentName': Modern React: von Null auf Full-Stack\n'language': 'DE'\n'date': '2025-08-27T09:53:51.000Z'\n'abstract': In der ersten Lesson lernst du, was React ist und wie es funktioniert. Anhand einer Beispielanwendung schauen wir uns den Projektaufbau und den Workspace an. Du erfährst, wie Komponenten aufgebaut sind, wie man mit Props, Listen und State arbeitet und wie Interaktionen in React abgebildet werden.\n'parentId': 'b2c71c7c41dfe8eab4593f02'\n'parentDescription': In diesem Videotutorial lernst du React von Grund auf – bis hin zur Full-Stack-Entwicklung mit Next.js. Du baust Single Page Applications, verwaltest State, entwickelst moderne Formulare, arbeitest mit serverseitigen Daten und setzt Routing effizient um. Zum Abschluss bekommst du eine Einführung in React Server Components und Next.js. Benötigte Vorkenntnisse: JavaScript-Grundlagen, TypeScript ist hilfreich, aber nicht zwingend nötig. Nach dem Tutorial bist du bereit, eigene client- und serverseitige Anwendungen mit React umzusetzen.\n'indexBrandName': 'InternationalJavaScriptCon'\n'indexSeriesName': ''\n'author': 'Nils Hartmann'\n'chunkSource': 'text'\n'text': React-Grundlagen In der ersten Lesson lernst du, was React ist und wie es funktioniert. Anhand einer Beispielanwendung schauen wir uns den Projektaufbau und den Workspace an. Du erfährst, wie Komponenten aufgebaut sind, wie man mit Props, Listen und State arbeitet und wie Interaktionen in React abgebildet werden. Ja, herzlich willkommen zu meinem Videokurs zu React. Mein Name ist Nils Hartmann. Ich beschäftige mich seit einigen Jahren mit der React-Entwicklung, gebe in dem Zusammenhang auch Workshops und mache Vorträge auf Konferenzen. Und in diesem Kurs möchte ich euch die Entwicklung von Web-Anwendungen mit React näherbringen. Dabei fangen wir sozusagen bei Null an. Das heißt ich zeige euch erst mal, was sind eigentlich die Grundlagen von React? Was kann man mit React überhaupt machen? Was ist React überhaupt? Und so weiter und so fort. Und dann entfernen wir uns sozusagen von dem Kern React ein bisschen. Wir gucken uns typische Bibliotheken an die man benutzt, wenn man React-Anwendung baut. Und wir werden auch die Frage besprechen, ob man React-Anwendung eigentlich nur kleinzeitig ausführt oder ob man sie auch auf dem Server ausführen sollte. Das Stichwort wäre hier zum Beispiel Server-Side-Rendering, Full-Stack-React-Anwendung oder auch Frameworks für React. Habt ihr vielleicht schon mal gehört. Das alles möchte ich mit euch besprechen, sodass ihr dann nach dem Tutorial einen guten Eindruck davon habt was React ist, wie React funktioniert und ob React auch vielleicht für euer Projekt, für eure Anwendung eine Option sein könnte. Und falls ja, mit welchem Ansatz sozusagen ihr dann eure React-Anwendung bauen würdet. Also eher so auf dem Client oder auf dem Server oder beides. Das könnt ihr dann nach dem Kurs hoffentlich für euch entscheiden. Bevor wir richtig einsteigen, möchte ich euch noch ein paar Punkte sagen, die wir in diesem Kurs besprechen und die wir auch nicht besprechen. Wir werden, wie gesagt, bei Null anfangen. Das heißt ich zeige euch die Grundlagen von React. Dann werden wir uns Bibliotheken angucken und im letzten Teil werden wir uns dann Frameworks angucken und zwar in erster Linie Next.js, mit dem wir dann React-Anwendungen auch auf dem Server ausführen.\n'slidetext': ''\n'from': 'index'\n'score': 62.706722259521484\n'normalizedScore': 0.6270672225952149\n'beforeDatePenaltyScore': 0.6270672225952149\n\n'documentId': '50c03dd02cf9b7c2ff4480f2'\n'chunk_id': '68b55eab33a5bf00132cb683'\n'access': 'granted'\n'part_number': 2\n'total_parts': 47\n'contentType': 'TUTORIAL'\n'title': React-Grundlagen\n'parentName': Modern React: von Null auf Full-Stack\n'language': 'DE'\n'date': '2025-08-27T09:53:51.000Z'\n'abstract': In der ersten Lesson lernst du, was React ist und wie es funktioniert. Anhand einer Beispielanwendung schauen wir uns den Projektaufbau und den Workspace an. Du erfährst, wie Komponenten aufgebaut sind, wie man mit Props, Listen und State arbeitet und wie Interaktionen in React abgebildet werden.\n'parentId': 'b2c71c7c41dfe8eab4593f02'\n'parentDescription': In diesem Videotutorial lernst du React von Grund auf – bis hin zur Full-Stack-Entwicklung mit Next.js. Du baust Single Page Applications, verwaltest State, entwickelst moderne Formulare, arbeitest mit serverseitigen Daten und setzt Routing effizient um. Zum Abschluss bekommst du eine Einführung in React Server Components und Next.js. Benötigte Vorkenntnisse: JavaScript-Grundlagen, TypeScript ist hilfreich, aber nicht zwingend nötig. Nach dem Tutorial bist du bereit, eigene client- und serverseitige Anwendungen mit React umzusetzen.\n'indexBrandName': 'InternationalJavaScriptCon'\n'indexSeriesName': ''\n'author': 'Nils Hartmann'\n'chunkSource': 'text'\n'text': ausführen. Wir werden uns nicht angucken, Themen zum Beispiel wie Styling, also wie ihr CSS in euren Anwendungen verwendet. Da macht React mehr oder weniger keine Aussage zu. Da könnt ihr alles benutzen, ihr was ihr möchtet. Alles was es an CSS-Optionen gibt, das werde ich hier nicht weiter besprechen. Und für den Kurs ist es hilfreich, wenn du JavaScript und TypeScript-Kenntnisse mitbringst. Du brauchst natürlich keine React-Kenntnisse. Kenntnisse von HTML sind sicherlich hilfreich. Kenntnisse grundsätzlich von Webentwicklungen sind sicherlich hilfreich. Ich glaube aber dass du dem Kurs auch sogar folgen kannst, wenn du keine oder nur wenig JavaScript und TypeScript-Kenntnisse hast. Du wirst wahrscheinlich die Konzepte dann zumindest auch verstehen, selbst wenn die ein oder andere Syntax vielleicht unklar ist. Anfangen werden wir bei Null mit einer klassischen Single-Page-Anwendung mit React. Das ist eigentlich mittlerweile fast ein bisschen umstritten, denn Single-Page-Anwendungen, klassische Single-Page-Anwendungen, die wir jahrelang mit React schon gebaut haben vielleicht oder die wir auch mit Angular oder Swelte bauen, die sind zumindestens was die Aussagen des React-Teams angeht, mittlerweile ein bisschen umstritten, um nicht zu sagen, das React-Team rät eigentlich davon ab, solche Anwendungen zu bauen. Trotz allem finde ich ganz hilfreich, damit anzufangen, weil wir dann nicht so viel Overhead haben, sozusagen, den wir lernen müssen. Ich möchte euch dazu eine Seite auf der React-Homepage zeigen. Da geht es darum, wie man eigentlich eine neue React-Anwendung anfängt. Und da steht relativ deutlich drin, ich übersetze das mal frei, wenn du eine neue Anwendung oder Webseite mit React baust, empfehlen wir zu starten mit einem Framework, also mit einem Framework zu starten. Und dann gibt es hier den Unterpunkt Full-Stack-Frameworks. Und hier stehen einige Full-Stack-Frameworks drauf, Next.js zum Beispiel. Das gucken wir uns dann auch zum Schluss an. Und wenn wir ganz weiter nach unten scrollen hier, dann findet man die Frage oder beziehungsweise die Antwort Start from scratch. Und da heißt es, wenn deine Anwendung Constraints hat, also Einschränkungen hat oder Anforderungen hat, die nicht\n'slidetext': ''\n'from': 'index'\n'score': 62.504058837890625\n'normalizedScore': 0.6250405883789063\n'beforeDatePenaltyScore': 0.6250405883789063\n\n'documentId': '50c03dd02cf9b7c2ff4480f2'\n'chunk_id': '68b55eb733a5bf00132cb6af'\n'access': 'granted'\n'part_number': 46\n'total_parts': 47\n'contentType': 'TUTORIAL'\n'title': React-Grundlagen\n'parentName': Modern React: von Null auf Full-Stack\n'language': 'DE'\n'date': '2025-08-27T09:53:51.000Z'\n'abstract': In der ersten Lesson lernst du, was React ist und wie es funktioniert. Anhand einer Beispielanwendung schauen wir uns den Projektaufbau und den Workspace an. Du erfährst, wie Komponenten aufgebaut sind, wie man mit Props, Listen und State arbeitet und wie Interaktionen in React abgebildet werden.\n'parentId': 'b2c71c7c41dfe8eab4593f02'\n'parentDescription': In diesem Videotutorial lernst du React von Grund auf – bis hin zur Full-Stack-Entwicklung mit Next.js. Du baust Single Page Applications, verwaltest State, entwickelst moderne Formulare, arbeitest mit serverseitigen Daten und setzt Routing effizient um. Zum Abschluss bekommst du eine Einführung in React Server Components und Next.js. Benötigte Vorkenntnisse: JavaScript-Grundlagen, TypeScript ist hilfreich, aber nicht zwingend nötig. Nach dem Tutorial bist du bereit, eigene client- und serverseitige Anwendungen mit React umzusetzen.\n'indexBrandName': 'InternationalJavaScriptCon'\n'indexSeriesName': ''\n'author': 'Nils Hartmann'\n'chunkSource': 'text'\n'text': übergeben wir einen neuen Wert,. wir übergeben einen Wert. React prüft, ist der Wert ein anderer als vorher. Und wenn der Wert abweicht, was er in meinem Fall ist, wenn ich auf einen der anderen Felder klicke, dann ruft React unsere Komponenten-Funktion hier nochmal erneut auf. Das heißt, diese Komponente wird re-rendert, wenn man das mal bisschen Denglisch formulieren darf. Wir sind jetzt also wir haben initial gerendert, haben diesen Wert zurückbekommen für Selected Image. Wir haben Set Selected Image mit einem anderen Bild aufgerufen. führt diese Funktion neu aus, das zweite Mal jetzt, und liefert uns jetzt nicht mehr den ersten Wert hier zurück, sondern den Wert, den wir zuvor mit Set Selected Image gesetzt haben. Das heißt, beim zweiten Rendern wäre dann hier All Images 0, All Images 2, was auch immer, und wir führen,. React führt eben wie gesagt, diese Funktion auf. Wir kriegen hier den neuen Wert, und da wir jetzt den neuen Wert in unserer Funktion hier drin haben, wird auch überall, wo wir diesen neuen Wert verwenden, die Oberfläche entsprechend angepasst, sodass wir nirgendswo in die Verlegenheit oder das Problem reinkommen können, dass wir in irgendeiner Form inkonsistent sind, also wir wollen konsistent sein, und das schaffen wir hiermit auch ganz gut. Es ist sehr, schwierig, mit React in Inkonsistenzen zu kommen. Genau, also das ist vielleicht auch ein kleines bisschen rustikaler Ansatz wir werden das gleich noch mal bisschen im Detail beleuchten, aber das ist erstmal so die Grundidee quasi, ich habe meinen Zustand, wenn der Zustand sich ändert, mit der Setter-Funktion schmeißt React alles weg, bis auf das Modell, was React sich für uns merkt, und führt die Funktion einfach neu aus, und dadurch habe ich immer den aktuellsten Wert in meiner Komponente vorhanden. So was wie Signale oder Signals was es in anderen Frameworks zum Beispiel gibt, oder so kleine feingranulare Updates das gibt es in React so erstmal nicht. Wir machen immer einen relativ rustikalen Ansatz, wir schmeißen den UI-State, wenn man so will, erstmal weg, führen einfach die Funktion neu aus, die Komponente neu\n'slidetext': ''\n'from': 'index'\n'score': 62.435791015625\n'normalizedScore': 0.62435791015625\n'beforeDatePenaltyScore': 0.62435791015625\n\n'documentId': '50c03dd02cf9b7c2ff4480f2'\n'chunk_id': '68b55eb533a5bf00132cb69b'\n'access': 'granted'\n'part_number': 26\n'total_parts': 47\n'contentType': 'TUTORIAL'\n'title': React-Grundlagen\n'parentName': Modern React: von Null auf Full-Stack\n'language': 'DE'\n'date': '2025-08-27T09:53:51.000Z'\n'abstract': In der ersten Lesson lernst du, was React ist und wie es funktioniert. Anhand einer Beispielanwendung schauen wir uns den Projektaufbau und den Workspace an. Du erfährst, wie Komponenten aufgebaut sind, wie man mit Props, Listen und State arbeitet und wie Interaktionen in React abgebildet werden.\n'parentId': 'b2c71c7c41dfe8eab4593f02'\n'parentDescription': In diesem Videotutorial lernst du React von Grund auf – bis hin zur Full-Stack-Entwicklung mit Next.js. Du baust Single Page Applications, verwaltest State, entwickelst moderne Formulare, arbeitest mit serverseitigen Daten und setzt Routing effizient um. Zum Abschluss bekommst du eine Einführung in React Server Components und Next.js. Benötigte Vorkenntnisse: JavaScript-Grundlagen, TypeScript ist hilfreich, aber nicht zwingend nötig. Nach dem Tutorial bist du bereit, eigene client- und serverseitige Anwendungen mit React umzusetzen.\n'indexBrandName': 'InternationalJavaScriptCon'\n'indexSeriesName': ''\n'author': 'Nils Hartmann'\n'chunkSource': 'text'\n'text': installieren im Browser, ist kein Muss, aber manchmal ist das ganz hilfreich, wenn man da reingucken möchte in seine Anwendung und interessanterweise das finde ich immer ganz spannend, wenn man diese Developer Tools installiert hat hat man hier oben so ein kleines React-Icon, das ist hier sehr, schwer lesbar und immer wenn ihr auf einer Webseite seid, die irgendwas mit React macht, dann seht ihr das ist eine mit React gebaute Webseite Das finde ich manchmal ganz interessant üblicherweise in Produktion, wenn man dann da reinguckt, also wenn man jetzt irgendeine öffentliche Webseite aufruft, die mit React gebaut ist, wird man dann nicht viel sehen in diesem Komponent-Tab, weil die Anwendung natürlich im Produktionsbild ganz anders aussieht als jetzt hier in unserem Entwicklungsumgebung. Trotz allem ist es vielleicht mal ganz interessant zu schauen, wie andere oder was andere mit React machen. Das ist das eine, das andere ist noch eine Kleinigkeit zu unserem Code, den wir in der Image-Preview-Komponente geschrieben haben. Wir haben gesagt, dieses Props-Argument ein Objekt ist und das ist immer in React so, selbst wenn ihr gar keine Properties für eure Komponente habt, dann wird euch ein leeres Objekt übergeben, aber ihr könnt euch darauf verlassen, da ist ein Objekt. Und weil das ein Objekt ist, kann ich prinzipiell in meinem Code hier auch mit Destrukturierung von JavaScript arbeiten. Das würde entsprechend so aussehen, dass ich aus diesem Property-Objekt direkt die Eigenschaften hier rausnehme mit den geschweiften Klammern. Wie gesagt, in React-Anwendung kein Mangel an geschweiften Klammern. Und dann kann ich mir hier unten das Props schenken jeweils. Ich baue das mal eben um, nehme das Props hier weg. Ist im Grunde genommen genau das Gleiche wie vorher, nur dass wir uns jetzt das Props-Punkt hier drin sparen. Und aus meiner Sicht hat auch das wieder Vor und Nachteile. Der Vorteil aus meiner Sicht ist, wie gesagt, ich muss nicht immer Props-Punkt vorschreiben. Ein zweiter Vorteil ist, wenn ich mit dem Props-Objekt hier arbeite, also wenn ich mir einfach Props hinschreibe, dann könnte ich in der Versuchung sein, Props-Punkt irgendwas gleich irgendwas hinzuschreiben, was\n'slidetext': ''\n'from': 'index'\n'score': 62.435791015625\n'normalizedScore': 0.62435791015625\n'beforeDatePenaltyScore': 0.62435791015625\n\n'documentId': '50c03dd02cf9b7c2ff4480f2'\n'chunk_id': '68b55eb633a5bf00132cb6a4'\n'access': 'granted'\n'part_number': 35\n'total_parts': 47\n'contentType': 'TUTORIAL'\n'title': React-Grundlagen\n'parentName': Modern React: von Null auf Full-Stack\n'language': 'DE'\n'date': '2025-08-27T09:53:51.000Z'\n'abstract': In der ersten Lesson lernst du, was React ist und wie es funktioniert. Anhand einer Beispielanwendung schauen wir uns den Projektaufbau und den Workspace an. Du erfährst, wie Komponenten aufgebaut sind, wie man mit Props, Listen und State arbeitet und wie Interaktionen in React abgebildet werden.\n'parentId': 'b2c71c7c41dfe8eab4593f02'\n'parentDescription': In diesem Videotutorial lernst du React von Grund auf – bis hin zur Full-Stack-Entwicklung mit Next.js. Du baust Single Page Applications, verwaltest State, entwickelst moderne Formulare, arbeitest mit serverseitigen Daten und setzt Routing effizient um. Zum Abschluss bekommst du eine Einführung in React Server Components und Next.js. Benötigte Vorkenntnisse: JavaScript-Grundlagen, TypeScript ist hilfreich, aber nicht zwingend nötig. Nach dem Tutorial bist du bereit, eigene client- und serverseitige Anwendungen mit React umzusetzen.\n'indexBrandName': 'InternationalJavaScriptCon'\n'indexSeriesName': ''\n'author': 'Nils Hartmann'\n'chunkSource': 'text'\n'text': im Browser ausführe, dann bin ich mir relativ sicher dass wird so funktionieren. Aber es gibt eine kleine React-Besonderheit bei dieser Map, dass nämlich die Elemente in einer Liste, die Root-Elemente in einer Liste, ein sogenanntes Key-Property benötigen. Das kann man hier so hinschreiben. Da kann ich zum Beispiel jetzt Image.id hinschreiben. Dieses Key-Property das hat jede Komponente in React. Da braucht ihr nichts für zu tun. Das konsumiert ihr auch nicht. Das könnt ihr immer bei jeder Komponente angeben. Das ist quasi eine Art Identifikationsmerkmal für eine konkrete Instanz einer Komponente, wenn man so möchte. Das braucht React, um zu ermitteln, welche Aktualisierungen an der Oberfläche gemacht werden müssen. Normalerweise braucht man das nicht angeben. Das kriegt React automatisch hin. Aber wenn wir Elemente in einer Liste erzeugen, muss auf dem Root-Element dieser Liste, das ist in dem Fall unser Image-Preview, muss dieses Key-Attribut explizit gesetzt sein und zwar auf einen Wert, innerhalb der Liste eindeutig ist. In dem Fall ist das die ID von unserem Image. Genau. Wenn ihr das nicht setzt, dann kriegt ihr eine Warnung. Das zeige euch gleich mal. Das kann sein dass eure Liste dann trotzdem funktioniert. Also es gibt viele Konstellationen in denen man das eigentlich nicht braucht. Aber React kann das nicht für euch entscheiden, ob ihr das braucht oder nicht, weil das davon abhängt zum Beispiel, ob ihr die Liste zur Laufzeit erweitert, ob ihr die Liste umsortiert, ob ihr sie filtert, ob ihr Elemente rein- rausnimmt. Davon hängt das ab ob und wie gut React ohne dieses Key-Attribut auskommt. Deswegen ist die ganz klare Empfehlung,-Attribut immer in einer Liste setzen, selbst wenn die Liste wie hier nicht erweitert oder gelöscht wird. Und wir werden die Liste übrigens nachher auch noch erweitern und löschen. Ich kann das ja mal am Anfang hier zum Testen einmal rausnehmen. Wir setzen es dann gleich wieder rein. Wichtig ist noch dass wir jetzt in unserer App-Komponente nicht mehr diese beiden Komponenten rendern, die nehme ich gleich raus, sondern natürlich unsere\n'slidetext': ''\n'from': 'index'\n'score': 62.40215301513672\n'normalizedScore': 0.6240215301513672\n'beforeDatePenaltyScore': 0.6240215301513672\n\n'documentId': '50c03dd02cf9b7c2ff4480f2'\n'chunk_id': '68b55eac33a5bf00132cb68e'\n'access': 'granted'\n'part_number': 13\n'total_parts': 47\n'contentType': 'TUTORIAL'\n'title': React-Grundlagen\n'parentName': Modern React: von Null auf Full-Stack\n'language': 'DE'\n'date': '2025-08-27T09:53:51.000Z'\n'abstract': In der ersten Lesson lernst du, was React ist und wie es funktioniert. Anhand einer Beispielanwendung schauen wir uns den Projektaufbau und den Workspace an. Du erfährst, wie Komponenten aufgebaut sind, wie man mit Props, Listen und State arbeitet und wie Interaktionen in React abgebildet werden.\n'parentId': 'b2c71c7c41dfe8eab4593f02'\n'parentDescription': In diesem Videotutorial lernst du React von Grund auf – bis hin zur Full-Stack-Entwicklung mit Next.js. Du baust Single Page Applications, verwaltest State, entwickelst moderne Formulare, arbeitest mit serverseitigen Daten und setzt Routing effizient um. Zum Abschluss bekommst du eine Einführung in React Server Components und Next.js. Benötigte Vorkenntnisse: JavaScript-Grundlagen, TypeScript ist hilfreich, aber nicht zwingend nötig. Nach dem Tutorial bist du bereit, eigene client- und serverseitige Anwendungen mit React umzusetzen.\n'indexBrandName': 'InternationalJavaScriptCon'\n'indexSeriesName': ''\n'author': 'Nils Hartmann'\n'chunkSource': 'text'\n'text': das sieht aus wie HTML Code, obwohl wir in einer JavaScript beziehungsweise TypeScript Datei oder Modul unterwegs sind. Dieser Code den ich hier hinschreibe, der wird in React JSX genannt. Deswegen heißt meine TypeScript Endung hier auch TSX und nicht nur TS. Es gibt soweit ich weiß, keine offizielle Erklärung, was JSX heißt, also wofür das steht. Vielleicht steht es nur für JSX. Einige sagen auch es steht für JavaScript XML, weil das hier so eine XML Syntax ist. Wie auch immer wir können das hier einfach so reinschreiben. Dieser Code, den wir hinschreiben, der sieht aus wie HTML beziehungsweise wie XML eigentlich auch. Und das ist unterm Strich nur in Anführungsstrichen sowas wie Syntaktischer Zucker für eine JavaScript API, die React uns zur Verfügung stellt und die unter der Haube dann aufgerufen wird. Wenn mal eine Anwendung gestartet wird, beziehungsweise mein Bildtool genauer gesagt, dann werden aus diesem Code JavaScript Funktionsaufrufe von React Apis. Das heißt, Laufzeit ist dieser ganze Code weg, zur Laufzeit sind das normale React Apis. Deswegen sagt man auch das ist nur Syntaktischer Zucker. Offiziell wird da auch nicht von Templatesprache gesprochen, obwohl ich denke, das ist natürlich eine Art natürlich auch von Templatesprache. Aber im Gegensatz zu Angular beispielsweise oder im Gegensatz auch zu sowas wie JSP oder sowas, ja wirklich Templatesprachen sind beziehungsweise Templatesprache mitbringen, haben wir hier um diesen Template Block sage ich mal herum, normales JavaScript. Und wir werden auch sehen dass wir dieses Template auch mit normalem JavaScript bearbeiten können. Das war sozusagen eine Grundidee auch von React, keine neue Templatesprache zu erfinden, sondern eine bestehende Sprache zu nehmen, JavaScript, und die für eine Komponentenbibliothek fehlenden Features wie ein Template Ausdruck hinzuzufügen. Ich persönlich finde das eigentlich ganz charmant, auch wenn ich da am Anfang bisschen skeptisch war, mache ich diesen Anlass doch mittlerweile ganz gerne. Wie auch immer, wir geben jetzt also diesen JSX Code zurück, der wird im Bildprozess ein bisschen verarbeitet, sodass da Funktionsaufrufe zurückkommen und diese Funktionsaufrufe sagen React dann\n'slidetext': ''\n'from': 'index'\n'score': 62.371219635009766\n'normalizedScore': 0.6237121963500977\n'beforeDatePenaltyScore': 0.6237121963500977\n\n'documentId': '50c03dd02cf9b7c2ff4480f2'\n'chunk_id': '68b55eac33a5bf00132cb68c'\n'access': 'granted'\n'part_number': 11\n'total_parts': 47\n'contentType': 'TUTORIAL'\n'title': React-Grundlagen\n'parentName': Modern React: von Null auf Full-Stack\n'language': 'DE'\n'date': '2025-08-27T09:53:51.000Z'\n'abstract': In der ersten Lesson lernst du, was React ist und wie es funktioniert. Anhand einer Beispielanwendung schauen wir uns den Projektaufbau und den Workspace an. Du erfährst, wie Komponenten aufgebaut sind, wie man mit Props, Listen und State arbeitet und wie Interaktionen in React abgebildet werden.\n'parentId': 'b2c71c7c41dfe8eab4593f02'\n'parentDescription': In diesem Videotutorial lernst du React von Grund auf – bis hin zur Full-Stack-Entwicklung mit Next.js. Du baust Single Page Applications, verwaltest State, entwickelst moderne Formulare, arbeitest mit serverseitigen Daten und setzt Routing effizient um. Zum Abschluss bekommst du eine Einführung in React Server Components und Next.js. Benötigte Vorkenntnisse: JavaScript-Grundlagen, TypeScript ist hilfreich, aber nicht zwingend nötig. Nach dem Tutorial bist du bereit, eigene client- und serverseitige Anwendungen mit React umzusetzen.\n'indexBrandName': 'InternationalJavaScriptCon'\n'indexSeriesName': ''\n'author': 'Nils Hartmann'\n'chunkSource': 'text'\n'text': habt, dann kennt ihr vielleicht sowas wie das MVC Pattern, also dass man sagt, wir haben sowas wie ein Model, wir haben sowas wie ein View und wir haben sowas wie ein Controller. Und je nachdem, welches Framework und welche Interpretation man von diesem MVC Pattern anwendet, sieht das immer ein bisschen anders aus. Aber die Idee ist, dass ich sozusagen eine Ansicht habe und diese besteht aus drei Dingen, drei Concerns wenn man so will. Ich habe meine Daten, das wäre das Model, ich habe ein View, das zeigt die Daten an und ich habe ein Controller, das verknüpft im Prinzip die Darstellung mit den Daten, das die Logik wenn man so will, die so eine Komponente hat. Wenn man zum Beispiel mal an Angular denkt, da ist das zum Teil so dass die nach diesem Pattern arbeiten, auch da natürlich ein bisschen modifiziert, ein bisschen anders interpretiert. In React ist das ganz ganz anders. In React haben wir im Prinzip sowas wie ein MVC Pattern nicht. Da hat sich das React Team damals als sie sich React ausgedacht haben, explizit gegen entschieden, weil sie gesagt haben, dass diese Einteilung in diese drei Teile, in diese drei Schichten, wenn man so will, Model View, Controller, dass die nicht so viel Sinn ergibt, weil eigentlich, wenn man an so einer Komponente arbeitet, hat man immer mit allen drei Dingen zu tun und es macht aus Sicht des React Teams nicht so viel Sinn, das aufzuteilen, weil üblicherweise sind diese drei Schichten oder diese drei Aspekte ja auch in unterschiedlichen Technologien implementiert. Wenn man zum Beispiel Java-Anwendungen jetzt an Java-Anwendungen denken würde, dann wäre zum Beispiel das View vielleicht eine JSP Datei, eine Timelyleaf Datei, eine Freemarker Datei,. Model und Controller wären ganz sicher in Java mit Spring zum Beispiel gebaut. Also da hätte man zwei unterschiedliche Technologien. In React ist alles JavaScript, Schrägstrich, TypeScript und alles ist erst mal in unseren Komponenten drin. Erst mal deswegen, weil wir nachher auch noch oder später auch noch sehen, dass man es natürlich teilweise auch bisschen anders macht. Aber der Grundgedanke ist erst mal der eine Komponente enthält alles was sie quasi\n'slidetext': ''\n'from': 'index'\n'score': 62.371219635009766\n'normalizedScore': 0.6237121963500977\n'beforeDatePenaltyScore': 0.6237121963500977\n\n'documentId': '50c03dd02cf9b7c2ff4480f2'\n'chunk_id': '68b55eab33a5bf00132cb68a'\n'access': 'granted'\n'part_number': 9\n'total_parts': 47\n'contentType': 'TUTORIAL'\n'title': React-Grundlagen\n'parentName': Modern React: von Null auf Full-Stack\n'language': 'DE'\n'date': '2025-08-27T09:53:51.000Z'\n'abstract': In der ersten Lesson lernst du, was React ist und wie es funktioniert. Anhand einer Beispielanwendung schauen wir uns den Projektaufbau und den Workspace an. Du erfährst, wie Komponenten aufgebaut sind, wie man mit Props, Listen und State arbeitet und wie Interaktionen in React abgebildet werden.\n'parentId': 'b2c71c7c41dfe8eab4593f02'\n'parentDescription': In diesem Videotutorial lernst du React von Grund auf – bis hin zur Full-Stack-Entwicklung mit Next.js. Du baust Single Page Applications, verwaltest State, entwickelst moderne Formulare, arbeitest mit serverseitigen Daten und setzt Routing effizient um. Zum Abschluss bekommst du eine Einführung in React Server Components und Next.js. Benötigte Vorkenntnisse: JavaScript-Grundlagen, TypeScript ist hilfreich, aber nicht zwingend nötig. Nach dem Tutorial bist du bereit, eigene client- und serverseitige Anwendungen mit React umzusetzen.\n'indexBrandName': 'InternationalJavaScriptCon'\n'indexSeriesName': ''\n'author': 'Nils Hartmann'\n'chunkSource': 'text'\n'text': zum Hintergrund schon mal. Ich habe hier ein Projekt angelegt, das basiert auf dem Build-Tool Veed. Das kann man in der Dokumentation von Veed nachlesen, wie man da mit React-Anwendungen anlegen kann. Da gibt es ein kleines Kommando-Zeilen-Tool. Da sagt man im Prinzip npm create Veed. Und dann sagt man noch, dass man da mit React-Anwendungen bauen will. Und dann wird ein kleines Projekt hingelegt. Das habe ich hier alles schon gemacht. Ich habe hier auch schon ein paar Pakete angelegt, die wir im weiteren Verlauf des Kurses benötigen werden. Aber im Grunde genommen sieht das so aus Es gibt eine Konfigurationsdatei von Veed. Da steht im Prinzip eigentlich nur drin, dass wir hier eine React-Anwendung bauen wollen. Dann haben wir eine Index-HTML-Datei. Das ist quasi immer der Einstieg von so einer React-Anwendung, wenn man sie denn mit Veed baut. Diese Index-HTML-Datei, zeigt auf eine Main-TSX-Datei. Und das ist quasi der Startpunkt für unsere React-Anwendung. Dann haben wir hier ein Source-Verzeichnis. Da liegen unsere Sourcen drin. Da ist jetzt nur ein ganz kleines bisschen hier schon mal vorbereitet. Wie gesagt ich habe hier eine Index-CSS-Datei, weil um das Styling kümmern wir uns in diesem Tutorial nicht. Das Styling habe ich hier schon vorbereitet Das sind so Tailwind-Klassen. Ich habe uns ein paar Hilfs-Dateien schon mal angelegt die wir später brauchen. Und dann gibt es hier einen Komponents-Ordner. Und in diesem Komponents-Ordner wollen wir jetzt anfangen, die Komponenten unserer Anwendung zu bauen. Und die allererste Komponente, damit ihr überhaupt mal seht, wie das so in React funktioniert, das soll eine ganz einfache Komponente sein. Es eine Komponente sein, die ein Bild darstellt. Diese Komponente soll Image Preview heißen. Und die Idee ist, ich habe ja diese Liste von Bildern in meinem Formular und aus dem ich dann ein Bild für mein Rezept auswählen kann. Und die Idee ist, dass diese Image Preview Komponente quasi eine Art wiederverwendbare Komponente ist, mit der ich eben ein Bild eines Kochrezepts oder beziehungsweise eines Gerichtes darstellen kann. Und um diese Komponente jetzt anzulegen,\n'slidetext': ''\n'from': 'index'\n'score': 62.371219635009766\n'normalizedScore': 0.6237121963500977\n'beforeDatePenaltyScore': 0.6237121963500977\n\n'documentId': '50c03dd02cf9b7c2ff4480f2'\n'chunk_id': '68b55eb733a5bf00132cb6ae'\n'access': 'granted'\n'part_number': 45\n'total_parts': 47\n'contentType': 'TUTORIAL'\n'title': React-Grundlagen\n'parentName': Modern React: von Null auf Full-Stack\n'language': 'DE'\n'date': '2025-08-27T09:53:51.000Z'\n'abstract': In der ersten Lesson lernst du, was React ist und wie es funktioniert. Anhand einer Beispielanwendung schauen wir uns den Projektaufbau und den Workspace an. Du erfährst, wie Komponenten aufgebaut sind, wie man mit Props, Listen und State arbeitet und wie Interaktionen in React abgebildet werden.\n'parentId': 'b2c71c7c41dfe8eab4593f02'\n'parentDescription': In diesem Videotutorial lernst du React von Grund auf – bis hin zur Full-Stack-Entwicklung mit Next.js. Du baust Single Page Applications, verwaltest State, entwickelst moderne Formulare, arbeitest mit serverseitigen Daten und setzt Routing effizient um. Zum Abschluss bekommst du eine Einführung in React Server Components und Next.js. Benötigte Vorkenntnisse: JavaScript-Grundlagen, TypeScript ist hilfreich, aber nicht zwingend nötig. Nach dem Tutorial bist du bereit, eigene client- und serverseitige Anwendungen mit React umzusetzen.\n'indexBrandName': 'InternationalJavaScriptCon'\n'indexSeriesName': ''\n'author': 'Nils Hartmann'\n'chunkSource': 'text'\n'text': hier drauf klicke, dieses ausgewählt und so weiter und so fort. Also wir können jetzt hier beliebig auswählen. So, was jetzt hier im Hintergrund passiert, ist ganz spannend und das muss man glaube ich einmal, da müssen wir jetzt einmal durchwählen Wenn React diese Komponente hier rendert, allererste Mal, also unsere Anwendung wird gestartet in unserem Fall, die App-Komponente wird gerendert, die Image-Selektor-Komponente wird gerendert, dann erzeugt React für uns ein Modell, das belegt es vor, also React belegt das Modell vor mit diesem ersten Image und legt dieses Modell bzw. Den Inhalt dieses Modells für uns irgendwo ab. Dann haben wir dieses Modell, den Wert, den Inhalt von diesem Modell hier als überall operieren, insbesondere hier in unserem Fall gucken, welches Bild ausgewählt ist. Viel mehr machen wir damit ja jetzt aktuell gar nicht. Da das eine normale JavaScript-Variable ist, kann ich die aber überall verwenden. Ich kann damit alles Mögliche machen, was ich möchte. Ich könnte zum Beispiel dieses auch nehmen und sagen, ich gebe hier mal, wenn es denn gesetzt ist, den Titel hier aus, ausgewähltes Bild. Nur mal als Beispiel, dass wirklich dieses Modell eine ganz normale JavaScript-Variable ist. kann damit alles machen, ich möchte. Wenn wir jetzt hier mal gucken, seht ihr ausgewähltes Bild, wenn ich hier umspringen, wird nicht nur sozusagen hier unten dieser Teil aktualisiert, sondern eben auch dieser Teil hier aktualisiert. Das ermöglicht uns eben dieser State sozusagen. Das ist jetzt das allererste Rendern aber nur gewesen. Ich starte die Anwendung nochmal neu. Ausgewähltes Bild ist Penne. Hier ist angehakt die Penne, weil wir das als initialen Zustand in unserem Modell gesetzt haben. Mit dieser Variable können wir jetzt eben alles machen was wir mit Variable machen können. Und wenn wir jetzt diesen Wert ändern, indem wir diese Setter-Funktion hier aufrufen, dann guckt React quasi in sein internes Modell von dieser Komponente. Also wie gesagt, der State, den bewahrt React für uns auf, irgendwo außerhalb von unserer Komponente. Und wenn wir die Setter-Funktion aufrufen, dann übergeben\n'slidetext': ''\n'from': 'index'\n'score': 62.28546905517578\n'normalizedScore': 0.6228546905517578\n'beforeDatePenaltyScore': 0.6228546905517578\n\n'documentId': '50c03dd02cf9b7c2ff4480f2'\n'chunk_id': '68b55eb633a5bf00132cb6a8'\n'access': 'granted'\n'part_number': 39\n'total_parts': 47\n'contentType': 'TUTORIAL'\n'title': React-Grundlagen\n'parentName': Modern React: von Null auf Full-Stack\n'language': 'DE'\n'date': '2025-08-27T09:53:51.000Z'\n'abstract': In der ersten Lesson lernst du, was React ist und wie es funktioniert. Anhand einer Beispielanwendung schauen wir uns den Projektaufbau und den Workspace an. Du erfährst, wie Komponenten aufgebaut sind, wie man mit Props, Listen und State arbeitet und wie Interaktionen in React abgebildet werden.\n'parentId': 'b2c71c7c41dfe8eab4593f02'\n'parentDescription': In diesem Videotutorial lernst du React von Grund auf – bis hin zur Full-Stack-Entwicklung mit Next.js. Du baust Single Page Applications, verwaltest State, entwickelst moderne Formulare, arbeitest mit serverseitigen Daten und setzt Routing effizient um. Zum Abschluss bekommst du eine Einführung in React Server Components und Next.js. Benötigte Vorkenntnisse: JavaScript-Grundlagen, TypeScript ist hilfreich, aber nicht zwingend nötig. Nach dem Tutorial bist du bereit, eigene client- und serverseitige Anwendungen mit React umzusetzen.\n'indexBrandName': 'InternationalJavaScriptCon'\n'indexSeriesName': ''\n'author': 'Nils Hartmann'\n'chunkSource': 'text'\n'text': benutzen, also darauf kommt es nicht an. Wichtig ist nur, ist in der Liste eindeutig und zwar nur in der Liste muss es eindeutig sein. Global muss es nicht eindeutig sein. Schauen wir nochmal. Liste, kein Fehler. Wir haben hier unsere Keys, die einzelnen Einträge hier und im Prinzip haben wir damit unsere Listen Komponente abgeschlossen. Wir haben jetzt unsere Liste von diesen Bildern und was wir machen möchten, ist diese Liste auswählbar zu machen. Das heißt, ich klicke hier drauf und dann kriege ich auch ein visuelles Feedback, dass ich dieses Bild jetzt ausgewählt habe. Denn nochmal zum Hintergrund wir wollen die Liste später ja in unserem Formular verwenden, wo ich eben ein Bild für ein Gericht auswählen soll. Dazu brauchen wir noch ein weiteres Konzept und das ist auch ganz ganz wichtig in React. Das ist der sogenannte Zustand von einer Komponente, in React auch State genannt. Der State sind quasi interne Daten einer Komponente, die die Komponente selber auch verändern darf. Wir erinnern uns, wir haben diese Properties, was ja auch Daten einer Komponente sind, aber die Properties die hat mir jemand übergeben. Wenn ich jetzt eine Komponente bin, dann hat mir jemand die Properties übergeben, aber ich kann natürlich auch eigene Daten haben, die ich selber verwalte und diese Daten werden in React State genannt. In anderen Frameworks wäre das vielleicht sowas wie das Modell. React aber wie gesagt State oder auf Deutsch Zustand genannt. Und um jetzt diese Daten in einer Komponente oder um eigene Daten in einer Komponente zu verwalten, zu verwenden, muss ich dazu eine Funktion aufrufen, die mir diese Daten quasi erzeugt. Und das machen wir mal. Die Idee ist jetzt, ich habe meinen Image Selektor, ich habe eine Liste von Bildern und ich möchte mir merken, welches Bild wurde eigentlich ausgewählt. Dazu brauche ich eine Funktion, die nennt sich in React Use State. Und das ist quasi eine Art Factory Funktion, die mir ein Modell für meine Komponente erzeugt. Da kann ich beliebige Daten reinschreiben. Das mache ich gleich, also das ist so noch nicht fertig. Da kann ich beliebige Daten reinschreiben.\n'slidetext': ''\n'from': 'index'\n'score': 62.28546905517578\n'normalizedScore': 0.6228546905517578\n'beforeDatePenaltyScore': 0.6228546905517578\n\n'documentId': '50c03dd02cf9b7c2ff4480f2'\n'chunk_id': '68b55eb533a5bf00132cb6a1'\n'access': 'granted'\n'part_number': 32\n'total_parts': 47\n'contentType': 'TUTORIAL'\n'title': React-Grundlagen\n'parentName': Modern React: von Null auf Full-Stack\n'language': 'DE'\n'date': '2025-08-27T09:53:51.000Z'\n'abstract': In der ersten Lesson lernst du, was React ist und wie es funktioniert. Anhand einer Beispielanwendung schauen wir uns den Projektaufbau und den Workspace an. Du erfährst, wie Komponenten aufgebaut sind, wie man mit Props, Listen und State arbeitet und wie Interaktionen in React abgebildet werden.\n'parentId': 'b2c71c7c41dfe8eab4593f02'\n'parentDescription': In diesem Videotutorial lernst du React von Grund auf – bis hin zur Full-Stack-Entwicklung mit Next.js. Du baust Single Page Applications, verwaltest State, entwickelst moderne Formulare, arbeitest mit serverseitigen Daten und setzt Routing effizient um. Zum Abschluss bekommst du eine Einführung in React Server Components und Next.js. Benötigte Vorkenntnisse: JavaScript-Grundlagen, TypeScript ist hilfreich, aber nicht zwingend nötig. Nach dem Tutorial bist du bereit, eigene client- und serverseitige Anwendungen mit React umzusetzen.\n'indexBrandName': 'InternationalJavaScriptCon'\n'indexSeriesName': ''\n'author': 'Nils Hartmann'\n'chunkSource': 'text'\n'text': super viele Entscheidungen, wie auch immer. Mir müsste damit irgendwie klarkommen. Also React ist nichts für Leute, die Probleme mit Entscheidungsschwächen haben. Jetzt haben wir unseren fachlichen Typen hier definiert. Dieses Image-DTO besteht, wie gesagt, aus diesen drei Eigenschaften Und jetzt möchte ich eine Komponente machen, die Image-Selektor-Komponente, die eine Liste von diesen Objekten mit unserer bestehenden Image-Preview-Komponente anzeigt. So, den Property-Typen haben wir schon definiert. Ich muss diesen Type-Skript-Typen für das Image-DTO hier jetzt einmal importieren. Seht ihr hier ganz normaler Import, fast normaler Hier steht Import-Type davor. Und kann jetzt hier wieder meine Properties hinschreiben. Image-Selektor-Props. Und da bekommen wir eine Liste von diesen Image-DTO-Objekten zurück. Auch hier wieder gleiches Spielchen wie eben. Wir geben diesen JSX-Code zurück. Classname ist in dem Fall Image-Selektor. Vielleicht auch hier nochmal ein kleiner Hinweis. Euch ist vielleicht aufgefallen oder vielleicht auch nicht, dass ich hier Classname und nicht Classhin schreibe. Das ist ein ganz wichtiger Punkt. Es gibt zwei drei Attribute, die wir in HTML üblicherweise verwenden, die in React ein kleines bisschen anders heißen oder auch ganz anders heißen. Classname schreibt ihr zum Beispiel als Classhin. Und es gibt noch zwei, drei andere, die auch anders genannt werden. Das Vor-Attributsmarsch heißt in React HTML Vor. Das ist manchmal, muss man dran denken einfach, ist keine große Sache. Aber manchmal gerade, wenn man Code von irgendwo kopiert, der nicht aus React kommt, dann ist es vielleicht manchmal bisschen nervig. Wie auch immer. Wir haben hier unser div, Classname. Und was ich jetzt machen möchte, ist erstens möchte ich eine Überschrift haben, denn wir wollen dieses Bild selektieren. Und jetzt möchte ich hier meine Liste ausgeben. Und um das für das Ausgeben der Liste werden wir die JavaScript Map Funktion verwenden, die in JavaScript auf Listen definiert ist. Also wir verwenden quasi eine normale eingebaute JavaScript Funktion, um damit React Code oder UI Code zu erzeugen. Wenn noch mal ganz kurz zum Hintergrund von dieser Funktion. Jetzt gehe\n'slidetext': ''\n'from': 'index'\n'score': 62.2513427734375\n'normalizedScore': 0.622513427734375\n'beforeDatePenaltyScore': 0.622513427734375\n\n'documentId': '50c03dd02cf9b7c2ff4480f2'\n'chunk_id': '68b55eac33a5bf00132cb68b'\n'access': 'granted'\n'part_number': 10\n'total_parts': 47\n'contentType': 'TUTORIAL'\n'title': React-Grundlagen\n'parentName': Modern React: von Null auf Full-Stack\n'language': 'DE'\n'date': '2025-08-27T09:53:51.000Z'\n'abstract': In der ersten Lesson lernst du, was React ist und wie es funktioniert. Anhand einer Beispielanwendung schauen wir uns den Projektaufbau und den Workspace an. Du erfährst, wie Komponenten aufgebaut sind, wie man mit Props, Listen und State arbeitet und wie Interaktionen in React abgebildet werden.\n'parentId': 'b2c71c7c41dfe8eab4593f02'\n'parentDescription': In diesem Videotutorial lernst du React von Grund auf – bis hin zur Full-Stack-Entwicklung mit Next.js. Du baust Single Page Applications, verwaltest State, entwickelst moderne Formulare, arbeitest mit serverseitigen Daten und setzt Routing effizient um. Zum Abschluss bekommst du eine Einführung in React Server Components und Next.js. Benötigte Vorkenntnisse: JavaScript-Grundlagen, TypeScript ist hilfreich, aber nicht zwingend nötig. Nach dem Tutorial bist du bereit, eigene client- und serverseitige Anwendungen mit React umzusetzen.\n'indexBrandName': 'InternationalJavaScriptCon'\n'indexSeriesName': ''\n'author': 'Nils Hartmann'\n'chunkSource': 'text'\n'text': anzulegen, lege ich eine neue Datei an. Die nenne ich Image Preview TSX, weil meine Komponente so heißen sollen. Streng genommen ist es in React Anwendungen egal, wie eine Datei heißt. Das ist bei den Frameworks nachher ein bisschen anders und auch bei dem Router den ich euch nachher zeige, ein bisschen anders. Aber wenn ihr ganz normale Komponenten in Anführungsstrichen baut, spielt der Dateinahme keine Rolle. Wichtig ist wir arbeiten mit TypeScript. Deswegen muss die Dateiendung Punkt TSX hier lauten. Ansonsten könnt ihr die nennen, wie ihr wollt. Es gibt das Pattern, dass man sagt, ich habe eine Komponente, heißt so und so. Image Preview jetzt in unserem Fall und dann heißt auch die Datei entsprechend. Das muss man nicht machen aber das hilft natürlich der Organisation. Und ganz wichtig ist, wenn man jetzt eine größere Anwendung hat mit ganz ganz vielen Komponenten und ganz, vielen Features und ganz, vielen Use Cases und so weiter, dann würde man wahrscheinlich hier auch nicht ein Komponents Ordner machen, sondern dann würde man die Anwendung noch ein bisschen nach Fachlichkeit z.B. Strukturieren. Für unsere jetzt zumindest am Anfang sehr kleine Anwendung finde ich das aber ganz hilfreich, wenn wir alles einfach in diesem Verzeichnis hier bauen. Auch das Verzeichnis oder den Verzeichnisnamen übrigens könnt ihr nennen, wie ihr möchtet. Wir sehen gleich, wie unsere Image Preview Komponente dann eigentlich in unsere Anwendung reinkommt. React ist ein im Prinzip eine Art Komponenten Framework, wenn man so will. Wir können in React, ich sage mal etwas überspitzt, gar nichts anderes machen als Komponenten bauen. Wir werden später sehen, das ganze Datenladen zum Beispiel vom Server, das ganze Routing ist gar nicht Bestandteil von React. Darauf begründet ist ja auch die Aussage begründet, dass man eigentlich gerne ein Framework benutzen soll. Nichtsdestotrotz wir können Komponenten bauen und das können wir auch in einer wie ich finde, sehr eleganten Art und Weise bauen. Und zwar sind React Komponenten technisch gesehen JavaScript bzw. TypeScript Funktion. Schreibe ich mal hin Function Image Preview. Und wenn ihr mal mit anderen Frameworks gearbeitet habt,\n'slidetext': ''\n'from': 'index'\n'score': 62.2513427734375\n'normalizedScore': 0.622513427734375\n'beforeDatePenaltyScore': 0.622513427734375\n\n'documentId': '50c03dd02cf9b7c2ff4480f2'\n'chunk_id': '68b55eb733a5bf00132cb6ab'\n'access': 'granted'\n'part_number': 42\n'total_parts': 47\n'contentType': 'TUTORIAL'\n'title': React-Grundlagen\n'parentName': Modern React: von Null auf Full-Stack\n'language': 'DE'\n'date': '2025-08-27T09:53:51.000Z'\n'abstract': In der ersten Lesson lernst du, was React ist und wie es funktioniert. Anhand einer Beispielanwendung schauen wir uns den Projektaufbau und den Workspace an. Du erfährst, wie Komponenten aufgebaut sind, wie man mit Props, Listen und State arbeitet und wie Interaktionen in React abgebildet werden.\n'parentId': 'b2c71c7c41dfe8eab4593f02'\n'parentDescription': In diesem Videotutorial lernst du React von Grund auf – bis hin zur Full-Stack-Entwicklung mit Next.js. Du baust Single Page Applications, verwaltest State, entwickelst moderne Formulare, arbeitest mit serverseitigen Daten und setzt Routing effizient um. Zum Abschluss bekommst du eine Einführung in React Server Components und Next.js. Benötigte Vorkenntnisse: JavaScript-Grundlagen, TypeScript ist hilfreich, aber nicht zwingend nötig. Nach dem Tutorial bist du bereit, eigene client- und serverseitige Anwendungen mit React umzusetzen.\n'indexBrandName': 'InternationalJavaScriptCon'\n'indexSeriesName': ''\n'author': 'Nils Hartmann'\n'chunkSource': 'text'\n'text': habe ja hier ein Bild und wenn das das Bild ist, was in meinem State auch steht, dann müsste es Selectiert werden, also als Selectiert dargestellt werden. Dazu füge ich hier mal das Check Property hin. breche das mal hier bisschen anders um und schreiben wir hier. Checked habe ich es genannt und nicht Selected. Und jetzt gucken wir einfach, wenn unser Bild im State, wenn wir es haben und dessen gleich der ID des Bildes ist, was wir hier gerade rendern in der Zeile, dann muss das als Checked dargestellt werden. Wichtig ist dass wir an dieser Stelle hier die IDs vergleichen, denn prinzipiell könnten ja die Objekte hier andere sein. Ich könnte ja das gleiche sozusagen ein Objekt der gleichen Struktur haben, mit dem gleichen Inhalten auch, aber zwei unterschiedliche Referenzen darauf. Deswegen wichtig für uns ist die ID zu vergleichen, auch wenn in unserem konkreten Fall jetzt auch die Referenzen auf die Images tatsächlich stabil sind in der Anwendung aber das ist natürlich nicht gesagt, dass das immer so ist. Deswegen vergleichen wir hier die IDs. So wenn wir jetzt mal in unsere Anwendung reinspringen, dann seht ihr das erste Bild, das zweite Bild, das mit der Index 1, das ist hier tatsächlich als ausgewählt markiert. Sehen wir an diesem kleinen Checktägchen, den wir ja am allerersten Schritt oder am zweiten Schritt eingebaut haben mit den Properties. Wenn ich jetzt hier irgendwo anders klicke, passiert aber nichts, weil wir React nicht gesagt haben, was dann eigentlich passieren soll. Wann soll eigentlich sich dieser State ändern? Und auch das ist ein ganz wichtiges Pattern von React oder normalisiert den Zustand einer Komponente nie für euch. Das müsst ihr immer selber machen. Da werden wir noch weitere Beispiele sehen, aber im ersten Beispiel müssten wir jetzt React sagen, was soll passieren, wenn irgendwo hingeklickt wird? Was sind die Ereignisse, die dazu führen quasi, dass sich unser State ändert und wie sollte er dann geändert werden? Es gibt in React nicht sowas wie zwei Wege, Data Binding zum Beispiel, dass ich sage, ich habe ein UI-Element, ich habe mein Modell und wenn sich\n'slidetext': ''\n'from': 'index'\n'score': 62.206233978271484\n'normalizedScore': 0.6220623397827149\n'beforeDatePenaltyScore': 0.6220623397827149\n\n'documentId': '50c03dd02cf9b7c2ff4480f2'\n'chunk_id': '68b55eaf33a5bf00132cb692'\n'access': 'granted'\n'part_number': 17\n'total_parts': 47\n'contentType': 'TUTORIAL'\n'title': React-Grundlagen\n'parentName': Modern React: von Null auf Full-Stack\n'language': 'DE'\n'date': '2025-08-27T09:53:51.000Z'\n'abstract': In der ersten Lesson lernst du, was React ist und wie es funktioniert. Anhand einer Beispielanwendung schauen wir uns den Projektaufbau und den Workspace an. Du erfährst, wie Komponenten aufgebaut sind, wie man mit Props, Listen und State arbeitet und wie Interaktionen in React abgebildet werden.\n'parentId': 'b2c71c7c41dfe8eab4593f02'\n'parentDescription': In diesem Videotutorial lernst du React von Grund auf – bis hin zur Full-Stack-Entwicklung mit Next.js. Du baust Single Page Applications, verwaltest State, entwickelst moderne Formulare, arbeitest mit serverseitigen Daten und setzt Routing effizient um. Zum Abschluss bekommst du eine Einführung in React Server Components und Next.js. Benötigte Vorkenntnisse: JavaScript-Grundlagen, TypeScript ist hilfreich, aber nicht zwingend nötig. Nach dem Tutorial bist du bereit, eigene client- und serverseitige Anwendungen mit React umzusetzen.\n'indexBrandName': 'InternationalJavaScriptCon'\n'indexSeriesName': ''\n'author': 'Nils Hartmann'\n'chunkSource': 'text'\n'text': diese Adresse. Und außerdem möchte ich noch angeben, ob dieses Image als markiert, als checked, als ausgewählt dargestellt werden soll oder nicht. Und deswegen möchte ich dass man hier auch noch ein Boolean Parameter übergeben kann, mit dem ich ausdrücken kann, das Bild soll jetzt als ausgewählt dargestellt werden oder nicht. Also diese drei Attribute möchte ich jetzt angeben können. Nehmen wir mal an, wir haben unsere Image Preview Komponente schon richtig dafür vorbereitet und wir könnten das jetzt so hinschreiben. Können wir jetzt aktuell nicht weil wir ja keine Properties haben. Aber nehmen wir mal an, wir hätten das schon gemacht. Dann würde React zur Laufzeit jetzt wie folgt vorgehen. React würde diese drei Properties finden in unserem Komponenten-Aufruf und würde die nehmen. Mal gucken, so funktioniert es natürlich nicht. Würde die nehmen und würde ein JavaScript-Objekt daraus machen. Also wie gesagt, sind jetzt zur Laufzeit. React hat diesen Code hier gefunden bzw. zur Bildzeit, generiert da jetzt irgendwelchen Codes oder Compiler das Bildtool baut da jetzt irgendwas daraus und dann kommt zur Laufzeit ein JavaScript-Objekt raus, das sieht ungefähr so aus. Ich kann das mal zeigen. Das haben wir hingeschrieben quasi in unserem Komponenten-Aufruf und da kommt ein JavaScript-Aufruf raus, der sieht ungefähr so aus. Also quasi ein Objekt, was genau so aussieht wie das, was wir hingeschrieben haben. So könnte man sich das glaube ich, vorstellen. Also wir könnten streng genommen ist das hier nichts weiter als eine Beschreibung für ein Objekt, das genau so aussieht. Mit den gleichen Eigenschaften hier und mit den gleichen Werten. So und dieses Objekt, das nimmt React jetzt und übergibt es als ersten Parameter an unsere Komponente. So ich schreibe das mal hier hin und jetzt können wir mit diesem Objekt in unserer Komponente arbeiten. Ihr müsst, wenn ihr keine Properties habt, wie wir das eben hatten, dann müsst ihr natürlich auch keine hinschreiben oder müsst ihr das Argument hier nicht hinschreiben. Wenn ihr welche habt, schreibt ihr das Props-Objekt hin. Und was ihr jetzt seht ist, dass ich hier ein dass\n'slidetext': ''\n'from': 'index'\n'score': 62.206233978271484\n'normalizedScore': 0.6220623397827149\n'beforeDatePenaltyScore': 0.6220623397827149\n\n'documentId': '50c03dd02cf9b7c2ff4480f2'\n'chunk_id': '68b55eab33a5bf00132cb689'\n'access': 'granted'\n'part_number': 8\n'total_parts': 47\n'contentType': 'TUTORIAL'\n'title': React-Grundlagen\n'parentName': Modern React: von Null auf Full-Stack\n'language': 'DE'\n'date': '2025-08-27T09:53:51.000Z'\n'abstract': In der ersten Lesson lernst du, was React ist und wie es funktioniert. Anhand einer Beispielanwendung schauen wir uns den Projektaufbau und den Workspace an. Du erfährst, wie Komponenten aufgebaut sind, wie man mit Props, Listen und State arbeitet und wie Interaktionen in React abgebildet werden.\n'parentId': 'b2c71c7c41dfe8eab4593f02'\n'parentDescription': In diesem Videotutorial lernst du React von Grund auf – bis hin zur Full-Stack-Entwicklung mit Next.js. Du baust Single Page Applications, verwaltest State, entwickelst moderne Formulare, arbeitest mit serverseitigen Daten und setzt Routing effizient um. Zum Abschluss bekommst du eine Einführung in React Server Components und Next.js. Benötigte Vorkenntnisse: JavaScript-Grundlagen, TypeScript ist hilfreich, aber nicht zwingend nötig. Nach dem Tutorial bist du bereit, eigene client- und serverseitige Anwendungen mit React umzusetzen.\n'indexBrandName': 'InternationalJavaScriptCon'\n'indexSeriesName': ''\n'author': 'Nils Hartmann'\n'chunkSource': 'text'\n'text': haben wir im ersten Teil, wenn wir uns gleich mit der Single-Page-Anwendung beschäftigen, bauen wir einen Client. Das habe ich genannt, das ReciPy-Admin-Tool. ReciPy ich schreibe es noch mal richtig. ReciPy, so und auch wieder nach oben hier mit der Schrift. Und das ist eben eine React Single-Page-Anwendung, das werden. React SPA. Und die kommuniziert direkt mit unserem Backend hier über HTTP beziehungsweise Restzugriffe. Man kann sicherlich darüber diskutieren, ob das was ich hier zur Verfügung gestellt habe, eine richtige Rest-API ist. Das ist mir aber jetzt ehrlich gesagt für diesen Kurs nicht ganz so wichtig. Wichtig ist, wir haben hier Endpunkte, die wir aufrufen können und dann die Daten bekommen, die unser Frontend benötigt. Im zweiten Schritt, wie gesagt, für diese Frontend-Anwendung Da sieht das Ganze ein bisschen anders aus. Da haben wir dann hier unseren Next.js-Server. Das ist das ReciPy-Frontend, wie ich das genannt habe. Und das ist eine Next.js-Anwendung. Und die Next.js-Anwendung greift natürlich auch auf dieses Backend zu. Der Unterschied ist aber zu der Single-Page-Anwendung hier, dass dieses Ding hier dieses ReciPy-Admin-Frontend, da das eine Single-Page-Anwendung ist, läuft die im Browser. Das heißt, Browser greift direkt auf unser Backend hier hinzu. In dieser Next.js-Anwendung das werden wir dann sehen, da läuft ein Teil im Browser und ein Teil auch im Next.js-Server. Das heißt, ist unsere Anwendung so bisschen aufgeteilt und die Requests sehen dann ungefähr so aus. Der Browser greift auf dieses Next.js-Backend zu und das Next.js-Backend greift dann auf unser richtiges Backend, unser Rest-Backend, unser API-Backend wie auch immer wir das nennen wollen, dann zu. Also da sieht das Deployment und alles dann ein kleines bisschen anders aus. Da beschäftigen wir uns dann aber mit, wenn wir zu diesem Teil gekommen sind. Gut, jetzt wissen wir sozusagen, wo wir hinwollen. Dann ist es Zeit anzufangen. Wie gesagt, wir fangen ganz vorne an, ganz klein. Wir gucken uns erst mal an was React eigentlich ist und wie wir da mit Anwendungen bauen. Und der erste Schritt wird eine ganz, kleine React-Komponente sein. Nur mal kurz zum\n'slidetext': ''\n'from': 'index'\n'score': 62.16608810424805\n'normalizedScore': 0.6216608810424805\n'beforeDatePenaltyScore': 0.6216608810424805\n\n'documentId': '50c03dd02cf9b7c2ff4480f2'\n'chunk_id': '68b55eac33a5bf00132cb690'\n'access': 'granted'\n'part_number': 15\n'total_parts': 47\n'contentType': 'TUTORIAL'\n'title': React-Grundlagen\n'parentName': Modern React: von Null auf Full-Stack\n'language': 'DE'\n'date': '2025-08-27T09:53:51.000Z'\n'abstract': In der ersten Lesson lernst du, was React ist und wie es funktioniert. Anhand einer Beispielanwendung schauen wir uns den Projektaufbau und den Workspace an. Du erfährst, wie Komponenten aufgebaut sind, wie man mit Props, Listen und State arbeitet und wie Interaktionen in React abgebildet werden.\n'parentId': 'b2c71c7c41dfe8eab4593f02'\n'parentDescription': In diesem Videotutorial lernst du React von Grund auf – bis hin zur Full-Stack-Entwicklung mit Next.js. Du baust Single Page Applications, verwaltest State, entwickelst moderne Formulare, arbeitest mit serverseitigen Daten und setzt Routing effizient um. Zum Abschluss bekommst du eine Einführung in React Server Components und Next.js. Benötigte Vorkenntnisse: JavaScript-Grundlagen, TypeScript ist hilfreich, aber nicht zwingend nötig. Nach dem Tutorial bist du bereit, eigene client- und serverseitige Anwendungen mit React umzusetzen.\n'indexBrandName': 'InternationalJavaScriptCon'\n'indexSeriesName': ''\n'author': 'Nils Hartmann'\n'chunkSource': 'text'\n'text': größer, dann sehen wir, dass wir hier unsere App Komponente haben und darunter sehen wir unsere Image Preview Komponente bzw. die gerenderten Elemente von dieser Image Preview Komponente. Ihr erinnert euch, dass sich die CSS Klasse Image Preview Komponente gesetzt haben und wir haben hier unser Icon, wir haben unser DIV und wir haben unser Bild mit der entsprechenden Beschreibung. Also React hat das genauso gerendert, wie wir das wollten. Dass diese Image Preview Komponente und diese App Komponente jetzt an dieser Stelle so in unserem Dom ist, wie sie ist, das liegt an Folgendem. Ich gehe nochmal in unser Projektchen rein und zwar haben wir diese Index.html Datei und diese Index.html Datei ist quasi die Route Datei für unser Bildtool, für Veed. Wenn wir Veed starten, wird diese Index.html Datei eingelesen. Veed sieht, dass hier ein Script Tag drin ist. Dieses Script Tag zeigt auf die Main.tsx Datei. Diese Main.tsx Datei ist ganz ganz klein. Das ist quasi der Startpunkt für unsere React Anwendung. Der wird später ein bisschen größer werden, aber im Prinzip sehen alle React Anwendungen so aus, dass sie so gestartet werden, mehr oder minder. Es gab eine kleine API Änderung in letzter Zeit, aber grundsätzlich sieht die so aus. Und dieses Starten sieht dann im Prinzip so aus. Man gibt ein Element aus der fertigen Index.html Datei hier an. Das ist in dem Fall ein Element mit der ID HUT. Ich gehe nochmal in die Index.html Datei zurück. Das ist dieses Ding hier. Und dann sagt man React, bitte die Komponenten bitte die Anwendung unterhalb von diesem Div hier reinrendern. Wir können später ein Framework benutzen. Next.js sieht es ein bisschen anders aus. Aber wenn ihr eine Single Page Anwendung baut, sieht das eben so aus. Dann würde der Browser jetzt zur Laufzeit diese Index.html Datei runterladen. Hier wäre dann nicht mehr Main.tsx, sondern die gebaute die fertige Anwendung und die fertige Anwendung würde dann hier rein gerendert werden, weil wir das hier entsprechend angewiesen haben in dieses Element. Bitte diese Komponente reinrendern. Und diese Komponente rendert dann schlussendlich unsere Image Preview Komponent. Also das ist ganz\n'slidetext': ''\n'from': 'index'\n'score': 62.12712097167969\n'normalizedScore': 0.6212712097167968\n'beforeDatePenaltyScore': 0.6212712097167968\n\n'documentId': '50c03dd02cf9b7c2ff4480f2'\n'chunk_id': '68b55ebd33a5bf00132cb6b0'\n'access': 'granted'\n'part_number': 47\n'total_parts': 47\n'contentType': 'TUTORIAL'\n'title': React-Grundlagen\n'parentName': Modern React: von Null auf Full-Stack\n'language': 'DE'\n'date': '2025-08-27T09:53:51.000Z'\n'abstract': In der ersten Lesson lernst du, was React ist und wie es funktioniert. Anhand einer Beispielanwendung schauen wir uns den Projektaufbau und den Workspace an. Du erfährst, wie Komponenten aufgebaut sind, wie man mit Props, Listen und State arbeitet und wie Interaktionen in React abgebildet werden.\n'parentId': 'b2c71c7c41dfe8eab4593f02'\n'parentDescription': In diesem Videotutorial lernst du React von Grund auf – bis hin zur Full-Stack-Entwicklung mit Next.js. Du baust Single Page Applications, verwaltest State, entwickelst moderne Formulare, arbeitest mit serverseitigen Daten und setzt Routing effizient um. Zum Abschluss bekommst du eine Einführung in React Server Components und Next.js. Benötigte Vorkenntnisse: JavaScript-Grundlagen, TypeScript ist hilfreich, aber nicht zwingend nötig. Nach dem Tutorial bist du bereit, eigene client- und serverseitige Anwendungen mit React umzusetzen.\n'indexBrandName': 'InternationalJavaScriptCon'\n'indexSeriesName': ''\n'author': 'Nils Hartmann'\n'chunkSource': 'text'\n'text': neu aus, und haben dann da jeweils den aktuellsten Wert hier in unserem State drin. So wie gesagt, das funktioniert auch soweit. Jetzt möchte ich noch eine Klitzekleinigkeit bauen, und zwar, wenn ich jetzt hier auf ein Bild klicke, was schon ausgewählt ist, dann möchte ich dass es sozusagen nicht mehr ausgewählt ist, dass die Auswahl dann wieder weg ist In dem Fall können wir jetzt hier unsere Handle Image-Click-Funktion anpassen. Auch das soll einfach nur noch mal ein Beispiel sein, dass diese Werte die wir haben im State und wie wir mit denen arbeiten, dass das wirklich ganz normaler JavaScript-Code ist, und wir ganz normal mit JavaScript damit arbeiten können. Und in diesem Fall sage ich, wenn mein zuvor selektiertes Bild vorhanden ist und dessen ID, der ID von dem jetzt neu ausgewählten Image entspricht, dann setze ich in meinen State undefined weil dann ist sozusagen die Auswahl wieder weg. Da könnte man theoretisch sich auch überlegen, ob man vielleicht Null verwendet oder so, um das bisschen expliziter zu machen, aber sei es drum. Und im anderen Fall setze ich das Bild. Also wenn das Bild was jetzt gerade angeklickt worden ist, schon das ist, was im State ist, dann setzen wir es auf undefined Wenn es ein anderes ist, wählen wir das aus. Und jetzt müsste ich prinzipiell die Spaghetti Napoli auch wieder entfernen können und wieder setzen und wieder setzen. Und ihr seht, hier ist es aktuell und hier ist es aktuell, es ist immer alles egal, wie ich es mache. Konsistent. Wie gesagt, das werden wir gleich noch in einem etwas komplexeren Beispiel sehen. Aber das ist erst mal sozusagen die Grundlage von internen Daten von React, die wie gesagt State genannt werden. Wir haben nicht sowas wie ein externes Modell, haben nicht sowas wie eine Modelklasse oder sowas die wir instanzieren. Wir verwenden die useStateFunktion. Da können wir alles beliebige an Daten reinschreiben. React bewahrt das für uns auf. Und immer wenn die Komponente gerendert wird, reicht React uns das quasi durch diesen useStateFunktionsaufruf wieder rein in die Komponente.\n'slidetext': ''\n'from': 'index'\n'score': 62.03522491455078\n'normalizedScore': 0.6203522491455078\n'beforeDatePenaltyScore': 0.6203522491455078\n\n'documentId': '50c03dd02cf9b7c2ff4480f2'\n'chunk_id': '68b55eb533a5bf00132cb69a'\n'access': 'granted'\n'part_number': 25\n'total_parts': 47\n'contentType': 'TUTORIAL'\n'title': React-Grundlagen\n'parentName': Modern React: von Null auf Full-Stack\n'language': 'DE'\n'date': '2025-08-27T09:53:51.000Z'\n'abstract': In der ersten Lesson lernst du, was React ist und wie es funktioniert. Anhand einer Beispielanwendung schauen wir uns den Projektaufbau und den Workspace an. Du erfährst, wie Komponenten aufgebaut sind, wie man mit Props, Listen und State arbeitet und wie Interaktionen in React abgebildet werden.\n'parentId': 'b2c71c7c41dfe8eab4593f02'\n'parentDescription': In diesem Videotutorial lernst du React von Grund auf – bis hin zur Full-Stack-Entwicklung mit Next.js. Du baust Single Page Applications, verwaltest State, entwickelst moderne Formulare, arbeitest mit serverseitigen Daten und setzt Routing effizient um. Zum Abschluss bekommst du eine Einführung in React Server Components und Next.js. Benötigte Vorkenntnisse: JavaScript-Grundlagen, TypeScript ist hilfreich, aber nicht zwingend nötig. Nach dem Tutorial bist du bereit, eigene client- und serverseitige Anwendungen mit React umzusetzen.\n'indexBrandName': 'InternationalJavaScriptCon'\n'indexSeriesName': ''\n'author': 'Nils Hartmann'\n'chunkSource': 'text'\n'text': als Kommentar erst hingeschrieben hatte, mir die IDE hier keine geschweiften Klammern drumrum gemacht und kann man sich jetzt streiten, ob man sie hinmacht oder nicht. Genau, ich speicher die Anwendung. Im Hintergrund läuft der Bildprozess los, aktualisiert unsere Anwendung so, dass wenn ich jetzt in unseren Browser reingehe, sehen wir die aktualisierte Komponente. Die sieht natürlich jetzt genauso aus, wie sie vorher auch ausgesehen hat, weil ich genau die gleichen Daten hier übergeben habe. Aber wir können ja spaßeshalber mal eine zweite Komponente hinzufügen und zwar eine Komponente, beziehungsweise ein Bild, nicht gecheckt ist und dazu habe ich hier noch ein zweites Bild als Demo vorbereitet und zwar sind das die Spaghetti Napoli und der Dateinamen in dem Fall ist Napoli und dieses Bild soll mal nicht gecheckt sein. Und wenn wir das jetzt hier mal anschauen, dann seht ihr, wir hier jetzt zwei Komponenten haben, einmal eine gecheckte und eine nicht gecheckte und außerdem haben sie natürlich unterschiedliche Titel und außerdem haben sie unterschiedliche Bilder und diese Bilder die werden noch ein kleines bisschen größer, wenn ich da drüber gehe mit der Maus. Das ist aber kein React, das ist jetzt quasi CSS und wie gesagt, wir binden die nachher noch in eine vernünftige Liste ein. Jetzt sieht es ein bisschen wild aus, aber zumindest ein kleines bisschen besser wird es nachher aussehen, wenn wir sie dann im richtigen Umfeld sozusagen verwenden. So das heißt, wir haben uns jetzt Properties angeguckt, wir können jetzt unsere Komponente sozusagen mit Daten von außen versorgen. Zwei Dinge noch, das eine ist, es gibt für die Browser die Developer Tools für React, sowohl für Chrome, für Edge, für Firefox und wenn ihr die installiert habt, ich habe das hier gemacht, dann könnt ihr in die Komponenten auch reinschauen und könnt hier unter anderem auch die Properties einer Komponente sehen und ihr könntet die sogar an der Stelle hier verändern, ihr könntet zum Arabiata, jetzt nicht mehr gecheckt und dann wird React hier auch die Darstellung entsprechend anpassen. Developer Tools würde ich an eurer Stelle installieren\n'slidetext': ''\n'from': 'index'\n'score': 62.03522491455078\n'normalizedScore': 0.6203522491455078\n'beforeDatePenaltyScore': 0.6203522491455078\n\n'documentId': '50c03dd02cf9b7c2ff4480f2'\n'chunk_id': '68b55eb633a5bf00132cb6a2'\n'access': 'granted'\n'part_number': 33\n'total_parts': 47\n'contentType': 'TUTORIAL'\n'title': React-Grundlagen\n'parentName': Modern React: von Null auf Full-Stack\n'language': 'DE'\n'date': '2025-08-27T09:53:51.000Z'\n'abstract': In der ersten Lesson lernst du, was React ist und wie es funktioniert. Anhand einer Beispielanwendung schauen wir uns den Projektaufbau und den Workspace an. Du erfährst, wie Komponenten aufgebaut sind, wie man mit Props, Listen und State arbeitet und wie Interaktionen in React abgebildet werden.\n'parentId': 'b2c71c7c41dfe8eab4593f02'\n'parentDescription': In diesem Videotutorial lernst du React von Grund auf – bis hin zur Full-Stack-Entwicklung mit Next.js. Du baust Single Page Applications, verwaltest State, entwickelst moderne Formulare, arbeitest mit serverseitigen Daten und setzt Routing effizient um. Zum Abschluss bekommst du eine Einführung in React Server Components und Next.js. Benötigte Vorkenntnisse: JavaScript-Grundlagen, TypeScript ist hilfreich, aber nicht zwingend nötig. Nach dem Tutorial bist du bereit, eigene client- und serverseitige Anwendungen mit React umzusetzen.\n'indexBrandName': 'InternationalJavaScriptCon'\n'indexSeriesName': ''\n'author': 'Nils Hartmann'\n'chunkSource': 'text'\n'text': gehe ich mal in den Browser und stellt euch mal vor, wir haben hier eine Liste, die sieht so aus, enthält irgendwelche Buchstaben zum Beispiel. Und ich möchte mit diesen Buchstaben jetzt irgendwas machen. Dann könnte ich in JavaScript hergehen und sagen, ich iteriere jetzt über diese Liste mit der Map Funktion. Diese Map Funktion die erwartet eine Callback Funktion. Und diese Callback Funktion wiederum, kann ein oder zwei Parameter entgegennehmen. In meinem Fall reicht es mir jetzt einen entgegen zu nehmen. Und das ist der aktuelle Wert. Und mit diesem aktuellen Wert kann ich jetzt irgendwas machen, zum Beispiel den in uppercase zu verwandeln. So und jetzt ruft JavaScript für jeden Eintrag in dieser Liste meine Callback Funktion hier auf, übergibt den jeweiligen Wert, also erst A, dann B dann C in kleinen Buchstaben und gibt einen neuen Wert für den Originalwert zurück. In meinem Fall eben der entsprechende Großbuchstabe. Und dann werden die ganzen Werte eingesammelt und JavaScript macht eine neue Liste davon. Und ihr seht hier schon das Ergebnis. Jetzt haben wir eine neue Liste mit drei Großbuchstaben. Kunst, neue Liste. Und das Wichtige ist jetzt hier, wenn wir da reinschauen, Kunst, neue Liste, neue Liste. ist das, dass das wirklich eine neue Referenz auch ist, die unsere alte Liste, die ist völlig unverändert, ist weiterhin, hier steht wieder bei abc. Und das ist auch ganz ganz wichtig, unabhängig davon, ob wir jetzt gleich eine UI-Liste damit in React bauen oder ob wir in React eine bestehende Liste haben und da irgendwas mit machen wollen, also sprich eine Datenliste, wenn man so möchte. Immer bestehende Listen und bestehende Objekte unverändert lassen. Nie direkt ändern, sondern immer eine Kopie im Zweifelsfall von der Liste machen und die dann verändern. Also genauso, wie wir das hier mit unserer Map-Funktion gemacht haben. So wie gesagt, in JavaScript mappen wir quasi eine Liste von Werten auf eine Liste von Werten und in React mappen wir wenn man so will, eine Liste von Daten auf eine Liste von UI-Beschreibungen, auf eine Liste von Elementen. Im Grunde\n'slidetext': ''\n'from': 'index'\n'score': 61.98845672607422\n'normalizedScore': 0.6198845672607421\n'beforeDatePenaltyScore': 0.6198845672607421\n\n'documentId': '50c03dd02cf9b7c2ff4480f2'\n'chunk_id': '68b55eaf33a5bf00132cb696'\n'access': 'granted'\n'part_number': 21\n'total_parts': 47\n'contentType': 'TUTORIAL'\n'title': React-Grundlagen\n'parentName': Modern React: von Null auf Full-Stack\n'language': 'DE'\n'date': '2025-08-27T09:53:51.000Z'\n'abstract': In der ersten Lesson lernst du, was React ist und wie es funktioniert. Anhand einer Beispielanwendung schauen wir uns den Projektaufbau und den Workspace an. Du erfährst, wie Komponenten aufgebaut sind, wie man mit Props, Listen und State arbeitet und wie Interaktionen in React abgebildet werden.\n'parentId': 'b2c71c7c41dfe8eab4593f02'\n'parentDescription': In diesem Videotutorial lernst du React von Grund auf – bis hin zur Full-Stack-Entwicklung mit Next.js. Du baust Single Page Applications, verwaltest State, entwickelst moderne Formulare, arbeitest mit serverseitigen Daten und setzt Routing effizient um. Zum Abschluss bekommst du eine Einführung in React Server Components und Next.js. Benötigte Vorkenntnisse: JavaScript-Grundlagen, TypeScript ist hilfreich, aber nicht zwingend nötig. Nach dem Tutorial bist du bereit, eigene client- und serverseitige Anwendungen mit React umzusetzen.\n'indexBrandName': 'InternationalJavaScriptCon'\n'indexSeriesName': ''\n'author': 'Nils Hartmann'\n'chunkSource': 'text'\n'text': Der anderen Seite, sprich, ich diese Variante jetzt hier wähle, dann müsste ich, wenn ich wissen wollte, was dieses Diff Class Name bedeutet, müsste ich weiter oben wieder in meinem Code gucken. Auf der anderen Seite, wenn ich so mache, dann ist mein Template hier unten natürlich ein bisschen länger und je nachdem, wie lang das Template ist, könnte es dann unter Umständen schwieriger zu lesen sein. Also es ist eine Abwägungsfrage und ich finde noch nicht mal, dass man so ganz harte Regeln da aufstellen kann. Die einzige Regel, ich dafür habe, wenn es ein einfacher Ausdruck ist, was auch immer einfach bedeutet, dann schreibe ich es meistens rein. Ansonsten finde ich es auch okay, die Klasse, die einfach Variablen zu benutzen. In jedem Fall sehen wir ein Beispiel dieser Variable, dass eben unsere Komponente wirklich eine normale JavaScript bzw. TypeScript Funktion ist und alles, wir JavaScript und TypeScript machen können, können wir auch in diesen Funktionen machen. Sprich in diesem Fall Variablen deklarieren. In diesem Fall entscheide ich mich jetzt mal hier für den unteren Teil und das zweite ist, dass ich ja auch dieses Icon hier anzeigen möchte oder nicht, je nachdem, ob etwas gesetzt ist oder nicht, nämlich ob mein Checked True ist oder nicht. Da habe ich jetzt mehrere Möglichkeiten. Das eine ist natürlich, ich könnte hier gehen und sagen, wenn Checked auf True ist, das kann ich mit dieser Kurzform machen, dann rennt da quasi diesen Ausdruck. Das ist ein bisschen spezielle Syntax hier. Dazu muss man wissen, wenn mit diesem und und-Operator von JavaScript, auch das ist ein Ausdruck, ich hier geschrieben habe, deswegen kann ich den hier in die geschweifelten Klammern schreiben, wenn dieser erste Teil vor diesem und und-Zeichen True zurückliefert, dann liefert dieser Ausdruck dieses Ding hier zurück. Das heißt, React würde, wenn Props Checked auf True gesetzt ist, dieses I-Element bekommen und das rendern. Wenn Props Checked hingegen False ist, dann liefert dieser Ausdruck False zurück. Das heißt, an React würde der Boolean False zurückgeben und wenn React ein Boolean übergeben\n'slidetext': ''\n'from': 'index'\n'score': 61.98845672607422\n'normalizedScore': 0.6198845672607421\n'beforeDatePenaltyScore': 0.6198845672607421\n\n'documentId': '50c03dd02cf9b7c2ff4480f2'\n'chunk_id': '68b55eab33a5bf00132cb684'\n'access': 'granted'\n'part_number': 3\n'total_parts': 47\n'contentType': 'TUTORIAL'\n'title': React-Grundlagen\n'parentName': Modern React: von Null auf Full-Stack\n'language': 'DE'\n'date': '2025-08-27T09:53:51.000Z'\n'abstract': In der ersten Lesson lernst du, was React ist und wie es funktioniert. Anhand einer Beispielanwendung schauen wir uns den Projektaufbau und den Workspace an. Du erfährst, wie Komponenten aufgebaut sind, wie man mit Props, Listen und State arbeitet und wie Interaktionen in React abgebildet werden.\n'parentId': 'b2c71c7c41dfe8eab4593f02'\n'parentDescription': In diesem Videotutorial lernst du React von Grund auf – bis hin zur Full-Stack-Entwicklung mit Next.js. Du baust Single Page Applications, verwaltest State, entwickelst moderne Formulare, arbeitest mit serverseitigen Daten und setzt Routing effizient um. Zum Abschluss bekommst du eine Einführung in React Server Components und Next.js. Benötigte Vorkenntnisse: JavaScript-Grundlagen, TypeScript ist hilfreich, aber nicht zwingend nötig. Nach dem Tutorial bist du bereit, eigene client- und serverseitige Anwendungen mit React umzusetzen.\n'indexBrandName': 'InternationalJavaScriptCon'\n'indexSeriesName': ''\n'author': 'Nils Hartmann'\n'chunkSource': 'text'\n'text': nicht so gut von existierenden Frameworks abgebildet werden oder wenn man vielleicht sogar sein eigenes Framework bauen will oder wenn du die Grundlagen von React lernen möchtest, dann gibt es auch noch andere Optionen. Dann musst du kein Framework benutzen. Und genau das werden wir im ersten Schritt machen. Wir werden keins dieser Frameworks benutzen und wir werden später auch noch diskutieren, in welchen Fällen aus meiner Sicht ein Framework überhaupt Sinn macht oder nicht. Denn nicht stimmen den Punkten, die hier auf dieser Webseite genannt sind oder die von dem React-Team ins Feld geführt werden, nicht in allen Punkten zu und sehen das ein bisschen differenzierter oder bisschen kritischer vielleicht. Das ist dann wie gesagt, meine Meinung. Aber dazu müssen wir natürlich erst mal wissen, was das eine ist und was überhaupt das andere ist. Und in diesem Kurs möchte ich mit euch eine vollständige React-Anwendung bauen. Am Anfang werden wir da sehr fein granular vorgehen, Schritt für Schritt. Und diese Anwendung besteht im Prinzip aus zwei Teilen, wenn man so möchte. Das eine ist eine Admin-Anwendung. Damit fangen wir gleich an. Damit können wir Daten verwalten. Und das andere habe ich mal Frontend-Anwendung genannt. Das wäre eine Anwendung die quasi öffentlich im Internet steht und die diese Daten anzeigt. Und damit fange ich mal an bzw. Das zeige euch jetzt mal im ersten Schritt hier. Das ist die fertige Anwendung, die nennt sich Recipify. Und die Idee davon ist, dass ich Kochrezepte eingeben kann und diese Kochrezepte anderen Menschen zur Verfügung stellen kann. Das ist jetzt die sogenannte Frontend-Anwendung Die läuft tatsächlich mit Next.js und die gucken wir uns dann später an. Ich möchte jetzt erst mal nur zeigen, wie sie quasi aussieht. Wir haben hier diese Landing-Page. Wir können hier die Seite aufrufen. Dann seht ihr wir haben hier eine Liste von Kochrezepten. Wir können auf ein Kochrezept draufklicken. Wir können dann dieses Kochrezept uns anschauen. Wir haben hier sowas wie Zutaten. Wir haben hier sowas wie Kochinstructions. Also was muss ich eigentlich machen, um dieses Gericht zu kochen? Ich kann hier\n'slidetext': ''\n'from': 'index'\n'score': 61.98845672607422\n'normalizedScore': 0.6198845672607421\n'beforeDatePenaltyScore': 0.6198845672607421\n\n'documentId': '50c03dd02cf9b7c2ff4480f2'\n'chunk_id': '68b55eac33a5bf00132cb68f'\n'access': 'granted'\n'part_number': 14\n'total_parts': 47\n'contentType': 'TUTORIAL'\n'title': React-Grundlagen\n'parentName': Modern React: von Null auf Full-Stack\n'language': 'DE'\n'date': '2025-08-27T09:53:51.000Z'\n'abstract': In der ersten Lesson lernst du, was React ist und wie es funktioniert. Anhand einer Beispielanwendung schauen wir uns den Projektaufbau und den Workspace an. Du erfährst, wie Komponenten aufgebaut sind, wie man mit Props, Listen und State arbeitet und wie Interaktionen in React abgebildet werden.\n'parentId': 'b2c71c7c41dfe8eab4593f02'\n'parentDescription': In diesem Videotutorial lernst du React von Grund auf – bis hin zur Full-Stack-Entwicklung mit Next.js. Du baust Single Page Applications, verwaltest State, entwickelst moderne Formulare, arbeitest mit serverseitigen Daten und setzt Routing effizient um. Zum Abschluss bekommst du eine Einführung in React Server Components und Next.js. Benötigte Vorkenntnisse: JavaScript-Grundlagen, TypeScript ist hilfreich, aber nicht zwingend nötig. Nach dem Tutorial bist du bereit, eigene client- und serverseitige Anwendungen mit React umzusetzen.\n'indexBrandName': 'InternationalJavaScriptCon'\n'indexSeriesName': ''\n'author': 'Nils Hartmann'\n'chunkSource': 'text'\n'text': dann zur Laufzeit, was im Browser dargestellt werden soll. Damit das Ganze funktioniert beziehungsweise damit unsere Komponente verwendet werden kann, müssen wir die natürlich auch noch einbinden. Dazu werde ich im ersten Schritt diese Komponente einmal exportieren aus diesem Modul, sodass sie in meiner Anwendung jetzt zur Verfügung steht. Und damit wir die ganzen Komponenten die wir jetzt bauen, hier so ein bisschen ausprobieren wollen, habe ich mal eine App Komponente gebaut. Auch das eine ganz normale React Komponente, die wird beim Start sozusagen initial angezeigt. ist unsere Main Komponente, unsere Root Komponente, wie auch immer wir das nennen wollen. Da geht die Anwendung los und in dieser App Komponente werde ich jetzt unsere Image Preview Komponente einbinden. Auch hier seht ihr natürlich, dass diese Komponente auch wieder diesen JSX Code zurückliefert, diese Beschreibung. Und was wir jetzt hier an dieser Stelle sehen ist, dass ich meine eigenen Komponenten genauso hinschreiben kann, wie die das Image Element, was wir gesehen haben. Schreibe ich einfach den Namen der Komponente hin in so einem XML Element oder in so einer XML Element Syntax und dann kann meine Anwendung diese Komponente rendern. Wenn wir jetzt mal die Anwendung starten, das mache ich hier mit dem Dev Script vom Veed Server oder vom Veed Bild Tool, dann läuft dieses Veed Tool los. Das Veed Tool nimmt unsere Anwendung, baut die sprich für Type Script aus bzw. Entfernt den Type Script Code aus unserer Anwendung, übersetzt das JSX in ausführbares JavaScript und stellt uns außerdem noch einen Entwicklungs Server zur Verfügung, über den wir jetzt auf unsere Anwendung zugreifen können. Das läuft hier auf dem Port 3000. Ich klicke da mal drauf und dann sehen wir hier unsere allererste React Komponente, unseren Image Chooser bzw. Image Preview Komponente. Diese Komponente wird nachher wenn wir die in die richtige Anwendung einbauen, noch ein kleines bisschen anders aussehen, usw. Aber für den ersten Fall reicht es uns erst mal, dass wir hier sehen, dass wir eine React Komponente gerendert haben. Wenn wir mal unseren Browser reinschauen, in den Dom Inspector hier, ich mache es ein bisschen größer,\n'slidetext': ''\n'from': 'index'\n'score': 61.94339370727539\n'normalizedScore': 0.619433937072754\n'beforeDatePenaltyScore': 0.619433937072754\n\n'documentId': '50c03dd02cf9b7c2ff4480f2'\n'chunk_id': '68b55eab33a5bf00132cb687'\n'access': 'granted'\n'part_number': 6\n'total_parts': 47\n'contentType': 'TUTORIAL'\n'title': React-Grundlagen\n'parentName': Modern React: von Null auf Full-Stack\n'language': 'DE'\n'date': '2025-08-27T09:53:51.000Z'\n'abstract': In der ersten Lesson lernst du, was React ist und wie es funktioniert. Anhand einer Beispielanwendung schauen wir uns den Projektaufbau und den Workspace an. Du erfährst, wie Komponenten aufgebaut sind, wie man mit Props, Listen und State arbeitet und wie Interaktionen in React abgebildet werden.\n'parentId': 'b2c71c7c41dfe8eab4593f02'\n'parentDescription': In diesem Videotutorial lernst du React von Grund auf – bis hin zur Full-Stack-Entwicklung mit Next.js. Du baust Single Page Applications, verwaltest State, entwickelst moderne Formulare, arbeitest mit serverseitigen Daten und setzt Routing effizient um. Zum Abschluss bekommst du eine Einführung in React Server Components und Next.js. Benötigte Vorkenntnisse: JavaScript-Grundlagen, TypeScript ist hilfreich, aber nicht zwingend nötig. Nach dem Tutorial bist du bereit, eigene client- und serverseitige Anwendungen mit React umzusetzen.\n'indexBrandName': 'InternationalJavaScriptCon'\n'indexSeriesName': ''\n'author': 'Nils Hartmann'\n'chunkSource': 'text'\n'text': so schlau sind, hier in meinen Beispieldaten sei mal dahingestellt. Ehrlich gesagt, die Beispieldaten habe ich mir von Chetjibiti generieren lassen, die nicht so für bare Münze unbedingt nehmen. Dann haben wir hier unten können wir eingeben, welche Zutaten das Rezept braucht, können natürlich auch Zutaten löschen und so weiter. Und wir können dann eingeben, wie man das Rezept eigentlich zubereitet. Und in diesem Formular, wie gesagt, da sind so unterschiedliche Patterns drin, die wir uns angucken werden, wie man die baut, beispielsweise bei diesen Instructions hier. Die kann ich zum Beispiel mit Dreck in Drop umschieben. Wenn ich festgestellt habe, ich habe in der falschen Reihenfolge eingegeben. Ein zweites Pattern ist hier bei diesem Image zum Beispiel, dass ich hier ein neues Bild hochladen kann. Ich habe jetzt nicht so viele Beispielbilder, deswegen nehme ich hier mal eine Nudel und dann nehmen wir die mal hier und dann wird die hochgeladen. Und dann kann ich hier so ein bisschen da noch reinzoomen, wenn ich das möchte. Rauszoomen, wie man das ebenso von modernen Anwendungen kennt, kann hier den Bildausschnitt festlegen. Das Bild ist ein bisschen klein, ich muss wieder bisschen reinzoomen. So hier schön mit den Tomaten und dem Käse. Und dann kann ich das speichern und könnte das jetzt auch diesem Rezept hinzufügen, wenn ich das möchte. Das Rezept könnte ich natürlich jetzt auch noch speichern, das lasse ich mal weil ich jetzt die hier nur so zum Beispiel so ein paar Änderungen gemacht habe, die nicht wirklich sinnvoll sind. Aber wie gesagt, man dieses Formular entwickelt, werde ich euch zeigen. Ich werde euch zeigen, wie man kleinseitig mit verschiedenen Routen arbeitet. Wenn ihr mal hier auf die URL achtet, werdet ihr sehen, dass sich die immer ändert. Wenn ich hier rumklick, relativ lang. Da stehen relativ viele Informationen drin. Aber so verhält sich das ja in modernen Anwendungen. Genau, also das sind sozusagen die Themen, die wir uns angucken wollen. Wir wollen angucken, wie baue ich überhaupt React-Komponenten Was sind die Grundlagen von React? Wie kann ich mit serverseitigen\n'slidetext': ''\n'from': 'index'\n'score': 61.77955627441406\n'normalizedScore': 0.6177955627441406\n'beforeDatePenaltyScore': 0.6177955627441406\n\n'documentId': '50c03dd02cf9b7c2ff4480f2'\n'chunk_id': '68b55eb533a5bf00132cb699'\n'access': 'granted'\n'part_number': 24\n'total_parts': 47\n'contentType': 'TUTORIAL'\n'title': React-Grundlagen\n'parentName': Modern React: von Null auf Full-Stack\n'language': 'DE'\n'date': '2025-08-27T09:53:51.000Z'\n'abstract': In der ersten Lesson lernst du, was React ist und wie es funktioniert. Anhand einer Beispielanwendung schauen wir uns den Projektaufbau und den Workspace an. Du erfährst, wie Komponenten aufgebaut sind, wie man mit Props, Listen und State arbeitet und wie Interaktionen in React abgebildet werden.\n'parentId': 'b2c71c7c41dfe8eab4593f02'\n'parentDescription': In diesem Videotutorial lernst du React von Grund auf – bis hin zur Full-Stack-Entwicklung mit Next.js. Du baust Single Page Applications, verwaltest State, entwickelst moderne Formulare, arbeitest mit serverseitigen Daten und setzt Routing effizient um. Zum Abschluss bekommst du eine Einführung in React Server Components und Next.js. Benötigte Vorkenntnisse: JavaScript-Grundlagen, TypeScript ist hilfreich, aber nicht zwingend nötig. Nach dem Tutorial bist du bereit, eigene client- und serverseitige Anwendungen mit React umzusetzen.\n'indexBrandName': 'InternationalJavaScriptCon'\n'indexSeriesName': ''\n'author': 'Nils Hartmann'\n'chunkSource': 'text'\n'text': das hingeschrieben habe. In dem Fall würde ich auch dazu tendieren, diesen Weg nicht zu gehen, sondern diesen Weg hier mit den Props Check, das unten reinzuschreiben, warum auch immer, ich finde es irgendwie glaube ich, besser, das so zu machen, aber wir haben gesehen, ihr könnt es auch anders machen, es gibt immer mehrere Wege. Grundsätzlich gibt es in React mehrere Wege zum Ziel zu kommen, gerade die Strukturierung von den Komponenten, wie fein oder grobgranular die Komponenten sein sollen, wie diese Templates in Anführungsstrichen strukturiert sind, da kann man viel darüber nachdenken. Tipp wäre, fangt erst mal an, wenn ihr feststellt, Komponente wird zu komplex, kann man sie aufteilen, wenn ihr feststellt, das Template wird zu komplex, kann man es aufteilen. Es gibt in React ein Prinzip, das nennt sich quasi, nicht quasi, zusammengehört, auch zusammenlassen soll. Einen wichtigen Punkt davon haben wir schon gesehen, wir haben keinen Model-View-Controller-Pattern hier, sondern wir alles in unserer Komponente drin. Ein anderer Punkt wäre in dem Fall auch dass ich diese Logik im Template hier an der Stelle lasse und nicht künstlich in Anführungsstrichen an eine andere Stelle verlage. Aber wie gesagt, das ist sozusagen nur so eine Richtschnur, man muss im Einzelfall immer leider entscheiden, wie man es macht oder nicht, oder man stellt pauschale Regeln auf, das geht natürlich auch, zurück zu unseren Properties. Wir haben jetzt die Properties hier verwendet, aber wir haben sie natürlich beim Aufrufen unserer Komponente noch gar nicht verwendet. Ich hatte hier oben aber schon den Aufruf hingeschrieben, wie er jetzt aussehen müsste. Ich kopiere den mal raus und gehe in unsere App-Komponente und nehme den hier mal rein. Theoretisch müsste jetzt auch der Compile-Fehler weggehen. Jetzt habe ich es richtig hingeschrieben und jetzt sieht unser Funktions-Aufruf oder unser Komponenten-Aufruf so aus. Auch hier seht ihr jetzt Boolean, wie gesagt, alles was kein String ist, immer in die geschweiften Klammern schreiben. Beim String kann ich die geschweiften Klammern tendenziell weglassen, weil ich diesen Code jetzt eben als\n'slidetext': ''\n'from': 'index'\n'score': 61.75106430053711\n'normalizedScore': 0.6175106430053711\n'beforeDatePenaltyScore': 0.6175106430053711\n\n'documentId': '50c03dd02cf9b7c2ff4480f2'\n'chunk_id': '68b55eb733a5bf00132cb6aa'\n'access': 'granted'\n'part_number': 41\n'total_parts': 47\n'contentType': 'TUTORIAL'\n'title': React-Grundlagen\n'parentName': Modern React: von Null auf Full-Stack\n'language': 'DE'\n'date': '2025-08-27T09:53:51.000Z'\n'abstract': In der ersten Lesson lernst du, was React ist und wie es funktioniert. Anhand einer Beispielanwendung schauen wir uns den Projektaufbau und den Workspace an. Du erfährst, wie Komponenten aufgebaut sind, wie man mit Props, Listen und State arbeitet und wie Interaktionen in React abgebildet werden.\n'parentId': 'b2c71c7c41dfe8eab4593f02'\n'parentDescription': In diesem Videotutorial lernst du React von Grund auf – bis hin zur Full-Stack-Entwicklung mit Next.js. Du baust Single Page Applications, verwaltest State, entwickelst moderne Formulare, arbeitest mit serverseitigen Daten und setzt Routing effizient um. Zum Abschluss bekommst du eine Einführung in React Server Components und Next.js. Benötigte Vorkenntnisse: JavaScript-Grundlagen, TypeScript ist hilfreich, aber nicht zwingend nötig. Nach dem Tutorial bist du bereit, eigene client- und serverseitige Anwendungen mit React umzusetzen.\n'indexBrandName': 'InternationalJavaScriptCon'\n'indexSeriesName': ''\n'author': 'Nils Hartmann'\n'chunkSource': 'text'\n'text': ich kriege nicht eine Liste einfach vom Bildern zurück oder sowas, sondern der erste Eintrag in meiner Liste ist zum Beispiel das Bild und der zweite Eintrag in meiner Liste sind die Kommentare zu dem Bild zum Beispiel. Sowas könnte ein Tupel sein, von React sieht das so aus, dass diese Funktion die wir hier haben, ich schraube das gleich noch anders hin, aber erstmal, dass wir es einmal gesehen haben, die liefert uns einen Tupel zurück, der aus zwei Einträgen besteht. Und der erste Eintrag ist eine Funktion zum Setzen dieses Wertes. Ich nenne das mal Selected Image. Das stimmt nicht. Der erste Eintrag in diesem Tupel ist der Wert, der gerade in unserem Zustand drin steht. Warum wir den da kriegen, sehen wir gleich. Ich nenne ihn mal Selected Image. Das wäre hier State 0. Und der zweite Eintrag ist eine Funktion zum Ändern dieser Daten. Nenne ich mal Set Selected Image. So kann man sich das ungefähr vorstellen. Das liefert diese Funktion jetzt zurück. Üblicherweise schreibt man das jetzt aber nicht so hin wie ich das hier hingeschrieben habe, sondern wir benutzen, so ähnlich wie bei unseren Properties hier, den Destrukturierungsoperator von JavaScript. Der sieht hier ein bisschen anders aus, weil hier destrukturieren wir ein Objekt, hier destrukturieren wir ein Array. Und das sieht dann wie folgt aus. Selected Image ist der erste Eintrag und Set Selected Image ist der zweite Eintrag. Und das brauchen wir dann nicht mehr. So wird das üblicherweise hingeschrieben. Und ehrlich gesagt, glaube ich, dass diesen RID-Destrukturierungsoperator, ist auch deswegen populär oder bekannt geworden, weil der hier ganz häufig in React so verwendet wird. Glaube ansonsten wäre er noch gar nicht so bekannt, wie er jetzt vielleicht ist. So, mit dieser Information können wir jetzt verschiedene Dinge machen. Wir haben jetzt also wie gesagt ein Selectiertes Bild. Das habe ich hier initial mal auf das erste Bild einfach gesetzt. Und damit können wir ja in unserer Liste zum Beispiel schon mal sagen, ob ein Bild das ich gerade mit der Image Preview Komponente render, ob das Selected ist oder nicht. Denn ich habe\n'slidetext': ''\n'from': 'index'\n'score': 61.69618606567383\n'normalizedScore': 0.6169618606567383\n'beforeDatePenaltyScore': 0.6169618606567383\n\n'documentId': '50c03dd02cf9b7c2ff4480f2'\n'chunk_id': '68b55eb533a5bf00132cb69e'\n'access': 'granted'\n'part_number': 29\n'total_parts': 47\n'contentType': 'TUTORIAL'\n'title': React-Grundlagen\n'parentName': Modern React: von Null auf Full-Stack\n'language': 'DE'\n'date': '2025-08-27T09:53:51.000Z'\n'abstract': In der ersten Lesson lernst du, was React ist und wie es funktioniert. Anhand einer Beispielanwendung schauen wir uns den Projektaufbau und den Workspace an. Du erfährst, wie Komponenten aufgebaut sind, wie man mit Props, Listen und State arbeitet und wie Interaktionen in React abgebildet werden.\n'parentId': 'b2c71c7c41dfe8eab4593f02'\n'parentDescription': In diesem Videotutorial lernst du React von Grund auf – bis hin zur Full-Stack-Entwicklung mit Next.js. Du baust Single Page Applications, verwaltest State, entwickelst moderne Formulare, arbeitest mit serverseitigen Daten und setzt Routing effizient um. Zum Abschluss bekommst du eine Einführung in React Server Components und Next.js. Benötigte Vorkenntnisse: JavaScript-Grundlagen, TypeScript ist hilfreich, aber nicht zwingend nötig. Nach dem Tutorial bist du bereit, eigene client- und serverseitige Anwendungen mit React umzusetzen.\n'indexBrandName': 'InternationalJavaScriptCon'\n'indexSeriesName': ''\n'author': 'Nils Hartmann'\n'chunkSource': 'text'\n'text': bisschen die Stärke von diesem Ansatz von React, dass man gesagt hat, wir wollen gar keine eigene Templatesprache bauen, sondern wir wollen quasi ein Template eine Template Syntax in bestehenden JavaScript Syntax einfügen. Das gucken wir uns an, wie das aussieht. Die Idee ist, gesagt, ich baue jetzt eine neue Komponente und diese Komponente heißt Image Selector. Image Selector T6. Dazu oder dabei werden wir auch ein weiteres Prinzip von React sehen, nämlich, dass ich so kleine Komponenten nehme, die ich dann zu höherwertigen Komponenten wenn man so will, zusammen aggregiere. In der Tendenz sind die kleinen Komponenten, die ganz unten im Komponentenbaum stehen, immer ein bisschen wiederverwendbarer. Und je höher ich im Komponentenbaum gehe, desto weniger wiederverwendbarer sind sie. In unserem Fall wäre das so Die App-Komponente ganz oben, die kann ich im Prinzip nicht nochmal verwenden. Das ist meine ganz konkrete Anwendung. Die Image Preview Komponente kann ich überall verwenden, wo ich einen Source und wo ich einen Titel habe für ein Bild. Und die Image Selector Komponente ist irgendwas dazwischen. Die kann ich immer dann verwenden, wenn ich eine Liste von Source und Titel habe und davon wie gesagt, diese Komponente muss natürlich auch wieder als Funktion vorliegen. Image Selector. Und das machen wir gleich hier. Und diese Komponente soll auch wieder Properties haben. Image Selector Props. Und zwar soll diese Komponente eine Liste entgegennehmen und diese Liste soll heißen All Images. Und um den Typen müssen wir uns gleich noch kümmern. Aber das soll im TypeScript eine Liste von solchen Image DTO Objekten sein. Die beschreiben wir als nächstes bevor wir jetzt weitermachen. Wir haben eben schon in der Image Preview Komponente Properties definiert. Die sahen so aus, im Prinzip genauso ähnlich, wie wir sie jetzt hier auch in dieser Selector Komponente haben. Der Unterschied ist, ich habe jetzt hier eine Liste und zwar nicht eine Liste von Strings oder Zahlen, von Booleans oder was auch immer, sondern eine Liste von Objekten. In dem Fall gehe ich mal davon aus, dieses Image was ich hier gleich beschreiben will, also was wieder aus Source und Titel besteht\n'slidetext': ''\n'from': 'index'\n'score': 61.69618606567383\n'normalizedScore': 0.6169618606567383\n'beforeDatePenaltyScore': 0.6169618606567383\n\n'documentId': '50c03dd02cf9b7c2ff4480f2'\n'chunk_id': '68b55eac33a5bf00132cb691'\n'access': 'granted'\n'part_number': 16\n'total_parts': 47\n'contentType': 'TUTORIAL'\n'title': React-Grundlagen\n'parentName': Modern React: von Null auf Full-Stack\n'language': 'DE'\n'date': '2025-08-27T09:53:51.000Z'\n'abstract': In der ersten Lesson lernst du, was React ist und wie es funktioniert. Anhand einer Beispielanwendung schauen wir uns den Projektaufbau und den Workspace an. Du erfährst, wie Komponenten aufgebaut sind, wie man mit Props, Listen und State arbeitet und wie Interaktionen in React abgebildet werden.\n'parentId': 'b2c71c7c41dfe8eab4593f02'\n'parentDescription': In diesem Videotutorial lernst du React von Grund auf – bis hin zur Full-Stack-Entwicklung mit Next.js. Du baust Single Page Applications, verwaltest State, entwickelst moderne Formulare, arbeitest mit serverseitigen Daten und setzt Routing effizient um. Zum Abschluss bekommst du eine Einführung in React Server Components und Next.js. Benötigte Vorkenntnisse: JavaScript-Grundlagen, TypeScript ist hilfreich, aber nicht zwingend nötig. Nach dem Tutorial bist du bereit, eigene client- und serverseitige Anwendungen mit React umzusetzen.\n'indexBrandName': 'InternationalJavaScriptCon'\n'indexSeriesName': ''\n'author': 'Nils Hartmann'\n'chunkSource': 'text'\n'text': ganz häufig so. Man hat so einen root Element. Wenn man eine Single Page Anwendung baut, hat man häufig ein root Element. Und da rendert man dann die Anwendung dann rein. So damit haben wir jetzt unsere erste React Komponente die Image Preview Komponente die in dieser Form natürlich noch nicht so wahnsinnig sinnvoll einsetzbar ist. Denn ich habe ja vorhin gesagt, wir wollen eine wiederverwendbare Komponente haben und diese Komponente können wir natürlich theoretisch an unterschiedlichen Stellen in unserer Anwendung einbauen, aber sie würde immer das Bild von Penel al-Arabiata anzeigen und wir haben ja auch noch andere Bilder, die wir in unserer Anwendung anzeigen möchten. Was ich also jetzt machen möchte, ist dass sich diese Image Preview Komponente parametrisierbar macht. Das heißt, man soll ihr Daten übergeben können, mit der sie dann arbeitet, unter anderem den Namen des Bildes und den Titel des Bildes. Und diese Daten, die wir der Komponente gleich übergeben, die werden in React Properties oder kurz Props genannt. Ich werde diese beiden Begriffe synonym verwenden, da gibt es auch glaube ich, keinen Unterschied. Ich vermute, dass es häufig von Props die Rede ist, weil das Wort ein bisschen kürzer ist und Properties gibt es natürlich auch in ganz vielen anderen Zusammenhängen. Also diese beiden Begriffe werden dafür verwendet. Und ich fange mal ganz hinten an und zwar so wie wir die Komponente gleich verwenden oder wie ich möchte, dass man diese Komponente gleich verwendet. Ich schreibe das mal hin hier als Beispiel. Bislang rufen wir die Komponente in unserer App Komponente ja so auf Image Preview und was ich jetzt möchte, ist, dass wir halt Properties übergeben. In XML übrigens würden diese Properties auch Attribute genannt. Das ist hier so was Ähnliches. Und wir schreiben sie auch in der gleichen Notation hin, wie wir in XML oder HTML Attribute hinschreiben würden. Und ich möchte jetzt, wie gesagt, dass wir einen Titel für unser Bild übergeben. Das wäre in dem Fall, wie gesagt, Penel al-Arabiata. Und dass wir den Image Source übergeben. Das wäre in dem Fall ich kopiere das mal hier unten, damit ich mich nicht verschreibe. Das wäre diese\n'slidetext': ''\n'from': 'index'\n'score': 61.69618606567383\n'normalizedScore': 0.6169618606567383\n'beforeDatePenaltyScore': 0.6169618606567383\n\n'documentId': '6f5764d4aae6fe7d53d79d62'\n'chunk_id': '68da368fe61fb6001259ad89'\n'access': 'granted'\n'part_number': 7\n'total_parts': 13\n'contentType': 'READ'\n'title': Formulare mit React: Gut in Form - Wie die Bibliothek react-hook-form hilft, komplexe Formulare zu entwickeln\n'parentName': iJS Magazin 5.2025\n'language': 'DE'\n'date': '2025-09-23T22:00:00.000Z'\n'abstract': Formulare sind aus den meisten Webanwendungen nicht wegzudenken. Die Entwicklung benutzerfreundlicher Formulare ist aber gar nicht so einfach und wird ohne Hilfsmittel schnell komplex und fehleranfällig. Die Bibliothek react-hook-form soll Abhilfe schaffen.\n'parentId': 'c2c5ea3e478bff04fc898402'\n'parentDescription': Kaum ein Softwareprojekt, das nicht in wesentlichen Teilen auf der JavaScript-Technologie basiert. Eine breite Unterstützung sowie, leistungsfähige Programmiersprachen, die Vielzahl moderner Tools, sowie ausgereifte Frameworks wie Angular, React, Vue.js oder Node.js machen den JavaScript-Werkzeugkasten zu einem Alleskönner. Das iJS Magazin informiert aktuell und umfassend über die wichtige und innovative Entwicklungen im JavaScript-Universum und bietet handfeste Praxisinformationen für Softwareentwickler und -architekten.\n'indexBrandName': ''\n'indexSeriesName': ''\n'author': 'Nils Hartmann'\n'chunkSource': 'text'\n'text': noch gar nicht direkt zugegriffen. Dazu gibt es mehrere Möglichkeiten. Eine typische Variante ist das Vorbelegen von Inhalten beim Erzeugen des Formulars. In unserem Fall könnte es zum Beispiel sein, dass mit dem Formular nicht nur neue Reservierungen eingegeben, sondern auch bestehende bearbeitet werden können. Dazu könnte eine bestehende Reservierung an die ReservierungForm-Komponente als Properties übergeben werden. Die Daten daraus werden dann beim useForm-Aufruf mit der Eigenschaft defaultValues in den Formzustand gesetzt. Damit ist das Formular mit den übergebenen Daten beim Rendern vorbelegt. Die reset-Funktion setzt das Formular nun übrigens auf die initialen Werte zurück, die mit defaultValues gesetzt sind – und nicht auf leere Werte. Um die Formularinhalte zu leeren, was der Titel des Buttons Clear ja verspricht, können beim reset-Aufruf neue defaultValues übergeben werden. Listing 5 zeigt die aktualisierte Implementierung. Listing 5: Das Formular kann vorbelegt werden und der Clear-Button löscht alle Inhalte type ReservationFormProps = { existingReservation?: { firstName: string; lastName: string; foodTruck: string; guests: number; }; }; function ReservationForm({ existingReservation, }: ReservationFormProps) { const form = useForm({ // ... defaultValues: existingReservation, }); const handleClear = () => { form.reset({ lastName: '', firstName: '', guests: null, foodTruck: '', }); }; return (  { /* ... */ }  handleClear()}> Clear   ); } Eine weitere Möglichkeit, den Inhalt eines Feldes zu setzen, ist die setValue-Funktion. Dieser Funktion wird der Name eines Feldes und der neue Wert übergeben. In unserem Formular wollen wir die Funktion dazu nutzen, den Benutzer beim Ausfüllen des Reservierungszeitraums zu unterstützen. Dazu erweitern wir zunächst das Formular um ein start- und ein end-Feld, die jeweils ein Datum reservieren. Da es sich dabei fachlich um zusammengehörige Werte handelt, sollen sie in unseren Formulardaten in einem eigenen Objekt abgelegt werden. Für dieses Objekt wird mit zod ein eigenes Schema definiert, das ReservationPeriod heißt und aus zwei Feldern besteht, die jeweils einem ISO-Date-String entsprechen sollen. In dem Schema sind darüber hinaus zwei eigene Validierungsregeln hinterlegt, die mit Hilfe der Bibliothek dayjs [7] sicherstellen, dass\n'slidetext': ''\n'from': 'index'\n'score': 61.40351486206055\n'normalizedScore': 0.6140351486206055\n'beforeDatePenaltyScore': 0.6140351486206055\n\n'documentId': '6f5764d4aae6fe7d53d79d62'\n'chunk_id': '68da368ee61fb6001259ad84'\n'access': 'granted'\n'part_number': 2\n'total_parts': 13\n'contentType': 'READ'\n'title': Formulare mit React: Gut in Form - Wie die Bibliothek react-hook-form hilft, komplexe Formulare zu entwickeln\n'parentName': iJS Magazin 5.2025\n'language': 'DE'\n'date': '2025-09-23T22:00:00.000Z'\n'abstract': Formulare sind aus den meisten Webanwendungen nicht wegzudenken. Die Entwicklung benutzerfreundlicher Formulare ist aber gar nicht so einfach und wird ohne Hilfsmittel schnell komplex und fehleranfällig. Die Bibliothek react-hook-form soll Abhilfe schaffen.\n'parentId': 'c2c5ea3e478bff04fc898402'\n'parentDescription': Kaum ein Softwareprojekt, das nicht in wesentlichen Teilen auf der JavaScript-Technologie basiert. Eine breite Unterstützung sowie, leistungsfähige Programmiersprachen, die Vielzahl moderner Tools, sowie ausgereifte Frameworks wie Angular, React, Vue.js oder Node.js machen den JavaScript-Werkzeugkasten zu einem Alleskönner. Das iJS Magazin informiert aktuell und umfassend über die wichtige und innovative Entwicklungen im JavaScript-Universum und bietet handfeste Praxisinformationen für Softwareentwickler und -architekten.\n'indexBrandName': ''\n'indexSeriesName': ''\n'author': 'Nils Hartmann'\n'chunkSource': 'text'\n'text': zur Verfügung. Abb. 1: Das Formular zum Reservieren eines Foodtrucks Anlegen des Formulars Im ersten Schritt sollen die Felder für Name, Foodtruck und Anzahl der Gäste implementiert werden. Da die Daten des Formulars mit zod validiert werden sollen, muss zunächst ein Schema mit den Feldern des Formulars mit zod beschrieben werden (Kasten: „Die Bibliothek zod“). Bis jetzt gibt es die Felder firstname (optionaler String), lastname (String), foodtruck (String) und guests (Zahl, die größer als fünf ist, da fünf die minimale Anzahl an Gästen ist, für die ein Foodtruck zur Verfügung steht). Der entsprechende Code ist in Listing 1 zu sehen. Listing 1: Definition der Formular-Felder mit zod const ReservationFormState = z.object({ firstName: z.string().optional(), lastName: z.string().nonempty(), foodTruck: z.string().nonempty(), guests: z.number().min(5), }); type ReservationFormState = z.infer; Die Bibliothek zod zod ist eine beliebte Bibliothek zur Validierung von JavaScript-Objekten. Dazu werden Objektstrukturen mit Feldern und „Typen“, ähnlich wie in TypeScript, beschrieben. In Ergänzung zu TypeScript können aber auch Regeln für erlaubte Werte angegeben werden (Längenbeschränkungen, Beschränkungen von numerischen Werten etc.). Das Listing in diesem Kasten zeigt eine Definition eines Objekts, das aus vier Feldern besteht. Das Feld guests muss einen numerischen Wert enthalten, der mindestens 5 ist. coerce gibt hier an, dass es sich bei dem Wert auch um einen anderen Typ handeln kann, solange er in eine Zahl konvertiert werden kann (zum Beispiel ein String aus einem Eingabefeld). Die Felder firstName, lastName und foodTruck sind jeweils vom Typ String, wobei firstName optional ist, d. h. auch undefined annehmen kann, lastName und foodTruck hingegen dürfen keine Leerstrings sein. Das Feld reservationBegin muss ein Datum im ISO-Format (Jahr-Monat-Tag) enthalten, wobei mit der refine-Funktion eine weitere eigene Bedingung definiert ist. Diese Funktion wird von zod aufgerufen, wenn die vorherige Bedingung erfüllt ist. In diesem Beispiel wird die daysjs-Funktion aus der gleichnamigen Bibliothek verwendet, um sicherzustellen, dass das Datum in der Zukunft liegt. Um zu überprüfen, ob ein Wert zur Laufzeit gemäß der zod-Beschreibung gültig ist, kann die parse-Methode\n'slidetext': ''\n'from': 'index'\n'score': 61.40351486206055\n'normalizedScore': 0.6140351486206055\n'beforeDatePenaltyScore': 0.6140351486206055\n\n'documentId': '50c03dd02cf9b7c2ff4480f2'\n'chunk_id': '68b55eb633a5bf00132cb6a7'\n'access': 'granted'\n'part_number': 38\n'total_parts': 47\n'contentType': 'TUTORIAL'\n'title': React-Grundlagen\n'parentName': Modern React: von Null auf Full-Stack\n'language': 'DE'\n'date': '2025-08-27T09:53:51.000Z'\n'abstract': In der ersten Lesson lernst du, was React ist und wie es funktioniert. Anhand einer Beispielanwendung schauen wir uns den Projektaufbau und den Workspace an. Du erfährst, wie Komponenten aufgebaut sind, wie man mit Props, Listen und State arbeitet und wie Interaktionen in React abgebildet werden.\n'parentId': 'b2c71c7c41dfe8eab4593f02'\n'parentDescription': In diesem Videotutorial lernst du React von Grund auf – bis hin zur Full-Stack-Entwicklung mit Next.js. Du baust Single Page Applications, verwaltest State, entwickelst moderne Formulare, arbeitest mit serverseitigen Daten und setzt Routing effizient um. Zum Abschluss bekommst du eine Einführung in React Server Components und Next.js. Benötigte Vorkenntnisse: JavaScript-Grundlagen, TypeScript ist hilfreich, aber nicht zwingend nötig. Nach dem Tutorial bist du bereit, eigene client- und serverseitige Anwendungen mit React umzusetzen.\n'indexBrandName': 'InternationalJavaScriptCon'\n'indexSeriesName': ''\n'author': 'Nils Hartmann'\n'chunkSource': 'text'\n'text': zu beschreiben, das ist einfach da. Und ihr braucht es auch in euren Properties oder in euren Komponenten, nicht zu konsumieren. Das macht React alles für euch. Jetzt habe ich ja gesagt, Attribut oder genau gesagt, der Wert für dieses Key-Attribut der muss in der Liste eindeutig sein. Jetzt könnte man ja auf die Idee kommen, in dieser Map-Funktion haben wir ja nicht nur das Objekt, über das wir gerade rüber gemapt sind aus der Liste, sondern wir haben ja auch noch den Index von diesem, den das Objekt in der Liste hat, also 0 1 2 3 und so weiter und so fort. Den könnte ich natürlich prinzipiell hier auch angeben und in unserem Fall wäre das sogar auch in Ordnung. Aber das Problem ist auch hier wieder, wenn ich die Liste verändere, wenn ich sie filter, wenn ich sie umsortiere und so weiter, dann kriege ich ja auch jedes Mal ein neues neuen Index für das gleiche Bild, wenn man so will. Also wenn ich die Liste einmal sortierungsmäßig umdrehen würde, dann würden die Index weiter von 0 1 2 und so weiter loslaufen. Aber die Image, die plötzlich andere. Die Idee ist schon, dass dieses Ding was ich hier angebe, sozusagen immer auf das gleiche Objekt wenn man so möchte, zeigt, das ich darstellen will. Deswegen verwendet man das Index-Attribut üblicherweise nicht. Das ist mit sehr sehr großer Gefahr sage ich mal, verbunden. Denn wenn ihr einen, also das eine ist, man lässt das Key-Attribut komplett weg, das ist unschön, aber meistens funktioniert die Anwendung noch. Wenn ihr das Falsches angibt, dann kann das wirklich sein, dass eure Anwendung nicht richtig funktioniert. Deswegen am besten immer irgendwas, eindeutig ist. In unserem Fall haben wir Glück, weil unser Backend wird uns später eine ID für ein Bild zurückliefern, der ist eindeutig, weil das ein Datenbank-Schlüssel ist. Wenn man sowas nicht hat, dann gibt es manchmal auch andere fachliche Informationen, die eindeutig sind, zum Beispiel vielleicht eine E-Mail-Adresse, Username oder irgendwas. Die kann man natürlich genauso gut nehmen. Ihr könnt jetzt Drinks benutzen, könnt Zahlen benutzen,\n'slidetext': ''\n'from': 'index'\n'score': 61.18595504760742\n'normalizedScore': 0.6118595504760742\n'beforeDatePenaltyScore': 0.6118595504760742\n\n'documentId': '50c03dd02cf9b7c2ff4480f2'\n'chunk_id': '68b55eb633a5bf00132cb6a6'\n'access': 'granted'\n'part_number': 37\n'total_parts': 47\n'contentType': 'TUTORIAL'\n'title': React-Grundlagen\n'parentName': Modern React: von Null auf Full-Stack\n'language': 'DE'\n'date': '2025-08-27T09:53:51.000Z'\n'abstract': In der ersten Lesson lernst du, was React ist und wie es funktioniert. Anhand einer Beispielanwendung schauen wir uns den Projektaufbau und den Workspace an. Du erfährst, wie Komponenten aufgebaut sind, wie man mit Props, Listen und State arbeitet und wie Interaktionen in React abgebildet werden.\n'parentId': 'b2c71c7c41dfe8eab4593f02'\n'parentDescription': In diesem Videotutorial lernst du React von Grund auf – bis hin zur Full-Stack-Entwicklung mit Next.js. Du baust Single Page Applications, verwaltest State, entwickelst moderne Formulare, arbeitest mit serverseitigen Daten und setzt Routing effizient um. Zum Abschluss bekommst du eine Einführung in React Server Components und Next.js. Benötigte Vorkenntnisse: JavaScript-Grundlagen, TypeScript ist hilfreich, aber nicht zwingend nötig. Nach dem Tutorial bist du bereit, eigene client- und serverseitige Anwendungen mit React umzusetzen.\n'indexBrandName': 'InternationalJavaScriptCon'\n'indexSeriesName': ''\n'author': 'Nils Hartmann'\n'chunkSource': 'text'\n'text': hier draufklicken-Symbol. Und wenn wir hier über einen Eintrag gehen, wird er auch hervorgehoben, sozusagen nach dem Motto hier kannst draufklicken. Dies könntest du jetzt auswählen. Wenn ich draufklick, passiert nichts, weil die Logik haben wir noch nicht implementiert. Das machen wir noch. Aber grafisch sozusagen, optisch ist es schon mal dafür vorbereitet. Und das sind die drei Bilder, die aus unseren Demodaten kommen. Und jetzt hatte ich ja dieses Key-Attribut bewusst mal rausgenommen. Und wenn wir auf die Konsole schauen, dann sehen wir hier eine Fehlermeldung, dass Each Child in a List, also jedes Kind in einer Liste sollte ein eindeutiges Key-Property haben. Es steht hier sogar, also das ist das, was wir euch erklärt haben. Jedes Root-Element in der Liste, eindeutiges Key-Property. Und dann steht hier sogar, was man machen soll, nämlich die Render-Methode von dem Diff angucken. können wir jetzt konkret, also das ist jetzt sozusagen nicht die Methode, die die Diff-Methode selber, sondern die Methode, die das Diff rendert. Und das sehen wir hier, dass das als Kind-Element von dem Image-Selektor aufgerufen worden ist. Also man kriegt eine relativ gute Fehlermeldung, inklusive, dass wir hier den Source-Code finden. Und normalerweise, wenn ich da draufklick, wird er auch aufgemacht. Hier wird auch aufgemacht. Also wir sehen genau die Stelle, das Problem sozusagen ist. Gehen wir mal wieder in unseren Code und reparieren das Ganze. Image-Selektor, kann ich das hier nochmal einfügen? Das war falsch, das war richtig. So jetzt haben wir hier das Key-Attribut. Und wenn wir unsere Anwendung nochmal neu starten, nicht irritieren von diesen Fehlern hier, das hat damit nichts zu tun. Ihr seht, wir haben keine Fehlermeldung mehr. Jetzt ist React glücklich. Und wenn wir in unseren Komponenten-Tab hier reingucken, dann sehen wir auch, dass diese Keys hier angezeigt werden. Also wir sehen, das hat jetzt funktioniert. Nochmal ganz wichtig, dieses Key-Attribut müsst ihr setzen. Das muss in der Liste eindeutig sein. Ihr braucht es nicht in euren Properties-Typen zu\n'slidetext': ''\n'from': 'index'\n'score': 61.18595504760742\n'normalizedScore': 0.6118595504760742\n'beforeDatePenaltyScore': 0.6118595504760742\n\n'documentId': '50c03dd02cf9b7c2ff4480f2'\n'chunk_id': '68b55eb533a5bf00132cb698'\n'access': 'granted'\n'part_number': 23\n'total_parts': 47\n'contentType': 'TUTORIAL'\n'title': React-Grundlagen\n'parentName': Modern React: von Null auf Full-Stack\n'language': 'DE'\n'date': '2025-08-27T09:53:51.000Z'\n'abstract': In der ersten Lesson lernst du, was React ist und wie es funktioniert. Anhand einer Beispielanwendung schauen wir uns den Projektaufbau und den Workspace an. Du erfährst, wie Komponenten aufgebaut sind, wie man mit Props, Listen und State arbeitet und wie Interaktionen in React abgebildet werden.\n'parentId': 'b2c71c7c41dfe8eab4593f02'\n'parentDescription': In diesem Videotutorial lernst du React von Grund auf – bis hin zur Full-Stack-Entwicklung mit Next.js. Du baust Single Page Applications, verwaltest State, entwickelst moderne Formulare, arbeitest mit serverseitigen Daten und setzt Routing effizient um. Zum Abschluss bekommst du eine Einführung in React Server Components und Next.js. Benötigte Vorkenntnisse: JavaScript-Grundlagen, TypeScript ist hilfreich, aber nicht zwingend nötig. Nach dem Tutorial bist du bereit, eigene client- und serverseitige Anwendungen mit React umzusetzen.\n'indexBrandName': 'InternationalJavaScriptCon'\n'indexSeriesName': ''\n'author': 'Nils Hartmann'\n'chunkSource': 'text'\n'text': Verständlichkeit und so weiter und so fort. Aber es geht, ihr könnt das machen. Nochmal ganz wichtig, dieser JSX-Code der wird zu Funktionsaufrufen umgesetzt und diese Funktionsaufrufe, liefern etwas zurück, die liefern ein Objekt zurück. Und ihr könnt euch quasi vorstellen, überall da wo ihr in JavaScript einen Funktionsaufruf machen könnt, der ein Objekt zurückliefert oder der irgendetwas zurückliefert, könnt ihr JSX-Code hinschreiben. Denn aus diesem Ding hier, was ich jetzt schreibe, aber so kann man sich es glaube ich vorstellen, wird Folgendes, Create Element nenne ich es einfach mal, und dann wird hier was weiß ich, ein i draus gemacht, und dann werden da noch die Properties übergeben und so weiter und so fort. Oder ansonsten wird Create Element Diff draus gemacht. Das stimmt nicht hundertprozentig hier, die API sieht ein bisschen anders aus als das, was ich hier hingeschrieben habe, aber so könnt ihr euch das zumindest einigermaßen vorstellen, hoffe ich jedenfalls, aus diesem hier wird nach dem Bildprozess ein Funktionsaufruf, der so aussieht. So, wenn man sich das vor Augen führt oder ich finde es ganz hilfreich, sich das vor Augen zu führen, denn dann kann man sich immer vorstellen, wo kann ich diesen JSX-Code eigentlich einsetzen. Ihr stellt euch einfach vor, aus dem Element wird ein Funktionsaufruf, heißt irgendwie, das ist für uns völlig egal, wichtig ist es ein Funktionsaufruf, da kommt irgendwas zurück und überall, wo wir einen Funktionsaufruf hinschreiben können, in JavaScript, etwas zurückliefert, können wir diese JSX Elemente einsetzen. Die können wir auch als Rückgabewert haben wir es ja schon gesehen, die können wir auch als Properties tatsächlich entgegennehmen, das werden wir später noch sehen, und wir können sie wie gesagt, variablen zuweisen. Das ist ein ganz ganz wichtiges Konzept, finde ich. Wie gesagt, es ist nicht so wichtig was intern dieses Bildtool draus macht, das ist ein Implementierungsdetail von React, aber sozusagen die Idee, was da rauskommt, das finde ich ganz gut, wenn man sich das so ungefähr hier vorstellen kann wie ich das\n'slidetext': ''\n'from': 'index'\n'score': 61.18595504760742\n'normalizedScore': 0.6118595504760742\n'beforeDatePenaltyScore': 0.6118595504760742\n\n'documentId': '50c03dd02cf9b7c2ff4480f2'\n'chunk_id': '68b55eab33a5bf00132cb686'\n'access': 'granted'\n'part_number': 5\n'total_parts': 47\n'contentType': 'TUTORIAL'\n'title': React-Grundlagen\n'parentName': Modern React: von Null auf Full-Stack\n'language': 'DE'\n'date': '2025-08-27T09:53:51.000Z'\n'abstract': In der ersten Lesson lernst du, was React ist und wie es funktioniert. Anhand einer Beispielanwendung schauen wir uns den Projektaufbau und den Workspace an. Du erfährst, wie Komponenten aufgebaut sind, wie man mit Props, Listen und State arbeitet und wie Interaktionen in React abgebildet werden.\n'parentId': 'b2c71c7c41dfe8eab4593f02'\n'parentDescription': In diesem Videotutorial lernst du React von Grund auf – bis hin zur Full-Stack-Entwicklung mit Next.js. Du baust Single Page Applications, verwaltest State, entwickelst moderne Formulare, arbeitest mit serverseitigen Daten und setzt Routing effizient um. Zum Abschluss bekommst du eine Einführung in React Server Components und Next.js. Benötigte Vorkenntnisse: JavaScript-Grundlagen, TypeScript ist hilfreich, aber nicht zwingend nötig. Nach dem Tutorial bist du bereit, eigene client- und serverseitige Anwendungen mit React umzusetzen.\n'indexBrandName': 'InternationalJavaScriptCon'\n'indexSeriesName': ''\n'author': 'Nils Hartmann'\n'chunkSource': 'text'\n'text': haben hier eine Liste mit unseren Kochrezepten. Wir können sehen, wie viel Feedback, also Kommentare dieses Kochrezept erhalten hat. Wir können hier auf Details klicken. Wir sehen, es auch aus unterschiedlichen Gründen relativ langsam ist und uns hier dann noch Details zu einem Rezept anschauen. Wir haben hier unten so eine Art Aufgabenliste. Auch das kennt man vielleicht aus anderen Anwendungen. Mit dieser Aufgabenliste kann ich Kommentare verwalten. Es ist nämlich so, dass wenn jetzt jemand einen Kommentar eingibt auf unserer Seite, dann muss er erst approved werden, also muss sozusagen genehmigt werden oder eben auch zurückgewiesen werden. Der kann gelöscht werden. Das kann ich alles über diese Tabelle machen. Und was natürlich ganz ganz wichtig ist. Ich kann hier neue Kochrezepte auch anlegen. Das ist ein relativ komplexes Formular, was wir uns auch im Detail angucken werden. Aus meiner Sicht ist die Entwicklung von Formularen eine sehr komplexe Angelegenheit insbesondere wenn wir sehr benutzerfreundliche Formulare bauen wollen. Und da werden wir hier so ein paar typische Probleme von Formularen sehen und wie wir die mit React beheben können. Ich gehe nochmal ganz kurz zurück und wähle mal ein bestehendes Rezept aus nur dass ihr mal das ausgefüllte Formular seht. Wie gesagt, das ist relativ lang. Wir können ja mal dieses Rezept hier anklicken. Und jetzt seht ihr das ausgefüllte Formular. Wir haben so was wie so ein Essens Typ. Können wir hier mal reingucken. Lunch, Drinks, Dinner und so weiter. Also was ist das eigentlich was wir kochen? Das hat jeweils einen Titel, eine Headline. Das ist so eine Kurzbeschreibung von so einem Rezept. Dann wie lange brauche ich, um das zu kochen? Wie lange brauche ich um das vorzubereiten? Ehrlich gesagt, bei diesem Gericht bin ich mir nicht sicher, ob man damit 15 Minuten auskommt, aber sei es drum. Wir haben ein Foto zu jedem Gericht. Da werden wir dann auch noch mal gucken, wie ich eigentlich mit sowas wie Bildern umgehen kann, dass ich die zuschneiden kann und so weiter. Wir haben Kategorien zu einem Rezept, die ich hier auswählen kann. Ob die immer so\n'slidetext': ''\n'from': 'index'\n'score': 61.18595504760742\n'normalizedScore': 0.6118595504760742\n'beforeDatePenaltyScore': 0.6118595504760742\n\n'documentId': '50c03dd02cf9b7c2ff4480f2'\n'chunk_id': '68b55eac33a5bf00132cb68d'\n'access': 'granted'\n'part_number': 12\n'total_parts': 47\n'contentType': 'TUTORIAL'\n'title': React-Grundlagen\n'parentName': Modern React: von Null auf Full-Stack\n'language': 'DE'\n'date': '2025-08-27T09:53:51.000Z'\n'abstract': In der ersten Lesson lernst du, was React ist und wie es funktioniert. Anhand einer Beispielanwendung schauen wir uns den Projektaufbau und den Workspace an. Du erfährst, wie Komponenten aufgebaut sind, wie man mit Props, Listen und State arbeitet und wie Interaktionen in React abgebildet werden.\n'parentId': 'b2c71c7c41dfe8eab4593f02'\n'parentDescription': In diesem Videotutorial lernst du React von Grund auf – bis hin zur Full-Stack-Entwicklung mit Next.js. Du baust Single Page Applications, verwaltest State, entwickelst moderne Formulare, arbeitest mit serverseitigen Daten und setzt Routing effizient um. Zum Abschluss bekommst du eine Einführung in React Server Components und Next.js. Benötigte Vorkenntnisse: JavaScript-Grundlagen, TypeScript ist hilfreich, aber nicht zwingend nötig. Nach dem Tutorial bist du bereit, eigene client- und serverseitige Anwendungen mit React umzusetzen.\n'indexBrandName': 'InternationalJavaScriptCon'\n'indexSeriesName': ''\n'author': 'Nils Hartmann'\n'chunkSource': 'text'\n'text': quasi zum Leben braucht. Daten, Darstellung, Logik. Wir fangen mal mit der Darstellung hier an. ist nämlich auch eine Sache, sehr sehr speziell ist in React. Eine Komponente gibt nämlich als Rückgabewert die Darstellung an der Oberfläche zurück, also das, dargestellt werden soll, wenn diese Komponente im Browser angezeigt wird, wenn die in unserer Anwendung verwendet wird. Und das kann sie machen, indem sie eine Art HTML-Code zurückgibt. In diesem Fall zum Beispiel könnte ich hier mein DIV direkt hinschreiben, was ich hier haben möchte. ich könnte hier zum Beispiel mein Image hinschreiben, Image Source. Und ich habe hier mal so paar Demo-Bilder vorbereitet. Die liegen unter Assets, Demo und dann zum Beispiel Penne PNG. Und dann haben wir hier auch ein Alt-Attribut für den Alternativtext. Penne Al-Arabiata, glaube ich wird es geschrieben. So das würde ich vielleicht hier ausgeben wollen und ich würde vielleicht auch noch einen Titel dazu ausgeben wollen, dass man das auch sehen kann Das ist der gleiche wie auch das Alt-Attribut. Und außerdem möchte ich noch ein kleines Icon dazu anzeigen. Die Idee ist von dieser Image Preview Komponente, das schon mal so als kleiner Ausblick, dass wir die nachher wie gesagt, in so eine Liste einbinden. Und in dieser Liste kann ich dann sagen, welches Image aus dieser Liste ist eigentlich ausgewählt. Und dazu möchte ich, dass dann da so ein kleiner Haken, so eine kleine Checkbox nebenan gezeigt wird. diese Icons, die zeige ich mit oder für diese Icons benutze ich Font Awesome, die Font Awesome Icon Bibliothek. Da könnt ihr natürlich auch alles Mögliche benutzen, was ihr benutzt, was ihr benutzen möchtet. In meinem Fall muss ich hier weil ich Font Awesome benutze, hier ein CSS Klassennamen hinschreiben, der so aussieht. Und prinzipiell, wenn ich jetzt alles richtig gemacht habe, müssten wir gleich ein Image sehen mit einem Titel und einem kleinen Checkbox daneben. Hier muss auch noch der CSS Klassennamen rein. Bevor wir uns das jetzt in der laufenden Anwendung anschauen, noch mal ein paar Bemerkungen zu dem, was ich jetzt hier hingeschrieben habe. Ihr seht das\n'slidetext': ''\n'from': 'index'\n'score': 61.12541198730469\n'normalizedScore': 0.6112541198730469\n'beforeDatePenaltyScore': 0.6112541198730469\n\n'documentId': '50c03dd02cf9b7c2ff4480f2'\n'chunk_id': '68b55eb533a5bf00132cb6a0'\n'access': 'granted'\n'part_number': 31\n'total_parts': 47\n'contentType': 'TUTORIAL'\n'title': React-Grundlagen\n'parentName': Modern React: von Null auf Full-Stack\n'language': 'DE'\n'date': '2025-08-27T09:53:51.000Z'\n'abstract': In der ersten Lesson lernst du, was React ist und wie es funktioniert. Anhand einer Beispielanwendung schauen wir uns den Projektaufbau und den Workspace an. Du erfährst, wie Komponenten aufgebaut sind, wie man mit Props, Listen und State arbeitet und wie Interaktionen in React abgebildet werden.\n'parentId': 'b2c71c7c41dfe8eab4593f02'\n'parentDescription': In diesem Videotutorial lernst du React von Grund auf – bis hin zur Full-Stack-Entwicklung mit Next.js. Du baust Single Page Applications, verwaltest State, entwickelst moderne Formulare, arbeitest mit serverseitigen Daten und setzt Routing effizient um. Zum Abschluss bekommst du eine Einführung in React Server Components und Next.js. Benötigte Vorkenntnisse: JavaScript-Grundlagen, TypeScript ist hilfreich, aber nicht zwingend nötig. Nach dem Tutorial bist du bereit, eigene client- und serverseitige Anwendungen mit React umzusetzen.\n'indexBrandName': 'InternationalJavaScriptCon'\n'indexSeriesName': ''\n'author': 'Nils Hartmann'\n'chunkSource': 'text'\n'text': zu erwähnen. Ihr könnt prinzipiell das Schlüsselwort Type verwenden, um ein Objekt zu beschreiben. Ihr könnt genauso gut auch TypeScript-Interfaces verwenden. Sieht von der Syntax fast genauso aus. Ich schreibe es mal als Interface hin, baue das dann gleich auf Type um. Das könnt ihr mittlerweile fast eins zu eins austauschen. je nachdem, was euch von der Syntax lieber ist, nehmt ihr das ein oder das andere. Wie auch immer, erst mal zurück zu diesem Objekt. Dieses Objekt soll, das kennen wir schon, einen Titel haben, das den Bildtitel enthält und das SourceProperty das den Fazit im Bild beschreibt. Und zusätzlich weil das wie gesagt, ein Objekt ist was ich später vom Server lese, hat das außerdem noch ein ID, quasi den primary key oder was auch immer von diesem Bild. So, das ist quasi die Beschreibung eines fachlichen Objektes, das ich in meiner Anwendung verwenden möchte. Und wie gesagt, nur, dass ihr den Unterschied einmal seht, ihr könnt es als Interface beschreiben oder ihr könnt es auch als Type beschreiben. Es sieht wirklich fast genauso aus. Nicht über den Kompilfehler jetzt wundern. Das liegt daran, dass jetzt ImageDTU hier zweimal in meinem Code hingeschrieben habe. Ich persönlich verwende immer Type lieber als Interface. Das liegt ein bisschen an meinem Java-Hintergrund sozusagen. In Java hat das Interface eine ganz andere Bedeutung als es in TypeScript hat. Deswegen fand ich es am Anfang verwirrend und habe mich dann irgendwie auf das Type-Schlüsselwort konzentriert, wenn man so will. Wie gesagt, ihr könnt beides verwenden. Die Unterschiede, die diese beiden Notationen haben, sind marginalst, aus meiner Sicht spielen sie in den allermeisten Anwendungsfällen, die ihr so in euren Anwendungen habt. Keine Rolle. Nehmt einfach das, was ihr besser findet. Und das Gleiche gilt übrigens auch für die Objekte, ihr also für die Properties die ihr beschreibt. Auch da könnt ihr Type oder Interface benutzen. Ganz wie ihr mögt. Und ich glaube, ihr seht schon an diesem Teil, also so weit, wie wir bislang gekommen sind, es gibt, wenn ihr React-Anwendungen baut, super\n'slidetext': ''\n'from': 'index'\n'score': 61.12541198730469\n'normalizedScore': 0.6112541198730469\n'beforeDatePenaltyScore': 0.6112541198730469\n\n'documentId': '50c03dd02cf9b7c2ff4480f2'\n'chunk_id': '68b55eb533a5bf00132cb69d'\n'access': 'granted'\n'part_number': 28\n'total_parts': 47\n'contentType': 'TUTORIAL'\n'title': React-Grundlagen\n'parentName': Modern React: von Null auf Full-Stack\n'language': 'DE'\n'date': '2025-08-27T09:53:51.000Z'\n'abstract': In der ersten Lesson lernst du, was React ist und wie es funktioniert. Anhand einer Beispielanwendung schauen wir uns den Projektaufbau und den Workspace an. Du erfährst, wie Komponenten aufgebaut sind, wie man mit Props, Listen und State arbeitet und wie Interaktionen in React abgebildet werden.\n'parentId': 'b2c71c7c41dfe8eab4593f02'\n'parentDescription': In diesem Videotutorial lernst du React von Grund auf – bis hin zur Full-Stack-Entwicklung mit Next.js. Du baust Single Page Applications, verwaltest State, entwickelst moderne Formulare, arbeitest mit serverseitigen Daten und setzt Routing effizient um. Zum Abschluss bekommst du eine Einführung in React Server Components und Next.js. Benötigte Vorkenntnisse: JavaScript-Grundlagen, TypeScript ist hilfreich, aber nicht zwingend nötig. Nach dem Tutorial bist du bereit, eigene client- und serverseitige Anwendungen mit React umzusetzen.\n'indexBrandName': 'InternationalJavaScriptCon'\n'indexSeriesName': ''\n'author': 'Nils Hartmann'\n'chunkSource': 'text'\n'text': aber dass die Komponente per Default Enabled ist, dann würde ich genau machen was ich eben gemacht hatte. Enabled gleich True zum Beispiel. Oder ich habe verschiedene Varianten einer Komponente, Groß, Mittel, Klein zum Beispiel, dann könnte es sein, die Variante ist optional und per Default setze ich sie dann auf Mittel zum Beispiel. Wie gesagt, ein bisschen vorsichtig sein, man kann das nicht mehr so einfach ändern oder wenn man es ändert, muss man die Anwendung anpassen. So das finde ich jedenfalls spricht für diesen Destrukturierungs-Operator, dagegen spricht, das stört einige Menschen. Ich schreibe einerseits die Typen hier hin und ich definiere einerseits den Typ, andererseits schreibe ich dann hier nochmal die ganzen Properties einzeln hin. Also ich habe sozusagen eine doppelte Schreibarbeit, finde ich auch eine berechtigte Kritik, aber es geht in TypeScript leider nicht anders. Und was man vielleicht auch sowohl als auch sehen kann, ist, ich hatte vorhin gesagt, ich finde es ganz gut, dass ich hier nicht mehr props.check zum Beispiel hinschreiben muss, props.title, das finde ich tatsächlich auch ganz gut, weil es ein bisschen kürzer ist. Auf der anderen Seite, ich schreibe es nochmal hin, wenn ich hier props vorhabe, ist natürlich sehr explizit. Ich weiß unmittelbar Aha, checkt das habe ich mir nicht selbst ausgedacht, sondern das kommt aus meinem Properties. Also auch da gilt, beide Wege haben ihre Vor- Nachteile. Ich fasse fast immer zu dem Destrukturierungsoperator, wenn ihr das aber nicht möchtet, wenn ihr das nicht lesbarer oder wenn ihr das komplizierter findet, dann arbeitet ihr mit props.punkt. ist überhaupt kein Problem, da haben wir überhaupt kein Problem an der Stelle. Also wir haben jetzt eine einzelne Komponente hier gebaut, das ist die Image Preview Komponente. Die Idee ist aber, dass ich die in der richtigen Anwendung in einer Liste von Images rendern kann, einfügen kann, dazu möchte ich euch im Folgenden jetzt zeigen, wie man Listen mit React baut und das kann ich schon mal so bisschen spoilern. Dazu werden wir mehr oder weniger normalen JavaScript Code verwenden. Auch da finde ich, sich so ein bisschen\n'slidetext': ''\n'from': 'index'\n'score': 61.12541198730469\n'normalizedScore': 0.6112541198730469\n'beforeDatePenaltyScore': 0.6112541198730469\n\n'documentId': '50c03dd02cf9b7c2ff4480f2'\n'chunk_id': '68b55eb533a5bf00132cb69c'\n'access': 'granted'\n'part_number': 27\n'total_parts': 47\n'contentType': 'TUTORIAL'\n'title': React-Grundlagen\n'parentName': Modern React: von Null auf Full-Stack\n'language': 'DE'\n'date': '2025-08-27T09:53:51.000Z'\n'abstract': In der ersten Lesson lernst du, was React ist und wie es funktioniert. Anhand einer Beispielanwendung schauen wir uns den Projektaufbau und den Workspace an. Du erfährst, wie Komponenten aufgebaut sind, wie man mit Props, Listen und State arbeitet und wie Interaktionen in React abgebildet werden.\n'parentId': 'b2c71c7c41dfe8eab4593f02'\n'parentDescription': In diesem Videotutorial lernst du React von Grund auf – bis hin zur Full-Stack-Entwicklung mit Next.js. Du baust Single Page Applications, verwaltest State, entwickelst moderne Formulare, arbeitest mit serverseitigen Daten und setzt Routing effizient um. Zum Abschluss bekommst du eine Einführung in React Server Components und Next.js. Benötigte Vorkenntnisse: JavaScript-Grundlagen, TypeScript ist hilfreich, aber nicht zwingend nötig. Nach dem Tutorial bist du bereit, eigene client- und serverseitige Anwendungen mit React umzusetzen.\n'indexBrandName': 'InternationalJavaScriptCon'\n'indexSeriesName': ''\n'author': 'Nils Hartmann'\n'chunkSource': 'text'\n'text': was aber nicht erlaubt ist, weil man dieses Props-Objekt nicht bearbeiten darf. Grundsätzlich gilt in React üblicherweise, wenn ein Objekt fertig ist, wenn es konstruiert ist, darf man es nicht mehr verändern. Das ist bei den Props auch so da müsste ich dran denken oder den TypeScript-Typen ein bisschen komplexer hinschreiben. Das finde ich ist ein Vorteil wenn ich hier destrukturiere, kann mir das nicht passieren. Außerdem spare ich mir das Props-Punkt. Und noch ein weiterer Vorteil finde ich, persönlich von diesem Weg strukturieren ist, ich kann hier sehr einfach Default-Werte vergeben. Wir haben jetzt zum Beispiel gesagt, dass dieses Checked hier dass das auch weggelassen werden kann, dann wäre Checked in unserer Komponente undefined. Das ist jetzt hier kein Problem, weil die einzigen Stellen, wo wir Checked abprüfen, ist hier und hier. Und da ist es uns aber theoretisch könnte ich hier auch das ganz explizit sagen, wenn es nicht gesetzt ist, dann setzt es auf False. Oder vielleicht habe ich sogar andere Komponente, wo ich explizit sagen möchte, wenn das nicht gesetzt ist, dann soll es True sein. Da muss man ein bisschen, also das ist erstmal sehr einfach hinzuschreiben, das finde ich gut. Man muss ein bisschen aufpassen, weil es nicht immer fachlich hundertprozentig sinnvoll ist, einen Default-Wert zu vergeben. Nehmen wir an unser Titel von unserem Bild wäre optional, ist schwierig wahrscheinlich einen Default-Wert für einen Titel zu finden. Also das ist dann eher so eine fachliche Frage. Deswegen muss man da bisschen aufpassen und die Werte müssen auch sinnvoll sein, denn ich kann ja nicht später, wenn ich die Image Preview Komponente an 100 Stellen in meiner Anwendung verwende, hergehen und plötzlich diesen Default-Wert hier umtauschen und funktioniert die Anwendung plötzlich ganz anders. Also da muss man sich sehr sicher sein, dass das gut funktioniert. Ein gutes Beispiel für Default-Verhalten wäre vielleicht, wenn ich sowas wie eine allgemeine Button-Komponente habe und diese allgemeine Button-Komponente die hat ein Enabled-Property und diese Enabled-Property ist optional. Und wenn ich es nicht hinschreiben möchte, aber\n'slidetext': ''\n'from': 'index'\n'score': 61.12541198730469\n'normalizedScore': 0.6112541198730469\n'beforeDatePenaltyScore': 0.6112541198730469\n\n'documentId': '50c03dd02cf9b7c2ff4480f2'\n'chunk_id': '68b55eb533a5bf00132cb697'\n'access': 'granted'\n'part_number': 22\n'total_parts': 47\n'contentType': 'TUTORIAL'\n'title': React-Grundlagen\n'parentName': Modern React: von Null auf Full-Stack\n'language': 'DE'\n'date': '2025-08-27T09:53:51.000Z'\n'abstract': In der ersten Lesson lernst du, was React ist und wie es funktioniert. Anhand einer Beispielanwendung schauen wir uns den Projektaufbau und den Workspace an. Du erfährst, wie Komponenten aufgebaut sind, wie man mit Props, Listen und State arbeitet und wie Interaktionen in React abgebildet werden.\n'parentId': 'b2c71c7c41dfe8eab4593f02'\n'parentDescription': In diesem Videotutorial lernst du React von Grund auf – bis hin zur Full-Stack-Entwicklung mit Next.js. Du baust Single Page Applications, verwaltest State, entwickelst moderne Formulare, arbeitest mit serverseitigen Daten und setzt Routing effizient um. Zum Abschluss bekommst du eine Einführung in React Server Components und Next.js. Benötigte Vorkenntnisse: JavaScript-Grundlagen, TypeScript ist hilfreich, aber nicht zwingend nötig. Nach dem Tutorial bist du bereit, eigene client- und serverseitige Anwendungen mit React umzusetzen.\n'indexBrandName': 'InternationalJavaScriptCon'\n'indexSeriesName': ''\n'author': 'Nils Hartmann'\n'chunkSource': 'text'\n'text': übergeben bekommt, dann rendert React gar nichts. Das heißt also wenn ihr True oder Boolean irgendwo hinschreibt, True oder False irgendwo hinschreibt, dann taugt das in eurer Komponente nicht auf. Wenn ich sowas hier hinschreiben würde, würde das einfach zur Laufzeit, das wäre weg, als wenn ich es nicht hingeschrieben hätte. Deswegen funktioniert dieser Kurzausdruck. In meinem konkreten Fall nützt mir das leider nur ein wenig, denn mein sehr handgeschriebenes oder sehr rustikales CSS erwartet, dass ich in dieser Komponente immer genau drei Kind-Elemente habe, nämlich das I, das div und das Image, beziehungsweise drei Kind-Elemente habe. In diesem Fall hätte ich aber mal drei, wenn nämlich Checked 2 ist und mal nur zwei. Deswegen hilft mir das hier nicht weiter, deswegen verwende ich auch hier den ternären Operator und render hier hinten einfach ein leeres div. Wenn das jetzt sozusagen eine richtige Anwendung wäre, irgendwann mal in Produktion soll und so, dann würde ich mir das mit dem CSS vielleicht nochmal überlegen, insbesondere wenn ich jemand hätte, der sich sehr gut mit CSS auskennt, im Gegensatz zu mir und der mir da auch eine Lösung bauen könnte, dass ich an der Stelle wirklich zwei oder drei Elemente renden kann und trotzdem sind die Abstände immer richtig und so weiter und so fort. Also das ist jetzt hier so ein kleiner Workaround. Für uns hat der Workaround den Charme, vielleicht, wir hier sehen, dass wir auch hier an der Stelle mit dem ternären Operator arbeiten können und nicht nur wie hier Strings zurückliefern können, sondern dass wir hier auch JSX-Elemente hinschreiben können hinter dem Fragezeichen. Übrigens wäre auch hier möglich, um das nochmal abschließend sozusagen zu verdeutlichen, wir könnten auch hier diesen Code hinschreiben. Jetzt habe ich hier das Fragezeichen vergessen. Auch hier wäre das möglich, diesen Code in eine Variable oder diesen JSX-Code einer Variablen zuzuweisen und dann hier unten die Variable einzusetzen. Das geht genauso. Und die Argumente für und wieder sind genau die gleichen, wie hier bei unserem Klassennamen schon, Lesbarkeit, Verständlichkeit\n'slidetext': ''\n'from': 'index'\n'score': 61.12541198730469\n'normalizedScore': 0.6112541198730469\n'beforeDatePenaltyScore': 0.6112541198730469\n\n'documentId': '50c03dd02cf9b7c2ff4480f2'\n'chunk_id': '68b55eaf33a5bf00132cb694'\n'access': 'granted'\n'part_number': 19\n'total_parts': 47\n'contentType': 'TUTORIAL'\n'title': React-Grundlagen\n'parentName': Modern React: von Null auf Full-Stack\n'language': 'DE'\n'date': '2025-08-27T09:53:51.000Z'\n'abstract': In der ersten Lesson lernst du, was React ist und wie es funktioniert. Anhand einer Beispielanwendung schauen wir uns den Projektaufbau und den Workspace an. Du erfährst, wie Komponenten aufgebaut sind, wie man mit Props, Listen und State arbeitet und wie Interaktionen in React abgebildet werden.\n'parentId': 'b2c71c7c41dfe8eab4593f02'\n'parentDescription': In diesem Videotutorial lernst du React von Grund auf – bis hin zur Full-Stack-Entwicklung mit Next.js. Du baust Single Page Applications, verwaltest State, entwickelst moderne Formulare, arbeitest mit serverseitigen Daten und setzt Routing effizient um. Zum Abschluss bekommst du eine Einführung in React Server Components und Next.js. Benötigte Vorkenntnisse: JavaScript-Grundlagen, TypeScript ist hilfreich, aber nicht zwingend nötig. Nach dem Tutorial bist du bereit, eigene client- und serverseitige Anwendungen mit React umzusetzen.\n'indexBrandName': 'InternationalJavaScriptCon'\n'indexSeriesName': ''\n'author': 'Nils Hartmann'\n'chunkSource': 'text'\n'text': Kleinigkeit in diesem JSX-Code hinweisen. Ihr seht hier, dass ich hier quasi Werte drin stehen habe. Hier jetzt Properties. Und die habe ich jeweils mit einem geschweiften Klammer eingeleitet bzw. geschlossen. In diesen geschweiften Klammern steht streng genommen oder formal gesehen ein JavaScript-Ausdruck drin. Es gibt in JavaScript Ausdrücke. Es gibt Anweisungen. Eine Anweisung wäre zum Beispiel ein If-Statement. Ein Ausdruck ist ein String zum Beispiel. Und alles, in JavaScript ein Ausdruck ist, dürft ihr hier hinschreiben. Alles, was eine Anweisung ist, zum Beispiel wie gesagt ein If, darf dann nicht rein. Hier dürfen nur Ausdrücke hin. Boolean ist zum Beispiel ein Ausdruck. Eine Zahl ist ein Ausdruck und so weiter und so fort. Deswegen kann ich das alles in diese geschweiften Klammern jetzt hier reinschreiben. Ausdruck, Ausdruck und so weiter. Es gibt eine kleine Abweichung von dieser Regel. Und zwar wenn ihr einen String habt, ihr mit diesen doppelten Anführungszeichen oder den einfachen Einführungszeichen hingeschrieben habt, dann könnt ihr streng genommen oder nicht nur streng genommen, dann könnt ihr die geschweiften Klammern in dem einzelnen Fall weglassen. Bei allen anderen Ausdrücken, also auch wenn ihr da jetzt eine Zahl hinschreiben wolltet oder ein Boolean hinschreiben wolltet, müsst ihr die geschweiften Klammern drumrum machen. Und meine Idee hier WebStorm, die macht die geschweiften Klammern automatisch immer drumrum, wenn ich Code Completion benutze. Und ich lasse die dann meistens auch drin, auch wenn sie an der Stelle nicht notwendig sind. Vorteil vom Drinlassen ist finde ich man muss sich nicht Gedanken machen Da habe ich jetzt einen String. Das heißt, ich kann sie weglassen oder habe ich keinen String. muss sie hinschreiben. Nachteil ist ein bisschen, finde ich, die Lesbarkeit wird nicht unbedingt dadurch erhöht. Und wir werden im weiteren Verlauf sehen, in React-Anwendung herrscht kein Mangel an geschweiften Klammern. Aber wie gesagt, das könnt ihr selber entscheiden. Ehrlich ich mache es manchmal so und manchmal so. Wenn die Idee mir das vorschlägt oder automatisch einfügt, dann lasse\n'slidetext': ''\n'from': 'index'\n'score': 61.12541198730469\n'normalizedScore': 0.6112541198730469\n'beforeDatePenaltyScore': 0.6112541198730469\n\n'documentId': '50c03dd02cf9b7c2ff4480f2'\n'chunk_id': '68b55eaf33a5bf00132cb693'\n'access': 'granted'\n'part_number': 18\n'total_parts': 47\n'contentType': 'TUTORIAL'\n'title': React-Grundlagen\n'parentName': Modern React: von Null auf Full-Stack\n'language': 'DE'\n'date': '2025-08-27T09:53:51.000Z'\n'abstract': In der ersten Lesson lernst du, was React ist und wie es funktioniert. Anhand einer Beispielanwendung schauen wir uns den Projektaufbau und den Workspace an. Du erfährst, wie Komponenten aufgebaut sind, wie man mit Props, Listen und State arbeitet und wie Interaktionen in React abgebildet werden.\n'parentId': 'b2c71c7c41dfe8eab4593f02'\n'parentDescription': In diesem Videotutorial lernst du React von Grund auf – bis hin zur Full-Stack-Entwicklung mit Next.js. Du baust Single Page Applications, verwaltest State, entwickelst moderne Formulare, arbeitest mit serverseitigen Daten und setzt Routing effizient um. Zum Abschluss bekommst du eine Einführung in React Server Components und Next.js. Benötigte Vorkenntnisse: JavaScript-Grundlagen, TypeScript ist hilfreich, aber nicht zwingend nötig. Nach dem Tutorial bist du bereit, eigene client- und serverseitige Anwendungen mit React umzusetzen.\n'indexBrandName': 'InternationalJavaScriptCon'\n'indexSeriesName': ''\n'author': 'Nils Hartmann'\n'chunkSource': 'text'\n'text': dass dieses Props-Objekt jetzt rot unterkringelt ist und das liegt daran, dass wir ja streng genommen hier TypeScript-Code hinschreiben. Wie erinnert euch? Punkt TSX ist die Dateiendung hier und in TypeScript muss sich die Funktionsargumente immer beschreiben. muss oder fast immer zumindestens, muss fast immer einen Typen dafür beschreiben. Und genau das fehlt hier noch. Und in React-Komponenten macht man das üblicherweise, indem man, wie gesagt, ein Objekt beschreibt, weil wir haben ja hier ein Objekt und das dann hier als diesen Typen dann hier als Props-Typ angeht. Das mache ich mal. Types, Image, Preview, Props. Der Name spielt keine Rolle, den ihr hier verwendet. Ich verfolge gerne das Pattern Image, Preview, also Komponentenname und dann Props hinten dran. Es gibt auch Leute, die nennen es nur Props, weil es kürzer ist. Könnt ihr machen, wie ihr möchtet. In dem Fall finde ich Image, Preview, Props ist sprechend. Manchmal zugegebenermaßen nervt es mich, weil die Typnamen dann sehr lang werden. Aber wie gesagt, das könnt ihr machen, wie ihr wollt. In unserem Fall erwarten wir ein Title, Property, das vom Typ String sein soll. Wir erwarten ein Source, Property, das vom Typ String sein soll, ebenfalls vom Typ String. Und wir erwarten ein Checked-Attribut und dieses Checked-Attribut, kann ausgelassen werden. Wenn jemand das nicht gecheckt haben will, dann kann man das weglassen. Aber wenn man es angibt, dann muss es ein Pullien sein. Deswegen schreibe ich hier Checked Fragezeichen hin. Optionales Property in diesem Objekt. Und wenn es gesetzt ist muss es ein Pullien sein. Und jetzt können wir hier hinterschreiben, Image, Preview, Props. Und dann können wir in unserer Komponente mit diesen Properties jetzt arbeiten. eine Sache, ich, also wir können erst mal die Properties ganz normal verwenden. Es gibt hier ein paar ganz einfache Fälle, zum Beispiel dieses Diff hier, wo der Titel dargestellt wird von dem Bild. Das können wir jetzt hier rausnehmen. Und stattdessen können wir Props.title hinschreiben. Das Gleiche gilt für das Alt-Attribut hier, Props.title. An dieser Stelle möchte ich euch noch auf eine Kleinigkeit\n'slidetext': ''\n'from': 'index'\n'score': 61.12541198730469\n'normalizedScore': 0.6112541198730469\n'beforeDatePenaltyScore': 0.6112541198730469\n\n'documentId': '1eed7659c187283042e70e2a'\n'chunk_id': '6876cd4b225e92fc1ac78ba0'\n'access': 'restricted'\n'part_number': 1\n'total_parts': 1\n'contentType': 'RHEINGOLD'\n'title': Das React-Ökosystem: ein Tag mit dem TanStack, React Router und vielem mehr\n'parentName': JavaScript Days München und online 2025\n'language': 'DE'\n'date': '2025-03-20T12:30:00.000Z'\n'abstract': Lerne das umfangreiche Ökosystem von React kennen. Es gibt kaum ein Problem, für das es keine Lösung in Form eines Pakets gibt. Dieser Workshop bietet dir die Möglichkeit, einen umfassenden Überblick über verschiedene React-Bibliotheken zu erhalten und praktische Erfahrungen im Einsatz dieser Tools zu sammeln. Der Fokus liegt auf spezialisierten Bibliotheken wie dem TanStack, React Router und react-hook-form, um typische Herausforderungen in der Entwicklung von React-Applikationen zu meistern, wie Serverkommunikation, Navigation und Formularhandling. Im Workshop wird vor allem hands-on gearbeitet. Du lernst durch praktische Übungen und das Schreiben von Code, den du direkt in deinen realen Anwendungen verwenden kannst. Der Workshop vermittelt Techniken für das Formularhandling mit react-hook-form, zeigt, wie Daten mit TanStack Query effektiv geladen werden, und erklärt die Implementierung komplexer Navigationsstrukturen mit React Router und dem TanStack Router. Nach dem Workshop hast du ein tiefes Verständnis für den Einsatz dieser Bibliotheken und kannst sie effektiv in deinen Projekten nutzen. Zusätzlich erhältst du Zugang zu einem GitHub-Repository mit allen Beispielen und Lösungen der Übungen, um das Gelernte nachhaltig zu festigen.\n'parentId': 'efd4ff41c4b9e889b50854b8'\n'parentDescription': 40 Workshops zu JavaScript, Angular, React, HTML & CSS und KI\n'indexBrandName': 'JavaScriptDays'\n'indexSeriesName': 'Munich'\n'author': 'Sebastian Springer'\n'chunkSource': 'text'\n'text': Das React-Ökosystem: ein Tag mit dem TanStack, React Router und vielem mehr Lerne das umfangreiche Ökosystem von React kennen. Es gibt kaum ein Problem, für das es keine Lösung in Form eines Pakets gibt. Dieser Workshop bietet dir die Möglichkeit, einen umfassenden Überblick über verschiedene React-Bibliotheken zu erhalten und praktische Erfahrungen im Einsatz dieser Tools zu sammeln. Der Fokus liegt auf spezialisierten Bibliotheken wie dem TanStack, React Router und react-hook-form, um typische Herausforderungen in der Entwicklung von React-Applikationen zu meistern, wie Serverkommunikation, Navigation und Formularhandling. Im Workshop wird vor allem hands-on gearbeitet. Du lernst durch praktische Übungen und das Schreiben von Code, den du direkt in deinen realen Anwendungen verwenden kannst. Der Workshop vermittelt Techniken für das Formularhandling mit react-hook-form, zeigt, wie Daten mit TanStack Query effektiv geladen werden, und erklärt die Implementierung komplexer Navigationsstrukturen mit React Router und dem TanStack Router. Nach dem Workshop hast du ein tiefes Verständnis für den Einsatz dieser Bibliotheken und kannst sie effektiv in deinen Projekten nutzen. Zusätzlich erhältst du Zugang zu einem GitHub-Repository mit allen Beispielen und Lösungen der Übungen, um das Gelernte nachhaltig zu festigen.\n'slidetext': ''\n'from': 'index'\n'score': 60.96226501464844\n'normalizedScore': 0.6096226501464844\n'beforeDatePenaltyScore': 0.6096226501464844\n\n'documentId': 'f8465c38d514d23af45f3eb0'\n'chunk_id': '690373b99669850016afad85'\n'access': 'restricted'\n'part_number': 12\n'total_parts': 16\n'contentType': 'RHEINGOLD'\n'title': The real cost of React re-renders in 2025\n'parentName': Frontmania 2025\n'language': 'EN'\n'date': '2025-10-08T12:30:00.000Z'\n'abstract': Modern React makes it deceptively easy to write code that looks performant, but hides costly re-renders, hydration mismatches, and subtle CPU bottlenecks. As applications scale and ship to users on slower devices or flaky networks, these problems compound into real-world slowdowns. In this talk, I'll dive deep into profiling React applications in 2025, leveraging the latest React DevTools, flamegraphs, and field metrics to uncover unexpected re-render patterns. I'll compare how React 18 cooperative scheduling and batching stacks up against React 19 new compiler-backed partial signals and smarter diffing, showing side-by-side examples of how seemingly harmless hooks can differ dramatically in cost. Also will touch React Forget and what it will bring. Aside code examples it should also form a structure for a team how to properly test the performance of applications.\n'parentId': '501ad2dcdca77f2683bdde34'\n'parentDescription': \n'indexBrandName': ''\n'indexSeriesName': ''\n'author': 'Emīls Pļavenieks'\n'chunkSource': 'text'\n'text': not a component. We return everything within this component. But if we, like we, as I said, we had this react counter, re-render counter for the whole component component and we had it for the title. And if we re-enable the highlighting for it. Like, we will go back to it just in a second, but this allows, this is what the smarter din means that it automatically tries to separate, separate out what, what is returned. And what it will separate in the compiler as like a magic component, let's say, that is not actually in our code. And as usually in all the presentations, everything works on the simple examples, and this was also true for the past Ract compiler, like talks, presentations, articles, everything, like all the simplest cases worked fine, but then like in real world applications we we have much more complex. Components, it started to not do the job properly, but Then like It came to the state where it kind of forced us to intervene within, like with the what's actually happening in the compiler, in a way that we had to work together with the compiler. For example, if we enabled it and it saved us a bunch of re-renders, but some part kept re-rendering, it was a good indicator that there's something wrong there, and we were not following the rules of react. And for the compiler to actually work, we are strictly need to remember the rules of react. You can read up on them on the React documentation. So, the state of the RAC compiler today is that it's bundled in, in the version 19. Uh, but yeah, like version 19, I'm not sure how many of you use version 19 in production, at least from all the people I have talked to, it's not much. A lot of are still on version 1718, or there are a few enterprises even still on version 16 because it just works for them, and the migrating upwards is uh far less of, A thing for them But we can install like. Additional dependencies for the version 17 and 18. And uh there's a small like written article in the React documentation as well, how to actually do it, and it also brings us the ESL2 link for that. So let's quickly do that. For example, here. Uh, it was here, so React compiler, this is the article they have, and in order to install it, it also provides what additional library you need to install. With the latest release, uh, that happened one week ago, 19.2, they simplified the installing and adding this to your existing projects if you're not using\n'slidetext': ''\n'from': 'index'\n'score': 60.056663513183594\n'normalizedScore': 0.600566635131836\n'beforeDatePenaltyScore': 0.600566635131836\n\n'documentId': '50c03dd02cf9b7c2ff4480f2'\n'chunk_id': '68b55eb533a5bf00132cb69f'\n'access': 'granted'\n'part_number': 30\n'total_parts': 47\n'contentType': 'TUTORIAL'\n'title': React-Grundlagen\n'parentName': Modern React: von Null auf Full-Stack\n'language': 'DE'\n'date': '2025-08-27T09:53:51.000Z'\n'abstract': In der ersten Lesson lernst du, was React ist und wie es funktioniert. Anhand einer Beispielanwendung schauen wir uns den Projektaufbau und den Workspace an. Du erfährst, wie Komponenten aufgebaut sind, wie man mit Props, Listen und State arbeitet und wie Interaktionen in React abgebildet werden.\n'parentId': 'b2c71c7c41dfe8eab4593f02'\n'parentDescription': In diesem Videotutorial lernst du React von Grund auf – bis hin zur Full-Stack-Entwicklung mit Next.js. Du baust Single Page Applications, verwaltest State, entwickelst moderne Formulare, arbeitest mit serverseitigen Daten und setzt Routing effizient um. Zum Abschluss bekommst du eine Einführung in React Server Components und Next.js. Benötigte Vorkenntnisse: JavaScript-Grundlagen, TypeScript ist hilfreich, aber nicht zwingend nötig. Nach dem Tutorial bist du bereit, eigene client- und serverseitige Anwendungen mit React umzusetzen.\n'indexBrandName': 'InternationalJavaScriptCon'\n'indexSeriesName': ''\n'author': 'Nils Hartmann'\n'chunkSource': 'text'\n'text': besteht und in dem Fall gleich noch aus einer ID auch, dass das ein Objekt ist, was möglicherweise von unserer Restschnittstelle kommt. Das kann natürlich auch anders heißen. Man muss das nicht DTO nennen. Darauf kommt es mir jetzt nicht an. Wo ich von ausgehe, ist, dass das A von unserem Server kommt und vor allen Dingen B, dass das ein Objekt ist, was wir in unserer ganzen Anwendung wieder und wieder verwenden werden. Die Properties, die wir jetzt bislang definiert haben, sind ja auch Objekte letzten Endes, die wir auch mit TypeScript beschrieben haben, aber die verwenden wir immer nur konkret für eine Komponente. In dem Fall Image DTO gehe ich jetzt einfach mal davon aus, dass wir diesen Typen oder diese Informationen, wie so ein Imageobjekt aussieht, das werden wir noch in ganz vielen Teilen in unserer Anwendung sehen. Das werden wir jetzt nicht nur hier in dieser Deswegen erzeuge ich dafür eine Datei, die types.ts heißt und darin werde ich die globalen Typen die globalen TypeScript Typen unserer Anwendung definieren. In unserem Fall ist die Anwendung sehr klein, deswegen schreibe ich eine types.ts Datei hin. Wenn ihr eine größere Anwendung mit mehreren Use Cases, mit mehreren Features habt, dann ist natürlich auch denkbar, dass man mehrere Types.ts Dateien anliegt, wo dann jeweils die fachlichen Typen dazu drin sind oder dass man mehrere Verzeichnisse macht und dann jeweils da drin eine Types.ts Datei hat. Also wie ihr mögt, ihr könnt eine nehmen, könnt es aufteilen, spielt keine Rolle. Ich mache jetzt nur eine, weil auch das kann ich schon mal spoilern, viel mehr als einen Typen werden wir in unserer Anwendung nicht brauchen. Aber wie gesagt, dieser Typ ist ein globaler Typ, ein fachlicher Typ, hat mit Properties nichts zu tun. Wir verwenden ihn für die Properties, aber wir werden ihn noch anderen Anwendungsfällen sehen. Unser Typ soll ImageDTU heißen und weil wir den in der ganzen Anwendung verwenden, müssen wir auch den exportieren. könnt TypeScript-Typen genauso exportieren, ihr JavaScript-Funktionen JavaScript-Variablen und so weiter exportieren könnt. eine kleine Sache sei mir noch gestattet zu\n'slidetext': ''\n'from': 'index'\n'score': 59.5158576965332\n'normalizedScore': 0.595158576965332\n'beforeDatePenaltyScore': 0.595158576965332\n\n'documentId': '50c03dd02cf9b7c2ff4480f2'\n'chunk_id': '68b55eaf33a5bf00132cb695'\n'access': 'granted'\n'part_number': 20\n'total_parts': 47\n'contentType': 'TUTORIAL'\n'title': React-Grundlagen\n'parentName': Modern React: von Null auf Full-Stack\n'language': 'DE'\n'date': '2025-08-27T09:53:51.000Z'\n'abstract': In der ersten Lesson lernst du, was React ist und wie es funktioniert. Anhand einer Beispielanwendung schauen wir uns den Projektaufbau und den Workspace an. Du erfährst, wie Komponenten aufgebaut sind, wie man mit Props, Listen und State arbeitet und wie Interaktionen in React abgebildet werden.\n'parentId': 'b2c71c7c41dfe8eab4593f02'\n'parentDescription': In diesem Videotutorial lernst du React von Grund auf – bis hin zur Full-Stack-Entwicklung mit Next.js. Du baust Single Page Applications, verwaltest State, entwickelst moderne Formulare, arbeitest mit serverseitigen Daten und setzt Routing effizient um. Zum Abschluss bekommst du eine Einführung in React Server Components und Next.js. Benötigte Vorkenntnisse: JavaScript-Grundlagen, TypeScript ist hilfreich, aber nicht zwingend nötig. Nach dem Tutorial bist du bereit, eigene client- und serverseitige Anwendungen mit React umzusetzen.\n'indexBrandName': 'InternationalJavaScriptCon'\n'indexSeriesName': ''\n'author': 'Nils Hartmann'\n'chunkSource': 'text'\n'text': lasse ich es meistens drin. Wenn ich selber hinschreibe und keinen Vorschlag bekomme, dann schreibe ich die geschweifte Klammer nicht unbedingt immerhin. Zurück zu unseren Properties hier. Wir haben jetzt die Properties hier eingesetzt. Wir haben sie hier eingesetzt. hier brauchen wir sie natürlich auch noch für das Bild. Das war das props.sauce. Und jetzt gibt es ja noch dieses Selected-Property. Und das Selected-Property möchte ich benutzen für zwei Dinge. Zum einen möchte ich den Klassennamen hier anpassen. Denn wenn dieses Image Selected ist, dann möchte ich, dass da eine zweite CSS-Klasse herankommt, die dann eben ausdrückt. Das Bild ist selektiert und sich dann eben grafisch ein bisschen anders darstellt. Das Zweite ist wenn die Komponente nicht selektiert ist, dann möchte ich natürlich auch diesen Checkbox nicht ändern. So, und den fangen wir mal mit dem ersten Fall an. Ich nehme den einfach mal und füge hier eine einfache Variable hinzu. Du Klassenamen oder du kannst ja mal Diff-Klasse-Namen nennen oder wie auch immer. Und dann fragen wir wenn du gecheckt bist, dann nehmen wir hier noch die CSS-Klasse Check dazu. Und ansonsten nehmen wir nur Preview. Dieses Ding hier, beziehungsweise genauer gesagt dieses auf der rechten Seite mit diesem Ternären Operator ist auch wieder ein JavaScript-Ausdruck. Das heißt, den darf ich auch direkt hier an diese Stelle hinschreiben. Das mache ich mal. Ich lasse mal beides drin hier dann können wir das mal gleich vergleichen. Das hier ist jetzt genau der gleiche Code wie dieses hier. Ob man jetzt das eine macht, sprich erst eine Variable deklarieren und dann die Variable hier unten einsetzen oder den Ternären Operator direkt hinschreiben. Das ist Geschmackssache. Es gibt eigentlich fast keinen objektiven Grund, warum man das eine oder das andere machen sollte. Ich würde da immer die Lesbarkeit in den Vordergrund stellen. Manchmal ist es einfacher, wenn man das direkt hier hinschreibt, weil wenn ich mir das Template in Anführungsstrichen hier unten angucke, dann brauche ich nicht irgendwo anders hinzuspringen, um zu verstehen, was eigentlich hier die Class Name Variable sein soll. Der\n'slidetext': ''\n'from': 'index'\n'score': 59.5158576965332\n'normalizedScore': 0.595158576965332\n'beforeDatePenaltyScore': 0.595158576965332\n\n'documentId': '50c03dd02cf9b7c2ff4480f2'\n'chunk_id': '68b55eab33a5bf00132cb688'\n'access': 'granted'\n'part_number': 7\n'total_parts': 47\n'contentType': 'TUTORIAL'\n'title': React-Grundlagen\n'parentName': Modern React: von Null auf Full-Stack\n'language': 'DE'\n'date': '2025-08-27T09:53:51.000Z'\n'abstract': In der ersten Lesson lernst du, was React ist und wie es funktioniert. Anhand einer Beispielanwendung schauen wir uns den Projektaufbau und den Workspace an. Du erfährst, wie Komponenten aufgebaut sind, wie man mit Props, Listen und State arbeitet und wie Interaktionen in React abgebildet werden.\n'parentId': 'b2c71c7c41dfe8eab4593f02'\n'parentDescription': In diesem Videotutorial lernst du React von Grund auf – bis hin zur Full-Stack-Entwicklung mit Next.js. Du baust Single Page Applications, verwaltest State, entwickelst moderne Formulare, arbeitest mit serverseitigen Daten und setzt Routing effizient um. Zum Abschluss bekommst du eine Einführung in React Server Components und Next.js. Benötigte Vorkenntnisse: JavaScript-Grundlagen, TypeScript ist hilfreich, aber nicht zwingend nötig. Nach dem Tutorial bist du bereit, eigene client- und serverseitige Anwendungen mit React umzusetzen.\n'indexBrandName': 'InternationalJavaScriptCon'\n'indexSeriesName': ''\n'author': 'Nils Hartmann'\n'chunkSource': 'text'\n'text': serverseitigen Daten umgehen? Denn diese ganzen Daten, die wir hier sehen, die sind ja alle irgendwo auf dem Server abgelegt. Wir wollen uns angucken, wie kann ich Formulare bauen? Und schlussendlich wollen wir uns angucken, wie kann ich eigentlich mit verschiedenen Routen in meiner Anwendung umgehen? Also sprich, mit verschiedenen Seiten, wenn man so will. Obwohl wir eine Single-Page-Anwendung bauen, wir ja sowas wie mehrere Seiten in dieser Anwendung. Wir haben hier zum Beispiel diese Dashboard-Seite. Wir haben diese Einstiegsseite. Und letzten Endes haben wir ja auch diese Seite zum Anlegen oder Bearbeiten von Rezepten. Also wir haben durchaus mehrere Seiten. Obwohl wir technisch eine Single-Page-Anwendung bauen, haben wir fachlich eine Multi-Page-Anwendung, wenn man so möchte. Bevor wir jetzt gleich in den Code einsteigen, möchte ich euch eine Sache noch zeigen. Und zwar, ist sozusagen die Architektur wenn man so will, von dieser Anwendung auf einer sehr sehr hohen Ebene. Und zwar sieht das bei mir wie folgt aus, damit wir wissen, wovon wir sprechen. Wir haben sozusagen ein Recipe-File-Backend. Wollen wir die Schrift hier ein klein bisschen größer machen und das vorhin nach oben schieben. Und dieses Recipe-File-Backend das stellt uns eine Rest-API zur Verfügung, mit der ich Rezepte lesen und schreiben kann. Rezepte lesen und schreiben. Und ich kann mich damit auch einloggen. Wobei, das werden wir erst im zweiten Schritt machen. Trotz allem kann ich das damit machen. Und man kann da auch Bewertungen abgeben. Und die Idee von diesem Backend ist, das ist fertig. Das gucken wir uns gar nicht an. Wen es technisch interessiert ist eine Spring-Boot-Anwendung. Für uns ist aber eigentlich relevant, dass es hier eine Rest-API gibt, die wir in unserer Anwendung konsumieren. Wir tun mal für dieses Tutorial so, als ob wir eine bestehende Rest-API haben. Vielleicht haben wir irgendeinen Dienst im Internet, den wir anschließen wollen. Und diese API konsumieren wir Die ist schon fertig gemacht für uns. Da beschäftigen wir uns weiter dann nicht mit, außer dass wir sie eben benutzen. So und jetzt haben\n'slidetext': ''\n'from': 'index'\n'score': 59.5158576965332\n'normalizedScore': 0.595158576965332\n'beforeDatePenaltyScore': 0.595158576965332\n\n'documentId': '50c03dd02cf9b7c2ff4480f2'\n'chunk_id': '68b55eab33a5bf00132cb685'\n'access': 'granted'\n'part_number': 4\n'total_parts': 47\n'contentType': 'TUTORIAL'\n'title': React-Grundlagen\n'parentName': Modern React: von Null auf Full-Stack\n'language': 'DE'\n'date': '2025-08-27T09:53:51.000Z'\n'abstract': In der ersten Lesson lernst du, was React ist und wie es funktioniert. Anhand einer Beispielanwendung schauen wir uns den Projektaufbau und den Workspace an. Du erfährst, wie Komponenten aufgebaut sind, wie man mit Props, Listen und State arbeitet und wie Interaktionen in React abgebildet werden.\n'parentId': 'b2c71c7c41dfe8eab4593f02'\n'parentDescription': In diesem Videotutorial lernst du React von Grund auf – bis hin zur Full-Stack-Entwicklung mit Next.js. Du baust Single Page Applications, verwaltest State, entwickelst moderne Formulare, arbeitest mit serverseitigen Daten und setzt Routing effizient um. Zum Abschluss bekommst du eine Einführung in React Server Components und Next.js. Benötigte Vorkenntnisse: JavaScript-Grundlagen, TypeScript ist hilfreich, aber nicht zwingend nötig. Nach dem Tutorial bist du bereit, eigene client- und serverseitige Anwendungen mit React umzusetzen.\n'indexBrandName': 'InternationalJavaScriptCon'\n'indexSeriesName': ''\n'author': 'Nils Hartmann'\n'chunkSource': 'text'\n'text': hier umrechnen, für wie viele Portionen ich ein Rezept kochen möchte. Also ein bisschen Interaktion haben wir auch dabei. Wir haben Bewertungen zu den Kochrezepten. Wir können eigene Bewertungen abgeben, wenn wir das möchten. Also im Prinzip alles Funktionalitäten, die man zum Beispiel auch von E-Commerce Webseiten kennt oder von Nachrichtenseiten. Also von ich sag mal, mehr oder weniger statischen Seiten, die sehr contentgetrieben sind und von denen wir möchten, dass sie natürlich sehr einfach zugänglich und sehr schnell zugänglich sind für unsere Benutzerinnen und Benutzer. Auf dieser Liste mit den Kochrezepten haben wir auch die typischen sage ich mal, typischen Bedienmuster. Wir können die Listen nach verschiedenen Dingen sortieren und wir können uns hier durch die einzelnen Seiten klicken, so wie man das auch von anderen Anwendungen kennt. Also ich denke mal, selbst wenn deine Domäne jetzt nicht unbedingt Kochrezepte sind, sondern du andere Arten von Anwendungen baust, kennst du wahrscheinlich das Problem, dass du Daten hast, die möchtest du sehr effizient und sehr schnell deinen Benutzerinnen und Benutzer zur Verfügung stellen. Und das ist eben sozusagen die Aufgabe von diesem Frontend. Das ist eine Customer Facing Web Anwendung, wenn man so will. Also wo die Endkundinnen und Kunden draufgehen. Der andere Teil unserer Anwendung. Und wie gesagt, da fangen wir dann auch in der Implementierung an. Das ist das sogenannte Administrationstool dazu. Da sind die Anforderungen vielleicht ein bisschen anders. Dieses Administrationstool, davon ist die Idee, dass ich das benutzen kann, um die Daten in diesem System zu pflegen. Also sprich neue Kochrezepte einzutragen, vielleicht andere zu bearbeiten, Kommentare freizuschalten und so was. Diese Anwendung ist ein bisschen einfacher oder hat weniger Features Ich muss mich hier natürlich anmelden, weil ich jetzt die Daten von diesem System verändere. Das können wir einmal ganz kurz hier machen. jetzt seht ihr schon, ich habe hier nicht ganz so schöne Oberfläche vielleicht. Die ist ein bisschen funktionaler. Wir haben jetzt hier ein sogenanntes Dashboard. Da sehen wir den aktuellen Datenbestand oder Ausschnitte aus diesem Datenbestand. Wir haben\n'slidetext': ''\n'from': 'index'\n'score': 59.5158576965332\n'normalizedScore': 0.595158576965332\n'beforeDatePenaltyScore': 0.595158576965332\n\n\nTop Vectors:\n'documentId': 'f8465c38d514d23af45f3eb0'\n'chunk_id': '690373b89669850016afad7d'\n'access': 'restricted'\n'part_number': 4\n'total_parts': 16\n'contentType': 'RHEINGOLD'\n'title': The real cost of React re-renders in 2025\n'parentName': Frontmania 2025\n'language': 'EN'\n'date': '2025-10-08T12:30:00.000Z'\n'abstract': Modern React makes it deceptively easy to write code that looks performant, but hides costly re-renders, hydration mismatches, and subtle CPU bottlenecks. As applications scale and ship to users on slower devices or flaky networks, these problems compound into real-world slowdowns. In this talk, I'll dive deep into profiling React applications in 2025, leveraging the latest React DevTools, flamegraphs, and field metrics to uncover unexpected re-render patterns. I'll compare how React 18 cooperative scheduling and batching stacks up against React 19 new compiler-backed partial signals and smarter diffing, showing side-by-side examples of how seemingly harmless hooks can differ dramatically in cost. Also will touch React Forget and what it will bring. Aside code examples it should also form a structure for a team how to properly test the performance of applications.\n'parentId': '501ad2dcdca77f2683bdde34'\n'parentDescription': \n'indexBrandName': ''\n'indexSeriesName': ''\n'author': 'Emīls Pļavenieks'\n'chunkSource': 'text'\n'text': you have seen where we get into this situation where like we received something from the parent component, we have props or some other hook, then we use this data within some use memo, and then within, from this use memo we use something within the use callback and then we pass it down, but it's actually not, it's not used further down. And we get these always still like these always changing dependencies. Or let's say if we wrapped everything, everything in the memorization utilities, it still re-renders because of those 1st 4, rules of why the components re-renders. So if we are doing all of this, it basically leads to a premature optimization where we try to optimize things that we don't necessarily need to at the time, and this can quickly backfire because, as I said, it basically adds additional overhead and we can get some side effects from it. And another thing is that if there are server side rendering, we really need, need to make sure that whatever we render there. Matches whatever UI would render for the first phase. Because if, if it doesn't, then these hydration mismatches actually are very costly. And also in pure components. Impure components are like necessarily to follow, like to follow the rules of react basically. If we are following them, we should be good. If we're not, we are slowly getting into some issues that could arise from that, and it's starting to cost us more. So let's step a bit back. What's actually happening in these re-render phases? Like whenever we trigger or react based on those four things triggers the component to re-render, there are two phases happening. The first is the render phase, and the second is the cometit phase. The render phase is basically a recursive process that starts from one node that wanted to re-render for any of the four reasons, and if it returns another component, it will try to render that component. And if that component renders something else, it will just gradually move towards down until it reaches a point when there's no components returned. And then the reactor will be able to build all of this tree inside the virtual dome. So on the first render, what happens, we have nothing, right? So it starts from the top, from the root, and then it goes down and it starts to create like all of this tree within the virtual dome. For the following rear renders, it basically tries to find the smallest changes it needed to make in order to. Like showcase what, what we want to do with these components, but all of this information is currently stored\n'slidetext': ''\n'from': 'vector'\n'score': 0.9233784079551697\n'normalizedScore': 0.9215640190440839\n'beforeDatePenaltyScore': 0.9233784079551697\n\n'documentId': 'f8465c38d514d23af45f3eb0'\n'chunk_id': '690373b89669850016afad7c'\n'access': 'restricted'\n'part_number': 3\n'total_parts': 16\n'contentType': 'RHEINGOLD'\n'title': The real cost of React re-renders in 2025\n'parentName': Frontmania 2025\n'language': 'EN'\n'date': '2025-10-08T12:30:00.000Z'\n'abstract': Modern React makes it deceptively easy to write code that looks performant, but hides costly re-renders, hydration mismatches, and subtle CPU bottlenecks. As applications scale and ship to users on slower devices or flaky networks, these problems compound into real-world slowdowns. In this talk, I'll dive deep into profiling React applications in 2025, leveraging the latest React DevTools, flamegraphs, and field metrics to uncover unexpected re-render patterns. I'll compare how React 18 cooperative scheduling and batching stacks up against React 19 new compiler-backed partial signals and smarter diffing, showing side-by-side examples of how seemingly harmless hooks can differ dramatically in cost. Also will touch React Forget and what it will bring. Aside code examples it should also form a structure for a team how to properly test the performance of applications.\n'parentId': '501ad2dcdca77f2683bdde34'\n'parentDescription': \n'indexBrandName': ''\n'indexSeriesName': ''\n'author': 'Emīls Pļavenieks'\n'chunkSource': 'text'\n'text': after. So, the first thing is that react component will render if the state changes. This is easy to understand. If we use the US state in some component on any interaction or any other side effect, we change it, the component will re-render. The second thing is when a parent component re-renders, it will trigger, like propagate the re-renders down to the children and descendants of them. Gradually down until we hit some blocker that can stop that. Whoops. Third reason I was clicking with the reasons. Yeah. So 3rd reason is if the context changes. So if we have instantiated the context in our application and use the provider and we have some components using this context, whenever we change it, it will also trigger a render for this component. And the fourth option is hook, hooks. So for the hooks. Like in the hooks, we can do some complex calculations, some slow loading. Also calculations, variables, some data fetching, and whenever we update the states of these hooks, the components that use these hooks will also re-render. And can you raise your hands if you were thinking about something more? OK, there are a few, uh, and this brings us to one of the most common myths I think in the world of React, is that components will be rendered if the props changed, right? Uh, but it's not necessarily true because change in the props doesn't trigger anything. And for these props to be changed, the parent component needs to be re-rendered, so it has some side effects within it that passes the props down, but natively, the propagation of the children causes the children to render. And that leads to the first illusion, the misuse of memorization. As we know, React provides us with the utility hooks like use memo and use callback. To save references or save on complex calculations. There's also a react. memo where we can wrap the whole component within, and this is the place where this myth about the properties could come up because the react memo does a shallow comparison of all the props the component receives in order to decide to propagate further down or no. However, if we use this, like if we wrap everything within the memorization hooks or the dot memo, it doesn't always solve all of our issues. It could actually sometimes like give an overhead for the application to just do the same thing it was doing before, but now it does more calculations because it compares the memoized references and everything. And also like within these hooks, like use memo and use callback, we have the dependency arrays, right? And I'm sure a lot of you\n'slidetext': ''\n'from': 'vector'\n'score': 0.9202862977981567\n'normalizedScore': 0.918471908887071\n'beforeDatePenaltyScore': 0.9202862977981567\n\n'documentId': '98f008c2694c3d36e48d5bcf'\n'chunk_id': '69118b0a0f4b7700138ebd96'\n'access': 'granted'\n'part_number': 4\n'total_parts': 7\n'contentType': 'READ'\n'title': React 19.2 Explained: Updates, Impact, and What to Watch For - A practical walkthrough of React’s latest improvements and fresh performance insights\n'parentName': iJS Magazine Volume 22\n'language': 'EN'\n'date': '2025-12-16T23:00:00.000Z'\n'abstract': React 19.2 brings targeted improvements to performance, rendering, and overall developer experience. Key highlights include updates to the core library and optimizations in React DOM for faster, more efficient UI rendering. Let’s take a closer look at what’s new.\n'parentId': 'b6ef74991ae60010a55b93d4'\n'parentDescription': Broaden your knowledge and expand your JavaScript techniques and practices. From Angular, React, and WebAssembly, to the best JavaScript IDEs, open source tools and more, you’ll learn insights on everything JS from seasoned experts in their field. Keep up with JavaScript news, tips, and advice with interviews, tutorials, and in-depth articles.\n'indexBrandName': ''\n'indexSeriesName': ''\n'author': 'Faris Aziz'\n'chunkSource': 'text'\n'text': rule, which may leave you in the dark as the dependencies continue to grow and evolve. Take this great example from the React Docs: you’re building a chat app, and when a user joins a new room, you want to show a notification once the connection is ready: function ChatRoom({ roomId, theme }) { useEffect(() => { const connection = createConnection(serverUrl, roomId); connection.on('connected', () => { showNotification('Connected!', theme); }); connection.connect(); return () => connection.disconnect(); }, [roomId, theme]); } This looks fine, but there’s a subtle issue. If the user switches between light and dark themes while the chat is connected, the entire effect re-runs, disconnecting and reconnecting the socket, just to show the notification with the right color. It’s probably not what you were going for. The connection should only reset when roomId changes, not because of theming. What most would do in this case is remove the theme from the dependency array. However, that results in a linter warning, and you ultimately will have to disable it with a comment. This is where useEffectEvent shines. It lets you separate the “event reaction” logic from the “effect setup” logic, so React can handle updates to values like theme without forcing a teardown and reconnect. Here’s the same example rewritten: function ChatRoom({ roomId, theme }) { const onConnected = useEffectEvent(() => { showNotification('Connected!', theme); }); useEffect(() => { const connection = createConnection(serverUrl, roomId); connection.on('connected', () => onConnected()); connection.connect(); return () => connection.disconnect(); }, [roomId]); // ✅ Effect runs only when roomId changes } The key difference is that the onConnected callback always “sees” the latest theme, but the effect itself remains stable because the event handler’s identity never changes. React treats useEffectEvent callbacks as stable by design, meaning they don’t need to appear in dependency arrays. This pattern is incredibly useful in real apps. Think about analytics events, WebSocket subscriptions, or integrations with browser APIs. You often need to respond to events (connection open, visibility change, playback start, etc.) without tearing down your entire effect tree every time an unrelated prop changes. So if you’ve been in the habit of sprinkling eslint-disable-next-line react-hooks/exhaustive-deps above every useEffect that listens to external events, this new addition to React’s collection of hooks finally makes that unnecessary. Just make sure to upgrade your eslint-plugin-react-hooks to latest. Improving cache management with cacheSignal in React Server Components The cache() function, used exclusively with React Server Components (RSCs), allows you to memoize the results of data fetching or expensive computations across requests. Starting with React 19.2, the core\n'slidetext': ''\n'from': 'vector'\n'score': 0.9119709134101868\n'normalizedScore': 0.9139613190196489\n'beforeDatePenaltyScore': 0.9119709134101868\n\n'documentId': 'dce2e7fce63ba63cdf7ee57a'\n'chunk_id': '6876df247899910dd58c0eb4'\n'access': 'granted'\n'part_number': 17\n'total_parts': 22\n'contentType': 'COURSE'\n'title': Mastering React: 5 Antipatterns and How to Fix Them\n'parentName': Mastering React: Best Practices for Optimized Performance\n'language': 'EN'\n'date': '2025-02-25T14:36:13.000Z'\n'abstract': This presentation unveils five critical antipatterns that have significantly slowed down our React application. Each section delves into a specific mistake, examining the challenges it created and the solutions implemented to address these issues. By analyzing real-world examples, this session offers invaluable insights and practical strategies for avoiding similar pitfalls in your development projects. Join us to gain the expertise needed to enhance performance and efficiency, driving your applications to new heights.\n'parentId': '159bcfd9af1467befd4bbe7b'\n'parentDescription': According to the 2024 JavaScript survey, React remains the top frontend framework, solidifying its dominance in web development. Unlock the full potential of React.js with this course designed for developers looking to optimize, scale, and modernize their React applications. From avoiding common antipatterns to implementing server components, you will gain hands-on experience with the latest React innovations and dive deep into real-world projects.\n'indexBrandName': 'InternationalJavaScriptCon'\n'indexSeriesName': ''\n'author': 'Jonas Herrmannsdörfer'\n'chunkSource': 'text'\n'text': has another hook which is called use memo. And that is actually or should be used for expensive calculations. What is use memo doing? Use memo first and the first render just runs the um, the code inside of the use memo function and just returns these to-dos and then it memorizes these values and whenever the to-dos or filter change in the future it rerun that code and memorize it again. But if they don't change and you have a rerender, well then it just used to memorize value and doesn't have to rerun that get filter to-DOS function. So in this case, whenever the to-dos or filter change it reruns it, otherwise it just used to memorize value and you don't have any problems of this expensive calculation. But what is important first is well when is the calculation really expensive? Do we even need to use use memo? And most of the time in the front end the calculations are not that expensive. So we are just doing some sim simple things, transforming a little bit of data while maybe filtering something out and it runs on every normal smartphone that is not high-end device without any problems. So most of the time you don't have to do any optimization unless you're looping over thousands of objects and doing wild transformations. But then maybe you should think about doing that in the backend and not in the front end maybe, but that's something you have to discuss in, in your special use case. But to summarize that, you should only do an optimization if you notice performance problems. You don't should, you shouldn't do any optimizations beforehand because your code just gets more complicated in the end and no one else will understand it and it doesn't have any benefits because well no one will notice it anyway. And when you notice some performance problems, but you should do this, you should measure what functions are really taking that that long or are slow in the end. Because what I noticed most of the time when my application had performance problems, mostly the problem was in the communication with the backend. 'cause I was asking for too much data and because of that it took very long to load but not because I just run a simple filter function or something like that. But yeah, a little bit of advertisement there as well. There's one talk for me on YouTube about antipas and GraphQL and react. It's about things like that, about over fetching and under fetching. Maybe some of you are using craft QL and I will talk a little about a bit about problems and how you can do optimizations there. Um, yeah to recap\n'slidetext': ''\n'from': 'vector'\n'score': 0.9258149862289429\n'normalizedScore': 0.9116766329602976\n'beforeDatePenaltyScore': 0.9258149862289429\n\n'documentId': '1afc9b7c648711b8f9bea5bc'\n'chunk_id': '6876cd0a225e92fc1ac78a44'\n'access': 'granted'\n'part_number': 5\n'total_parts': 15\n'contentType': 'COURSE'\n'title': Scaling and Optimizing React Applications: Advanced Techniques for Large-Scale Projects\n'parentName': Mastering React: Best Practices for Optimized Performance\n'language': 'EN'\n'date': '2025-02-25T14:36:13.000Z'\n'abstract': In this session, we'll explore critical strategies for scaling and optimizing React applications to ensure top performance as your projects grow. Learn how to structure large applications for long-term scalability, manage complex state efficiently, and handle large data sets without sacrificing speed. We’ll cover advanced techniques like code splitting, lazy loading, and component rendering optimizations, as well as methods to streamline build times in CI/CD pipelines. Whether you’re scaling a fast-growing app or managing a large enterprise project, this session provides actionable insights to future-proof your React applications for continued success.\n'parentId': '159bcfd9af1467befd4bbe7b'\n'parentDescription': According to the 2024 JavaScript survey, React remains the top frontend framework, solidifying its dominance in web development. Unlock the full potential of React.js with this course designed for developers looking to optimize, scale, and modernize their React applications. From avoiding common antipatterns to implementing server components, you will gain hands-on experience with the latest React innovations and dive deep into real-world projects.\n'indexBrandName': 'InternationalJavaScriptCon'\n'indexSeriesName': ''\n'author': 'Ahmed Megahd'\n'chunkSource': 'text'\n'text': you need. Same for the lazy, uh, lazy loading. If you don't need this now, you could, uh, load it later. Especially for example, if you, if you have a form and you have some imports, but you will use this import when you submit the form, so you don't need to, to import it from the beginning. Same way we could talk about React memo and use memo as well and use Quebec about, uh, preventing unnecessary update to the component. So here we have a user card and we have burned component that, uh, have props as a users take pro parameter as users and user card. We're using it as a child component. And inside it we use the user data. What's happened here that we, if the parent component was updated, this means the user card will be also updated. Uh, but what if we don't, uh, if the user data wasn't changed, but we have a lot of component inside and the user data wasn't changed, we, in this case, we don't use, we don't want to re-render the user card if it was rendered before, and I don't need it. Don't need, uh, to load it. Imagine if you have a dashboard or Facebook or LinkedIn or any website and you have your user details, that is al always a static in the header. It didn't change. So I don't need to re-render all this header every time that I refresh the page. So if you are linked in, normally the header is still static and you just, uh, render the site inside. So if you think that your, um, this component is not required to render, you could use, uh, react memo, which is help you, uh, to to store the, the case and track the user data. If it changed, it'll render. If not, it'll stay the same. Same for filter items. If you, if you have data, if you have a components that have a lot of calculations, and let's say we are doing a filtering for, for a, for a table. If the data didn't, if we rerender the form and the data didn't change, so doesn't make sense that we relearn the, uh, or re learned or make the calculation again. So if you using use memo, it'll memorize if this items was changed or not. If it changed, it'll make the filter process again. But if it didn't change, we don't have to to, to refilter and recalculate how the state of the data, again, same as for using callback. And this is, uh, similar, similar from rear-ending part. If you had parent\n'slidetext': ''\n'from': 'vector'\n'score': 0.9227443337440491\n'normalizedScore': 0.9086059804747695\n'beforeDatePenaltyScore': 0.9227443337440491\n\n'documentId': '4ebfb70f9a681ab244108b0f'\n'chunk_id': '68f24f70d754e200146e6e9a'\n'access': 'restricted'\n'part_number': 13\n'total_parts': 16\n'contentType': 'RHEINGOLD'\n'title': Managing Complex State in React\n'parentName': International JavaScript New York 2025\n'language': 'EN'\n'date': '2025-09-30T15:15:00.000Z'\n'abstract': As React applications grow and succeed, managing state becomes increasingly complex—and expensive if left unchecked. But complexity doesn’t have to mean chaos. In this session, we’ll explore why thoughtful state management is critical for maintainability and performance. You’ll learn how to leverage powerful built-in React features and proven techniques to organize your state, reduce bugs, and keep your codebase scalable. Whether you're dealing with deeply nested components or asynchronous data flows, you'll leave with practical strategies to make your apps more robust and easier to evolve.\n'parentId': '9f97d5cdc68d72a05f834df4'\n'parentDescription': The JavaScript Fullstack Conference - Angular, Node.js, React and more\n'indexBrandName': 'InternationalJavaScriptCon'\n'indexSeriesName': 'NewYork'\n'author': 'Mary Shaw'\n'chunkSource': 'text'\n'text': would it That's a good com. That's a good question. So like in our, in our uh, my example of a reducer where I had that diagram with like 10 things on them, I could have put all the logic for all of those inside the switch statement and had a 3000 line file. But instead, like each one I just called a function. And so that function became, it didn't know about React, it didn't need to know about React 'cause it put put in input and it brought out output and it, so it's just a JavaScript function. It is supporting the React library, but it's just a function. Yeah, thanks for asking. Um, and so yeah, like I said, you just unit test each function. One of the things that's I think really helpful with React is they have this single source of truth principle. React has one source data has one source of truth and data only flows down. The thing on the, the most small child's component cannot change the upper component, but you can pass a function from a context down there and then you can call it to get that thing up to change. And that seems simple, but there are some engineers my org that just, it doesn't make sense to them. And so, and so they have certain problems with their, their code because they're like, well, we're setting this here and we're setting it again down there. Um, and then yeah, you, there are some engineers who have done some really interesting things because, um, they were trying to solve this, but they weren't tru truly understanding how to kind of organize it with a composition by putting it in the context and then sending it down and then passing the function and then you calling the function to set it up high again and then everything will just re-render. And it's, it won't be expensive if they, things that are expensive, call use memo, you can re-render a whole lot of things, but they don't actually re-render if their, their input doesn't change. So, so it's actually a lot faster than you think it might be. So we talked about the easy block combining the easy to, and we talked about breaking up the hard problem, but sometimes people just wanna know, how do I start, I'm starting, how do I make sure it's good? Um, and so the first thing I do, like when I'm starting a brand new app that's, I know it's gonna be really complicated. I just start with, um, betting the data, then I create a provider 'cause I know it's gonna have a lot of\n'slidetext': ''\n'from': 'vector'\n'score': 0.9107722043991089\n'normalizedScore': 0.9085257378624524\n'beforeDatePenaltyScore': 0.9107722043991089\n\n'documentId': 'f8465c38d514d23af45f3eb0'\n'chunk_id': '690373b89669850016afad7a'\n'access': 'restricted'\n'part_number': 1\n'total_parts': 16\n'contentType': 'RHEINGOLD'\n'title': The real cost of React re-renders in 2025\n'parentName': Frontmania 2025\n'language': 'EN'\n'date': '2025-10-08T12:30:00.000Z'\n'abstract': Modern React makes it deceptively easy to write code that looks performant, but hides costly re-renders, hydration mismatches, and subtle CPU bottlenecks. As applications scale and ship to users on slower devices or flaky networks, these problems compound into real-world slowdowns. In this talk, I'll dive deep into profiling React applications in 2025, leveraging the latest React DevTools, flamegraphs, and field metrics to uncover unexpected re-render patterns. I'll compare how React 18 cooperative scheduling and batching stacks up against React 19 new compiler-backed partial signals and smarter diffing, showing side-by-side examples of how seemingly harmless hooks can differ dramatically in cost. Also will touch React Forget and what it will bring. Aside code examples it should also form a structure for a team how to properly test the performance of applications.\n'parentId': '501ad2dcdca77f2683bdde34'\n'parentDescription': \n'indexBrandName': ''\n'indexSeriesName': ''\n'author': 'Emīls Pļavenieks'\n'chunkSource': 'text'\n'text': The real cost of React re-renders in 2025 Modern React makes it deceptively easy to write code that looks performant, but hides costly re-renders, hydration mismatches, and subtle CPU bottlenecks. As applications scale and ship to users on slower devices or flaky networks, these problems compound into real-world slowdowns. In this talk, I'll dive deep into profiling React applications in 2025, leveraging the latest React DevTools, flamegraphs, and field metrics to uncover unexpected re-render patterns. I'll compare how React 18 cooperative scheduling and batching stacks up against React 19 new compiler-backed partial signals and smarter diffing, showing side-by-side examples of how seemingly harmless hooks can differ dramatically in cost. Also will touch React Forget and what it will bring. Aside code examples it should also form a structure for a team how to properly test the performance of applications. So, yeah, again, I, I hope you have, you're having a good time here because there have been uh quite a lot of good talks, and uh this will be about react, react and the re-renders and what's actually happening underneath to better understand of where we should seek for these performance improvements. So with that, we will start with a bit of React history. Like back in the wild wild west, uh there was this simple to understand reconciliation process, which was synchronous, yet it was blocking. Meaning that whatever we started to do, it had to be finished before we can do another interaction. For example, we clicked somewhere and we needed to wait until, let's say it was a list of and the filter input and we started to type something and we can see that what we're typing is that like lagging behind. And the list is slowly updating, and this is because it started to do this process and for the next input, like the browser did. Combine all of these events after and only then pushed it to React, so it was blocking and in the world of modern web apps, it was not good. So after that React offered us Weber and this was like. They told us that we have hope. We have hope to build something better. The main key difference was that it introduced the concurrent mode for the reconciliation process, meaning that all of these tasks that needed to be run were split into smaller pieces called fibers. Like they have their own attributes and like actions and rules they follow. However, the main thing was that it could have been that these smaller bits of fibers could be paused. In order for a higher priority task to be done. For example, if we\n'slidetext': ''\n'from': 'vector'\n'score': 0.9102048873901367\n'normalizedScore': 0.908390498479051\n'beforeDatePenaltyScore': 0.9102048873901367\n\n'documentId': 'c7561d4953f0e9be339434dc'\n'chunk_id': '690e04350f4b7700138eb912'\n'access': 'granted'\n'part_number': 9\n'total_parts': 28\n'contentType': 'RHEINGOLD'\n'title': React 2026 - Neue Features im Praxis-Check\n'parentName': W-JAX 2025\n'language': 'DE'\n'date': '2025-11-06T11:00:00.000Z'\n'abstract': Seit der W-JAX vor einem Jahr sind gleich mehrere neue React-Releases erschienen, die eine Reihe von neuen Features mitbringen, um unsere Anwendungen flüssiger und schneller zu machen. Dazu gehören Activities, Fragment Refs, optimistische Updates und einiges mehr. Auch den React Compiler gibt es in einer 1.0-Version und auf der diesjährigen React 'Hauskonferenz' im Oktober wurde mit 'Async React' sogar eine ganz neue Strategie ausgegeben.  In diesem Live-Coding-Vortrag möchte ich euch die wichtigsten Neuerungen vorstellen, so dass ihr danach einen Überblick habt, was es an Neuigkeiten gibt und entscheiden könnt, welche davon für euch relevant sind.\n'parentId': '26c78c073b722105116a13de'\n'parentDescription': Die Konferenz für Java, Architektur- und Software-Innovation\n'indexBrandName': 'JAX'\n'indexSeriesName': ''\n'author': 'Nils Hartmann'\n'chunkSource': 'text'\n'text': Property nicht kennt. Aber nehmen wir mal an, wir hätten hier so eine leere Liste, die wir übergeben wollen. Dann wäre in dem Moment dieser Servings Chooser, wenn ich den mit Memo umschlossen hätte, würde der auch wieder jedes Mal neu gerändert werden, weil das hier eine neue Referenz auf ein leeres Array ist, sieht harmlos aus, führt aber tatsächlich dazu, dass wir diesen Memo- Effekt wieder ausgeschaltet haben. Und da kommt man vom 100. ins 1000. hier würde ich das vielleicht noch sehen. Ach ja, was habe ich denn da gemacht? Vielleicht habe ich dieses Array aber auch von der Oberkomponente übergeben. Und die erzeugen das nicht richtig und so weiter und so fort. Also schönes Thema ist ist es nicht. Und jetzt kommt endlich der React Compiler ins Spiel. Der verspricht uns nämlich, diesen ganzen Youth Callback und Memo und Usememo Kram und so für uns zu machen, für uns selber zu machen. Und damit wir das richtig schön sehen, mache ich jetzt mal hier meine. mache ich jetzt hier mal meine mühevoll implementierten Optimierungen wieder zurück. Das können wir hier einmal kopieren, das ist einmal vorher nachher sehen. So, Kolberg weg. Nein, bis daher. So. Und dann müssen wir einmal hier kurz die Memos entfernen. Kurz ist gut. So. also der Nachteil finde ich an diesem Ansatz, den ich jetzt gerade gewählt habe oder den wir bislang ja wählen mussten an diesem manuellen ist einerseits eben, was ich gerade bei H Callback gesagt habe. Man vergisst da irgendwie so eine Abhängigkeit hinzuschreiben oder auch bei den Properties. Also das ist fehleranfällig plus, wie wir hier auch sehen, finde ich, es macht den Code auch nicht unbedingt lesbarer. also eigentlich macht macht ihn schon schneller unter Umständen, aber eben nicht im eigentlichen Sinne besser. Also ich habe jetzt alles unsere Optimierung wieder zurückgängig gemacht. Und wenn wir jetzt hier neu rendern, dann sind wir wieder bei unseren 23. Natürlich. Und jetzt, meine Damen und Herren, habe ich in diesem Projekt den React Compiler installiert. Das ist ein Babel Plug-in. Und wenn ihr Vat benutzt, den Vat- Bild Server. Dann ist\n'slidetext': ''\n'from': 'vector'\n'score': 0.9073342680931091\n'normalizedScore': 0.9071054956203796\n'beforeDatePenaltyScore': 0.9073342680931091\n\n'documentId': 'c7561d4953f0e9be339434dc'\n'chunk_id': '690e04350f4b7700138eb911'\n'access': 'granted'\n'part_number': 9\n'total_parts': 28\n'contentType': 'RHEINGOLD'\n'title': React 2026 - Neue Features im Praxis-Check\n'parentName': W-JAX 2025\n'language': 'DE'\n'date': '2025-11-06T11:00:00.000Z'\n'abstract': Seit der W-JAX vor einem Jahr sind gleich mehrere neue React-Releases erschienen, die eine Reihe von neuen Features mitbringen, um unsere Anwendungen flüssiger und schneller zu machen. Dazu gehören Activities, Fragment Refs, optimistische Updates und einiges mehr. Auch den React Compiler gibt es in einer 1.0-Version und auf der diesjährigen React 'Hauskonferenz' im Oktober wurde mit 'Async React' sogar eine ganz neue Strategie ausgegeben.  In diesem Live-Coding-Vortrag möchte ich euch die wichtigsten Neuerungen vorstellen, so dass ihr danach einen Überblick habt, was es an Neuigkeiten gibt und entscheiden könnt, welche davon für euch relevant sind.\n'parentId': '26c78c073b722105116a13de'\n'parentDescription': Die Konferenz für Java, Architektur- und Software-Innovation\n'indexBrandName': 'JAX'\n'indexSeriesName': ''\n'author': 'Nils Hartmann'\n'chunkSource': 'text'\n'text': Property nicht kennt. Aber nehmen wir mal an, wir hätten hier so eine leere Liste, die wir übergeben wollen. Dann wäre in dem Moment dieser Servings Chooser, wenn ich den mit Memo umschlossen hätte, würde der auch wieder jedes Mal neu gerändert werden, weil das hier eine neue Referenz auf ein leeres Array ist, sieht harmlos aus, führt aber tatsächlich dazu, dass wir diesen Memo- Effekt wieder ausgeschaltet haben. Und da kommt man vom 100. ins 1000. hier würde ich das vielleicht noch sehen. Ach ja, was habe ich denn da gemacht? Vielleicht habe ich dieses Array aber auch von der Oberkomponente übergeben. Und die erzeugen das nicht richtig und so weiter und so fort. Also schönes Thema ist ist es nicht. Und jetzt kommt endlich der React Compiler ins Spiel. Der verspricht uns nämlich, diesen ganzen Youth Callback und Memo und Usememo Kram und so für uns zu machen, für uns selber zu machen. Und damit wir das richtig schön sehen, mache ich jetzt mal hier meine. mache ich jetzt hier mal meine mühevoll implementierten Optimierungen wieder zurück. Das können wir hier einmal kopieren, das ist einmal vorher nachher sehen. So, Kolberg weg. Nein, bis daher. So. Und dann müssen wir einmal hier kurz die Memos entfernen. Kurz ist gut. So. also der Nachteil finde ich an diesem Ansatz, den ich jetzt gerade gewählt habe oder den wir bislang ja wählen mussten an diesem manuellen ist einerseits eben, was ich gerade bei H Callback gesagt habe. Man vergisst da irgendwie so eine Abhängigkeit hinzuschreiben oder auch bei den Properties. Also das ist fehleranfällig plus, wie wir hier auch sehen, finde ich, es macht den Code auch nicht unbedingt lesbarer. also eigentlich macht macht ihn schon schneller unter Umständen, aber eben nicht im eigentlichen Sinne besser. Also ich habe jetzt alles unsere Optimierung wieder zurückgängig gemacht. Und wenn wir jetzt hier neu rendern, dann sind wir wieder bei unseren 23. Natürlich. Und jetzt, meine Damen und Herren, habe ich in diesem Projekt den React Compiler installiert. Das ist ein Babel Plug-in. Und wenn ihr Vat benutzt, den Vat- Bild Server. Dann ist\n'slidetext': ''\n'from': 'vector'\n'score': 0.9073342680931091\n'normalizedScore': 0.9071054956203796\n'beforeDatePenaltyScore': 0.9073342680931091\n\n'documentId': 'f8465c38d514d23af45f3eb0'\n'chunk_id': '690373b99669850016afad84'\n'access': 'restricted'\n'part_number': 11\n'total_parts': 16\n'contentType': 'RHEINGOLD'\n'title': The real cost of React re-renders in 2025\n'parentName': Frontmania 2025\n'language': 'EN'\n'date': '2025-10-08T12:30:00.000Z'\n'abstract': Modern React makes it deceptively easy to write code that looks performant, but hides costly re-renders, hydration mismatches, and subtle CPU bottlenecks. As applications scale and ship to users on slower devices or flaky networks, these problems compound into real-world slowdowns. In this talk, I'll dive deep into profiling React applications in 2025, leveraging the latest React DevTools, flamegraphs, and field metrics to uncover unexpected re-render patterns. I'll compare how React 18 cooperative scheduling and batching stacks up against React 19 new compiler-backed partial signals and smarter diffing, showing side-by-side examples of how seemingly harmless hooks can differ dramatically in cost. Also will touch React Forget and what it will bring. Aside code examples it should also form a structure for a team how to properly test the performance of applications.\n'parentId': '501ad2dcdca77f2683bdde34'\n'parentDescription': \n'indexBrandName': ''\n'indexSeriesName': ''\n'author': 'Emīls Pļavenieks'\n'chunkSource': 'text'\n'text': screen. Um, If we are writing In here, as we can see, yeah, it's, it's slow, right? As I said, because it tries to fulfill all of the necessary thing for the single key input before it can proceed to the next one. And as I said, the fiber introduced the concurrent mode where we can kind of set the higher priority tasks in, but it also comes with this CV that we do not have a direct API how to manage which of the function parts are higher priority, which are the lower ones. But there are a few helpers that we can use in order to lower. Or. Like debund natively, some of the actions. For example, if we want to input inside the input and we want to see what we are actually typing to see if there's a typo or something, uh, instead of directly setting the state, we can use, for example, start transition, which will indicate that whatever we set in there, it needs like the render process of that needs to happen kind of in the background. And whenever we are done with the current interaction, it can like change to that, and this should allow us to start to write in there and like if we have written the second letter before the react goes into commit phase, then it will drop everything it did in the render and do a whole new re-render for the two letters of the word, and this saves us the cost of going through this additional. Commit phases. So Then there's another thing, like, if you want to go more into details, there's like a lot of more things to actually seek for within these dev tools. Uh, Talia later will have also talk related to the dev tools. I recommend visiting that. It should be very interesting. If I remember correctly, it will use AI. Uh, but yeah, going further, have you heard about React Forget? Like it was code named React Forget. Uh, actually, it's a React compiler. And Like the hope the react team is giving us is that we will be able to forget about the memorization as a whole. Like we will not need to figure out, does this need to be memorized, does the component uses this property within other memorized dependent TRA, etc. Like we should be able to forget about everything. It also kind of adds smarter diffing to that, and it has, since this, it has this automatic memorization, the smart diffing applies to parts where, for example, Here in the code where. Let's go. So filter counter. I think this is good enough as well, um. Here we return JS 6, it's not\n'slidetext': ''\n'from': 'vector'\n'score': 0.9075859785079956\n'normalizedScore': 0.9057715895969098\n'beforeDatePenaltyScore': 0.9075859785079956\n\n'documentId': '004c178a34c278c75190f756'\n'chunk_id': '6903813a52f58e0014b29c42'\n'access': 'granted'\n'part_number': 23\n'total_parts': 26\n'contentType': 'RHEINGOLD'\n'title': Caching, Payloads, and Other Dark Arts: A Frontend Engineer’s Journey\n'parentName': International JavaScript Conference Munich 2025\n'language': 'EN'\n'date': '2025-10-30T11:00:00.000Z'\n'abstract': This talk breaks down how we rescued a near-unusable frontend dashboard that was constrained by a rigid, third-party API and strict compliance requirements. The usual frontend performance tricks didn’t work, so we had to dig deeper. We started by diagnosing real usage issues through profiling and UX bottleneck analysis, which surfaced unexpected insights that reshaped our strategy. To regain control, we built a Backend-for-Frontend (BFF) layer using Next.js API routes. This let us shrink payloads, merge calls, and customize data delivery to suit the UI. On the frontend, we implemented caching strategies using TanStack Query, though the principles apply beyond that stack, to keep critical financial data accurate and reactive without overwhelming the UI. We handled lifecycle-sensitive updates, stale data, and render minimization under tight constraints. Throughout the journey, we navigated tradeoffs between compliance, performance, and UX, making conscious decisions on what to optimize and where to compromise. The session wraps with a live demo showcasing real implementation patterns and measurable before-and-after performance improvements.\n'parentId': 'd9a5c0715a7cff50bbb51e14'\n'parentDescription': \n'indexBrandName': 'InternationalJavaScriptCon'\n'indexSeriesName': 'Munich'\n'author': 'Faris Aziz'\n'chunkSource': 'text'\n'text': that timeout to 500 milliseconds, which it's most likely that the request on the server won't resolve, what happens is the timeout triggers on the server, it bails, the client starts to load and it's like, I don't have the dehydrated state, so I'm gonna make the request on the client's side, and it starts to reconcile between the server, uh, and the client to see what data it managed to fetch and what data it didn't manage to fetch. And so this way you've also got another layer of reser um resilience. Question at the end of the day is now, Faris, did we have to go through all this jumping of engineering loops and couldn't the back end have just made the diamond point? Um, it's not the point. The point is sometimes we can be pragmatic, sometimes we can, um, but sometimes we can be pragmatic, but we also want to be curious, and we also want to be creative with our solutions. And this solution that was put in place at the startup that I was working at previously actually lasted 2 years. It's probably still there today, because it allowed to unblock work for uh uh the back end to be able to work on more important things. You're able to actually drive a lot of the effort from a product perspective to work on the things that are actually important for the client or the end user. So yeah, sometimes you have to be creative. Now, I've got 9 minutes, so I'm going to actually go into a little bit of a teaser uh with what I had mentioned a little bit in the, The, the, the second half of the talk, which is, how can the data returned from my BFF actually improve react reconciliation? So, uh, react the way that it reconciles typically is that, um, it uses, you know, something called object dot is under the hood to be able to see if any dependencies or props have changed. And the easiest way to reconcile is actually with primitive types. So comparing strings, comparing numbers, so on and so forth. It's a little bit more complicated to reconcile. Reference based uh reference based types, so objects and arrays, that's why we tend to use use memo, because references aren't compared, it's you references are compared, you're not going to now go and look at every single key value pair in an object and see if that's the same, and then reconcile as a result of that. React is pragmatic, it's like the effort to check every single key value pair is probably more than just re-rendering the whole thing,\n'slidetext': ''\n'from': 'vector'\n'score': 0.9063405990600586\n'normalizedScore': 0.9057282649434933\n'beforeDatePenaltyScore': 0.9063405990600586\n\n'documentId': '4ebfb70f9a681ab244108b0f'\n'chunk_id': '68f24f6fd754e200146e6e98'\n'access': 'restricted'\n'part_number': 11\n'total_parts': 16\n'contentType': 'RHEINGOLD'\n'title': Managing Complex State in React\n'parentName': International JavaScript New York 2025\n'language': 'EN'\n'date': '2025-09-30T15:15:00.000Z'\n'abstract': As React applications grow and succeed, managing state becomes increasingly complex—and expensive if left unchecked. But complexity doesn’t have to mean chaos. In this session, we’ll explore why thoughtful state management is critical for maintainability and performance. You’ll learn how to leverage powerful built-in React features and proven techniques to organize your state, reduce bugs, and keep your codebase scalable. Whether you're dealing with deeply nested components or asynchronous data flows, you'll leave with practical strategies to make your apps more robust and easier to evolve.\n'parentId': '9f97d5cdc68d72a05f834df4'\n'parentDescription': The JavaScript Fullstack Conference - Angular, Node.js, React and more\n'indexBrandName': 'InternationalJavaScriptCon'\n'indexSeriesName': 'NewYork'\n'author': 'Mary Shaw'\n'chunkSource': 'text'\n'text': choose. There's libraries, like I said, like Redux or um, or your network cache. A lot of people forget about your network cache. Like you're, you're, you're in your browser. HATP was built to cache the things that matter. And so sometimes you don't have to build an extra local storage layer right on top of it does does the exact same thing as your network because it's already there. Composition is bringing it all together and just organizing all the same bits in a way that makes sense for you and for everyone who comes after you after you get that promotion. 'cause you're such a good coder. Um, so the building blocks that I think for com composition is important. So I will have components that basically are display components. They don't do anything else. I'll have components that are context components that have the custom hooks. I'll have the custom hooks and a display component might have call a custom hook or two. Um, and then I'll have functions that aren't part of React that will make network calls and do all those things. And so the way you organize this matters for how that component, that app is going to be maintained over time, right? And uh, anytime if there's something new, for example, that search results search form search results, we built it in polymer and we, we built the historical record search form and built it and it was all finished and looked great and it was like, oh, let's add this to a different type of data to this, um, a different type of records that we're keeping. And so we had a different kind of a form for that. And so we had to start over. We had, it was gonna take twice as long basically to shoehorn the new one into the old one in polymer and then React came along and we didn't have to do it in polymer. And so, but the first thing we did in React was instead of writing a search form only for historical historical records, we wrote it for both historical records in our other genealogy data store. And because we did that and all the unit tests checked both 'cause I, we knew that this was gonna happen, right? And we'd already kind of seen the effects. We were able to write unit tests for both systems. And so when we had finished the historical records and they were like, oh, let's apply it to the other one, is that gonna take twice as much time? And I was like, no, I was done in a week because I'd already done it and I'd made sure it was set up this way.\n'slidetext': ''\n'from': 'vector'\n'score': 0.9060242176055908\n'normalizedScore': 0.9037777510689343\n'beforeDatePenaltyScore': 0.9060242176055908\n\n'documentId': '09c1d40fca67448b12b69d10'\n'chunk_id': '68ecc3644ddebd0013afffa9'\n'access': 'granted'\n'part_number': 6\n'total_parts': 12\n'contentType': 'READ'\n'title': State Management in React - Comparing lightweight approaches\n'parentName': iJS Magazine Volume 20\n'language': 'EN'\n'date': '2025-08-26T22:00:00.000Z'\n'abstract': Let’s examine several state management approaches and use cases in React, focusing on lightweight solutions with a low overhead and a limited impact on the overall application.\n'parentId': '5a3a6ad9da8f235bfee3bd9f'\n'parentDescription': Broaden your knowledge and expand your JavaScript techniques and practices. From Angular, React, and WebAssembly, to the best JavaScript IDEs, open source tools and more, you’ll learn insights on everything JS from seasoned experts in their field. Keep up with JavaScript news, tips, and advice with interviews, tutorials, and in-depth articles.\n'indexBrandName': ''\n'indexSeriesName': ''\n'author': 'Sebastian Springer'\n'chunkSource': 'text'\n'text': and free of side effects. This means that the same inputs always result in the same outputs and the current state is only changed based on the action provided. If you stick to this rule, your code will be clearer and better structured, and error handling is easier. You’ll also be more flexible when it comes to future software extensions. Listing 4 shows an implementation of state management with the useReducer hook. Listing 4: Using the useReducer-Hooks import { createContext, Dispatch, FC, ReactNode, useContext, useEffect, useReducer, } from 'react'; import { Cart, CartItem } from './types/Cart'; const SET_CART = 'setCart'; const ADD_TO_CART = 'addToCartAsync'; const FETCH_CART = 'fetchCart'; type FetchCartAction = { type: typeof FETCH_CART; }; type SetCartAction = { type: typeof SET_CART; payload: Cart; }; type AddToCartAsyncAction = { type: typeof ADD_TO_CART; payload: CartItem; }; type CartAction = FetchCartAction | SetCartAction | AddToCartAsyncAction; type CartContextType = [Cart, Dispatch]; const CartContext = createContext(null); type CartProviderProps = { children: ReactNode; }; function cartReducer(state: Cart, action: CartAction): Cart { switch (action.type) { case SET_CART: return action.payload; default: throw new Error(`Unhandled action type: ${action.type}`); } } function cartMiddleware(dispatch: Dispatch, cart: Cart) { return async function (action: CartAction) { switch (action.type) { case FETCH_CART: { const response = await fetch('http://localhost:3001/cart'); const data = await response.json(); dispatch({ type: SET_CART, payload: data }); break; } case ADD_TO_CART: { const response = await fetch('http://localhost:3001/cart', { method: 'PUT', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ items: [...cart.items, action.payload], }), }); const updatedCart = await response.json(); dispatch({ type: SET_CART, payload: updatedCart }); break; } default: dispatch(action); } }; } export const CartProvider: FC = ({ children }) => { const [cart, dispatch] = useReducer(cartReducer, { items: [] }); const enhancedDispatch = cartMiddleware(dispatch, cart); useEffect(() => { enhancedDispatch({ type: FETCH_CART }); }, []); return (  {children}  ); }; export function useCart() { const context = useContext(CartContext); if (!context) { throw new Error('useCart must be used within a CartProvider'); } return context; } export function useAddToCart() { const [, dispatch] = useCart(); const addToCart = (item: CartItem) => { dispatch({ type: ADD_TO_CART, payload: item }); }; return addToCart; } The CartProvider component is the starting point for implementation. It holds the context and creates the\n'slidetext': ''\n'from': 'vector'\n'score': 0.9077728986740112\n'normalizedScore': 0.9036240348770808\n'beforeDatePenaltyScore': 0.9077728986740112\n\n'documentId': 'f8465c38d514d23af45f3eb0'\n'chunk_id': '690373b99669850016afad87'\n'access': 'restricted'\n'part_number': 14\n'total_parts': 16\n'contentType': 'RHEINGOLD'\n'title': The real cost of React re-renders in 2025\n'parentName': Frontmania 2025\n'language': 'EN'\n'date': '2025-10-08T12:30:00.000Z'\n'abstract': Modern React makes it deceptively easy to write code that looks performant, but hides costly re-renders, hydration mismatches, and subtle CPU bottlenecks. As applications scale and ship to users on slower devices or flaky networks, these problems compound into real-world slowdowns. In this talk, I'll dive deep into profiling React applications in 2025, leveraging the latest React DevTools, flamegraphs, and field metrics to uncover unexpected re-render patterns. I'll compare how React 18 cooperative scheduling and batching stacks up against React 19 new compiler-backed partial signals and smarter diffing, showing side-by-side examples of how seemingly harmless hooks can differ dramatically in cost. Also will touch React Forget and what it will bring. Aside code examples it should also form a structure for a team how to properly test the performance of applications.\n'parentId': '501ad2dcdca77f2683bdde34'\n'parentDescription': \n'indexBrandName': ''\n'indexSeriesName': ''\n'author': 'Emīls Pļavenieks'\n'chunkSource': 'text'\n'text': But, so. Getting back to the what. Yeah, React, 19.2. So, while I was making this presentation and the Demo app, which was halfly white coded. Uh, one week ago, React released a new version, React. 19.2, which like introduced new features, but currently in the US there's also happening a React conference. So if you're really interested in that, I'm sure there will be new material to watch and read in the next days. But one thing I want to bring out is activity. Activity is a component that was brought in that basically allows us to create this component within the virtual dome. Like we can set some specific states for it to like do all of the computation. Like if it's a slow component, it's good because in the background it has a lower priority. So while the user is not is not interacting with the page, it can already start to build up the states, start to build up the variables. If there's data fetching, it can also start to fetch the data, and once we want to show this component on the screen, we just toggle a boolean for this activity component, and it already knows like everything what it wants to render. So at that point, it kind of skips the surrender phase and directly puts everything in the commit phase. And that's, this is also a place where we can gain something. And there's use effect events. That's a new hook, yet another. Think trying to fix the use effect side effects. Uh, yeah, but, um, it's actually something that could benefit for some parts, and this is more if you were using some like action handlers within these use effect side effects that you had. Uh, in the dependency array, let's say, I know you had a team in there for whatever reason, but now you can kind of with these use effect events create an action that will be Like an action that will receive an event from the side effect. So in the side effect, you only keep the logic that you actually want to interact. From or with and then you call this action with that event and that allows to like pull out these maybe contextch uh parts from the dependent the like theme for example. And another thing is performance tracks and dev tools. And uh this is something that if you're using RAC 19.2, it adds additional like things, useful things to the existing Chrome dev tools, like where we went over this profiling, it provides more detail on the components and other things regards to that. So, what are the real costs? Wrapping everything up, the real costs of react, re-renders\n'slidetext': ''\n'from': 'vector'\n'score': 0.9053711891174316\n'normalizedScore': 0.9035568002063459\n'beforeDatePenaltyScore': 0.9053711891174316\n\n'documentId': 'dce2e7fce63ba63cdf7ee57a'\n'chunk_id': '6876df237899910dd58c0eb3'\n'access': 'granted'\n'part_number': 16\n'total_parts': 22\n'contentType': 'COURSE'\n'title': Mastering React: 5 Antipatterns and How to Fix Them\n'parentName': Mastering React: Best Practices for Optimized Performance\n'language': 'EN'\n'date': '2025-02-25T14:36:13.000Z'\n'abstract': This presentation unveils five critical antipatterns that have significantly slowed down our React application. Each section delves into a specific mistake, examining the challenges it created and the solutions implemented to address these issues. By analyzing real-world examples, this session offers invaluable insights and practical strategies for avoiding similar pitfalls in your development projects. Join us to gain the expertise needed to enhance performance and efficiency, driving your applications to new heights.\n'parentId': '159bcfd9af1467befd4bbe7b'\n'parentDescription': According to the 2024 JavaScript survey, React remains the top frontend framework, solidifying its dominance in web development. Unlock the full potential of React.js with this course designed for developers looking to optimize, scale, and modernize their React applications. From avoiding common antipatterns to implementing server components, you will gain hands-on experience with the latest React innovations and dive deep into real-world projects.\n'indexBrandName': 'InternationalJavaScriptCon'\n'indexSeriesName': ''\n'author': 'Jonas Herrmannsdörfer'\n'chunkSource': 'text'\n'text': of code that looked very complicated and it's the same thing in the end. So to recap that because that was really simple, well don't put it in state when it can be calculated from existing props in state. What you should instead is just calculate it during rendering. And why is this good to do it? Well first of all you have faster code. I mean it's probably not noticeable to the user because it's just one extra update and it's not really expensive this calculation but well it's one less update that we have so already good and it was quite easy. And more important for me is the code gets a lot more simpler because you remove that use effect, we remove that use state, it's just easier to read. And additionally, if you add more logic in that use effect, well it's quite easy to introduce some bugs because the state is kind of getting out of sync in this use effect. So yeah, a lot of advantages and also it's not meant to well do it like that and not use use effect for it. Yeah, just do it. Um, during the rendering, the transformation. And now our next example where we shouldn't use use effect for cash and expensive calculations. What are we doing in this case? Well we have a to-do list again. Um, then we have a new to-do state and then we also have all the visible to-dos as state. And then we have another use effect. This runs whenever the to-do changes or the filter changes and well then in this set visible to-do we are also doing some filtering. But when we look at this, well it's the same thing again, it's just a transformation of some data. So well we can just um, avoid this redundant state and use effect and just do it during rendering. So we just use the get filter todos and we have all visible todos um, variable and we just can just render that so simple as that. But this is only the the case if this get filter todos is a normal function, nothing expensive is happening there. But in this case, I mean we are talking about expensive calculations so maybe there's something expensive in there. So if it is the case that this get filter todos is a very slow function, what can we do instead of using use effect But for that the um, yeah react has another hook which is called use memo. And that is actually or should be used for expensive calculations. What is use memo doing? Use memo first and the first render just runs the um, the code inside of the use memo function and just\n'slidetext': ''\n'from': 'vector'\n'score': 0.9154788255691528\n'normalizedScore': 0.9013404722998732\n'beforeDatePenaltyScore': 0.9154788255691528\n\n'documentId': '11aa4ab6eae82f7b6df75323'\n'chunk_id': '68c26fc50a53cd001394ab8f'\n'access': 'granted'\n'part_number': 2\n'total_parts': 3\n'contentType': 'READ'\n'title': Essential React Tips: A Developer's Cheat Sheet - React 19's Must-Know Concepts\n'parentName': iJS Magazine Volume 19\n'language': 'EN'\n'date': '2025-06-24T22:00:00.000Z'\n'abstract': This cheat sheet offers a quick reference guide to key features and commands in React, helping developers streamline their workflow and accelerate development.\n'parentId': 'a1269c65e87d5b8ebcde4b28'\n'parentDescription': Broaden your knowledge and expand your JavaScript techniques and practices. From Angular, React, and WebAssembly, to the best JavaScript IDEs, open source tools and more, you’ll learn insights on everything JS from seasoned experts in their field. Keep up with JavaScript news, tips, and advice with interviews, tutorials, and in-depth articles.\n'indexBrandName': ''\n'indexSeriesName': ''\n'author': 'Jaime Garcia'\n'chunkSource': 'text'\n'text': Parent {children}  ); }  Child  Key Takeaway children is a special parameter in React that holds the elements inside a component. In the snippet above, children is equal to < h2 >Child. One important thing to remember is that React requires a root component. If you have multiple elements at the same level, you can wrap them using a Fragment to avoid unnecessary HTML wrappers. useEffect import { useEffect, useState } from 'react'; function Timer() { const [seconds, setSeconds] = useState(0); useEffect(() => { const interval = setInterval(() => { setSeconds((s) => s + 1); }, 1_000); return () => clearInterval(interval); // Cleanup }, []); return \n\nSeconds: {seconds}; } Remember useEffect runs on the client, not the server. The function passed to useEffect executes when the component is added to the DOM or when any of its dependencies (the second argument, an array) change. Additionally, an optional cleanup function can be defined, which React will run when the component is removed from the DOM. Rendering Arrays function TodoList() { const todo = [ 'Create project', 'Write code for the module A', 'Deploy the app' ]; return (  Todo List \n\n- {item}  ); } Insight The key to rendering an array in React is to iterate through it and build a JSX element. The most common method for this is .map(). It's also important to set a unique key for each element in the list. React uses this key to track and update nodes efficiently, improving performance when the list changes. Controlled Elements import { useState } from 'react'; function ControlledElements() { const [value, setValue] = useState(''); return (  setValue(event.target.value)} /> ); } Remember Controlled Elements rely on a state variable, allowing you to access the value as the user types. This is useful for validations or triggering side effects. Notice how the onChange listener receives a DOM event, which holds the value the user just entered. Conditional and Short-Circuit import Greeting from '../greeting'; import Counter from '../counter'; function Component() { const showGreeting = true const shortCircuit = true return (  Conditionals {showGreeting ?  : } {shortCircuit && \n\nShort-circuiting}  ); } Remember Conditional rendering and short-circuit evaluation are useful for toggling components. In the snippet above, the flag is\n'slidetext': ''\n'from': 'vector'\n'score': 0.9084420204162598\n'normalizedScore': 0.9008411018248087\n'beforeDatePenaltyScore': 0.9084420204162598\n\n'documentId': '1afc9b7c648711b8f9bea5bc'\n'chunk_id': '6876cd0c225e92fc1ac78a4e'\n'access': 'granted'\n'part_number': 15\n'total_parts': 15\n'contentType': 'COURSE'\n'title': Scaling and Optimizing React Applications: Advanced Techniques for Large-Scale Projects\n'parentName': Mastering React: Best Practices for Optimized Performance\n'language': 'EN'\n'date': '2025-02-25T14:36:13.000Z'\n'abstract': In this session, we'll explore critical strategies for scaling and optimizing React applications to ensure top performance as your projects grow. Learn how to structure large applications for long-term scalability, manage complex state efficiently, and handle large data sets without sacrificing speed. We’ll cover advanced techniques like code splitting, lazy loading, and component rendering optimizations, as well as methods to streamline build times in CI/CD pipelines. Whether you’re scaling a fast-growing app or managing a large enterprise project, this session provides actionable insights to future-proof your React applications for continued success.\n'parentId': '159bcfd9af1467befd4bbe7b'\n'parentDescription': According to the 2024 JavaScript survey, React remains the top frontend framework, solidifying its dominance in web development. Unlock the full potential of React.js with this course designed for developers looking to optimize, scale, and modernize their React applications. From avoiding common antipatterns to implementing server components, you will gain hands-on experience with the latest React innovations and dive deep into real-world projects.\n'indexBrandName': 'InternationalJavaScriptCon'\n'indexSeriesName': ''\n'author': 'Ahmed Megahd'\n'chunkSource': 'text'\n'text': the one who is responsible for deciding which, what we are, what exactly you need. Yeah, I think we, we finish here. Maybe feel free to con contact with me and maybe, um, we have more questions. Otherwise, we, we are done. Could we take any questions? Uh, no it, you just do it if you don't expect the slide Here, for example, we, we, if we are using, uh, a component that use filter, filter items is if the, when you, uh, is a parent component, have a props with the items and have another things, but the items is wasn't updated. So it doesn't make sense that we, when you run or re-render that you run everything and reload, uh, and co uh, and make the process of filtering the items again. So if the items didn't change, you try to use reacted memo. Uh, so it doesn't make the process again or render the item, uh, the components or the child component if it's not required. Mm-hmm, yes. But if it's, it's even, even it's more complex filter or maybe it could be a simple filter, but the items is a lot. But the easier, the easier example could be the user card that you, once you keep going, scrolling, navigating your data didn't change or prof data profile didn't change. So it doesn't, uh, doesn't make sense to keep re rendering this component. Anything else? Yeah, which part exactly? Yeah, what exactly? No, I, um, no, but I'm, I'm not sure as, as well how much it'll be able to do it because in general, act by default try to opt, optimize or automatically do a lot of things for you. But you, you know more about what you are doing in your project and when it's possible you could specify, uh, the cases or explain for the act how to build your project. That, so I don't know exactly the result for it. Anything else? Okay, so you could end the session. Thank you. You, I.\n'slidetext': ''\n'from': 'vector'\n'score': 0.9092563390731812\n'normalizedScore': 0.8951179858039016\n'beforeDatePenaltyScore': 0.9092563390731812\n\n'documentId': 'a0fdc76247703b13b691d244'\n'chunk_id': '687a47b16b250430a47836e2'\n'access': 'granted'\n'part_number': 4\n'total_parts': 16\n'contentType': 'READ'\n'title': React 19 – Die neuesten Features - Alles, was Sie wissen müssen\n'parentName': Entwickler Magazin 6.2024\n'language': 'DE'\n'date': '2024-07-24T22:00:00.000Z'\n'abstract': 2024 ist das Jahr von React 19. Warum ist das so besonders? Weil das Team hinter der populären Bibliothek ein ziemliches Geheimnis um das nächste Release macht. Das neueste React-Release verspricht Verbesserungen sowohl an den APIs von React als auch an der Developer Experience sowie an der Performance von Applikationen. Was genau in React 19 auf Sie wartet, und ob sich das Update lohnt, erfahren Sie in diesem Artikel.\n'parentId': '88a1b1cb2d1279f2ae33dd83'\n'parentDescription': Das Entwickler Magazin bietet Software-Entwicklern Einblicke und Orientierung in einem Markt an Entwicklungstechnologien, -tools und -ansätzen, der stets komplexer wird. Mit seiner Kompetenz in einer breiten Palette an Programmiersprachen, Tools, Plattformen und Engineering-Techniken liefert es einen fundierten Marktüberblick und bietet technische Entscheidungshilfen für Entwickler, Projektleiter und Manager.\n'indexBrandName': ''\n'indexSeriesName': ''\n'author': 'Sebastian Springer'\n'chunkSource': 'text'\n'text': erfüllen kann. Doch zunächst sollten wir die Frage klären: Warum brauchen wir ein weiteres Werkzeug für React? Der Compiler optimiert den Code Ihrer Applikation zur Build-Zeit. Die wichtigste Aufgabe des Compilers ist die Memoisierung von Strukturen. Das Thema Memoisierung gibt es in React schon deutlich länger als die Überlegung für den Compiler. Die folgenden Funktionen können Sie bereits jetzt für die Memoisierung von Komponenten, Funktionen und Objekten verwenden: - memo: Mit dieser Funktion können Sie Komponenten memoisieren. Die Komponenten, die Sie dieser Funktion übergeben, rendert React nur neu, wenn sich ihre Props ändern. Dazu vergleicht React die Prop-Werte zwischen den Render-Zyklen. Sie können die Standardvergleichsfunktion durch Ihre eigene Implementierung ersetzen. Allerdings besitzt die Memoisierung mit der memo-Funktion für React lediglich einen Vorschlagscharakter. Die Bibliothek entscheidet in letzter Instanz immer selbst, ob eine Komponente neu gerendert wird. Sie sollten memo also nur zur Verbesserung der Performance und nicht zum Steuern von Render-Zyklen verwenden. - useMemo: Die memo-Funktion arbeitet mit ganzen Komponenten. Wollen Sie innerhalb einer Komponente den Wert einer Berechnung speichern, sodass er beim Neurendern nicht wieder berechnet werden muss, können Sie useMemo verwenden. Dieser Funktion übergeben Sie eine Callback-Funktion, die einen Wert berechnet, und ein Array von Abhängigkeiten. Sobald sich eine der Abhängigkeiten ändert, wird der Wert erneut berechnet, ansonsten arbeitet React mit dem zwischengespeicherten Wert. - useCallback: In React arbeiten Sie sehr häufig mit Callback-Funktionen. Auch diese können Sie mit useMemo memoisieren, damit die Funktionsobjekte nicht bei jedem Render-Zyklus neu erzeugt werden. useCallback ist eine Hilfsfunktion, deren Funktionalität Sie mit etwas mehr Aufwand auch mit useMemo nachbilden können. Der React-Compiler macht diese Funktionen überflüssig und erlaubt Ihnen vor allem, sich keine Gedanken mehr machen zu müssen, wann Sie die Funktionen einsetzen und wann Sie sie besser vermeiden sollten. Generell erschweren die Memoisierungsfunktionen die Lesbarkeit des Codes. Fällt das weg, ist es auf jeden Fall ein Gewinn für Lesbarkeit und Performance. Der React-Compiler wurde während der Entwicklung\n'slidetext': ''\n'from': 'vector'\n'score': 0.9205667972564697\n'normalizedScore': 0.8946097142814571\n'beforeDatePenaltyScore': 0.9205667972564697\n\n'documentId': 'dce2e7fce63ba63cdf7ee57a'\n'chunk_id': '6876df237899910dd58c0eab'\n'access': 'granted'\n'part_number': 8\n'total_parts': 22\n'contentType': 'COURSE'\n'title': Mastering React: 5 Antipatterns and How to Fix Them\n'parentName': Mastering React: Best Practices for Optimized Performance\n'language': 'EN'\n'date': '2025-02-25T14:36:13.000Z'\n'abstract': This presentation unveils five critical antipatterns that have significantly slowed down our React application. Each section delves into a specific mistake, examining the challenges it created and the solutions implemented to address these issues. By analyzing real-world examples, this session offers invaluable insights and practical strategies for avoiding similar pitfalls in your development projects. Join us to gain the expertise needed to enhance performance and efficiency, driving your applications to new heights.\n'parentId': '159bcfd9af1467befd4bbe7b'\n'parentDescription': According to the 2024 JavaScript survey, React remains the top frontend framework, solidifying its dominance in web development. Unlock the full potential of React.js with this course designed for developers looking to optimize, scale, and modernize their React applications. From avoiding common antipatterns to implementing server components, you will gain hands-on experience with the latest React innovations and dive deep into real-world projects.\n'indexBrandName': 'InternationalJavaScriptCon'\n'indexSeriesName': ''\n'author': 'Jonas Herrmannsdörfer'\n'chunkSource': 'text'\n'text': also pass the move down and move up function. And what will now happen is, well we will get a warning that child enlist should have a unique key. You probably read that in your console as well sometime, but why does react even need keys? So um, an example that on the React documentation, why react uh, need keys is about files. So imagine you have a file system on your MacBook for example like here and you don't have names for that file system. Uh, you just have the order of the file. So the red file we can see here, well that's named first file, the green file, the second file, and the yellow file. Well it's the third file and I guess we can get used to that. It's a bit well confusing because we are just have the information about the order. But I mean it should work. But what is happening if we are removing a file, so say for example here we removed the first file, what is now happening, the names are changing because now what was the second file beforehand is now the first file, it was the third file, it's now the second file. Okay? And it is similar for um, react. If you just use an index, well it kind of gets confusing or react itself because it can't identify what um, element via rendering there. So what React is doing, it needs these keys to identify the items itself and to make some changes on what to render or well not render. And in our example, well we did the same thing. Um, we split this mistake and we used index as a key. So in this case, same situation with the files, everything is just named from the index. And well, when the order changes it might get a bit confusing. And in our case when we have our application, so we are rendering our to-dos for each to-do we have a button where we can move to to-do up or down? Well then it kind of gets messy. We click down and we click up and this selected element from the button, well it just stays below so it doesn't move up with this uh, with the row itself. So this is not what we want. So how can we fix that? Well, we can fix that by using a unique key that helps react identify what element should be shown where, um, and stays the same when we are changing the order of our array. But where should we get our key? Well the most obvious solution and the solution I use in 99% of the cases we should use a database key because they are unique by nature.\n'slidetext': ''\n'from': 'vector'\n'score': 0.9063214063644409\n'normalizedScore': 0.8921830530951613\n'beforeDatePenaltyScore': 0.9063214063644409\n\n'documentId': '1ae09fdefb18f120d737740a'\n'chunk_id': '687a20f8a98d5a30b3a34096'\n'access': 'restricted'\n'part_number': 6\n'total_parts': 7\n'contentType': 'RHEINGOLD'\n'title': Mastering React: 5 Antipatterns and How to Fix Them\n'parentName': International JavaScript Conference Munich 2024\n'language': 'EN'\n'date': '2024-11-14T08:00:00.000Z'\n'abstract': This presentation unveils five critical antipatterns that have significantly slowed down our React application. Each section delves into a specific mistake, examining the challenges it created and the solutions implemented to address these issues. By analyzing real-world examples, this session offers invaluable insights and practical strategies for avoiding similar pitfalls in your development projects. Join us to gain the expertise needed to enhance performance and efficiency, driving your applications to new heights.\n'parentId': 'R8y8tP2vbKi3twHpf'\n'parentDescription': The JavaScript Fullstack Conference - Angular, Node.js, React and more\n'indexBrandName': 'InternationalJavaScriptCon'\n'indexSeriesName': 'Munich'\n'author': 'Jonas Herrmannsdörfer'\n'chunkSource': 'text'\n'text': it in state when it can be calculated during rendering. I mean it's probably not noticeable to the user but well it's one less update that we have simpler because you remove that use effect, we remove well it's quite easy to introduce some bugs So yeah, a lot of advantages Yeah, just do it. for cash and expensive calculations. Um, then we have a new to-do state This runs whenever the to-do changes or the filter changes But when we look at this, well it's the same thing again, and use effect and just do it during rendering. and we just can just render that so simple as that. But in this case, So if it is the case that the um, for expensive calculations. and the first render just runs the um, the code inside whenever the to-dos But if they don't change and doesn't have to rerun that get filter to-DOS function. otherwise it just used to memorize value But what is important first is well when is the And most of the time in the front end the calculations transforming a little bit of data that is not high-end device without any problems. and doing wild transformations. but that's something you have to discuss in, you should only do an optimization if you notice beforehand because your code just gets more complicated in because well no one will notice it anyway. what functions are really taking that that long of the time when my application had performance problems, 'cause I was asking for too much data and filter function or something like that. and GraphQL and react. Maybe some of you are using craft QL Um, yeah to recap that, well first and if it is expensive, well you should use use memo instead that one is actually happening quite often or have any other event. And additionally when someone else is reading that code, that is well happening from an event, to share when you should use uh, an uh, an event handler. The handle by click function, this adds a product and navigates to the checkout. Hmm. So we are doing that in use effect. and if that product is in the cart, we want Well okay why? Oops, why is that problematic? depending on what you do, maybe you store it in local that product is still in the card Well every time you refresh and your user gets kind of confused So when should it be in effect because the component was displayed Um, and in our case, well that shouldn't be run So how can we do that? We add a new function by product. We use that in the handle by click We also do that navigation to the checkout page. Well\n'slidetext': ''\n'from': 'vector'\n'score': 0.911060094833374\n'normalizedScore': 0.8912628292099595\n'beforeDatePenaltyScore': 0.911060094833374\n\n\n Dieser Content von  ist in deiner Sprache nicht verfügbar. Zurück zur Antwort"
}