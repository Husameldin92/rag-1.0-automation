{
  "test_id": "test_001_de",
  "query": "Was sind die Hauptfunktionen von Angular Signals in Version 17?",
  "endpoint": "reader_explore",
  "user": {
    "tier": "elevate",
    "language": "de"
  },
  "prompt": "main",
  "actual_response": "gpt-4.1-mini keyword: Angular Signals 17 16 15 Hauptfunktionen\nAngular Signals in Version 17 sind ein zentraler Bestandteil der „Angular Renaissance“ und stellen einen neuen reaktiven Basisdatentyp dar, der die Art und Weise der Zustandsverwaltung und Change Detection in Angular grundlegend verändert. Die Hauptfunktionen und Merkmale von Angular Signals in Version 17 lassen sich wie folgt zusammenfassen:\n\nReaktiver Basisdatentyp für State ManagementSignals sind Wrapper um Werte, die bei Änderungen interessierte Konsumenten informieren. Sie ermöglichen eine feingranulare, lokale Change Detection, die nur die Komponenten aktualisiert, deren Signalwerte sich geändert haben. Dies führt zu einer verbesserten Performance gegenüber der bisherigen globalen Change Detection.Beispiel:  \nconst count = signal(0);  \ncount.set(3);\n\nDabei müssen Signals mit einem Initialwert versehen werden und werden wie immutable Datenstrukturen behandelt. Die bisherige Möglichkeit, Signals per Mutation zu verändern (signal.mutate()), wurde in Angular 17 entfernt und durch eine Update-Funktion ersetzt.Beispiel für Update:  \nitems.update(itemsArray => [itemsArray, ...newItem]);\n\n\nStabilisierung und Integration in Angular CoreDie in Angular 16 als Developer Preview eingeführten Signals sind in Angular 17 als stabil markiert. Sie sind nun fester Bestandteil des Frameworks und werden für die zukünftige Entwicklung von Angular-Anwendungen empfohlen.\n\nVerbesserte Change DetectionSignals ermöglichen eine „lokale Change Detection“, die nur die tatsächlich betroffenen Komponenten überprüft, im Gegensatz zur bisherigen globalen oder OnPush-Change Detection. Dies reduziert unnötige Prüfungen und verbessert die Laufzeitperformance.\n\nNeue Lifecycle-Hooks für KomponentenAngular 17 führt zwei neue Lifecycle-Hooks ein, die eng mit Signals zusammenhängen: afterRender() und afterNextRender(). Diese können als Callback-Funktionen genutzt werden, um nach dem Rendern einer Komponente Aktionen auszuführen, ähnlich wie die computed()-Funktion bei Signals.\n\nSignal-basierte KomponentenkommunikationMit Angular 17.1 und 17.2 wurden Input Signals und Model Signals eingeführt, die eine Signal-basierte Property-Bindung und Two-way Bindings ermöglichen. Dies ersetzt teilweise die bisherigen Dekoratoren wie @Input und @Output durch Funktionen, die eine bessere Typisierung und Signal-Integration bieten.\n\nIntegration mit RxJSObwohl Signals bewusst einfach gehalten sind, harmonieren sie gut mit RxJS. Angular bietet einen Interop-Layer (@angular/core/rxjs-interop), der die Umwandlung zwischen Signals und Observables ermöglicht. So können Entwickler die Vorteile beider Welten nutzen: Signals für synchrone Datenbindung und RxJS für asynchrone Ereignisverarbeitung.\n\nNeue Control-Flow-Syntax und Lazy LoadingAngular 17 führt eine neue Control-Flow-Syntax ein (z. B. @switch, @case, @default, @defer), die auf Signals basiert und das bedingte Laden und Vorladen von Komponenten unterstützt. Dies verbessert die Performance durch Lazy Loading und optimierte Rendering-Strategien.\n\nBreaking Changes im Umgang mit Signals  \n\nDie Mutation von Signals wurde entfernt; Änderungen erfolgen nur noch über set oder update.  \nRouter-Konfigurationen wurden angepasst, um mit der neuen Architektur kompatibel zu sein.\n\n\n\nZusammenfassend sind Angular Signals in Version 17 ein leistungsfähiges, reaktives State-Management-Werkzeug, das die Performance verbessert, die Komplexität reduziert und die Grundlage für moderne Angular-Anwendungen bildet. Entwickler sollten neue Anwendungen mit Signals planen und bestehende Anwendungen schrittweise migrieren, um von den Vorteilen zu profitieren.\nQuellen:  \n\n„Angular 17: Neues Release des Web-Frameworks“ (iJS Magazin 2.2024)  \n„Renaissance? Angular 17! Neues Release des Web-Frameworks“ (Entwickler Magazin 2.2024)  \n„Angular: Signals, Standalone, SSR – So bauen Sie Angular-Apps der Zukunft“ (Windows Developer 7.2024)  \n„Signal-basierte Komponentenkommunikation in Angular 17.1 und 17.2“ (Windows Developer 5.2024)  \n„Professional Tips for Using Signals in Angular“ (JavaScript Magazine Volume 17)  \n„Signals und State Management – Frontend-Entwicklung mit Signals – Teil 3“ (Windows Developer 2.2024)  \n„Angular Signals: Gamechanger für reaktive Entwicklung“ (JavaScript Days 2024)  \n„Angular 17: The Web Framework's Newest Release“ (JavaScript Magazine Volume 12)04721391f3f7580f0631b9d3Die mit Angular 16 eingeführten Signals sind nun als Stable markiert. Das eigentliche Ziel bei Einführung der Signals war es, zone.js optional zu machen, indem ein neuer, Signal-basierter Change-Detection-Mechanismus eingeführt wird. Mit Angular 17 kommt das Angular-Team diesem Ziel einen großen Schritt näher: Signals ermöglichen eine sogenannte “lokale Change-Detection”, also einen Change-Detection-Vorgang, der sich nur auf die Komponenten bezieht, die auch wirklich geänderte (Signal)-Werte haben.f1151315d5ffa6c7887a8812Ein wichtiger Detail in Angular 17 ist, dass die mit Angular 16 eingeführten Signals nun als Stable markiert sind. Das eigentliche Ziel bei Einführung der Signals war es, zone.js optional zu machen, indem ein neuer, Signal-basierter Change-Detection-Mechanismus eingeführt wird. Die Methode mutate wurde entfernt, zumal sie nicht zur Semantik von Immutables passt.bd2918fe362ada7129c4ae2cSignals werden die Zukunft der Datenbindung in Angular prägen. Das Signals-Konzept selbst ist allerdings nur ein Teil des Ganzen. Wir brauchen auch die Möglichkeit, über Signals mit anderen Komponenten zu kommunizieren. Angular 17.1 bringt dazu Input Signals, und ab Angular 17.2 gibt es Model Signals für Two-way Bindings sowie Unterstützung für Signal-basierte Content- und View-Querys.eba6f5d083b14f4d8d53d87aDer ab Version 16 mit Angular ausgelieferte RxJS-Interop-Layer erlaubt es, die Einfachheit von Signals mit den vielen und teils komplexen Möglichkeiten von RxJS zu kombinieren. Das Ergebnis ist ein Observable, das Arrays mit Flight-Objekten liefert. Die Funktion toSignal erzeugt ein darauf basierendes Signal.de0df53930e2e1e582caf57fDie Möglichkeit, Signals durch Mutation zu verändern, wurde entfernt. Signals müssen als immutable Datenstrukturen behandelt werden; Änderungen sollten durch die signal.update()-Funktion vorgenommen werden. Neben den Signals gibt es Breaking Changes im Router. Diese Properties wurden aus der öffentlichen API entfernt und müssen jetzt über provideRouter() oder RouterModule.forRoot() konfiguriert werden.04721391f3f7580f0631b9d3Einführung der neuen Lifecycle-Hooks afterRender() und afterNextRender sowie die Stabilisierung von Signals. Lazy Loading für Animationen und die Integration der View Transitions DOM-API für optimierte Übergänge und Animationen. Einführung einer neuen Control-Flow-Syntax als Developer Preview, die *ngIf, *ngFor, und ngSwitch ersetzt und zusätzliche Verbesserungen wie @if, @for, und erforderliches Track-by für Listen umfasst.\n\nQuellen:\n\n04721391f3f7580f0631b9d3 Dieser READ-Artikel aus dem iJS Magazin 2.2024 erklärt die Stabilisierung der Signals in Angular 17, ihre Rolle bei der lokalen Change Detection und die neuen Lifecycle-Hooks. Er beschreibt auch die Umstellung auf immutable Datenstrukturen und die neue Control-Flow-Syntax.\nf1151315d5ffa6c7887a8812 In diesem READ-Artikel des Entwickler Magazins 2.2024 werden die Breaking Changes bei Signals in Angular 17 erläutert, insbesondere die Entfernung der Mutation von Signals und die neuen Konfigurationsmöglichkeiten im Router.\nbd2918fe362ada7129c4ae2c Dieser READ-Artikel aus Windows Developer 5.2024 beschreibt die Signal-basierte Komponentenkommunikation mit Input Signals und Model Signals, die in Angular 17.1 und 17.2 eingeführt wurden.\neba6f5d083b14f4d8d53d87a In diesem READ-Artikel aus Windows Developer 7.2023 wird die Integration von Signals mit RxJS über den Interop-Layer erläutert, was die Kombination der Vorteile beider reaktiven Systeme ermöglicht.\nde0df53930e2e1e582caf57f Dieser READ-Artikel aus dem JavaScript Magazine Volume 12 behandelt die Entfernung der signal.mutate()-Funktion, die Umstellung auf immutable Updates und die Anpassungen im Router-API in Angular 17.\n04721391f3f7580f0631b9d3 Der Artikel aus dem iJS Magazin 2.2024 beschreibt zudem neue Features wie die Lifecycle-Hooks, Lazy Loading für Animationen und die neue Control-Flow-Syntax, die eng mit Signals zusammenhängen.\n\nMehr zu diesem Thema:\n\n68fe3d9fc389515d1d6bea43 Dieses fortgeschrittene COURSE-Material „Professional Tips for Using Signals in Angular“ bietet vertiefte Einblicke und praktische Tipps zum effektiven Einsatz von Signals. ⚠️ Zugang ist auf „elevate“ beschränkt, daher haben Sie Zugriff.\n5229d453d1393d2c3d86e145 Ein weiterer READ-Artikel aus Windows Developer 2.2024, der die Auswirkungen von Signals auf das State Management und die zukünftige Bedeutung des NgRx Signal Store behandelt.\n9836770500f149a58b7769f9 Ein READ-Artikel aus dem JavaScript Magazine Volume 17, der drei professionelle Tipps für die Nutzung von Signals gibt und die Harmonisierung mit RxJS erläutert.\n8b35e3d0070110b78d6c9434 Ein umfassender READ-Artikel aus Windows Developer 7.2024, der die Angular Renaissance beschreibt und die Rolle von Signals, Standalone-Komponenten und SSR in Angular 17 darstellt.\n\nChunks:\n'contentType': READ\n'documentId': de0df53930e2e1e582caf57f\n'title': Angular 17: The Web Framework's Newest ReleaseRenaissance? Angular 17! - All features at a glance\n'abstract': The popular JavaScript framework Angular has released version 17. It can be difficult to keep up with all the changes in angular, but this article covers an overview of Angular 17 features.\n'parentName': JavaScript Magazine Volume 12\n'parentDescription': Broaden your knowledge and expand your JavaScript techniques and practices. From Angular, React, and WebAssembly, to the best JavaScript IDEs, open source tools and more, you’ll learn insights on everything JS from seasoned experts in their field. Keep up with JavaScript news, tips, and advice with interviews, tutorials, and in-depth articles.\n'author': Karsten Sitterberg\n'language': EN\n'date': Fri Mar 22 2024 02:00:00 GMT+0000 (Coordinated Universal Time)\n'access': granted\n'chunkSource': text\n'text': can also be reloaded using a time trigger. You must give a trigger a duration to load the component after. For example, Listing 17 specifies that the defer block should start loading the '' component after 1.5 seconds. Regardless of the 'on' condition used, the '@loading' block can be given an 'after' and/or a 'minimum' duration. In Listing 17, the 'after' specification ensures that the loading state is displayed after 100 milliseconds at the earliest. The 'minimum' specification makes sure that the loading state is displayed for at least 150 milliseconds. Similarly, the 'minimum' specification for '@placeholder' ensures that the placeholder is displayed for at least 150 milliseconds before displaying the loading state. @defer (on timer(1500ms)) {  } @loading (after 100ms; minimum 150ms) { \n\n...Loading... } @placeholder (minimum 100ms) { Placeholder } Listing 17: Timer condition and minimum specifications The new defer syntax also allows direct optimization. An optional 'prefetch' statement can also be specified in the defer condition. The logic specified after the prefetch statement corresponds to the defer logic described above. In Listing 18, a component should only be displayed when the state of the variable 'isVisible' changes to 'true'. The prefetch condition is used so the component can be displayed now without loading time. Once the 'prefetchCondition' variable changes to 'true', Angular prefetches the '@defer' block content. If 'isVisible' changes to 'true', no more loading time is needed, since the component is already 'present' and only needs to be rendered. In the example shown in Listing 18, an 'on' condition is used for pre-fetching instead of a 'when' condition. In this case, Angular starts reloading the component when the outer component has rendered. @defer (when isVisible; prefetch when prefetchCondition) { //... @defer (when isVisible; prefetch on immediate) { //... Listing 18: Prefetch conditions Angular CLI 17 will have an automatic migration to transform the old control flow directives to the new syntax. This should simplify changing to the new syntax. But at least in Angular 17, both syntax variants can still be used. Breaking Changes Since Angular 17 is a major release, there’s also a few breaking changes. One breaking change concerns the Signal feature introduced in Angular 16. Signals were still in a preview mode in Angular 16, hence the short time until this change. With Signals, it’s been shown that the 'signal.mutate()' function can cause inconsistencies in the application. Therefore, the option to change a Signal has been removed. Signals should no longer be changed by mutation, but should be used like an immutable data structure instead. Listing 19 shows an\n'slidetext': \n'part_name': 11\n'total_parts': 15\n'from': index\n'score': 118.17251586914062\n'normalizedScore': 1.6481133064182514\n'beforeDatePenaltyScore': 1.6881787981305802\n\n'contentType': READ\n'documentId': 04721391f3f7580f0631b9d3\n'title': Angular 17: Neues Release des Web-FrameworksRenaissance? Angular 17! - Alle Features im Überblick\n'abstract': Das beliebte JavaScript-Framework Angular veröffentlicht Version 17. Da bei Angular viel in Bewegung ist, kann manch einer da den Überblick verlieren. Wir stellen alle Features von Angular 17 vor.\n'parentName': iJS Magazin 2.2024\n'parentDescription': Kaum ein Softwareprojekt, das nicht in wesentlichen Teilen auf der JavaScript-Technologie basiert. Eine breite Unterstützung sowie, leistungsfähige Programmiersprachen, die Vielzahl moderner Tools, sowie ausgereifte Frameworks wie Angular, React, Vue.js oder Node.js machen den JavaScript-Werkzeugkasten zu einem Alleskönner. Das iJS Magazin informiert aktuell und umfassend über die wichtige und innovative Entwicklungen im JavaScript-Universum und bietet handfeste Praxisinformationen für Softwareentwickler und -architekten.\n'author': Karsten Sitterberg\n'language': DE\n'date': Wed Apr 03 2024 22:00:00 GMT+0000 (Coordinated Universal Time)\n'access': granted\n'chunkSource': text\n'text': wird, entspricht der oben beschriebenen Defer-Logik. In Listing 18 oben soll zum Beispiel eine Komponente erst dann angezeigt werden, wenn der Zustand der Variablen “isVisible” auf “true” wechselt. Damit die Komponente zu diesem Zeitpunkt dann ohne Ladezeit angezeigt werden kann, wird die Prefetch-Bedinung verwendet: Sobald die Variable “prefetchCondition” auf “true” wechselt, lädt Angular den Inhalt des “@defer”-Block vor. Wenn im Anschluss “isVisible” auf “true” wechselt, wird keine Ladezeit mehr benötigt, da die Komponente schon “vorhanden” ist und nur noch gerendert werden muss. Im unteren Beispiel aus Listing 18 wird statt einer “when”-Bedinung eine “on”-Bedinung zum pre-fetchen verwendet. In diesem Fall fängt Angular mit dem Nachladen der Komponente an, sobald die äußere Komponente gerendert wurde. Listing 18: Prefetch-Bedingungen @defer (when isVisible; prefetch when prefetchCondition) { //... @defer (when isVisible; prefetch on immediate) { //... Um die alten Control-Flow-Direktiven auf die neue Syntax zu transformieren, wird es im Angular-CLI 17 eine automatische Migration geben, die den Wechsel zur neuen Syntax vereinfachen soll. Zumindest in Angular 17 sind aber noch beide Syntax-Varianten verwendbar. Breaking Changes in Angular 17 Da Angular 17 ein Major Release ist, gibt es entsprechend auch ein paar Breaking Changes. Ein Breaking Change betrifft das mit Angular 16 eingeführte Feature der Signals. Die Signals wurden mit Angular 16 noch als Developer-Preview gehandelt, daher die kurze Zeit bis zu dieser Änderung. Bei den Signals hat es sich gezeigt, dass die “signal.mutate()”-Funktion zu Inkonsistenzen in der Anwendung führen kann. Daher wurde diese Möglichkeit, ein Signal zu ändern, entfernt. Signals sollten nun nicht mehr per Mutation verändert werden, sondern stattdessen immer wie eine immutable Datenstruktur verwendet werden. In Listing 19 ist beispielhaft gezeigt, wie ein Signal, das ein Array enthält, bisher verändert werden konnte, und wie es ab Angular 17 geschehen sollte. Listing 19: Items zu einem “Signal” hinzufügen im Angular 16/17-Vergleich // Mit Angular 16 items.mutate(itemsArray => itemsArray.push(newItem)); // Ab Angular 17: items.update(itemsArray => [itemsArray, ...newItem]); Neben den Signals gibt es Breaking Changes im Router. Dieser hat bisher die Properties - “canceledNavigationResolution“ - “paramsInheritanceStrategy“\n'slidetext': \n'part_name': 16\n'total_parts': 21\n'from': index\n'score': 115.31459045410156\n'normalizedScore': 1.60834059500967\n'beforeDatePenaltyScore': 1.6473512922014508\n\n'contentType': READ\n'documentId': de0df53930e2e1e582caf57f\n'title': Angular 17: The Web Framework's Newest ReleaseRenaissance? Angular 17! - All features at a glance\n'abstract': The popular JavaScript framework Angular has released version 17. It can be difficult to keep up with all the changes in angular, but this article covers an overview of Angular 17 features.\n'parentName': JavaScript Magazine Volume 12\n'parentDescription': Broaden your knowledge and expand your JavaScript techniques and practices. From Angular, React, and WebAssembly, to the best JavaScript IDEs, open source tools and more, you’ll learn insights on everything JS from seasoned experts in their field. Keep up with JavaScript news, tips, and advice with interviews, tutorials, and in-depth articles.\n'author': Karsten Sitterberg\n'language': EN\n'date': Fri Mar 22 2024 02:00:00 GMT+0000 (Coordinated Universal Time)\n'access': granted\n'chunkSource': text\n'text': the 'signal.mutate()' function can cause inconsistencies in the application. Therefore, the option to change a Signal has been removed. Signals should no longer be changed by mutation, but should be used like an immutable data structure instead. Listing 19 shows an example of how a Signal containing an array could previously be changed and how it should be done from Angular 17 onwards. // With Angular 16 items.mutate(itemsArray => itemsArray.push(newItem)); // From Angular 17: items.update(itemsArray => [itemsArray, ...newItem]); Listing 19: Comparing adding items to a 'Signal' between Angular 16/17 Besides Signals, there are also breaking changes in the router. So far, this has the properties: - “canceledNavigationResolution“ - “paramsInheritanceStrategy“ - “titleStrategy“ - “urlUpdateStrategy“ - “malformedUriErrorHandler“ - “urlHandlingStrategy“ With Angular 17, these properties were removed from the router’s public API. Instead of using the router, these properties should now be configured with the corresponding configuration parameters in the 'provideRouter()' function or the 'RouterModule.forRoot()' hook. Angular 17 in Practice The changes allow new types of architecture and optimizations which were previously impossible or difficult to implement. An example from practice illustrates this: A played a leading role in developing an integrated platform to provide effective, secure, fully GDPR-compliant remote training. If you look at a live screenshot (Figure 3), you’ll see that the audio and video control is directly available in the primary view (bottom left switch). This means that the associated components and services cannot be reloaded later with lazy loading, since there’s no nested route that would allow the code to be split accordingly. This is now possible thanks to the new option to carry out code splitting and lazy loading at the component level. This means that initial application loads are considerably faster, since audio/video functionality in particular is complex and accounts for large portions of the code. Figure 3: A complex Angular real-time application It is also advantageous to be able to do without zone.js and implement better controlled and fine-grained change detection using Signals. This leads to an overall improved performance and reduced load on the client system. On the other hand, this requires corresponding changes that cannot be implemented by an automatic code transformation. All involved developers must learn the new concepts and master them in depth in order to effectively and meaningfully use these new possibilities. By the way, what about the Angular module system? It still exists today, but the plan is to make modules optional in the future. This is also intended to make it easier for new developers to get started with Angular. Angular Material Angular Material 17 introduces both an important and significant change for\n'slidetext': \n'part_name': 12\n'total_parts': 15\n'from': index\n'score': 110.91653442382812\n'normalizedScore': 1.5444564286280729\n'beforeDatePenaltyScore': 1.5845219203404017\n\n'contentType': READ\n'documentId': de0df53930e2e1e582caf57f\n'title': Angular 17: The Web Framework's Newest ReleaseRenaissance? Angular 17! - All features at a glance\n'abstract': The popular JavaScript framework Angular has released version 17. It can be difficult to keep up with all the changes in angular, but this article covers an overview of Angular 17 features.\n'parentName': JavaScript Magazine Volume 12\n'parentDescription': Broaden your knowledge and expand your JavaScript techniques and practices. From Angular, React, and WebAssembly, to the best JavaScript IDEs, open source tools and more, you’ll learn insights on everything JS from seasoned experts in their field. Keep up with JavaScript news, tips, and advice with interviews, tutorials, and in-depth articles.\n'author': Karsten Sitterberg\n'language': EN\n'date': Fri Mar 22 2024 02:00:00 GMT+0000 (Coordinated Universal Time)\n'access': granted\n'chunkSource': text\n'text': 1: Old Angular-Logo on the left and new Angular-Logo on the right. Angular Angular 17 comes with a lot of new features. The Angular team calls it one of the 'biggest' releases in its history. Besides the version updates for zone.js and TypeScript, it also offers many smaller and larger innovations. Two innovations related to the new APIs regarding Signals have already been added in Angular 16.2.0. Namely, it adds two new component lifecycle hooks. These are special because they don’t have to be implemented with an interface like conventional lifecycle hooks. They can be called as a callback function. This is similar to the 'computed()' function in Signals. Listing 6 shows an example with the new hooks. The two hooks are called 'afterRender()' and 'afterNextRender()' and are executed, according to their name, after Angular renders the respective component. The difference between the two hooks is that 'afterNextRender()' is only called once, after the next rendering process, while 'afterRender()' remains active as long as the component is active. However, these two hooks are still listed as 'Developer Preview' and are subject to change. @Component({}) export class DemoComponent { val = 42; constructor() { afterRender(() => { console.log('afterRender', this.val); }); afterNextRender(() => { console.log('afterNextRender', this.val); }); } } Listing 6: Implementing the new lifecycle hooks Signals An important detail in Angular 17 is that the signals introduced in Angular 16 are now stable. The goal of introducing Signals was to make zone.js optional by introducing a new, signal-based change detection mechanism. In Angular 17, the team has come a step closer to this goal. Signals enable 'local change detection', a change detection process that only refers to the components that have changed (signal) values. Figure 1 shows an example of the difference between the change detection mechanisms. In the standard case, the complete component graph is checked for each asynchronous event. With OnPush-ChangeDetection, components that triggered the change detection or have changed '@Input()' values and their respective parent components (up to the AppComponent) are checked. With Signals, you can now check only the components that have changed signal values. Figure 2: Comparing change detection mechanisms Animations Animations can be reloaded in Angular 17 with lazy loading. The browser must first load smaller bundles, making the initial application smaller, leading to shorter application loading and start times. To activate lazy loading for animations, the 'provideAnimationsAsync()' function must be used. Here, the 'BrowserAnimationModule' should no longer be imported and the 'provideAnimations()' function should no longer be used. The special thing about an SPA is that, as a rule,\n'slidetext': \n'part_name': 5\n'total_parts': 15\n'from': index\n'score': 99.96965789794922\n'normalizedScore': 1.3880724782583742\n'beforeDatePenaltyScore': 1.428137969970703\n\n'contentType': READ\n'documentId': 64ace3828d8056484c3534ab\n'title': Angular 16 releasedAlles zu neuen Features und Breaking Changes\n'abstract': Wir geben einen Überblick zu allen wichtigen Infos zum Release von Angular 16. Alles zu Signals, der Angular-CLI und TypeScript in Angular 16 erfahren Sie hier.\n'parentName': iJS Magazin Band 27\n'parentDescription': Kaum ein Softwareprojekt, das nicht in wesentlichen Teilen auf der JavaScript-Technologie basiert. Eine breite Unterstützung sowie, leistungsfähige Programmiersprachen, die Vielzahl moderner Tools, sowie ausgereifte Frameworks wie Angular, React, Vue.js oder Node.js machen den JavaScript-Werkzeugkasten zu einem Alleskönner. Das iJS Magazin informiert aktuell und umfassend über die wichtige und innovative Entwicklungen im JavaScript-Universum und bietet handfeste Praxisinformationen für Softwareentwickler und -architekten.\n'author': Karsten Sitterberg\n'language': DE\n'date': Thu Apr 06 2023 00:00:00 GMT+0000 (Coordinated Universal Time)\n'access': granted\n'chunkSource': text\n'text': die technische, aber auch die konzeptionelle Komplexität reduziert werden. Gleichzeitig hat das Thema auch etwas Beigeschmack: Die offiziellen Diskussionen wurden erst ca. drei Wochen vor Verabschiedung des ersten Release-Candidate von Angular 16 öffentlich gestartet. Bei einer Entwicklungszeit von sechs Monaten und den potenziell immensen Konsequenzen einer solchen Designänderung wirkt das schon sehr kurzfristig. Kritische Kommentare in den RFC Diskussionen wurden zudem sehr diplomatisch abgetan, es wirkt, als sei sowieso alles intern durch das Angular-Team und Google entschieden worden. Assoziationen mit Paris 2016 sind dabei nicht ganz unbegründet. So ein Vorgehen stellt ein ernstzunehmendes Risiko für die Angular-Community dar. Ob Angular damit wirklich konzeptionell simpler wird, solange der mitgelieferte HttpClient RxJS verwendet, darf auch bezweifelt werden. Schließlich kommen Entwickler so zwangsläufig mit beiden Konzepten in Kontakt. Aber vielleicht wird ja auch drei Wochen vor dem ersten Release Candidate von Angular 17 der HttpClient mit demselben Argument abgekündigt. Auch wenn es sich also um vielversprechende Visionen und fast schon eine neue Generation Angular handelt - etwas mehr Fingerspitzengefühl und Transparenz wären hier wünschenswert. Technisch handelt es sich bei den Signals um eine Reactivity-Engine, mit der Änderungen am Zustand von speziellen Daten-Objekten zu Updates der zugehörigen DOM-Elemente führen. Anders als Promises und RxJS-Observable sind Aktionen auf “Signals” stets synchron. Da Webanwendungen inhärent durch Events getrieben sind, passt RxJS prinzipiell sehr gut. Daher gibt es zur Transformation zwischen Signals und Observables das neue Paket @angular/rxjs-interop, das Transformations-APIs wie ‘toObservable()’ und ‘toSignal()’ zur Verfügung stellt. Ein Signal kann einfach erzeugt werden, indem die neue Funktion signal() aufgerufen wird. Der Typ-Parameter T steht dabei für den Datentypen, der von diesem Signal “verwaltet” werden soll. In Listing 19 ist anhand des Signal counter zu sehen, dass der Typ eines Signal auch durch Definition eines Initialwertes, hier die Zahl 0, festlegen kann. Ausgelesen wird das Signal dann, indem es wie eine Funktion aufgerufen wird. Das ist beispielsweise im Template der Komponente aus Listing 19 gezeigt. Normalerweise sollte bei Ausgaben in Templates\n'slidetext': \n'part_name': 15\n'total_parts': 21\n'from': index\n'score': 101.26533508300781\n'normalizedScore': 1.3777259879470782\n'beforeDatePenaltyScore': 1.4466476440429688\n\n'contentType': READ\n'documentId': 8b35e3d0070110b78d6c9434\n'title': Angular: Signals, Standalone, SSRSo bauen Sie Angular-Apps der Zukunft\n'abstract': Mit der Veröffentlichung der 16. Hauptversion von Angular läutete das Angular-Team die „Angular Renaissance“ ein. Wörtlich übersetzt bedeutet das nichts Geringeres als die Wiedergeburt von Googles SPA-Framework - eine treffende Bezeichnung, denn Angular-Codebasen werden sich nachhaltig verändern. Der Unterschied zwischen Angular-2- und Angular-17-Code ist mit bloßem Auge erkennbar.\n'parentName': Windows Developer 7.2024\n'parentDescription': Windows Developer informiert umfassend und herstellerneutral über die neuen Trends und Möglichkeiten der Software- und Systementwicklung rund um Microsoft- und Web-Technologien. Von der klassischen .NET-Entwicklung über .NET Core bis hin zu neuen Technologien wie Windows 10, Microsoft Azure und der ganzen Bandbreite der aktuellen Web-, Phone- und Tabletentwicklung für Android und iOS mit Xamarin und unterschiedlichen JavaScript-Frameworks. Professionelle Entwickler und IT-Entscheider erhalten genau die Informationen, die sie für den erfolgreichen Einsatz von unternehmensorientierten Lösungen benötigen.\n'author': Christian Liebel\n'language': DE\n'date': Mon Jun 10 2024 22:00:00 GMT+0000 (Coordinated Universal Time)\n'access': granted\n'chunkSource': text\n'text': Angular: Signals, Standalone, SSR So bauen Sie Angular-Apps der Zukunft Mit der Veröffentlichung der 16. Hauptversion von Angular läutete das Angular-Team die „Angular Renaissance“ ein. Wörtlich übersetzt bedeutet das nichts Geringeres als die Wiedergeburt von Googles SPA-Framework - eine treffende Bezeichnung, denn Angular-Codebasen werden sich nachhaltig verändern. Der Unterschied zwischen Angular-2- und Angular-17-Code ist mit bloßem Auge erkennbar. Mit der Veröffentlichung der 16. Hauptversion von Angular läutete das Angular-Team die „Angular Renaissance“ ein. Wörtlich übersetzt bedeutet das nichts Geringeres als die Wiedergeburt von Googles SPA-Framework – eine treffende Bezeichnung, denn Angular-Codebasen werden sich nachhaltig verändern. Der Unterschied zwischen Angular-2- und Angular-17-Code ist mit bloßem Auge erkennbar. Derzeit führt das Angular-Team zahlreiche neue Features und Konzepte in das Framework ein. Ziel dieser Änderungen ist, Angular zu vereinfachen und damit Anfänger:innen den Einstieg zu erleichtern, Schnittstellen zu modernisieren und die Performance von Angular-Anwendungen zu verbessern, damit das Framework auch im kommenden Jahrzehnt seines Bestehens konkurrenzfähig bleibt. Alle neuen Funktionen sind abwärtskompatibel und interoperabel. In diesem Artikel soll es um drei dieser Features gehen: 1. den neuen reaktiven Basisdatentyp Signals, 2. die Standalone-Schnittstellen als NgModule-Killer und 3. den neuen Ansatz zum Server-side Rendering, der es in die 17. Hauptversion von Angular geschafft hat. Angular-Entwickler:innen, die neue Anwendungen erstellen, sollten diese Features in jedem Fall berücksichtigen. Bestandsanwendungen sollten schnellstmöglich migriert werden. In diesem Artikel wird zu jedem Feature angegeben, ob, wann und wie eine Migration vorgenommen werden sollte. Signals – Die neue Art des State Management Mit der 16. Hauptversion von Angular wurden Signals in das Framework eingeführt. Es handelt sich um den neuen reaktiven Basisdatentyp [1]. Ein Signal ist ein Wrapper um einen bestimmten Wert. Wenn sich dieser ändert, informiert das Signal interessierte Konsumenten, sodass diese auf die Änderung reagieren können. const count = signal(0); count.set(3); Ein neues schreibbares Signal lässt sich über die Methode signal() erzeugen. Signals müssen zwingend mit einem Initialwert vorbelegt sein, der als Argument angegeben wird. Es ist\n'slidetext': \n'part_name': 1\n'total_parts': 9\n'from': index\n'score': 97.78054809570312\n'normalizedScore': 1.3634433166998685\n'beforeDatePenaltyScore': 1.396864972795759\n\n'contentType': READ\n'documentId': 04721391f3f7580f0631b9d3\n'title': Angular 17: Neues Release des Web-FrameworksRenaissance? Angular 17! - Alle Features im Überblick\n'abstract': Das beliebte JavaScript-Framework Angular veröffentlicht Version 17. Da bei Angular viel in Bewegung ist, kann manch einer da den Überblick verlieren. Wir stellen alle Features von Angular 17 vor.\n'parentName': iJS Magazin 2.2024\n'parentDescription': Kaum ein Softwareprojekt, das nicht in wesentlichen Teilen auf der JavaScript-Technologie basiert. Eine breite Unterstützung sowie, leistungsfähige Programmiersprachen, die Vielzahl moderner Tools, sowie ausgereifte Frameworks wie Angular, React, Vue.js oder Node.js machen den JavaScript-Werkzeugkasten zu einem Alleskönner. Das iJS Magazin informiert aktuell und umfassend über die wichtige und innovative Entwicklungen im JavaScript-Universum und bietet handfeste Praxisinformationen für Softwareentwickler und -architekten.\n'author': Karsten Sitterberg\n'language': DE\n'date': Wed Apr 03 2024 22:00:00 GMT+0000 (Coordinated Universal Time)\n'access': granted\n'chunkSource': text\n'text': Hooks besteht darin, dass “afterNextRender()” nur einmal, nach dem nächsten Rendering-Vorgang, aufgerufen wird, während “afterRender()” aktiv bleibt, solange die Komponente aktiv ist. Diese beiden Hooks sind allerdings noch als “Developer Preview” geführt, können sich also noch ändern. Listing 6: Implementierung der neuen Lifecycle-Hooks @Component({}) export class DemoComponent { val = 42; constructor() { afterRender(() => { console.log('afterRender', this.val); }); afterNextRender(() => { console.log('afterNextRender', this.val); }); } } Signals sind stable in Angular 17 Ein wichtiges Detail in Angular 17 ist, dass die mit Angular 16 eingeführten Signals nun als Stable markiert sind. Das eigentliche Ziel bei Einführung der Signals war es, zone.js optional zu machen, indem ein neuer, Signal-basierter Change-Detection-Mechanismus eingeführt wird. Mit Angular 17 kommt das Angular-Team diesem Ziel einen großen Schritt näher: Signals ermöglichen eine sogenannte “lokale Change-Detection”, also einen Change-Detection-Vorgang, der sich nur auf die Komponenten bezieht, die auch wirklich geänderte (Signal)-Werte haben. In Abbildung 2 ist beispielhaft der Unterschied zwischen den verschiedenen Change-Detection-Mechanismen dargestellt. Im Standardfall wird bei jedem asynchronen Event der komplette Komponentengraph überprüft. Bei OnPush-ChangeDetection werden die Komponenten überprüft, die die Change-Detection ausgelöst haben, oder geänderte “@Input()”-Werte haben, und deren jeweilige Parent-Komponenten (bis hoch zur AppComponent). Mit Signals ist es nun möglich, dass wirklich nur die Komponenten überprüft werden, die geänderte Signal-Werte haben. Abbildung 2: Change-Detection-Mechanismen im Vergleich Animations mit Lazy-Loading in Angular 17 Animationen können in Angular 17 per Lazy Loading nachgeladen werden. Dadurch muss der Browser initial kleinere Bundles laden, macht also die initiale Anwendung kleiner und führt somit zu geringeren Anwendungs-Lade- und -Startzeiten. Um das Lazy-Loading der Animationen zu aktivieren, muss die Funktion “provideAnimationsAsync()” verwendet werden. Das “BrowserAnimationModule” sollte in diesem Fall dann nicht mehr importiert bzw. die Funktion “provideAnimations()” nicht mehr genutzt werden. Das Besondere an einer SPA ist, dass im Regelfall nur beim Start der Anwendung ein HTML-Dokument geladen wird. Beim Wechsel auf eine andere Route werden lediglich Bestandteile im Browser-DOM ausgetauscht. Damit können Animationen nicht wie bei serverseitigen Anwendungen\n'slidetext': \n'part_name': 8\n'total_parts': 21\n'from': index\n'score': 94.35299682617188\n'normalizedScore': 1.3088892574678175\n'beforeDatePenaltyScore': 1.3478999546595982\n\n'contentType': READ\n'documentId': eba6f5d083b14f4d8d53d87a\n'title': Was ist neu in Angular 16? Signals, Hydration, esbuild und mehrKolumne: Enterprise Angular\n'abstract': Mit Angular 16 kommen gleich zwei große Neuerungen: Signals und Non-destructive Hydration. Außerdem gibt es zahlreiche Abrundungen, die das Arbeiten mit dem Framework vereinfachen. In diesem Artikel gehe ich anhand von Beispielen auf die wichtigsten Neuerungen ein. Den Quellcode findet man im Branch ng16-features auf GitHub [1].\n'parentName': Windows Developer 7.2023\n'parentDescription': Windows Developer informiert umfassend und herstellerneutral über die neuen Trends und Möglichkeiten der Software- und Systementwicklung rund um Microsoft- und Web-Technologien. Von der klassischen .NET-Entwicklung über .NET Core bis hin zu neuen Technologien wie Windows 10, Microsoft Azure und der ganzen Bandbreite der aktuellen Web-, Phone- und Tabletentwicklung für Android und iOS mit Xamarin und unterschiedlichen JavaScript-Frameworks. Professionelle Entwickler und IT-Entscheider erhalten genau die Informationen, die sie für den erfolgreichen Einsatz von unternehmensorientierten Lösungen benötigen.\n'author': Manfred Steyer\n'language': DE\n'date': Tue Jun 13 2023 00:00:00 GMT+0000 (Coordinated Universal Time)\n'access': granted\n'chunkSource': text\n'text': Was ist neu in Angular 16? Signals, Hydration, esbuild und mehr Kolumne: Enterprise Angular Mit Angular 16 kommen gleich zwei große Neuerungen: Signals und Non-destructive Hydration. Außerdem gibt es zahlreiche Abrundungen, die das Arbeiten mit dem Framework vereinfachen. In diesem Artikel gehe ich anhand von Beispielen auf die wichtigsten Neuerungen ein. Den Quellcode findet man im Branch ng16-features auf GitHub [1]. Mit Angular 16 kommen gleich zwei große Neuerungen: Signals und Non-destructive Hydration. Außerdem gibt es zahlreiche Abrundungen, die das Arbeiten mit dem Framework vereinfachen. In diesem Artikel gehe ich anhand von Beispielen auf die wichtigsten Neuerungen ein. Den Quellcode findet man im Branch ng16-features auf GitHub [1]. Signals Die wohl größte Neuerung in Angular 16 sind Signals. Dabei handelt es sich um einen simplen reaktiven Building Block, der künftig eine feingranulare Change Detection ohne Zone.js ermöglichen soll. Ein Signal ist ein Objekt, das einen Wert aufnimmt. Konsumenten können diesen Wert lesen und aktualisieren. Außerdem können sie sich informieren lassen, wenn sich der Wert ändert (Abb. 1). Abb. 1: Signals Bindet sich das Template einer Komponente an ein Signal, stößt Angular die Change Detection an, sobald sich das Signal ändert. Ein Beispiel dafür findet sich in Listing 1, in dem alle zu bindenden Eigenschaften from, to und flights als Signals vorliegen. Listing 1 import { computed, effect, signal } from '@angular/core'; [...] @Component([…]) export class FlightSearchComponent implements OnInit { from = signal('Hamburg'); // in Germany to = signal('Graz'); // in Austria flights = signal([]); flightRoute = computed(() => this.from() + ' to ' + this.to()); constructor() { effect(() => { this.search(); }); } async search() { if (!this.from() || !this.to()) return; const flights = await this.flightService.findPromise( this.from(), this.to() ); this.flights.set(flights); } } Um das Erzeugen der Signals kümmert sich die Funktion signal, die das Angular-Team im Paket @angular/core platziert hat. Diese Funktion liefert ein sogenanntes WritableSignal, also ein Signal, das der Programmcode nicht nur lesen, sondern auch aktualisieren kann. T steht für den Typ des verwalteten Werts. In den meisten Fällen kann signal diesen Typ aus dem übergebenen Standardwert herleiten. Falls nicht, ist ein Typparameter wie bei der Eigenschaft flight an signal zu übergeben.\n'slidetext': \n'part_name': 1\n'total_parts': 9\n'from': index\n'score': 94.95108795166016\n'normalizedScore': 1.293111498595145\n'beforeDatePenaltyScore': 1.356444113595145\n\n'contentType': READ\n'documentId': 64ace3828d8056484c3534ab\n'title': Angular 16 releasedAlles zu neuen Features und Breaking Changes\n'abstract': Wir geben einen Überblick zu allen wichtigen Infos zum Release von Angular 16. Alles zu Signals, der Angular-CLI und TypeScript in Angular 16 erfahren Sie hier.\n'parentName': iJS Magazin Band 27\n'parentDescription': Kaum ein Softwareprojekt, das nicht in wesentlichen Teilen auf der JavaScript-Technologie basiert. Eine breite Unterstützung sowie, leistungsfähige Programmiersprachen, die Vielzahl moderner Tools, sowie ausgereifte Frameworks wie Angular, React, Vue.js oder Node.js machen den JavaScript-Werkzeugkasten zu einem Alleskönner. Das iJS Magazin informiert aktuell und umfassend über die wichtige und innovative Entwicklungen im JavaScript-Universum und bietet handfeste Praxisinformationen für Softwareentwickler und -architekten.\n'author': Karsten Sitterberg\n'language': DE\n'date': Thu Apr 06 2023 00:00:00 GMT+0000 (Coordinated Universal Time)\n'access': granted\n'chunkSource': text\n'text': Vermeidung von Endlosschleifen Signals immer nur gelesen, nie geschrieben werden. Dies wird auch durch die Signal-API überprüft und dann ggf. ein Fehler geworfen. Listing 21: Beispiel für Logging als Signal-Effect constructor() { effect(() => { console.log(this.invoice()) }) } Signals sollen perspektivisch auch selbst - unabhängig von Zone.js - die Change-Detection in Komponenten steuern können. Dieses Verhalten ist noch nicht Teil von Angular 16, soll aber aktiviert werden können, indem signals: true in die Komponenten-Metadaten aufgenommen wird. In dem Fall werden die Inputs einer Komponente auch als Signals statt als veränderliche Objekte ausgeprägt. Allerdings ändert sich auch die Syntax, mit der man @Input, @Output und dergleichen schreibt: All diese Angular-Konzepte sind dann keine @-Decorators mehr, sondern spezielle Signals-Funktionen. Beispielsweise werden Inputs dann zu input()- und Outputs zu output()-Signals. Das passt dann gut dazu, dass die TypeScript Standard-Decorators nicht für Parameter, sondern nur für Typen funktionieren. Ähnlich verhält es sich mit Queries für ‘viewChild/ren’ und ‘contentChild/ren’, auch diese werden dann als Signal bereitgestellt. Im Lifecycle verändert sich die API bei Signal Komponenten ebenfalls: Mit ‘afterNextRender’ wird eine Funktion nach Beendigung des nächsten DOM-Update-Zyklus ausgeführt. Das ist in etwa wie bisher ein ‘ngAfterViewInit’, wird allerdings öfter aufgerufen. Mit ‘afterRender’ wird nach jeder DOM-Aktualisierung der angegebene Callback aufgerufen. Schließlich gibt es noch ‘afterRenderEffect’, der einen ‘effect’ mit jedem ‘afterRender’ aufruft. Insgesamt wirkt das Design bereits jetzt sehr vielversprechend und zukunftsweisend. Einzig die Frage nach der Einheitlichkeit der APIs in Anbetracht der RxJS Verwendung bleibt offen. Hier könnte sich aber auch ein sinnvolles Hybridkonzept etablieren. Aktuell sind Signals noch eine Preview-API und die weitere Entwicklung wird sicherlich auch vom Feedback der Community abhängen. Breaking Changes in Angular 16 Bei Major Releases ist gemäß Semantic-Versioning Konventionen auch stets mit inkompatiblen Änderungen zu rechnen. Das hält auch Angular 16 so, doch halten sich die Auswirkungen für den Großteil der Nutzer sicherlich im Rahmen. So haben sich die Versionsanforderungen der verwendeten Werkzeuge und Frameworks geändert. Zunächst wird als TypeScript-Version mindestens 4.9 verlangt.\n'slidetext': \n'part_name': 18\n'total_parts': 21\n'from': index\n'score': 95.06877136230469\n'normalizedScore': 1.2892036490798908\n'beforeDatePenaltyScore': 1.3581253051757813\n\n'contentType': READ\n'documentId': d0a30c39b6f199c25af1b450\n'title': Extensions und Typisierung mit dem NgRx Signal StoreKolumne: Enterprise Angular\n'abstract': Der kurz nach Angular 17 erschienene NgRx Signal Store bietet eine sehr leichtgewichtige Lösung für State Management. Ohne direkte Abhängigkeiten zu RxJs, setzt er vollständig auf Signals. Seine größte Stärke ist jedoch zweifelsfrei seine hochgradige Erweiterbarkeit und mit sogenannten Custom Features lassen sich wiederkehrende Aufgaben sehr einfach zentral implementieren.\n'parentName': Windows Developer 2.2024\n'parentDescription': Windows Developer informiert umfassend und herstellerneutral über die neuen Trends und Möglichkeiten der Software- und Systementwicklung rund um Microsoft- und Web-Technologien. Von der klassischen .NET-Entwicklung über .NET Core bis hin zu neuen Technologien wie Windows 10, Microsoft Azure und der ganzen Bandbreite der aktuellen Web-, Phone- und Tabletentwicklung für Android und iOS mit Xamarin und unterschiedlichen JavaScript-Frameworks. Professionelle Entwickler und IT-Entscheider erhalten genau die Informationen, die sie für den erfolgreichen Einsatz von unternehmensorientierten Lösungen benötigen.\n'author': Manfred Steyer\n'language': DE\n'date': Tue Jan 09 2024 02:00:00 GMT+0000 (Coordinated Universal Time)\n'access': granted\n'chunkSource': text\n'text': Extensions und Typisierung mit dem NgRx Signal Store Kolumne: Enterprise Angular Der kurz nach Angular 17 erschienene NgRx Signal Store bietet eine sehr leichtgewichtige Lösung für State Management. Ohne direkte Abhängigkeiten zu RxJs, setzt er vollständig auf Signals. Seine größte Stärke ist jedoch zweifelsfrei seine hochgradige Erweiterbarkeit und mit sogenannten Custom Features lassen sich wiederkehrende Aufgaben sehr einfach zentral implementieren. Der kurz nach Angular 17 erschienene NgRx Signal Store bietet eine sehr leichtgewichtige Lösung für State Management. Ohne direkte Abhängigkeiten zu RxJs, setzt er vollständig auf Signals. Seine größte Stärke ist jedoch zweifelsfrei seine hochgradige Erweiterbarkeit und mit sogenannten Custom Features lassen sich wiederkehrende Aufgaben sehr einfach zentral implementieren. Das erste hier präsentierte Beispiel zu Custom Features gestaltet sich sehr geradlinig. Danach wird es etwas anspruchsvoller: Der Konsument eines Features muss in der Lage sein, die Namen der Features und Methoden, eingerichtet von Signals, zu bestimmen. Ansonsten kommt es sehr schnell zu Namenskonflikten. Wie die darauffolgenden Beispiele zeigen, ist das kein Wiederspruch zu einer strengen Typisierung in TypeScript. Die hier gezeigten Ansätze sind inspiriert von einem Beispiel von Marko Stanimirović, dem NgRx-Core-Team-Member hinter dem Signal Store und der mit dem Signal Store ausgelieferten Lösung @ngrx/signals/entity zum Verwalten von Entitäten. Der Quellcode findet sich, wie immer, in meinem GitHub-Repo unter [1] (Branch: arc-signal-store-custom-typed). Signal Store 101 Bevor wir starten, möchte ich alle mit ins Boot holen und die wichtigsten Aspekte des NgRx Signal Store zusammenfassen. Einen detaillierten Überblick gibt es unter [2]. Der Signal Store kommt seit Version 17 mit NgRx und befindet sich im npm-Paket @ngrx/signals. Im Zentrum steht die Funktion signalStore, die einen neuen Signal Store erzeugt. Dabei handelt es sich um einen Angular Service, der zur Zustandsverwaltung Signals, davon abgeleitete (berechnete) Signals sowie Methoden spendiert bekommt (Listing 1). Listing 1 import { patchState, signalStore, withHooks, withMethods, withComputed, withState, } from '@ngrx/signals'; [...] export const FlightBookingStore = signalStore( { providedIn: 'root' }, // State Properties withState({ from: 'Paris', to: 'London', initialized: false,\n'slidetext': \n'part_name': 1\n'total_parts': 8\n'from': index\n'score': 92.88995361328125\n'normalizedScore': 1.2809338456202604\n'beforeDatePenaltyScore': 1.3269993373325892\n\n'contentType': COURSE\n'documentId': 68fe3d9fc389515d1d6bea43\n'title': Professional Tips for Using Signals in Angularnull\n'abstract': The new Signals in Angular are a simple reactive building block. However, as is so often the case, the devil is in the detail. In this article, I will give three tips to help you use Signals in a more straightforward way.\n'parentName': Advanced Angular: Signals, NgRx & AI Forms\n'parentDescription': Level up your Angular skills with this advanced course, highlighting the framework’s evolving features. We will cover cutting-edge topics, from mastering state management with the NgRx Signal store and unlocking AI-enhanced forms’ potential, to revisiting the performance benefits of server-side rendering. You will learn how to effectively use Signals through professional tips and real-world insights, and explore emerging features like httpResource in Angular 19.2. Whether you are scaling enterprise apps or upgrading legacy codebases, this course equips you with the practices to build smarter, faster Angular applications and stay ahead in today’s Angular ecosystem.\n'author': Manfred Steyer\n'language': DE\n'date': Fri May 02 2025 10:49:04 GMT+0000 (Coordinated Universal Time)\n'access': restricted\n'chunkSource': text\n'text': Professional Tips for Using Signals in Angular The new Signals in Angular are a simple reactive building block. However, as is so often the case, the devil is in the detail. In this article, I will give three tips to help you use Signals in a more straightforward way. The new Signals in Angular are a simple reactive building block. However, as is so often the case, the devil is in the detail. In this article, I will give three tips to help you use Signals in a more straightforward way. The examples used for this can be found here. Guiding theory: Unidirectional data flow with signals The approach for establishing a unidirectional data flow (Fig. 1) serves as the guiding theory for my three tips. Fig. 1: Unidirectional data flow with a store Handlers for UI events delegate to the store. I use the abstract term “intention”, since this process is different for different stores. With the Redux-based NgRx store, actions are dispatched; whereas with the lightweight NgRx Signal store, the component calls a method offered by the store. The store executes synchronous or asynchronous tasks. These usually lead to a status change, which the application transports to the views of the individual components with signals. As part of this data flow, the state can be projected onto view models using computed, i.e. onto data structures that represent the view of individual use cases on the state. This approach is based on the fact that signals are primarily suitable for informing the view synchronously about data and data changes. They are less suitable for asynchronous tasks and for representing events. For one, they don’t offer a simple way of dealing with overlapping asynchronous requests and the resulting race conditions. Furthermore, they cannot directly represent error states. Second, signals ignore the resulting intermediate states in the case of directly consecutive value changes. This desired property is called “glitch free”. For example, if a signal changes from 1 to 2 and immediately afterwards from 2 to 3, the consumer only receives a notification about the 3. This is also conducive to data binding performance, especially as updating with intermediate results would result in an unnecessary performance overhead. Tip 1: Signals harmonize with RxJS Signals are deliberately kept simple. That's why it offers fewer options than RxJS, which has been established in the Angular world for years. Thanks to the RxJS interop that Angular provides, the best of both worlds can be combined. Listing 1 demonstrates this. It converts the signals from and to into observables and implements a typeahead based on them. To do this, it uses the operators filter, debounceTime and switchMap provided\n'slidetext': \n'part_name': 1\n'total_parts': 6\n'from': index\n'score': 89.5231704711914\n'normalizedScore': 1.272237004473206\n'beforeDatePenaltyScore': 1.2789024353027343\n\n'contentType': READ\n'documentId': 64ace3828d8056484c3534ab\n'title': Angular 16 releasedAlles zu neuen Features und Breaking Changes\n'abstract': Wir geben einen Überblick zu allen wichtigen Infos zum Release von Angular 16. Alles zu Signals, der Angular-CLI und TypeScript in Angular 16 erfahren Sie hier.\n'parentName': iJS Magazin Band 27\n'parentDescription': Kaum ein Softwareprojekt, das nicht in wesentlichen Teilen auf der JavaScript-Technologie basiert. Eine breite Unterstützung sowie, leistungsfähige Programmiersprachen, die Vielzahl moderner Tools, sowie ausgereifte Frameworks wie Angular, React, Vue.js oder Node.js machen den JavaScript-Werkzeugkasten zu einem Alleskönner. Das iJS Magazin informiert aktuell und umfassend über die wichtige und innovative Entwicklungen im JavaScript-Universum und bietet handfeste Praxisinformationen für Softwareentwickler und -architekten.\n'author': Karsten Sitterberg\n'language': DE\n'date': Thu Apr 06 2023 00:00:00 GMT+0000 (Coordinated Universal Time)\n'access': granted\n'chunkSource': text\n'text': kann die unregisterFn() aufgerufen werden. Dann würde in diesem Beispiel doSomethingOnDestroy() nicht mehr aufgerufen. Neben der DestroyRef wurde noch ein neues Paket @angular/rxjs-interop eingeführt, das vor allem mit den neuen Signals verwendet wird. Zusätzlich bietet dieses Paket aber auch noch die Funktion takeUntilDestroyed() an. Diese Funktion ist ein Pipeable rxjs-Operator und kann verwendet werden, um Observables zu beenden, sobald die zugehörige Komponente destroyed wurde. Unter der Haube verwendet dieser neue Operator eine DestroyRef. In Listing 18 wird gezeigt, wie man den Operator nutzen kann, um ein Intervall-Observable zu beenden, sobald die Komponente abgeräumt wird. In diesem Fall wird dem takeUntilDestroyed-Operator explizit eine DestroyRef mitgegeben. Dieser Schritt kann allerdings auch weggelassen werden, dann besorgt sich der Operator die DestroyRef selbst per inject()-Funktion. Das hätte dann hier aber zur Folge, dass der Operator - oder das ganze Observable - im Konstruktor erzeugt werden muss, da der inject()-Mechanismus den Konstruktor-Kontext benötigt. Listing 18: Beispiel zur Verwendung der DestroyRef constructor(private destroyRef: DestroyRef) { const unregisterFn = destroyRef.onDestroy(() => doSomethingOnDestroy() ); // unregisterFn(); // Nimmt onDestroy-Logik zurück } ngOnInit(): void { interval(1000) .pipe(takeUntilDestroyed(this.destroyRef)) .subscribe(val => console.log('value:', val)) } Signals in Angular 16 - Hört die Signale… In Angular 16 hält ein neues und gleichzeitig so wegweisendes Konzept Einzug, das dem eine eigene Überschrift zu widmen ist. Die Rede ist von den “Signals”, einem Konzept, das sicherlich nicht zuletzt von Vue inspiriert wurde. Langfristiges Ziel ist es dabei, ohne “Zone.js” auszukommen und die Change-Detection mit anderen Mitteln abbilden zu können. Das ist sicherlich wichtig, um Standalone-Anwendungen zu verschlanken und vielleicht sogar die Möglichkeiten zu eröffnen, einzelne Elemente mit Angular umzusetzen, vergleichbar mit React und Vue. Als Motivation wurde angegeben, dass Angular-Anwendungen auf diese Weise einfacher werden, da die Verwendung von RxJS nicht mehr zwingend nötig ist. Damit soll die technische, aber auch die konzeptionelle Komplexität reduziert werden. Gleichzeitig hat das Thema auch etwas Beigeschmack: Die offiziellen Diskussionen wurden erst ca. drei Wochen vor Verabschiedung des ersten Release-Candidate\n'slidetext': \n'part_name': 14\n'total_parts': 21\n'from': index\n'score': 93.4918212890625\n'normalizedScore': 1.2666757908907167\n'beforeDatePenaltyScore': 1.3355974469866072\n\n'contentType': READ\n'documentId': 5229d453d1393d2c3d86e145\n'title': Signals und State ManagementFrontend-Entwicklung mit Signals – Teil 3\n'abstract': Bereits ab Angular 17 kann ein Teil des Signals API produktiv eingesetzt werden. Die neu veröffentlichte Control-Flow-Syntax dient auch als Grundlage für Signal-basierte Komponenten, die voraussichtlich 2024 veröffentlicht werden. Bis diese APIs einsatzbereit sind, können bereits Schritte unternommen werden, um aktuell vorhandene State-Management-Implementierungen auf Signals umzustellen. Unsere Artikelserie soll dabei helfen, schon jetzt in die neue Welt einzutauchen, um die richtigen Entscheidungen treffen zu können, sobald die neuen Framework APIs die Developer-Preview-Phase verlassen. Dieser dritte Artikel geht auf die Auswirkungen von Signals auf das State Management ein.\n'parentName': Windows Developer 2.2024\n'parentDescription': Windows Developer informiert umfassend und herstellerneutral über die neuen Trends und Möglichkeiten der Software- und Systementwicklung rund um Microsoft- und Web-Technologien. Von der klassischen .NET-Entwicklung über .NET Core bis hin zu neuen Technologien wie Windows 10, Microsoft Azure und der ganzen Bandbreite der aktuellen Web-, Phone- und Tabletentwicklung für Android und iOS mit Xamarin und unterschiedlichen JavaScript-Frameworks. Professionelle Entwickler und IT-Entscheider erhalten genau die Informationen, die sie für den erfolgreichen Einsatz von unternehmensorientierten Lösungen benötigen.\n'author': Michael Egger-Zikes\n'language': DE\n'date': Tue Jan 09 2024 02:00:00 GMT+0000 (Coordinated Universal Time)\n'access': granted\n'chunkSource': text\n'text': humorvoll, dass es ein neues, weiteres State-Management-Paket gibt, weil sie das eben ganz gut können – Bibliotheken für Zustandsverwaltung implementieren, die sich noch dazu großer Beliebtheit erfreuen. Für Angular-Entwickler:innen bleibt nun das Fragezeichen, welches der beiden leichtgewichtigen Pakete zu bevorzugen ist. Der Component Store eignet sich aktuell als etablierte, produktionsgeeignete Lösung, die auch ein Signal API anbietet. Der Signal Store wird als neue Alternative vor allem in Zukunft spannend werden, wenn die eigenen Angular-Projekte in Richtung Signals refaktoriert werden. Nachdem Signal-based Components inklusive neuer Change Detection erst 2024 erwartet und voraussichtlich zunächst als Developer Preview veröffentlicht werden, kann man aktuell von Angular 19 (Herbst 2024) oder 20 (Frühjahr 2025) als mögliche Zeitpunkte ausgehen, zu denen auch die Signal-based Components production-ready sind. Damit wird auch der Signal Store an Bedeutung gewinnen. Nichtsdestotrotz muss nicht so lange gewartet werden – bereits mit den aktuellen Versionen bieten Signals Vorteile als automatischer Trigger für die onPush Change Detection Strategy (Version 16) und eine neue, optimierte Change-Detection-Variante, die zwar immer noch zone.js benötigt, aber bei Verwendung von onPush und Signals keine Elternkomponenten mehr für den Change-Detection-Lauf mitprüft (Version 17). Zusammengefasst heißt das, dass die Zukunft sehr wahrscheinlich dem Signal Store gehört, der Component Store aber weiterhin supportet wird und als etabliertes Paket zuverlässig eingesetzt werden kann. Der Signal Store ist funktional aufgebaut und nutzt moderne TypeScript-Funktionen, um unterschiedliche Features bei Bedarf zu importieren und für die Definition des individuellen, projekt-spezifischen State Management API zu nutzen. Das Konzept erinnert an Standalone provide-Funktionen, die per with-Funktionen konfiguriert bzw. um Features erweitert werden können. Dieser Aufbau ist im NgRx-Namespace neu und eignet sich ideal für das Tree-Shaking, um nicht verwendete Features aus den finalen Bundles zu entfernen (Listing 1). Zudem öffnet diese Schnittstelle auch die Tür für generische Communityfeatures, die sich nahtlos in den Signal Store integrieren können. Beispiele dafür sind der Loading State für Entitäten, eine Cacheimplementierung für Teile des Stores und eine Undo/Redo-Funktionalität. Selbst das Redux-Pattern inklusive Actions könnte als Custom-Feature\n'slidetext': \n'part_name': 6\n'total_parts': 10\n'from': index\n'score': 91.53166961669922\n'normalizedScore': 1.2615297885262313\n'beforeDatePenaltyScore': 1.3075952802385602\n\n'contentType': READ\n'documentId': 04721391f3f7580f0631b9d3\n'title': Angular 17: Neues Release des Web-FrameworksRenaissance? Angular 17! - Alle Features im Überblick\n'abstract': Das beliebte JavaScript-Framework Angular veröffentlicht Version 17. Da bei Angular viel in Bewegung ist, kann manch einer da den Überblick verlieren. Wir stellen alle Features von Angular 17 vor.\n'parentName': iJS Magazin 2.2024\n'parentDescription': Kaum ein Softwareprojekt, das nicht in wesentlichen Teilen auf der JavaScript-Technologie basiert. Eine breite Unterstützung sowie, leistungsfähige Programmiersprachen, die Vielzahl moderner Tools, sowie ausgereifte Frameworks wie Angular, React, Vue.js oder Node.js machen den JavaScript-Werkzeugkasten zu einem Alleskönner. Das iJS Magazin informiert aktuell und umfassend über die wichtige und innovative Entwicklungen im JavaScript-Universum und bietet handfeste Praxisinformationen für Softwareentwickler und -architekten.\n'author': Karsten Sitterberg\n'language': DE\n'date': Wed Apr 03 2024 22:00:00 GMT+0000 (Coordinated Universal Time)\n'access': granted\n'chunkSource': text\n'text': '@NgModule()'s. - Funktionale HTTP-Interceptoren werden in Angular CLI 17 bevorzugt, klassenbasierte sind optional. - Einführung der neuen Syntax @switch, @case, und @default für Conditional Rendering und neue Direktiven wie @defer für Lazy Loading. - @defer unterstützt bedingtes Laden und Vorladen mit prefetch. - Die Angular CLI bietet eine automatische Migration zur neuen Syntax an; alte und neue Syntax können in Version 17 parallel genutzt werden. - Integration der neuen Lifecycle-Hooks afterRender() und afterNextRender sowie die Stabilisierung von Signals. - Lazy Loading für Animationen und die Integration der View Transitions DOM-API für optimierte Übergänge und Animationen. - Einführung einer neuen Control-Flow-Syntax als Developer Preview, die *ngIf, *ngFor, und ngSwitch ersetzt und zusätzliche Verbesserungen wie @if, @for, und erforderliches Track-by für Listen umfasst. Breaking Changes in Angular 17 - Entfernung von signal.mutate(): Die Möglichkeit, Signals durch Mutation zu verändern, wurde entfernt. Signals müssen als immutable Datenstrukturen behandelt werden; Änderungen sollten durch die signal.update()-Funktion vorgenommen werden. - Signal-Handhabung als immutable: Anstatt Signals zu mutieren, sollten Entwickler diese nun behandeln, als wären sie immutable, und entsprechend aktualisieren. - Entfernung von Router Properties: Bestimmte Router Properties wie canceledNavigationResolution, paramsInheritanceStrategy, titleStrategy, urlUpdateStrategy, malformedUriErrorHandler und urlHandlingStrategy wurden aus der öffentlichen API entfernt. - Neue Konfiguration über provideRouter() oder RouterModule.forRoot(): Die zuvor entfernten Router Properties müssen jetzt über die provideRouter()-Funktion oder im RouterModule.forRoot()-Hook konfiguriert werden. - Änderung in der Navigation: Die Konfiguration der Navigationsstrategie und Fehlerbehandlung muss an die neuen Methoden angepasst werden, um Inkompatibilitäten mit dem Router-Service von Angular 17 zu vermeiden. TypeScript Mit der neuen Angular-Version wird auch eine neue TypeScript-Version unterstützt. In Angular 17 muss nun zugleich TypeScript mindestens in Version 5.2 verwendet werden. Da beim Release von Angular 16 noch TypeScript 5.0 vorausgesetzt wurde, wollen wir uns an dieser Stelle sowohl einige interessante Neuerungen sowohl aus TypeScript 5.1 als auch aus TypeScript 5.2 ansehen. Implizites “return“ bei Rückgabe von “undefined“ Wenn in JavaScript eine Funktion keine “return”-Angabe enthält, hat diese Funktion dennoch immer implizit “undefined” als Rückgabewert. In TypeScript hat sich diese Tatsache bisher nicht\n'slidetext': \n'part_name': 2\n'total_parts': 21\n'from': index\n'score': 90.58707427978516\n'normalizedScore': 1.255090363948007\n'beforeDatePenaltyScore': 1.2941010611397878\n\n'contentType': READ\n'documentId': 62f599587e3fd28de76c2756\n'title': Signals werden erwachsen – das neue Resource API in Angular 19Kolumne: Enterprise Angular\n'abstract': Das in Angular 19 zunächst experimentell eingeführte Resource API ermöglicht das asynchrone Laden von Daten in der Welt von Signals. Das gibt uns endlich die Möglichkeit, HTTP-Zugriffe in den reaktiven Fluss zu integrieren. In diesem Artikel zeige ich, wie man damit ein typisches CRUD-Szenario erstellt. Das verwendete Codebeispiel findet sich unter [1] im Branch 02e-resource.\n'parentName': iJS Magazin 1.2025\n'parentDescription': Kaum ein Softwareprojekt, das nicht in wesentlichen Teilen auf der JavaScript-Technologie basiert. Eine breite Unterstützung sowie, leistungsfähige Programmiersprachen, die Vielzahl moderner Tools, sowie ausgereifte Frameworks wie Angular, React, Vue.js oder Node.js machen den JavaScript-Werkzeugkasten zu einem Alleskönner. Das iJS Magazin informiert aktuell und umfassend über die wichtige und innovative Entwicklungen im JavaScript-Universum und bietet handfeste Praxisinformationen für Softwareentwickler und -architekten.\n'author': Manfred Steyer\n'language': DE\n'date': Wed Jan 29 2025 23:00:00 GMT+0000 (Coordinated Universal Time)\n'access': granted\n'chunkSource': text\n'text': Signals werden erwachsen – das neue Resource API in Angular 19 Kolumne: Enterprise Angular Das in Angular 19 zunächst experimentell eingeführte Resource API ermöglicht das asynchrone Laden von Daten in der Welt von Signals. Das gibt uns endlich die Möglichkeit, HTTP-Zugriffe in den reaktiven Fluss zu integrieren. In diesem Artikel zeige ich, wie man damit ein typisches CRUD-Szenario erstellt. Das verwendete Codebeispiel findet sich unter [1] im Branch 02e-resource. Das in Angular 19 zunächst experimentell eingeführte Resource API ermöglicht das asynchrone Laden von Daten in der Welt von Signals. Das gibt uns endlich die Möglichkeit, HTTP-Zugriffe in den reaktiven Fluss zu integrieren. In diesem Artikel zeige ich, wie man damit ein typisches CRUD-Szenario erstellt. Das verwendete Codebeispiel findet sich unter [1] im Branch 02e-resource. Beispielanwendung Zur Demonstration der einzelnen Features nutze ich die bereits aus früheren Artikeln bekannte Demoanwendung Austrian Desserts (Abb. 1). Abb. 1: Beispielanwendung: Austrian Desserts In dieser Anwendung kann man nach Desserts der Alpenrepublik anhand des originalen österreichischen Namens oder der jeweiligen englischen Übersetzung suchen. Die einzelnen Desserts lassen sich bewerten. Als Alternative können Benutzer:innen auch die Bewertungen eines anerkannten Experten auf diesem Gebiet – es handelt sich dabei um meine Wenigkeit – laden. Außerdem gibt es eine Detailansicht zum Bearbeiten von Desserts (Abb. 2). Abb. 2: Detailansicht in Beispielanwendung Erste Schritte mit dem Resource API Jede mit dem Resource API definierte Resource hat eine Funktion loader, die ein Promise mit den geladenen Daten zurückgibt. Dieser Loader kommt unmittelbar nach der Initialisierung der Resource zum Einsatz. Zusätzlich kann die Resource ein request Signal haben, das Parameter (Suchkriterien) für den Loader bereitstellt. Jedes Mal, wenn sich das request Signal ändert, stößt die Resource den Loader erneut an (Listing 1). Listing 1 import { resource } from '@angular/core'; […] @Component([...]) export class DessertsComponent { #dessertService = inject(DessertService); [...] // Criteria for search originalName = signal(''); englishName = signal(''); // Combine criteria to computed Signal dessertsCriteria = computed(() => ({ originalName: this.originalName(), englishName: this.englishName(), })); // Define resource with request (=search criteria) and loader // Every time, the request is changing, the loader is triggered\n'slidetext': \n'part_name': 1\n'total_parts': 9\n'from': index\n'score': 88.41615295410156\n'normalizedScore': 1.2488203528374586\n'beforeDatePenaltyScore': 1.263087899344308\n\n'contentType': COURSE\n'documentId': 68fe3d9fc389515d1d6bea43\n'title': Professional Tips for Using Signals in Angularnull\n'abstract': The new Signals in Angular are a simple reactive building block. However, as is so often the case, the devil is in the detail. In this article, I will give three tips to help you use Signals in a more straightforward way.\n'parentName': Advanced Angular: Signals, NgRx & AI Forms\n'parentDescription': Level up your Angular skills with this advanced course, highlighting the framework’s evolving features. We will cover cutting-edge topics, from mastering state management with the NgRx Signal store and unlocking AI-enhanced forms’ potential, to revisiting the performance benefits of server-side rendering. You will learn how to effectively use Signals through professional tips and real-world insights, and explore emerging features like httpResource in Angular 19.2. Whether you are scaling enterprise apps or upgrading legacy codebases, this course equips you with the practices to build smarter, faster Angular applications and stay ahead in today’s Angular ecosystem.\n'author': Manfred Steyer\n'language': DE\n'date': Fri May 02 2025 10:49:04 GMT+0000 (Coordinated Universal Time)\n'access': restricted\n'chunkSource': text\n'text': { this.store.load(id); }); }); } With this common pattern, untracked ensures that the reactive context does not spill over to the load method. It can write to Signals and the effect doesn’t register for Signals that read load. Angular only triggers the effect again when the Signal id changes, especially since it reads it outside of untracked. Unfortunately, this code is not especially easy to read. It’s a good idea to hide it behind a helper function: constructor() { explicitEffect(this.id, (id) => { this.store.load(id); }); } The created auxiliary function explicitEffect receives a signal and subscribes to it with an effect. The effect triggers the transferred lambda expression using untracked (Listing 6). Listing 6 import { Signal, effect, untracked } from '@angular/core'; export function explicitEffect(source: Signal, action: (value: T) => void) { effect(() => { const s = source(); untracked(() => { action(s) }); }); } Interestingly, the explicit definition of Signals to be obeyed corresponds to the standard behavior of effects in other frameworks, like Solid. The combination of effect and untracked shown is also used in many libraries. Examples include the classic NgRx store, the RxJS interop mentioned above, the rxMethod, or the open source library ngxtension, which offers many extra functions for Signals. To summarize RxJS and Signals harmonize wonderfully together and the RxJS interop from Angular gives us the best of both worlds. Using RxJS is recommended for representing events. For processing asynchronous tasks, RxJS or stores (which can be based on RxJS) are recommended. The synchronous transport of data to the view should be handled by Signals. Together, RxJS, stores, and Signals are the building blocks for establishing a unidirectional data flow. The flattening operators in RxJS can also elegantly avoid race conditions. Alternatively or in addition to this, flags can be used to indicate if a request is currently in progress at the backend. Even if Signals weren’t primarily created to display events, there are cases when you want to react to changes in a Signal. This is the case with framework APIs based on Signals. In addition to the RxJS interop, the rxMethod from the Signal Store can also be used. Another option is the effect/untracked pattern for implementing effects that only react to explicitly named Signals.\n'slidetext': \n'part_name': 6\n'total_parts': 6\n'from': index\n'score': 87.40137481689453\n'normalizedScore': 1.2419256379832508\n'beforeDatePenaltyScore': 1.248591068812779\n\n'contentType': COURSE\n'documentId': 68fe3d9fc389515d1d6bea43\n'title': Professional Tips for Using Signals in Angularnull\n'abstract': The new Signals in Angular are a simple reactive building block. However, as is so often the case, the devil is in the detail. In this article, I will give three tips to help you use Signals in a more straightforward way.\n'parentName': Advanced Angular: Signals, NgRx & AI Forms\n'parentDescription': Level up your Angular skills with this advanced course, highlighting the framework’s evolving features. We will cover cutting-edge topics, from mastering state management with the NgRx Signal store and unlocking AI-enhanced forms’ potential, to revisiting the performance benefits of server-side rendering. You will learn how to effectively use Signals through professional tips and real-world insights, and explore emerging features like httpResource in Angular 19.2. Whether you are scaling enterprise apps or upgrading legacy codebases, this course equips you with the practices to build smarter, faster Angular applications and stay ahead in today’s Angular ecosystem.\n'author': Manfred Steyer\n'language': DE\n'date': Fri May 02 2025 10:49:04 GMT+0000 (Coordinated Universal Time)\n'access': restricted\n'chunkSource': text\n'text': requests. The switchMap only deals with the last search request. It cancels any queries that are already running when a new query arrives. This behavior corresponds to what users intuitively expect when working with search filters. The mergeMap and concatMap operators execute all requests: the former in parallel and the latter sequentially. The exhaustMap operator ignores further requests as long as one is running. These options are another reason for using RxJS and for the RxJS interop and rxMethod. Another strategy often used in addition or as an alternative is a flag that indicates if the application is currently communicating with the backend. Listing 3 loadRatings(): void { patchState(store, { loading: true }); ratingService.loadExpertRatings().subscribe({ next: (ratings) => { patchState(store, { ratings, loading: false }); }, error: (error) => { patchState(store, { loading: false }); toastService.show('Error loading ratings!'); console.error(error); }, }); }, Depending on the flag’s value, the application can display a loading indicator or deactivate the respective button. The latter is counterproductive or even impossible with a highly reactive UI if the application can manage without an explicit button. Tip 3: Signals as triggers As mentioned earlier, Signals are especially suitable for transporting data to the view, like what’s seen on the right in Figure 1. Real events, UI events, or events displayed with RxJS are the better solution for transmitting an intention. There are several reasons why: First, Signals’ glitch-free property can reduce consecutive changes to the last change. Consumers must subscribe to the Signal in order to be able to react to value changes. This requires an effect that triggers the desired action and writes the result to a signal. Effects that write to Signals are not welcome. By default, they are even penalized by Angular with an exception. The Angular team wants to avoid confusing reactive chains - changes that lead to changes, which in turn, lead to further changes. On the other hand, Angular is converting more and more APIs to signals. One example is Signals that can be bound to form fields or Signals that represent passed values (inputs). In most cases, you could argue that instead of listening for the Signal, you can also use the event that led to the Signal change. But in some cases, this is a detour that bypasses the new signal-based APIs. Listing 4 shows an example of a component that receives the ID of a data set to be displayed as an input signal. The router takes this ID from a routing parameter. This is possible with the relatively new feature withComponentInputBinding. Listing 4 @Component({ […] }) export class DessertDetailComponent implements OnChanges {\n'slidetext': \n'part_name': 4\n'total_parts': 6\n'from': index\n'score': 86.80384826660156\n'normalizedScore': 1.233389544407637\n'beforeDatePenaltyScore': 1.2400549752371652\n\n'contentType': READ\n'documentId': 9836770500f149a58b7769f9\n'title': Professional Tips for Using Signals in AngularEnterprise Angular\n'abstract': The new Signals in Angular are a simple reactive building block. However, as is so often the case, the devil is in the detail. In this article, I will give three tips to help you use Signals in a more straightforward way.\n'parentName': JavaScript Magazine Volume 17\n'parentDescription': Broaden your knowledge and expand your JavaScript techniques and practices. From Angular, React, and WebAssembly, to the best JavaScript IDEs, open source tools and more, you’ll learn insights on everything JS from seasoned experts in their field. Keep up with JavaScript news, tips, and advice with interviews, tutorials, and in-depth articles.\n'author': Manfred Steyer\n'language': EN\n'date': Tue Feb 25 2025 23:00:00 GMT+0000 (Coordinated Universal Time)\n'access': granted\n'chunkSource': text\n'text': Professional Tips for Using Signals in Angular Enterprise Angular The new Signals in Angular are a simple reactive building block. However, as is so often the case, the devil is in the detail. In this article, I will give three tips to help you use Signals in a more straightforward way. The new Signals in Angular are a simple reactive building block. However, as is so often the case, the devil is in the detail. In this article, I will give three tips to help you use Signals in a more straightforward way. The examples used for this can be found here. Guiding theory: Unidirectional data flow with signals The approach for establishing a unidirectional data flow (Fig. 1) serves as the guiding theory for my three tips. Fig. 1: Unidirectional data flow with a store Handlers for UI events delegate to the store. I use the abstract term “intention”, since this process is different for different stores. With the Redux-based NgRx store, actions are dispatched; whereas with the lightweight NgRx Signal store, the component calls a method offered by the store. The store executes synchronous or asynchronous tasks. These usually lead to a status change, which the application transports to the views of the individual components with signals. As part of this data flow, the state can be projected onto view models using computed, i.e. onto data structures that represent the view of individual use cases on the state. This approach is based on the fact that signals are primarily suitable for informing the view synchronously about data and data changes. They are less suitable for asynchronous tasks and for representing events. For one, they don’t offer a simple way of dealing with overlapping asynchronous requests and the resulting race conditions. Furthermore, they cannot directly represent error states. Second, signals ignore the resulting intermediate states in the case of directly consecutive value changes. This desired property is called “glitch free”. For example, if a signal changes from 1 to 2 and immediately afterwards from 2 to 3, the consumer only receives a notification about the 3. This is also conducive to data binding performance, especially as updating with intermediate results would result in an unnecessary performance overhead. Tip 1: Signals harmonize with RxJS Signals are deliberately kept simple. That's why it offers fewer options than RxJS, which has been established in the Angular world for years. Thanks to the RxJS interop that Angular provides, the best of both worlds can be combined. Listing 1 demonstrates this. It converts the signals from and to into observables and implements a typeahead based on them. To do this, it uses the operators filter, debounceTime and\n'slidetext': \n'part_name': 1\n'total_parts': 6\n'from': index\n'score': 86.65045166015625\n'normalizedScore': 1.2258152267194806\n'beforeDatePenaltyScore': 1.2378635951450894\n\n'contentType': READ\n'documentId': 1c2d0d1ddbcc6e6469e58943\n'title': Angular 19: Incremental Hydration, Hybrid Rendering und SignalsKolumne: Enterprise Angular\n'abstract': Mit Version 19 bringt Angular zwei wichtige Features, die unsere Anwendungen performanter machen: Incremental Hydration und Hybrid Rendering. Daneben erhält das Framework weitere Möglichkeiten rund um Signals.\n'parentName': iJS Magazin 1.2025\n'parentDescription': Kaum ein Softwareprojekt, das nicht in wesentlichen Teilen auf der JavaScript-Technologie basiert. Eine breite Unterstützung sowie, leistungsfähige Programmiersprachen, die Vielzahl moderner Tools, sowie ausgereifte Frameworks wie Angular, React, Vue.js oder Node.js machen den JavaScript-Werkzeugkasten zu einem Alleskönner. Das iJS Magazin informiert aktuell und umfassend über die wichtige und innovative Entwicklungen im JavaScript-Universum und bietet handfeste Praxisinformationen für Softwareentwickler und -architekten.\n'author': Manfred Steyer\n'language': DE\n'date': Wed Jan 29 2025 23:00:00 GMT+0000 (Coordinated Universal Time)\n'access': granted\n'chunkSource': text\n'text': für eine bestimmte Route und deren Child-Routen festzulegen. Automatische Migrationen Um automatisiert auf die Features der modernen Angular-Versionen zu migrieren, führt Angular 19 einige Schematics ein, die sich wie folgt anstoßen lassen: ng g @angular/core:inject-migration ng g @angular/core:route-lazy-loading ng g @angular/core:signal-input-migration ng g @angular/core:output-migration ng g @angular/core:signal-queries-migration Der erste Schematic überführt Constructor Injection in Property Injection mit der inject-Funktion. Der zweite konfiguriert für Routen, die auf Standalone Components verweisen, Lazy Loading mittels loadComponent. Die restlichen drei Schematics ersetzen @Input, @Output sowie @ContentChild(ren) und @ViewChild(ren) durch ihre modernen Signal-basierten Gegenstücke. Weitere Aktualisierungen Neben den besprochenen größeren Neuerungen kommt Angular 19 auch mit einigen kleineren Abrundungen. Nachfolgend eine Auswahl davon: - Die Eigenschaft standalone bei Komponenten, Direktiven und Pipes ist standardmäßig true. Möchte eine Anwendung diese Building Blocks nach wie vor über Angular-Module bereitstellen, muss sie standalone explizit auf false setzen. Ein Schematic kümmert sich im Rahmen von ng update darum. - Die angularCompilerOptions in der tsconfig.json haben ein Flag strictStandalone. Setzt man es auf true, liefert die CLI beim Einsatz von standalone: false eine Fehlermeldung. - Der Angular Language Service liefert eine Warnung, wenn das imports-Array einer Standalone Component einen Building Block enthält, der im Template nicht zum Einsatz kommt. - @let ist als produktionsreif eingestuft. - Templates unterstützen den Einsatz des JavaScript-Operators typeof. - Hot Module Replacement (HMR) ist standardmäßig für Styles aktiviert. Nach einer Änderung einer Stylesheet-Datei patcht ng serve die Styles im Browser, ohne die Seite neu zu laden. Der aktuelle Anwendungszustand bleibt erhalten. Durch Setzen einer Umgebungsvariablen bietet ng serve dieses Verhalten auch für Templates: NG_HMR_TEMPLATES=1 ng serve Zusammenfassung Mit Incremental Hydration und Hybrid Rendering greift Angular zwei moderne Features auf, die sich mittlerweile auch in anderen, teils jüngeren Frameworks wiederfinden. Damit beweist Angular ein weiteres Mal, dass es in der Lage ist, sich von innen heraus zu erneuern, um langfristig relevant zu bleiben. Das neue Resource API und Linked Signals sind wichtige Ergänzungen und geben einen guten Vorgeschmack darauf, wie sich künftig reaktives Angular mit Signals\n'slidetext': \n'part_name': 9\n'total_parts': 10\n'from': index\n'score': 86.39270782470703\n'normalizedScore': 1.219913993845157\n'beforeDatePenaltyScore': 1.2341815403529577\n\n'contentType': COURSE\n'documentId': qREnL94qsTwnQH8ic\n'title': Angular Signals: Gamechanger für reaktive Entwicklungnull\n'abstract': Das Angular-Team stellt sein reaktives Modell auf den Prüfstand und schlägt als neuen Ansatz die von anderen Frameworks bekannten Signals vor. Während Altanwendungen zunächst weiter funktionieren wie gehabt, bieten Signals entscheidende Vorteile gegenüber dem bestehenden Modell. Brauchen Anwendungen in Zukunft überhaupt noch RxJS? Welche Vorteile haben Signals auf die Performance einer Anwendung? Und wie funktioniert das Reaktivitätsmodell im Detail? Yannick Baron von Thinktecture und Google Developer Expert für Angular beantwortet alle Fragen rund um die neuen Angular-Signals.\n'parentName': Moderne Architekturen mit Angular\n'parentDescription': Dieser Kurs richtet sich an erfahrene Frontend-Entwickler:innen, die bereits mit Angular vertraut sind und ihr Wissen auf die nächste Stufe heben möchten. Wir tauchen tief in die Welt der Angular-Architektur ein und erkunden innovative Konzepte und bewährte Praktiken, die dazu beitragen, moderne und wartbare Anwendungen für komplexe Szenarien zu entwickeln. Angular-Architektur: Wir untersuchen die neuen Angular Signals und diskutieren Optionen für das Zustandsmanagement mit Signals sowie die Zusammenarbeit von Signal Components mit herkömmlichen Komponenten. Strategic Design: Als Untermenge von Domain-driven Design (DDD) ermöglicht Strategic Design die Umsetzung großer und langfristig wartbarer Frontend-Monolithen. NgRx: Wir nehmen die Verwendung von NgRx unter die Lupe, um nicht nur To-do-Items im UI anzuzeigen, sondern auch die Herausforderungen des State-Managements in der Frontend-Entwicklung auf elegante Weise zu bewältigen. Native Federation: Du lernst, wie das erfolgreiche mentale Modell von webpack Module Federation auf eine werkzeugagnostische Weise durch Native Federation implementiert werden kann.\n'author': Yannick Baron\n'language': DE\n'date': Wed Dec 13 2023 15:29:13 GMT+0000 (Coordinated Universal Time)\n'access': restricted\n'chunkSource': text\n'text': gucken, dass sie change popol propagieren. Das heißt da gibt es noch ein paar kleine unstimmigkeiten aber für so kleine use cases wie ich habe eine komponente, die hat nur ein klein bisschen state oder? ich habe mein Mein component Store, ich setze zum Beispiel im component Store mittlerweile auf Signals, weil das zum Beispiel Sachen wie der SWI la di from ein bisschen schöner machen, weil du willst manchmal eben den synchronen Read haben. Ja, du machst jetzt drückst jetzt auf den button du willst zu dem zeitpunkt wo dieses ding durch den stream läuft, an diesem zeitpunkt willst du ein snap schon von deinem state dafür ist singen super, das macht dann halt so sachen wie live ist so ein bisschen einfacher schöner parteien weniger code, aber hier Abwehr sohn 16 abwehr so einen 17 control floh und dann hoffentlich mit Version 18 schon mal die ersten coolen ais für signal base zeug wie zum beispiel neue die neuen wie heißen die ne hooks lifetime cycle events ja ng und inne und onans und so weiter. Also damit wir bleiben erst mal den angola versionen würde zu empfehlen, dass wir auf angola 16 mit signals migrieren bei den beständen der anwendungen. Wenn ja was sind dann die notwendigen schrecken was du empfehlen würdest? Ich würde auf jeden fall auf engler 16 gehen. Ja also falls das die Frage war, ob ihr nicht auf enger 16 gehen solltet ihr sollt ich mein jetzt mal migrieren? Signal ah okay, wie gesagt ich würde nicht hingehen, eure ganze applikation jetzt aus signets umschreiben, ich würde entweder neue sachen kleine abgekapselten sachen wie ich habe eine kleine komponente wie was weiß ich eine tree komponente oder eine auf zu klapp komponente oder sowas? Ja da würde ich schon hingehen, das ganze so ein bisschen auf signets umstellen einfach mal um sich so ein bisschen die finger damit nass zu machen aber des weiteren würde ich glauben, dass sich dann nicht mehr allzu viel ändert. Aber es gibt halt im hintergrund natürlich wenn du richtig hardcore paar sachen machst gibt es ein paar unstimmigkeiten, das heißt ich würde auf keinen fall hingehen versuchen die ganze code base of teufel raus umzustellen. Wenn\n'slidetext': \n'part_name': 28\n'total_parts': 31\n'from': index\n'score': 87.92870330810547\n'normalizedScore': 1.2078858513443202\n'beforeDatePenaltyScore': 1.2561243329729352\n\n'contentType': READ\n'documentId': eba6f5d083b14f4d8d53d87a\n'title': Was ist neu in Angular 16? Signals, Hydration, esbuild und mehrKolumne: Enterprise Angular\n'abstract': Mit Angular 16 kommen gleich zwei große Neuerungen: Signals und Non-destructive Hydration. Außerdem gibt es zahlreiche Abrundungen, die das Arbeiten mit dem Framework vereinfachen. In diesem Artikel gehe ich anhand von Beispielen auf die wichtigsten Neuerungen ein. Den Quellcode findet man im Branch ng16-features auf GitHub [1].\n'parentName': Windows Developer 7.2023\n'parentDescription': Windows Developer informiert umfassend und herstellerneutral über die neuen Trends und Möglichkeiten der Software- und Systementwicklung rund um Microsoft- und Web-Technologien. Von der klassischen .NET-Entwicklung über .NET Core bis hin zu neuen Technologien wie Windows 10, Microsoft Azure und der ganzen Bandbreite der aktuellen Web-, Phone- und Tabletentwicklung für Android und iOS mit Xamarin und unterschiedlichen JavaScript-Frameworks. Professionelle Entwickler und IT-Entscheider erhalten genau die Informationen, die sie für den erfolgreichen Einsatz von unternehmensorientierten Lösungen benötigen.\n'author': Manfred Steyer\n'language': DE\n'date': Tue Jun 13 2023 00:00:00 GMT+0000 (Coordinated Universal Time)\n'access': granted\n'chunkSource': text\n'text': Hektik: Bestandscode muss nicht zwingend migriert werden. RxJS Interop Signals und RxJS weisen einige Gemeinsamkeiten auf, zumal beide reaktive Anwendungen ermöglichen. Im Gegensatz zu RxJS wurden Signals jedoch bewusst sehr einfach gehalten. Das primäre Ziel ist die Unterstützung der Change Detection. Der ab Version 16 mit Angular ausgelieferte RxJS-Interop-Layer erlaubt es, die Einfachheit von Signals mit den vielen und teils komplexen Möglichkeiten von RxJS zu kombinieren. Der Interop-Layer befindet sich im Namensraum @angular/core/rxjs-interop und bietet Funktionen zum Umwandeln von Signals in Observables und vice versa (Listing 3). Listing 3 import { toObservable, toSignal } from '@angular/core/rxjs-interop'; [...] from = signal('Hamburg'); to = signal('Graz'); from$ = toObservable(this.from); to$ = toObservable(this.to); flights$ = combineLatest({ from: this.from$, to: this.to$ }).pipe( debounceTime(300), tap(() => this.loading.set(true)), switchMap((combi) => this.flightService.find(combi.from, combi.to)), tap(() => this.loading.set(false)) ); flights = toSignal(this.flights$, { initialValue: [] }); Die Funktion toObservable überführt die Signals from und to in entsprechende Observables. Das ermöglicht die Nutzung von RxJS-basierten Operatoren, wie combineLatest, debounceTime und switchMap. Das Ergebnis ist ein Observable, das Arrays mit Flight-Objekten liefert. Die Funktion toSignal erzeugt ein darauf basierendes Signal. Da ein Signal im Gegensatz zu einem Observable immer einen Wert aufweist, legt das Beispiel einen Initialwert fest. Stattdessen könnte der Aufrufer der Funktion toSignal auch versichern, dass das Observable synchron einen Initialwert veröffentlicht. Dazu ist die Eigenschaft requireSync auf true zu setzen: flights = toSignal(this.flights$, { requireSync: true }); In beiden Fällen leitet toSignal die Typisierung des Signal vom Observable ab. Im gezeigten Fall ergibt sich ein Signal. Kommen weder initialValue noch requireSync zum Einsatz, nimmt toSignal den Typ undefined in die Typisierung auf. Somit würde sich hier ein Signal ergeben, das undefined als Initialwert aufweist. Auch Signals, die auf Observables basieren, sind an die Lebenszeitspanne des nutzenden Building Block – zum Beispiel der jeweiligen Komponente oder des jeweiligen Service – gebunden. Bei Observables, die auf Signals basieren, ist das jedoch nicht so. Das Angular-Team wollte das von RxJS gewohnte Verhalten nicht ändern. Wer\n'slidetext': \n'part_name': 3\n'total_parts': 9\n'from': index\n'score': 88.83242797851562\n'normalizedScore': 1.205702070407366\n'beforeDatePenaltyScore': 1.269034685407366\n\n'contentType': RHEINGOLD\n'documentId': 85CC7npzPgB2pD7n8\n'title': Workshop: Modern Angular Architecture & Developmentnull\n'abstract': Since version 14, Angular has experienced a resurgence. It all began with the introduction of Standalone Components, but it has now evolved into a new generation with Signals and advanced hydration features, as seen in the current Angular version 16. In this workshop, we will delve into the modern Angular application landscape. Starting from an architectural perspective, we will explore the application of Domain-Driven Design, Modularized Applications, and Micro Frontends. You will learn how to effectively scale your teams and applications to meet your business requirements. During the afternoon session, we will focus on Signals and their transformative impact on Angular development. We will discuss how Signals affect RxJs and explore their implications for state management. Additionally, we will provide a preview of the upcoming Signal Component, scheduled for release in Angular 17. To fully participate in this workshop, it is recommended that you already possess familiarity with Angular and its core concepts. Join us for this immersive workshop, where you will gain valuable insights into the modern landscape of Angular development.\n'parentName': International JavaScript New York\n'parentDescription': \n'author': Michael Egger-Zikes,Rainer Hahnekamp\n'language': EN\n'date': Mon Sep 25 2023 06:30:00 GMT+0000 (Coordinated Universal Time)\n'access': restricted\n'chunkSource': text\n'text': Workshop: Modern Angular Architecture & Development Since version 14, Angular has experienced a resurgence. It all began with the introduction of Standalone Components, but it has now evolved into a new generation with Signals and advanced hydration features, as seen in the current Angular version 16. In this workshop, we will delve into the modern Angular application landscape. Starting from an architectural perspective, we will explore the application of Domain-Driven Design, Modularized Applications, and Micro Frontends. You will learn how to effectively scale your teams and applications to meet your business requirements. During the afternoon session, we will focus on Signals and their transformative impact on Angular development. We will discuss how Signals affect RxJs and explore their implications for state management. Additionally, we will provide a preview of the upcoming Signal Component, scheduled for release in Angular 17. To fully participate in this workshop, it is recommended that you already possess familiarity with Angular and its core concepts. Join us for this immersive workshop, where you will gain valuable insights into the modern landscape of Angular development.\n'slidetext': \n'part_name': 1\n'total_parts': 1\n'from': index\n'score': 88.03595733642578\n'normalizedScore': 1.2028941238569633\n'beforeDatePenaltyScore': 1.2576565333775112\n\n'contentType': READ\n'documentId': 1c2d0d1ddbcc6e6469e58943\n'title': Angular 19: Incremental Hydration, Hybrid Rendering und SignalsKolumne: Enterprise Angular\n'abstract': Mit Version 19 bringt Angular zwei wichtige Features, die unsere Anwendungen performanter machen: Incremental Hydration und Hybrid Rendering. Daneben erhält das Framework weitere Möglichkeiten rund um Signals.\n'parentName': iJS Magazin 1.2025\n'parentDescription': Kaum ein Softwareprojekt, das nicht in wesentlichen Teilen auf der JavaScript-Technologie basiert. Eine breite Unterstützung sowie, leistungsfähige Programmiersprachen, die Vielzahl moderner Tools, sowie ausgereifte Frameworks wie Angular, React, Vue.js oder Node.js machen den JavaScript-Werkzeugkasten zu einem Alleskönner. Das iJS Magazin informiert aktuell und umfassend über die wichtige und innovative Entwicklungen im JavaScript-Universum und bietet handfeste Praxisinformationen für Softwareentwickler und -architekten.\n'author': Manfred Steyer\n'language': DE\n'date': Wed Jan 29 2025 23:00:00 GMT+0000 (Coordinated Universal Time)\n'access': granted\n'chunkSource': text\n'text': sich das API rxResource aus @angular/core/rxjs-interop verwenden. Es funktioniert wie resource, allerdings liefert der Loader ein Observable. Listing 8 dessertsResource = rxResource({ request: this.dessertsCriteria, loader: (param) => { return timer(300).pipe( switchMap(() => this.#dessertService.find(param.request))); } }); Der Loader der rxResource bekommt kein AbortSignal, da Observables direkt durch implizites oder explizites Abmelden abgebrochen werden können. Es ist wichtig zu wissen, dass die aktuelle Implementierung von rxResource nur den ersten empfangenen Wert aus dem Observable verwendet. Intern nutzt sie firstValueFrom, um das Observable in ein Promise umzuwandeln. Dieses Promise übergibt sie danach an resource. Während dieses Verhalten für HTTP-Aufrufe in Ordnung ist, führt es zu Überraschungen, wenn mehrere Werte über einen Stream empfangen werden, z. B. beim Einsatz von WebSockets. Im letzteren Fall sollte die Anwendung die Observables auf klassische Weise nutzen. Linked Signals Eine weitere Neuerung, die ab Angular 19 als Developer Preview vorliegt, sind die sogenannten Linked Signals. Auf dem ersten Blick wirken sie wie ein berechnetes Signal. Allerdings sind berechnete Signals read-only. Linked Signals haben jedoch eine veränderbare Arbeitskopie. Deswegen bieten sich Linked Signals an, um berechnete Werte oder read-only Zustände an Template-driven Forms zu binden. Das Beispiel veranschaulicht das anhand eines read-only Signals loadedDessert, das von einem Store kommt. dessert = { originalName: linkedSignal(() => this.loadedDessert().originalName), englishName: linkedSignal(() => this.loadedDessert().englishName), kcal: linkedSignal(() => this.loadedDessert().kcal), rating: linkedSignal(() => this.loadedDessert().rating) }; Die hier eingerichteten Linked Signals lassen sich direkt mit ngModel binden:  Die Datenbindung schreibt in die lokale Arbeitskopie zurück, die die Anwendung später – beispielsweise beim Betätigen einer Schaltfläche – zum Store zurücksendet. Ändert sich der Quellwert im Store, überschreibt das Linked Signal die lokale Arbeitskopie damit. Die Anzeige bleibt also aktuell. Neben der einfachen Signatur, die an computed erinnert, bietet linkedSignal auch eine etwas komplexere, die Zugriff auf den vorherigen Wert gewährt: delta = linkedSignal({ source: () => this.loadedDessert().rating, computation: (current, previous) => (previous?.source ?? 0) - current }); Dieses Linked Signal nutzt als Quelle (source) das Rating des aktuellen Desserts.\n'slidetext': \n'part_name': 7\n'total_parts': 10\n'from': index\n'score': 84.5038833618164\n'normalizedScore': 1.1929307872324337\n'beforeDatePenaltyScore': 1.2071983337402343\n\n'contentType': READ\n'documentId': 9836770500f149a58b7769f9\n'title': Professional Tips for Using Signals in AngularEnterprise Angular\n'abstract': The new Signals in Angular are a simple reactive building block. However, as is so often the case, the devil is in the detail. In this article, I will give three tips to help you use Signals in a more straightforward way.\n'parentName': JavaScript Magazine Volume 17\n'parentDescription': Broaden your knowledge and expand your JavaScript techniques and practices. From Angular, React, and WebAssembly, to the best JavaScript IDEs, open source tools and more, you’ll learn insights on everything JS from seasoned experts in their field. Keep up with JavaScript news, tips, and advice with interviews, tutorials, and in-depth articles.\n'author': Manfred Steyer\n'language': EN\n'date': Tue Feb 25 2025 23:00:00 GMT+0000 (Coordinated Universal Time)\n'access': granted\n'chunkSource': text\n'text': { this.store.load(id); }); }); } With this common pattern, untracked ensures that the reactive context does not spill over to the load method. It can write to Signals and the effect doesn’t register for Signals that read load. Angular only triggers the effect again when the Signal id changes, especially since it reads it outside of untracked. Unfortunately, this code is not especially easy to read. It’s a good idea to hide it behind a helper function: constructor() { explicitEffect(this.id, (id) => { this.store.load(id); }); } The created auxiliary function explicitEffect receives a signal and subscribes to it with an effect. The effect triggers the transferred lambda expression using untracked (Listing 6). Listing 6 import { Signal, effect, untracked } from '@angular/core'; export function explicitEffect(source: Signal, action: (value: T) => void) { effect(() => { const s = source(); untracked(() => { action(s) }); }); } Interestingly, the explicit definition of Signals to be obeyed corresponds to the standard behavior of effects in other frameworks, like Solid. The combination of effect and untracked shown is also used in many libraries. Examples include the classic NgRx store, the RxJS interop mentioned above, the rxMethod, or the open source library ngxtension, which offers many extra functions for Signals. To summarize RxJS and Signals harmonize wonderfully together and the RxJS interop from Angular gives us the best of both worlds. Using RxJS is recommended for representing events. For processing asynchronous tasks, RxJS or stores (which can be based on RxJS) are recommended. The synchronous transport of data to the view should be handled by Signals. Together, RxJS, stores, and Signals are the building blocks for establishing a unidirectional data flow. The flattening operators in RxJS can also elegantly avoid race conditions. Alternatively or in addition to this, flags can be used to indicate if a request is currently in progress at the backend. Even if Signals weren’t primarily created to display events, there are cases when you want to react to changes in a Signal. This is the case with framework APIs based on Signals. In addition to the RxJS interop, the rxMethod from the Signal Store can also be used. Another option is the effect/untracked pattern for implementing effects that only react to explicitly named Signals.\n'slidetext': \n'part_name': 6\n'total_parts': 6\n'from': index\n'score': 84.22395324707031\n'normalizedScore': 1.1911509636744442\n'beforeDatePenaltyScore': 1.2031993321010044\n\n'contentType': COURSE\n'documentId': oaGpszBqb9pMPpjD7\n'title': Angular Signals im Vergleich mit RxJS Observables: Ein Blick auf Ereignisbehandlung und asynchrone Datenströmenull\n'abstract': Mit der Einführung von Angular Signals in Angular 16 erhalten Entwickler:innen eine weitere Möglichkeit, ihre Angular-Anwendung reaktiv und performant zu gestalten. Lange war die reaktive Erweiterung RxJS der Platzhirsch, wenn es darum ging, Ereignisbehandlung und asynchrone Datenströme in Angular zu Entwickeln In diesem Vortrag werden Sie gemeinsam mit Google Developer Expert Martina Kraus einen detaillierten Vergleich beider Technologien im Kontext der Performance- und Ereignisbehandlung durchführen. Nach einer kleinen Einfûhrung tauchen wir tiefer in die Funktionsweise von Angular Signals ein, wie sie in Komponenten eingebunden werden und wie sie die Kommunikation zwischen verschiedenen Module der Anwendung ermöglichen. Am Ende werden Sie ein besseres Verständnis dafür haben, wie Angular Signals im Vergleich zu RxJS Observables funktionieren und wie sie in ihren eigenen Angular-Projekten effektiv eingesetzt werden können.\n'parentName': Moderne Architekturen mit Angular\n'parentDescription': Dieser Kurs richtet sich an erfahrene Frontend-Entwickler:innen, die bereits mit Angular vertraut sind und ihr Wissen auf die nächste Stufe heben möchten. Wir tauchen tief in die Welt der Angular-Architektur ein und erkunden innovative Konzepte und bewährte Praktiken, die dazu beitragen, moderne und wartbare Anwendungen für komplexe Szenarien zu entwickeln. Angular-Architektur: Wir untersuchen die neuen Angular Signals und diskutieren Optionen für das Zustandsmanagement mit Signals sowie die Zusammenarbeit von Signal Components mit herkömmlichen Komponenten. Strategic Design: Als Untermenge von Domain-driven Design (DDD) ermöglicht Strategic Design die Umsetzung großer und langfristig wartbarer Frontend-Monolithen. NgRx: Wir nehmen die Verwendung von NgRx unter die Lupe, um nicht nur To-do-Items im UI anzuzeigen, sondern auch die Herausforderungen des State-Managements in der Frontend-Entwicklung auf elegante Weise zu bewältigen. Native Federation: Du lernst, wie das erfolgreiche mentale Modell von webpack Module Federation auf eine werkzeugagnostische Weise durch Native Federation implementiert werden kann.\n'author': Martina Kraus\n'language': DE\n'date': Wed Dec 13 2023 15:29:13 GMT+0000 (Coordinated Universal Time)\n'access': restricted\n'chunkSource': text\n'text': Angular Signals im Vergleich mit RxJS Observables: Ein Blick auf Ereignisbehandlung und asynchrone Datenströme Mit der Einführung von Angular Signals in Angular 16 erhalten Entwickler:innen eine weitere Möglichkeit, ihre Angular-Anwendung reaktiv und performant zu gestalten. Lange war die reaktive Erweiterung RxJS der Platzhirsch, wenn es darum ging, Ereignisbehandlung und asynchrone Datenströme in Angular zu Entwickeln In diesem Vortrag werden Sie gemeinsam mit Google Developer Expert Martina Kraus einen detaillierten Vergleich beider Technologien im Kontext der Performance- und Ereignisbehandlung durchführen. Nach einer kleinen Einfûhrung tauchen wir tiefer in die Funktionsweise von Angular Signals ein, wie sie in Komponenten eingebunden werden und wie sie die Kommunikation zwischen verschiedenen Module der Anwendung ermöglichen. Am Ende werden Sie ein besseres Verständnis dafür haben, wie Angular Signals im Vergleich zu RxJS Observables funktionieren und wie sie in ihren eigenen Angular-Projekten effektiv eingesetzt werden können. ja herzlich willkommen hier auf entwickler de zu unserem Javas geta. Schön, dass ihr die Zeit genommen habt heute hier live dabei zu sein. Wir haben drei spannende Sessions zu brandaktuellen Themen aus dem natürlich javaskript Universum vorbereitet für euch, die wir hier live streamen, als sogenanntes FOTA live event. Ihr kennt das vielleicht ihr habt als Frist war hier Zugriff auf eine ganze reihe von live events dieser art. Jeden jede woche gibt es einiges hier zu sehen zu ja, aber eine micro services. Kubin das war gestern ja aber es gibt da denn nun heute? Also lohnt sich hier immer wieder mal vorbeizuschauen und heute eben frühste live event ja was gibt after? Nun, wir schauen gleich mal auf das Programm ich führe euch heute durchs Programm, mein Name ist Hartmut Schlosser Redakteur hier auf entwickler de und ja, ich freue mich gleich die Martina Kraus begrüßen zu dürfen. 14 Uhr geht es los mit Angola. Signers ganz prakt neues thema das jetzt aktuell diskutiert wird. Ähm sollte man sich mal anschauen was es damit auf sich hat, nicht nur im jahr im angola umfeld wichtig ähm einfach mal spannend auch den vergleich zu wagen zu Observer Observer das schon länger kennen. 15\n'slidetext': \n'part_name': 1\n'total_parts': 22\n'from': index\n'score': 86.17090606689453\n'normalizedScore': 1.1827744621832128\n'beforeDatePenaltyScore': 1.231012943812779\n\n'contentType': RHEINGOLD\n'documentId': 59c6dfa238c69ebd748cc7dc\n'title': Angular Signals: Neue Features für die reaktive Entwicklungnull\n'abstract': Angular Signals sind seit einiger Zeit ein spannender Bestandteil der reaktiven Entwicklung in Angular. Mit neuen Features wie linkedSignal() und resource() in Angular 20 rücken sie weiter in den Fokus. Doch wie funktionieren Signals und was macht sie so besonders – insbesondere in Bezug auf die Performance? Welche Vorteile bieten sie gegenüber klassischen RxJS-Patterns? Felix Schütz von Thinktecture gibt eine praxisnahe Einführung in Angular Signals und die damit verbundenen neuen Features und zeigt, wie sie die Entwicklung von modernen, reaktiven Anwendungen nachhaltig verändern. Zusätzlich gibt er einen Ausblick auf die geplante Unterstützung von Signal-basierten Formularen.\n'parentName': JavaScript Days Berlin und online 2025\n'parentDescription': 40 Workshops zu JavaScript, Angular, React, Typescript und KI\n'author': Felix Schütz\n'language': DE\n'date': Wed Oct 22 2025 11:30:00 GMT+0000 (Coordinated Universal Time)\n'access': restricted\n'chunkSource': text\n'text': Angular Signals: Neue Features für die reaktive Entwicklung Angular Signals sind seit einiger Zeit ein spannender Bestandteil der reaktiven Entwicklung in Angular. Mit neuen Features wie linkedSignal() und resource() in Angular 20 rücken sie weiter in den Fokus. Doch wie funktionieren Signals und was macht sie so besonders – insbesondere in Bezug auf die Performance? Welche Vorteile bieten sie gegenüber klassischen RxJS-Patterns? Felix Schütz von Thinktecture gibt eine praxisnahe Einführung in Angular Signals und die damit verbundenen neuen Features und zeigt, wie sie die Entwicklung von modernen, reaktiven Anwendungen nachhaltig verändern. Zusätzlich gibt er einen Ausblick auf die geplante Unterstützung von Signal-basierten Formularen.\n'slidetext': \n'part_name': 1\n'total_parts': 1\n'from': vector\n'score': 0.9380064010620117\n'normalizedScore': 0.945562481687963\n'beforeDatePenaltyScore': 0.9380064010620117\n\n'contentType': RHEINGOLD\n'documentId': bdffbea5001602c274727100\n'title': Quo vadis, Angular State Management?null\n'abstract': Mit der Einführung von Signals hat Angular ein klares Zeichen für modernes State Management gesetzt. Signals fungieren als Container für Anwendungs-State und sind reaktiv. Dadurch ermöglichen sie die einfache Erstellung abgeleiteter Werte, wie sie beispielsweise für ViewModels benötigt werden. Ergänzt werden sie durch Hilfsfunktionen wie resource, die Signals nahtlos mit Backend-Kommunikation verbinden – eine runde Sache. Doch wie weit kommt man mit diesen nativen Tools und wann wird eine spezialisierte Lösung wie der NgRx Signal Store notwendig? Diese Frage steht im Mittelpunkt meines Vortrags, in dem ich die Grenzen der nativen Signals und die Vorteile spezialisierter Bibliotheken aufzeige.\n'parentName': W-JAX 2025\n'parentDescription': Die Konferenz für Java, Architektur- und Software-Innovation\n'author': Rainer Hahnekamp\n'language': DE\n'date': Thu Nov 06 2025 09:30:00 GMT+0000 (Coordinated Universal Time)\n'access': restricted\n'chunkSource': text\n'text': Quo vadis, Angular State Management? Mit der Einführung von Signals hat Angular ein klares Zeichen für modernes State Management gesetzt. Signals fungieren als Container für Anwendungs-State und sind reaktiv. Dadurch ermöglichen sie die einfache Erstellung abgeleiteter Werte, wie sie beispielsweise für ViewModels benötigt werden. Ergänzt werden sie durch Hilfsfunktionen wie resource, die Signals nahtlos mit Backend-Kommunikation verbinden – eine runde Sache. Doch wie weit kommt man mit diesen nativen Tools und wann wird eine spezialisierte Lösung wie der NgRx Signal Store notwendig? Diese Frage steht im Mittelpunkt meines Vortrags, in dem ich die Grenzen der nativen Signals und die Vorteile spezialisierter Bibliotheken aufzeige.\n'slidetext': \n'part_name': 1\n'total_parts': 1\n'from': vector\n'score': 0.9286953806877136\n'normalizedScore': 0.9374774887109252\n'beforeDatePenaltyScore': 0.9286953806877136\n\n'contentType': RHEINGOLD\n'documentId': 01a63ca630515849aaa314b1\n'title': Angular Signals: Neue Features für die reaktive Entwicklungnull\n'abstract': Angular Signals sind seit einiger Zeit ein spannender Bestandteil der reaktiven Entwicklung in Angular. Mit neuen Features wie linkedSignal() und resource() in Angular 19 rücken sie weiter in den Fokus. Doch wie funktionieren Signals und was macht sie so besonders – insbesondere in Bezug auf die Performance? Welche Vorteile bieten sie gegenüber klassischen RxJS-Patterns?Felix Schütz von Thinktecture gibt eine praxisnahe Einführung in Angular Signals und die damit verbundenen neuen Features und zeigt, wie sie die Entwicklung von modernen, reaktiven Anwendungen nachhaltig verändern. Zusätzlich gibt er einen Ausblick auf die geplante Unterstützung von Signal-basierten Formularen.\n'parentName': JavaScript Days München und online 2025\n'parentDescription': 40 Workshops zu JavaScript, Angular, React, HTML & CSS und KI\n'author': Felix Schütz\n'language': DE\n'date': Wed Mar 19 2025 12:30:00 GMT+0000 (Coordinated Universal Time)\n'access': restricted\n'chunkSource': text\n'text': Angular Signals: Neue Features für die reaktive Entwicklung Angular Signals sind seit einiger Zeit ein spannender Bestandteil der reaktiven Entwicklung in Angular. Mit neuen Features wie linkedSignal() und resource() in Angular 19 rücken sie weiter in den Fokus. Doch wie funktionieren Signals und was macht sie so besonders – insbesondere in Bezug auf die Performance? Welche Vorteile bieten sie gegenüber klassischen RxJS-Patterns?Felix Schütz von Thinktecture gibt eine praxisnahe Einführung in Angular Signals und die damit verbundenen neuen Features und zeigt, wie sie die Entwicklung von modernen, reaktiven Anwendungen nachhaltig verändern. Zusätzlich gibt er einen Ausblick auf die geplante Unterstützung von Signal-basierten Formularen.\n'slidetext': \n'part_name': 1\n'total_parts': 1\n'from': vector\n'score': 0.9387110471725464\n'normalizedScore': 0.9284349360176758\n'beforeDatePenaltyScore': 0.9387110471725464\n\n'contentType': READ\n'documentId': 11e1079277948f18298e5d3d\n'title': Angular: Signals, Standalone, SSRSo bauen Sie Angular-Apps der Zukunft\n'abstract': Mit der Veröffentlichung der 16. Hauptversion von Angular läutete das Angular-Team die „Angular Renaissance“ ein. Wörtlich übersetzt bedeutet das nichts Geringeres als die Wiedergeburt von Googles SPA-Framework - eine treffende Bezeichnung, denn Angular-Codebasen werden sich nachhaltig verändern. Der Unterschied zwischen Angular-2- und Angular-17-Code ist mit bloßem Auge erkennbar.\n'parentName': iJS Magazin 4.2024\n'parentDescription': Kaum ein Softwareprojekt, das nicht in wesentlichen Teilen auf der JavaScript-Technologie basiert. Eine breite Unterstützung sowie, leistungsfähige Programmiersprachen, die Vielzahl moderner Tools, sowie ausgereifte Frameworks wie Angular, React, Vue.js oder Node.js machen den JavaScript-Werkzeugkasten zu einem Alleskönner. Das iJS Magazin informiert aktuell und umfassend über die wichtige und innovative Entwicklungen im JavaScript-Universum und bietet handfeste Praxisinformationen für Softwareentwickler und -architekten.\n'author': Christian Liebel\n'language': DE\n'date': Wed Oct 09 2024 22:00:00 GMT+0000 (Coordinated Universal Time)\n'access': granted\n'chunkSource': text\n'text': Angular: Signals, Standalone, SSR So bauen Sie Angular-Apps der Zukunft Mit der Veröffentlichung der 16. Hauptversion von Angular läutete das Angular-Team die „Angular Renaissance“ ein. Wörtlich übersetzt bedeutet das nichts Geringeres als die Wiedergeburt von Googles SPA-Framework - eine treffende Bezeichnung, denn Angular-Codebasen werden sich nachhaltig verändern. Der Unterschied zwischen Angular-2- und Angular-17-Code ist mit bloßem Auge erkennbar. Mit der Veröffentlichung der 16. Hauptversion von Angular läutete das Angular-Team die „Angular Renaissance“ ein. Wörtlich übersetzt bedeutet das nichts Geringeres als die Wiedergeburt von Googles SPA-Framework – eine treffende Bezeichnung, denn Angular-Codebasen werden sich nachhaltig verändern. Der Unterschied zwischen Angular-2- und Angular-17-Code ist mit bloßem Auge erkennbar. Derzeit führt das Angular-Team zahlreiche neue Features und Konzepte in das Framework ein. Ziel dieser Änderungen ist, Angular zu vereinfachen und damit Anfänger:innen den Einstieg zu erleichtern, Schnittstellen zu modernisieren und die Performance von Angular-Anwendungen zu verbessern, damit das Framework auch im kommenden Jahrzehnt seines Bestehens konkurrenzfähig bleibt. Alle neuen Funktionen sind abwärtskompatibel und interoperabel. In diesem Artikel soll es um drei dieser Features gehen: 1. den neuen reaktiven Basisdatentyp Signals, 2. die Standalone-Schnittstellen als NgModule-Killer und 3. den neuen Ansatz zum Server-side Rendering, der es in die 17. Hauptversion von Angular geschafft hat. Angular-Entwickler:innen, die neue Anwendungen erstellen, sollten diese Features in jedem Fall berücksichtigen. Bestandsanwendungen sollten schnellstmöglich migriert werden. In diesem Artikel wird zu jedem Feature angegeben, ob, wann und wie eine Migration vorgenommen werden sollte. Signals – Die neue Art des State Management Mit der 16. Hauptversion von Angular wurden Signals in das Framework eingeführt. Es handelt sich um den neuen reaktiven Basisdatentyp [1]. Ein Signal ist ein Wrapper um einen bestimmten Wert. Wenn sich dieser ändert, informiert das Signal interessierte Konsumenten, sodass diese auf die Änderung reagieren können. const count = signal(0); count.set(3); Ein neues schreibbares Signal lässt sich über die Methode signal() erzeugen. Signals müssen zwingend mit einem Initialwert vorbelegt sein, der als Argument angegeben wird. Es ist\n'slidetext': \n'part_name': 1\n'total_parts': 9\n'from': vector\n'score': 0.9492647647857666\n'normalizedScore': 0.9257883111651426\n'beforeDatePenaltyScore': 0.9492647647857666\n\n'contentType': READ\n'documentId': 8b35e3d0070110b78d6c9434\n'title': Angular: Signals, Standalone, SSRSo bauen Sie Angular-Apps der Zukunft\n'abstract': Mit der Veröffentlichung der 16. Hauptversion von Angular läutete das Angular-Team die „Angular Renaissance“ ein. Wörtlich übersetzt bedeutet das nichts Geringeres als die Wiedergeburt von Googles SPA-Framework - eine treffende Bezeichnung, denn Angular-Codebasen werden sich nachhaltig verändern. Der Unterschied zwischen Angular-2- und Angular-17-Code ist mit bloßem Auge erkennbar.\n'parentName': Windows Developer 7.2024\n'parentDescription': Windows Developer informiert umfassend und herstellerneutral über die neuen Trends und Möglichkeiten der Software- und Systementwicklung rund um Microsoft- und Web-Technologien. Von der klassischen .NET-Entwicklung über .NET Core bis hin zu neuen Technologien wie Windows 10, Microsoft Azure und der ganzen Bandbreite der aktuellen Web-, Phone- und Tabletentwicklung für Android und iOS mit Xamarin und unterschiedlichen JavaScript-Frameworks. Professionelle Entwickler und IT-Entscheider erhalten genau die Informationen, die sie für den erfolgreichen Einsatz von unternehmensorientierten Lösungen benötigen.\n'author': Christian Liebel\n'language': DE\n'date': Mon Jun 10 2024 22:00:00 GMT+0000 (Coordinated Universal Time)\n'access': granted\n'chunkSource': text\n'text': Angular: Signals, Standalone, SSR So bauen Sie Angular-Apps der Zukunft Mit der Veröffentlichung der 16. Hauptversion von Angular läutete das Angular-Team die „Angular Renaissance“ ein. Wörtlich übersetzt bedeutet das nichts Geringeres als die Wiedergeburt von Googles SPA-Framework - eine treffende Bezeichnung, denn Angular-Codebasen werden sich nachhaltig verändern. Der Unterschied zwischen Angular-2- und Angular-17-Code ist mit bloßem Auge erkennbar. Mit der Veröffentlichung der 16. Hauptversion von Angular läutete das Angular-Team die „Angular Renaissance“ ein. Wörtlich übersetzt bedeutet das nichts Geringeres als die Wiedergeburt von Googles SPA-Framework – eine treffende Bezeichnung, denn Angular-Codebasen werden sich nachhaltig verändern. Der Unterschied zwischen Angular-2- und Angular-17-Code ist mit bloßem Auge erkennbar. Derzeit führt das Angular-Team zahlreiche neue Features und Konzepte in das Framework ein. Ziel dieser Änderungen ist, Angular zu vereinfachen und damit Anfänger:innen den Einstieg zu erleichtern, Schnittstellen zu modernisieren und die Performance von Angular-Anwendungen zu verbessern, damit das Framework auch im kommenden Jahrzehnt seines Bestehens konkurrenzfähig bleibt. Alle neuen Funktionen sind abwärtskompatibel und interoperabel. In diesem Artikel soll es um drei dieser Features gehen: 1. den neuen reaktiven Basisdatentyp Signals, 2. die Standalone-Schnittstellen als NgModule-Killer und 3. den neuen Ansatz zum Server-side Rendering, der es in die 17. Hauptversion von Angular geschafft hat. Angular-Entwickler:innen, die neue Anwendungen erstellen, sollten diese Features in jedem Fall berücksichtigen. Bestandsanwendungen sollten schnellstmöglich migriert werden. In diesem Artikel wird zu jedem Feature angegeben, ob, wann und wie eine Migration vorgenommen werden sollte. Signals – Die neue Art des State Management Mit der 16. Hauptversion von Angular wurden Signals in das Framework eingeführt. Es handelt sich um den neuen reaktiven Basisdatentyp [1]. Ein Signal ist ein Wrapper um einen bestimmten Wert. Wenn sich dieser ändert, informiert das Signal interessierte Konsumenten, sodass diese auf die Änderung reagieren können. const count = signal(0); count.set(3); Ein neues schreibbares Signal lässt sich über die Methode signal() erzeugen. Signals müssen zwingend mit einem Initialwert vorbelegt sein, der als Argument angegeben wird. Es ist\n'slidetext': \n'part_name': 1\n'total_parts': 9\n'from': vector\n'score': 0.9492647647857666\n'normalizedScore': 0.9158431056856905\n'beforeDatePenaltyScore': 0.9492647647857666\n\n'contentType': RHEINGOLD\n'documentId': E8GpqxYcngd3MofGq\n'title': Angular Signals: Gamechanger für reaktive Entwicklungnull\n'abstract': Das Angular-Team stellt sein reaktives Modell auf den Prüfstand und schlägt als neuen Ansatz die von anderen Frameworks bekannten Signals vor. Während Altanwendungen zunächst weiter funktionieren wie gehabt, bieten Signals entscheidende Vorteile gegenüber dem bestehenden Modell.  Brauchen Anwendungen in Zukunft überhaupt noch RxJS? Welche Vorteile haben Signals auf die Performance einer Anwendung? Und wie funktioniert das Reaktivitätsmodell im Detail?  Yannick Baron von Thinktecture und Google Developer Expert für Angular beantwortet alle Fragen rund um die neuen Angular-Signals.\n'parentName': JavaScript Days Berlin und online 2024\n'parentDescription': 40 Workshops zu JavaScript, Angular, React, Typescript und KI\n'author': Yannick Baron\n'language': DE\n'date': Wed Oct 23 2024 11:30:00 GMT+0000 (Coordinated Universal Time)\n'access': restricted\n'chunkSource': text\n'text': Angular Signals: Gamechanger für reaktive Entwicklung Das Angular-Team stellt sein reaktives Modell auf den Prüfstand und schlägt als neuen Ansatz die von anderen Frameworks bekannten Signals vor. Während Altanwendungen zunächst weiter funktionieren wie gehabt, bieten Signals entscheidende Vorteile gegenüber dem bestehenden Modell. Brauchen Anwendungen in Zukunft überhaupt noch RxJS? Welche Vorteile haben Signals auf die Performance einer Anwendung? Und wie funktioniert das Reaktivitätsmodell im Detail? Yannick Baron von Thinktecture und Google Developer Expert für Angular beantwortet alle Fragen rund um die neuen Angular-Signals.\n'slidetext': \n'part_name': 1\n'total_parts': 1\n'from': vector\n'score': 0.9359365701675415\n'normalizedScore': 0.9135748425743148\n'beforeDatePenaltyScore': 0.9359365701675415\n\n'contentType': READ\n'documentId': 289cab1ef800cbd306a62af3\n'title': Angular 18 – erwachsen, aber aktivAlles zur neuen Version\n'abstract': Mit Angular 18 steht Entwickler:innen eine Vielzahl neuer Features und Verbesserungen zur Verfügung, die die Entwicklung moderner Webanwendungen weiter optimieren. Angular 18 baut auf die Fortschritte der Vorgängerversionen auf und führt zahlreiche Performanceoptimierungen sowie neue APIs ein, die die Arbeit mit dem Framework noch effizienter gestalten.\n'parentName': iJS Magazin 4.2024\n'parentDescription': Kaum ein Softwareprojekt, das nicht in wesentlichen Teilen auf der JavaScript-Technologie basiert. Eine breite Unterstützung sowie, leistungsfähige Programmiersprachen, die Vielzahl moderner Tools, sowie ausgereifte Frameworks wie Angular, React, Vue.js oder Node.js machen den JavaScript-Werkzeugkasten zu einem Alleskönner. Das iJS Magazin informiert aktuell und umfassend über die wichtige und innovative Entwicklungen im JavaScript-Universum und bietet handfeste Praxisinformationen für Softwareentwickler und -architekten.\n'author': Karsten Sitterberg\n'language': DE\n'date': Wed Oct 09 2024 22:00:00 GMT+0000 (Coordinated Universal Time)\n'access': granted\n'chunkSource': text\n'text': bei neu generierten Projekten in Zukunft deshalb nicht mehr assets, sondern public. Weiterhin wird mit Angular CLI 18 der Befehl ng doc entfernt, da dieser ohnehin nur selten genutzt wurde. Die offizielle Empfehlung ist, stattdessen in der Dokumentation unter [1] nachzuschauen. Breaking Changes Neben der neu unterstützten Node.js-Version 22 wurde auch die minimal notwendige Node.js-Version angepasst. Die minimal notwendige LTS-Node.js-Version ist nun 18.19.1, Node.js 19 wird gar nicht mehr unterstützt, und Node.js 20 erst ab Version 20.11.1. Weiterhin wurde die Anbindung des alten, nur noch im webpack-Build unterstützten Sass API (NG_BUILD_LEGACY_SASS) entfernt. Das Legacy API ermöglichte beispielsweise noch die alte ~-Import-Syntax. Angular Auch mit den Minor-Angular-17-Versionen sind einige interessante Neuerungen in Bezug auf die Zukunft von Angular hinzugekommen. Das betrifft zum einen die Weiterentwicklung des Frameworks im Allgemeinen. Zum anderen sind vor allem die Angular-Signal-APIs deutlich erweitert worden, um so das Ziel zu erreichen, Angular-Anwendungen in Zukunft ohne zone.js laufen lassen zu können. Die Neuerungen sollen an dieser Stelle kurz vorgestellt werden. Angular 17.1, 17.2 und 17.3 Ganz besondere Aufmerksamkeit haben die Signal APIs innerhalb der letzten Angular-Versionen erhalten. Dazu gehören vor allem APIs, mit denen die Decorators innerhalb von Komponenten durch Signal-Varianten ersetzt werden können. Das gilt vor allem für Komponenten bzw. Anwendungen, die künftig ohne zone.js auskommen sollen. Um die Neuerungen zu veranschaulichen, wird in Listing 6 die Komponente DemoFormComponent gezeigt, die ein boolesches @Input für den Nachtmodus und ein String-@Input für den momentanen Formularwert hat. Der Input für den Formularwert hat außerdem das Flag required, es wird also ein Compilerfehler ausgegeben, wenn dieser Input nicht gebunden ist. Außerdem ist ein @Output mit dem Namen valueChange vorhanden, der bei jeder Wertänderung des Formulars emittiert. Zu jedem @Output gehört immer ein EventEmitter. (Da der EventEmitter jedoch vom RxJS Subject erbt, könnte an dieser Stelle auch ein Observable stehen, dazu später mehr.) Da der Input value und der Output valueChange heißen, können beide per Two-way Data Binding angebunden werden:  Die Variable 'firstname'\n'slidetext': \n'part_name': 5\n'total_parts': 15\n'from': vector\n'score': 0.9319087266921997\n'normalizedScore': 0.9084322730715757\n'beforeDatePenaltyScore': 0.9319087266921997\n\n'contentType': READ\n'documentId': d93198ee7197abce047d0dc1\n'title': Signals und State ManagementFrontend-Entwicklung mit Signals – Teil 3\n'abstract': Bereits ab Angular 17 kann ein Teil des Signals API produktiv eingesetzt werden. Die neu veröffentlichte Control-Flow-Syntax dient auch als Grundlage für Signal-basierte Komponenten, die voraussichtlich 2024 veröffentlicht werden. Bis diese APIs einsatzbereit sind, können bereits Schritte unternommen werden, um aktuell vorhandene State-Management-Implementierungen auf Signals umzustellen. Unsere Artikelserie soll dabei helfen, schon jetzt in die neue Welt einzutauchen, um die richtigen Entscheidungen treffen zu können, sobald die neuen Framework APIs die Developer-Preview-Phase verlassen. Dieser dritte Artikel geht auf die Auswirkungen von Signals auf das State Management ein.\n'parentName': iJS Magazin 3.2024\n'parentDescription': Kaum ein Softwareprojekt, das nicht in wesentlichen Teilen auf der JavaScript-Technologie basiert. Eine breite Unterstützung sowie, leistungsfähige Programmiersprachen, die Vielzahl moderner Tools, sowie ausgereifte Frameworks wie Angular, React, Vue.js oder Node.js machen den JavaScript-Werkzeugkasten zu einem Alleskönner. Das iJS Magazin informiert aktuell und umfassend über die wichtige und innovative Entwicklungen im JavaScript-Universum und bietet handfeste Praxisinformationen für Softwareentwickler und -architekten.\n'author': Michael Egger-Zikes\n'language': DE\n'date': Thu Jul 04 2024 22:00:00 GMT+0000 (Coordinated Universal Time)\n'access': granted\n'chunkSource': text\n'text': Signals und State Management Frontend-Entwicklung mit Signals – Teil 3 Bereits ab Angular 17 kann ein Teil des Signals API produktiv eingesetzt werden. Die neu veröffentlichte Control-Flow-Syntax dient auch als Grundlage für Signal-basierte Komponenten, die voraussichtlich 2024 veröffentlicht werden. Bis diese APIs einsatzbereit sind, können bereits Schritte unternommen werden, um aktuell vorhandene State-Management-Implementierungen auf Signals umzustellen. Unsere Artikelserie soll dabei helfen, schon jetzt in die neue Welt einzutauchen, um die richtigen Entscheidungen treffen zu können, sobald die neuen Framework APIs die Developer-Preview-Phase verlassen. Dieser dritte Artikel geht auf die Auswirkungen von Signals auf das State Management ein. Bereits ab Angular 17 kann ein Teil des Signals API produktiv eingesetzt werden. Die neu veröffentlichte Control-Flow-Syntax dient auch als Grundlage für Signal-basierte Komponenten, die voraussichtlich 2024 veröffentlicht werden. Bis diese APIs einsatzbereit sind, können bereits Schritte unternommen werden, um aktuell vorhandene State-Management-Implementierungen auf Signals umzustellen. Unsere Artikelserie soll dabei helfen, schon jetzt in die neue Welt einzutauchen, um die richtigen Entscheidungen treffen zu können, sobald die neuen Framework APIs die Developer-Preview-Phase verlassen. Dieser dritte Artikel geht auf die Auswirkungen von Signals auf das State Management ein. Während die Angular-Community beginnen kann, das Signals API in der eigenen Codebase zu verwenden, arbeitet das Angular-Team intensiv an weiterführenden Signal-Implementierungen, die schlussendlich punktuellere View-Updates und auch das Nachladen von einzelnen Applikationsbestandteilen ermöglichen werden. Signals werden das Angular-Framework allerdings auch in anderen Bereichen verändern. Einer davon ist die Zustandsverwaltung der Frontend-Applikation. Zustandsverwaltung mit Angular Angular selbst gibt bislang kein konkretes Konzept für State Management vor. Zustand, der in einer Komponente angezeigt werden soll, kann z. B. Klassen-Properties zugewiesen und mit Stringinterpolation an das Template gebunden und damit angezeigt werden. Die Change Detection kümmert sich darum, dass geänderte Property-Werte auch in der HTML-View aktualisiert werden. Mit Hilfe von Property Bindings kann Zustand auch an Kindkomponenten und Direktiven weitergegeben werden, wobei diese Änderungen per Event Emitter an die Elternkomponente zurückgesendet werden können. Mit dem\n'slidetext': \n'part_name': 1\n'total_parts': 10\n'from': vector\n'score': 0.9384304285049438\n'normalizedScore': 0.9069813721445937\n'beforeDatePenaltyScore': 0.9384304285049438\n\n'contentType': RHEINGOLD\n'documentId': 4d3f036f4ec6fbdb475269f9\n'title': Angular Signal – Revolution der Angular-Entwicklungnull\n'abstract': Angular mitten im Wandel. In der modernen, neuen Angular-Entwicklung spielen Signals als kleine Revolution eine zentrale Rolle. Dieser Vortrag taucht in die Welt der Signals ein, erklärt, wie sie funktionieren und warum sie die Angular-Anwendungsentwicklung revolutionieren. Wir werden die technischen Aspekte und Best Practices für den effektiven Einsatz von Angular-Signals untersuchen und schauen, wie ein Angular Applikation mit Signals aussehen kann. Dieser Vortrag ist eine unverzichtbare Ressource für alle, die ihr Wissen in der Angular-Entwicklung erweitern und die Möglichkeiten von Angular-Signals voll ausschöpfen möchten.\n'parentName': BASTA! Herbst 2024\n'parentDescription': Die Konferenz für .NET, Windows & Open Innovation\n'author': Fabian Gosebrink\n'language': DE\n'date': Thu Sep 19 2024 10:00:00 GMT+0000 (Coordinated Universal Time)\n'access': restricted\n'chunkSource': text\n'text': Angular Signal – Revolution der Angular-Entwicklung Angular mitten im Wandel. In der modernen, neuen Angular-Entwicklung spielen Signals als kleine Revolution eine zentrale Rolle. Dieser Vortrag taucht in die Welt der Signals ein, erklärt, wie sie funktionieren und warum sie die Angular-Anwendungsentwicklung revolutionieren. Wir werden die technischen Aspekte und Best Practices für den effektiven Einsatz von Angular-Signals untersuchen und schauen, wie ein Angular Applikation mit Signals aussehen kann. Dieser Vortrag ist eine unverzichtbare Ressource für alle, die ihr Wissen in der Angular-Entwicklung erweitern und die Möglichkeiten von Angular-Signals voll ausschöpfen möchten. ::. --> ::. Mittagessen steht. Wir wollen uns heute ein bisschen Angular Signals angucken. Ich glaube, das ist auch in eurem Interesse oder? Haben sie aber schon vor ein paar Tagen oder noch diesen Talk anbieten. bisschen unter der Haube an wie das Ganze funktioniert. wie das Ganze eben unter der Haube wirklich funktioniert, Das heißt wir gucken uns an, wie ihr das in eurer Applikation einsetzen könnt. So der zweite Teil überlappt sich so ein bisschen mit dem, ihr solltet dann hier rausgehen und zumindest wissen, und vor allen Dingen, wie ihr emigrieren könnt. in seiner Applikation? Ach, sehr gut, prima. Das ist schon mal gut. ist auch so ein bisschen einzuordnen, Warum ist Angular hingegangen und hat das Ganze gemacht? Signals selber, aber die haben auch irgendwie sowas Ähnliches., Finde ich auch sehr, gut, recht zunächst gucken, was können wir machen und adaptieren Also eine coole Sache. Wir müssen so bisschen gucken, wie die läuft. Heute Morgen habe ich über Container und Presentational schön mit on push Change Detection versehen. die du sowieso durchläufst, nehme ich erst mal raus. Jetzt ist die Frage, wie läuft die normale Change Detection? von Components. Der ist riesig groß. rennt Angular los und dieser komplette Baum, der Dom, Entweder ist was passiert oder es ist nichts passiert. sagen,, ist okay, nur wenn sich wirklich was geändert hat. aber trotzdem overhead. Davon haben wir als Entwickler gar nicht viel mitbekommen, die auf jede Change Detection Run gucken, wie oft das Ganze geht, da geht eine Menge ab. Und\n'slidetext': \n'part_name': 1\n'total_parts': 11\n'from': vector\n'score': 0.9307624697685242\n'normalizedScore': 0.9056010846410508\n'beforeDatePenaltyScore': 0.9307624697685242\n\n'contentType': READ\n'documentId': 16b7f80d5b4b04e3989c2532\n'title': Angular 18 – erwachsen, aber aktivAlles zur neuen Version\n'abstract': Mit Angular 18 steht Entwickler:innen eine Vielzahl neuer Features und Verbesserungen zur Verfügung, die die Entwicklung moderner Webanwendungen weiter optimieren. Angular 18 baut auf die Fortschritte der Vorgängerversionen auf und führt zahlreiche Performanceoptimierungen sowie neue APIs ein, die die Arbeit mit dem Framework noch effizienter gestalten.\n'parentName': Windows Developer 10.2024\n'parentDescription': Windows Developer informiert umfassend und herstellerneutral über die neuen Trends und Möglichkeiten der Software- und Systementwicklung rund um Microsoft- und Web-Technologien. Von der klassischen .NET-Entwicklung über .NET Core bis hin zu neuen Technologien wie Windows 10, Microsoft Azure und der ganzen Bandbreite der aktuellen Web-, Phone- und Tabletentwicklung für Android und iOS mit Xamarin und unterschiedlichen JavaScript-Frameworks. Professionelle Entwickler und IT-Entscheider erhalten genau die Informationen, die sie für den erfolgreichen Einsatz von unternehmensorientierten Lösungen benötigen.\n'author': Karsten Sitterberg\n'language': DE\n'date': Wed Aug 28 2024 22:00:00 GMT+0000 (Coordinated Universal Time)\n'access': granted\n'chunkSource': text\n'text': bei neu generierten Projekten in Zukunft deshalb nicht mehr assets, sondern public. Weiterhin wird mit Angular CLI 18 der Befehl ng doc entfernt, da dieser ohnehin nur selten genutzt wurde. Die offizielle Empfehlung ist, stattdessen in der Dokumentation unter [1] nachzuschauen. Breaking Changes Neben der neu unterstützten Node.js-Version 22 wurde auch die minimal notwendige Node.js-Version angepasst. Die minimal notwendige LTS-Node.js-Version ist nun 18.19.1, Node.js 19 wird gar nicht mehr unterstützt, und Node.js 20 erst ab Version 20.11.1. Weiterhin wurde die Anbindung des alten, nur noch im webpack-Build unterstützten Sass API (NG_BUILD_LEGACY_SASS) entfernt. Das Legacy API ermöglichte beispielsweise noch die alte ~-Import-Syntax. Angular Auch mit den Minor-Angular-17-Versionen sind einige interessante Neuerungen in Bezug auf die Zukunft von Angular hinzugekommen. Das betrifft zum einen die Weiterentwicklung des Frameworks im Allgemeinen. Zum anderen sind vor allem die Angular-Signal-APIs deutlich erweitert worden, um so das Ziel zu erreichen, Angular-Anwendungen in Zukunft ohne zone.js laufen lassen zu können. Die Neuerungen sollen an dieser Stelle kurz vorgestellt werden. Angular 17.1, 17.2 und 17.3 Ganz besondere Aufmerksamkeit haben die Signal APIs innerhalb der letzten Angular-Versionen erhalten. Dazu gehören vor allem APIs, mit denen die Decorators innerhalb von Komponenten durch Signal-Varianten ersetzt werden können. Das gilt vor allem für Komponenten bzw. Anwendungen, die künftig ohne zone.js auskommen sollen. Um die Neuerungen zu veranschaulichen, wird in Listing 6 die Komponente DemoFormComponent gezeigt, die ein boolesches @Input für den Nachtmodus und ein String-@Input für den momentanen Formularwert hat. Der Input für den Formularwert hat außerdem das Flag required, es wird also ein Compilerfehler ausgegeben, wenn dieser Input nicht gebunden ist. Außerdem ist ein @Output mit dem Namen valueChange vorhanden, der bei jeder Wertänderung des Formulars emittiert. Zu jedem @Output gehört immer ein EventEmitter. (Da der EventEmitter jedoch vom RxJS Subject erbt, könnte an dieser Stelle auch ein Observable stehen, dazu später mehr.) Da der Input value und der Output valueChange heißen, können beide per Two-way Data Binding angebunden werden:  Die Variable 'firstname'\n'slidetext': \n'part_name': 5\n'total_parts': 15\n'from': vector\n'score': 0.9319087266921997\n'normalizedScore': 0.9049802182770551\n'beforeDatePenaltyScore': 0.9319087266921997\n\n'contentType': READ\n'documentId': 04721391f3f7580f0631b9d3\n'title': Angular 17: Neues Release des Web-FrameworksRenaissance? Angular 17! - Alle Features im Überblick\n'abstract': Das beliebte JavaScript-Framework Angular veröffentlicht Version 17. Da bei Angular viel in Bewegung ist, kann manch einer da den Überblick verlieren. Wir stellen alle Features von Angular 17 vor.\n'parentName': iJS Magazin 2.2024\n'parentDescription': Kaum ein Softwareprojekt, das nicht in wesentlichen Teilen auf der JavaScript-Technologie basiert. Eine breite Unterstützung sowie, leistungsfähige Programmiersprachen, die Vielzahl moderner Tools, sowie ausgereifte Frameworks wie Angular, React, Vue.js oder Node.js machen den JavaScript-Werkzeugkasten zu einem Alleskönner. Das iJS Magazin informiert aktuell und umfassend über die wichtige und innovative Entwicklungen im JavaScript-Universum und bietet handfeste Praxisinformationen für Softwareentwickler und -architekten.\n'author': Karsten Sitterberg\n'language': DE\n'date': Wed Apr 03 2024 22:00:00 GMT+0000 (Coordinated Universal Time)\n'access': granted\n'chunkSource': text\n'text': '@NgModule()'s. - Funktionale HTTP-Interceptoren werden in Angular CLI 17 bevorzugt, klassenbasierte sind optional. - Einführung der neuen Syntax @switch, @case, und @default für Conditional Rendering und neue Direktiven wie @defer für Lazy Loading. - @defer unterstützt bedingtes Laden und Vorladen mit prefetch. - Die Angular CLI bietet eine automatische Migration zur neuen Syntax an; alte und neue Syntax können in Version 17 parallel genutzt werden. - Integration der neuen Lifecycle-Hooks afterRender() und afterNextRender sowie die Stabilisierung von Signals. - Lazy Loading für Animationen und die Integration der View Transitions DOM-API für optimierte Übergänge und Animationen. - Einführung einer neuen Control-Flow-Syntax als Developer Preview, die *ngIf, *ngFor, und ngSwitch ersetzt und zusätzliche Verbesserungen wie @if, @for, und erforderliches Track-by für Listen umfasst. Breaking Changes in Angular 17 - Entfernung von signal.mutate(): Die Möglichkeit, Signals durch Mutation zu verändern, wurde entfernt. Signals müssen als immutable Datenstrukturen behandelt werden; Änderungen sollten durch die signal.update()-Funktion vorgenommen werden. - Signal-Handhabung als immutable: Anstatt Signals zu mutieren, sollten Entwickler diese nun behandeln, als wären sie immutable, und entsprechend aktualisieren. - Entfernung von Router Properties: Bestimmte Router Properties wie canceledNavigationResolution, paramsInheritanceStrategy, titleStrategy, urlUpdateStrategy, malformedUriErrorHandler und urlHandlingStrategy wurden aus der öffentlichen API entfernt. - Neue Konfiguration über provideRouter() oder RouterModule.forRoot(): Die zuvor entfernten Router Properties müssen jetzt über die provideRouter()-Funktion oder im RouterModule.forRoot()-Hook konfiguriert werden. - Änderung in der Navigation: Die Konfiguration der Navigationsstrategie und Fehlerbehandlung muss an die neuen Methoden angepasst werden, um Inkompatibilitäten mit dem Router-Service von Angular 17 zu vermeiden. TypeScript Mit der neuen Angular-Version wird auch eine neue TypeScript-Version unterstützt. In Angular 17 muss nun zugleich TypeScript mindestens in Version 5.2 verwendet werden. Da beim Release von Angular 16 noch TypeScript 5.0 vorausgesetzt wurde, wollen wir uns an dieser Stelle sowohl einige interessante Neuerungen sowohl aus TypeScript 5.1 als auch aus TypeScript 5.2 ansehen. Implizites “return“ bei Rückgabe von “undefined“ Wenn in JavaScript eine Funktion keine “return”-Angabe enthält, hat diese Funktion dennoch immer implizit “undefined” als Rückgabewert. In TypeScript hat sich diese Tatsache bisher nicht\n'slidetext': \n'part_name': 2\n'total_parts': 21\n'from': vector\n'score': 0.9424538612365723\n'normalizedScore': 0.9034431610406057\n'beforeDatePenaltyScore': 0.9424538612365723\n\n'contentType': READ\n'documentId': 716e141fb1acae69460b0dd2\n'title': Angular 18 – erwachsen, aber aktivAlles zur neuen Version\n'abstract': Mit Angular 18 steht Entwickler:innen eine Vielzahl neuer Features und Verbesserungen zur Verfügung, die die Entwicklung moderner Webanwendungen weiter optimieren. Angular 18 baut auf die Fortschritte der Vorgängerversionen auf und führt zahlreiche Performanceoptimierungen sowie neue APIs ein, die die Arbeit mit dem Framework noch effizienter gestalten.\n'parentName': Java Magazin 9.2024\n'parentDescription': Über neun Millionen Software-Entwickler weltweit sorgen dafür, dass die Java-Technologie in allen Geschäftsfeldern und in allen Branchen eine zentrale Rolle spielt. Zudem ist das Java-Ökosystem der wichtigste Takt- und Impulsgeber für die gesamte Software-Industrie, wenn es um technische Innovationen geht. Das Java Magazin begleitet seit über 20 Jahren alle wesentlichen Entwicklungen der Java-Welt aktuell, kritisch und mit großer praktischer Relevanz. Software-Architekten, Entwickler und Projektleiter vertrauen auf die anerkannte Kompetenz der Redaktion verbunden mit ihrem Experten-Netzwerk bekannter Fachautoren.\n'author': Karsten Sitterberg\n'language': DE\n'date': Mon Aug 05 2024 22:00:00 GMT+0000 (Coordinated Universal Time)\n'access': granted\n'chunkSource': text\n'text': bei neu generierten Projekten in Zukunft deshalb nicht mehr assets, sondern public. Weiterhin wird mit Angular CLI 18 der Befehl ng doc entfernt, da dieser ohnehin nur selten genutzt wurde. Die offizielle Empfehlung ist, stattdessen in der Dokumentation unter [1] nachzuschauen. Breaking Changes Neben der neu unterstützten Node.js-Version 22 wurde auch die minimal notwendige Node.js-Version angepasst. Die minimal notwendige LTS-Node.js-Version ist nun 18.19.1, Node.js 19 wird gar nicht mehr unterstützt, und Node.js 20 erst ab Version 20.11.1. Weiterhin wurde die Anbindung des alten, nur noch im webpack-Build unterstützten Sass API (NG_BUILD_LEGACY_SASS) entfernt. Das Legacy API ermöglichte beispielsweise noch die alte ~-Import-Syntax. Angular Auch mit den Minor-Angular-17-Versionen sind einige interessante Neuerungen in Bezug auf die Zukunft von Angular hinzugekommen. Das betrifft zum einen die Weiterentwicklung des Frameworks im Allgemeinen. Zum anderen sind vor allem die Angular-Signal-APIs deutlich erweitert worden, um so das Ziel zu erreichen, Angular-Anwendungen in Zukunft ohne zone.js laufen lassen zu können. Die Neuerungen sollen an dieser Stelle kurz vorgestellt werden. Angular 17.1, 17.2 und 17.3 Ganz besondere Aufmerksamkeit haben die Signal APIs innerhalb der letzten Angular-Versionen erhalten. Dazu gehören vor allem APIs, mit denen die Decorators innerhalb von Komponenten durch Signal-Varianten ersetzt werden können. Das gilt vor allem für Komponenten bzw. Anwendungen, die künftig ohne zone.js auskommen sollen. Um die Neuerungen zu veranschaulichen, wird in Listing 6 die Komponente DemoFormComponent gezeigt, die ein boolesches @Input für den Nachtmodus und ein String-@Input für den momentanen Formularwert hat. Der Input für den Formularwert hat außerdem das Flag required, es wird also ein Compilerfehler ausgegeben, wenn dieser Input nicht gebunden ist. Außerdem ist ein @Output mit dem Namen valueChange vorhanden, der bei jeder Wertänderung des Formulars emittiert. Zu jedem @Output gehört immer ein EventEmitter. (Da der EventEmitter jedoch vom RxJS Subject erbt, könnte an dieser Stelle auch ein Observable stehen, dazu später mehr.) Da der Input value und der Output valueChange heißen, können beide per Two-way Data Binding angebunden werden:  Die Variable 'firstname'\n'slidetext': \n'part_name': 5\n'total_parts': 15\n'from': vector\n'score': 0.9319087266921997\n'normalizedScore': 0.903089807318151\n'beforeDatePenaltyScore': 0.9319087266921997\n\n'contentType': READ\n'documentId': 04721391f3f7580f0631b9d3\n'title': Angular 17: Neues Release des Web-FrameworksRenaissance? Angular 17! - Alle Features im Überblick\n'abstract': Das beliebte JavaScript-Framework Angular veröffentlicht Version 17. Da bei Angular viel in Bewegung ist, kann manch einer da den Überblick verlieren. Wir stellen alle Features von Angular 17 vor.\n'parentName': iJS Magazin 2.2024\n'parentDescription': Kaum ein Softwareprojekt, das nicht in wesentlichen Teilen auf der JavaScript-Technologie basiert. Eine breite Unterstützung sowie, leistungsfähige Programmiersprachen, die Vielzahl moderner Tools, sowie ausgereifte Frameworks wie Angular, React, Vue.js oder Node.js machen den JavaScript-Werkzeugkasten zu einem Alleskönner. Das iJS Magazin informiert aktuell und umfassend über die wichtige und innovative Entwicklungen im JavaScript-Universum und bietet handfeste Praxisinformationen für Softwareentwickler und -architekten.\n'author': Karsten Sitterberg\n'language': DE\n'date': Wed Apr 03 2024 22:00:00 GMT+0000 (Coordinated Universal Time)\n'access': granted\n'chunkSource': text\n'text': Angular 17: Neues Release des Web-Frameworks Renaissance? Angular 17! - Alle Features im Überblick Das beliebte JavaScript-Framework Angular veröffentlicht Version 17. Da bei Angular viel in Bewegung ist, kann manch einer da den Überblick verlieren. Wir stellen alle Features von Angular 17 vor. Bei Angular ist viel in Bewegung. Manch einer kann da den Überblick verlieren, oder gar Angst vor Überforderung bekommen. Ob diese Sorge begründet ist oder der Plan des Angular-Teams, für Angular eine Renaissance einzuläuten, gelingen kann, soll in diesem Beitrag beleuchtet werden. Vorneweg: Wer bisher Angular Upgrades vor sich her geschoben hat, oder plant lediglich zum Ende eines LTS Zyklus zu aktualisieren, der sollte die aktuellen Entwicklungen sehr genau beobachten und bewerten, ob inkrementelle Updates mit kleinen Schritten, statt großer Sprünge aus Aufwand- und Risikosicht nicht sinnvoller sind. Wir werfen natürlich nicht nur einen Blick auf die Angular-Core Änderungen, sondern werden auch TypeScript und Angular-Material betrachten. Das Angular 17 Release in Stichpunkten Hier findet ihr knapp zusammengefasst einige der wichtigsten Neuerungen und Breaking Changes in Angular 17. TypeScript - Angular 17 erfordert mindestens TypeScript 5.2. - Implizites 'return' bei 'undefined' wird nun unterstützt; Funktionen mit Rückgabetyp 'undefined' sind mit 'void'-Funktionen kompatibel. - Unabhängige Typangaben für Getter und Setter werden mit TypeScript 5.1 ermöglicht. - Neue Metadaten für Decorators mit TypeScript 5.2, um Verhalten zu definieren und auszulesen. Angular CLI - Angular CLI nutzt 'esbuild' für schnellere Builds und kleinere Ergebnisse, einschließlich eines Vite-basierten Development-Servers. - Server-Side Rendering Funktionalitäten unter dem Paket '@angular/ssr' wurden eingeführt, mit vereinfachten SSR-Optionen im CLI. - Es gibt mehrere Breaking Changes in Angular CLI, einschließlich der Anforderung von TypeScript 5.2 und zone.js 0.14.0, sowie der Anhebung der minimalen Node.js-Version auf 18.13.0. Angular 17 - Neue Anwendungen initialisieren den Angular Router standardmäßig und erzeugen Anwendungen als 'standalone' ohne '@NgModule()'s. - Funktionale HTTP-Interceptoren werden in Angular CLI 17 bevorzugt, klassenbasierte sind optional. - Einführung der neuen Syntax @switch, @case, und @default für Conditional Rendering und neue Direktiven wie @defer für Lazy\n'slidetext': \n'part_name': 1\n'total_parts': 21\n'from': vector\n'score': 0.9420861005783081\n'normalizedScore': 0.9030754003823416\n'beforeDatePenaltyScore': 0.9420861005783081\n\n'contentType': READ\n'documentId': f1151315d5ffa6c7887a8812\n'title': Renaissance? Angular 17!Neues Release des Web-Frameworks\n'abstract': Bei Angular ist viel in Bewegung. Manch einer kann da den Überblick verlieren, oder gar Angst vor Überforderung bekommen. Ob diese Sorge begründet ist oder der Plan des Angular-Teams, für Angular eine Renaissance einzuläuten, gelingen kann, soll in diesem Beitrag beleuchtet werden.\n'parentName': Entwickler Magazin 2.2024\n'parentDescription': Das Entwickler Magazin bietet Software-Entwicklern Einblicke und Orientierung in einem Markt an Entwicklungstechnologien, -tools und -ansätzen, der stets komplexer wird. Mit seiner Kompetenz in einer breiten Palette an Programmiersprachen, Tools, Plattformen und Engineering-Techniken liefert es einen fundierten Marktüberblick und bietet technische Entscheidungshilfen für Entwickler, Projektleiter und Manager.\n'author': Karsten Sitterberg\n'language': DE\n'date': Tue Jan 23 2024 02:00:00 GMT+0000 (Coordinated Universal Time)\n'access': granted\n'chunkSource': text\n'text': CLI 17 eine automatische Migration geben, die den Wechsel zur neuen Syntax vereinfachen soll. Zumindest in Angular 17 sind aber noch beide Syntaxvarianten verwendbar. Breaking Changes in Angular 17 Da Angular 17 ein Major Release ist, gibt es entsprechend auch ein paar Breaking Changes. Ein Breaking Change betrifft das mit Angular 16 eingeführte Feature der Signals. Die Signals wurden mit Angular 16 noch als Developer-Preview gehandelt, daher die kurze Zeit bis zu dieser Änderung. Bei den Signals hat es sich gezeigt, dass die signal.mutate()-Funktion zu Inkonsistenzen in der Anwendung führen kann. Daher wurde diese Möglichkeit, ein Signal zu ändern, entfernt. Signals sollten nun nicht mehr per Mutation verändert werden, sondern stattdessen immer wie eine Immutable-Datenstruktur verwendet werden. In Listing 19 ist beispielhaft gezeigt, wie ein Signal, das ein Array enthält, bisher verändert werden konnte, und wie es ab Angular 17 geschehen sollte. Listing 19: Items zu einem Signal hinzufügen im Angular-16/17-Vergleich // Mit Angular 16 items.mutate(itemsArray => itemsArray.push(newItem)); // Ab Angular 17: items.update(itemsArray => [itemsArray, ...newItem]); Neben den Signals gibt es Breaking Changes im Router. Dieser hat bisher die Properties - canceledNavigationResolution - paramsInheritanceStrategy - titleStrategy - urlUpdateStrategy - malformedUriErrorHandler - urlHandlingStrategy zur Verfügung gestellt. Mit Angular 17 wurden diese Properties aus dem Public API des Routers entfernt. Statt über den Router sollten diese Properties jetzt durch die entsprechenden Konfigurationsparameter in der provideRouter()-Funktion oder dem RouterModule.forRoot() Hook konfiguriert werden. Angular 17 in der Praxis Mit den Änderungen sind neuartige Architekturen möglich und Optimierungen, die früher gar nicht oder nur schwer umsetzbar waren. Zur Illustration soll ein Beispiel aus der Praxis dienen. Um effektive, sichere und vollständig DSGVO-konforme Remote-Schulungen durchzuführen, wurde eine integrierte Plattform entwickelt, an der der Autor dieses Beitrags federführend beteiligt war. Schaut man sich einen Livescreenshot an (Abb. 2), so ist direkt zu erkennen, dass die Steuerung von Audio und Video direkt in der primären Ansicht verfügbar ist (Schalter unten links). Das bedeutet, dass die zugehörigen Komponenten und Services nicht durch Lazy Loading später nachgeladen werden können, da es keine geschachtelte Route gibt, mit der ein entsprechendes Code-Splitting\n'slidetext': \n'part_name': 16\n'total_parts': 20\n'from': vector\n'score': 0.9473196268081665\n'normalizedScore': 0.9024048170231589\n'beforeDatePenaltyScore': 0.9473196268081665\n\n'contentType': READ\n'documentId': 3caa038a2f16278ab3c6040a\n'title': Angular 18 – erwachsen, aber aktivAlles zur neuen Version\n'abstract': Mit Angular 18 steht Entwickler:innen eine Vielzahl neuer Features und Verbesserungen zur Verfügung, die die Entwicklung moderner Webanwendungen weiter optimieren. Angular 18 baut auf die Fortschritte der Vorgängerversionen auf und führt zahlreiche Performanceoptimierungen sowie neue APIs ein, die die Arbeit mit dem Framework noch effizienter gestalten.\n'parentName': Entwickler Magazin 6.2024\n'parentDescription': Das Entwickler Magazin bietet Software-Entwicklern Einblicke und Orientierung in einem Markt an Entwicklungstechnologien, -tools und -ansätzen, der stets komplexer wird. Mit seiner Kompetenz in einer breiten Palette an Programmiersprachen, Tools, Plattformen und Engineering-Techniken liefert es einen fundierten Marktüberblick und bietet technische Entscheidungshilfen für Entwickler, Projektleiter und Manager.\n'author': Karsten Sitterberg\n'language': DE\n'date': Wed Jul 24 2024 22:00:00 GMT+0000 (Coordinated Universal Time)\n'access': granted\n'chunkSource': text\n'text': bei neu generierten Projekten in Zukunft deshalb nicht mehr assets, sondern public. Weiterhin wird mit Angular CLI 18 der Befehl ng doc entfernt, da dieser ohnehin nur selten genutzt wurde. Die offizielle Empfehlung ist, stattdessen in der Dokumentation unter [1] nachzuschauen. Breaking Changes Neben der neu unterstützten Node.js-Version 22 wurde auch die minimal notwendige Node.js-Version angepasst. Die minimal notwendige LTS-Node.js-Version ist nun 18.19.1, Node.js 19 wird gar nicht mehr unterstützt, und Node.js 20 erst ab Version 20.11.1. Weiterhin wurde die Anbindung des alten, nur noch im webpack-Build unterstützten Sass API (NG_BUILD_LEGACY_SASS) entfernt. Das Legacy API ermöglichte beispielsweise noch die alte ~-Import-Syntax. Angular Auch mit den Minor-Angular-17-Versionen sind einige interessante Neuerungen in Bezug auf die Zukunft von Angular hinzugekommen. Das betrifft zum einen die Weiterentwicklung des Frameworks im Allgemeinen. Zum anderen sind vor allem die Angular-Signal-APIs deutlich erweitert worden, um so das Ziel zu erreichen, Angular-Anwendungen in Zukunft ohne zone.js laufen lassen zu können. Die Neuerungen sollen an dieser Stelle kurz vorgestellt werden. Angular 17.1, 17.2 und 17.3 Ganz besondere Aufmerksamkeit haben die Signal APIs innerhalb der letzten Angular-Versionen erhalten. Dazu gehören vor allem APIs, mit denen die Decorators innerhalb von Komponenten durch Signal-Varianten ersetzt werden können. Das gilt vor allem für Komponenten bzw. Anwendungen, die künftig ohne zone.js auskommen sollen. Um die Neuerungen zu veranschaulichen, wird in Listing 6 die Komponente DemoFormComponent gezeigt, die ein boolesches @Input für den Nachtmodus und ein String-@Input für den momentanen Formularwert hat. Der Input für den Formularwert hat außerdem das Flag required, es wird also ein Compilerfehler ausgegeben, wenn dieser Input nicht gebunden ist. Außerdem ist ein @Output mit dem Namen valueChange vorhanden, der bei jeder Wertänderung des Formulars emittiert. Zu jedem @Output gehört immer ein EventEmitter. (Da der EventEmitter jedoch vom RxJS Subject erbt, könnte an dieser Stelle auch ein Observable stehen, dazu später mehr.) Da der Input value und der Output valueChange heißen, können beide per Two-way Data Binding angebunden werden:  Die Variable 'firstname'\n'slidetext': \n'part_name': 5\n'total_parts': 15\n'from': vector\n'score': 0.9319087266921997\n'normalizedScore': 0.902103505948288\n'beforeDatePenaltyScore': 0.9319087266921997\n\n'contentType': READ\n'documentId': 52ef1d82560c140fe2ed1886\n'title': Angular 18 – erwachsen, aber aktivAlles zur neuen Version\n'abstract': Mit Angular 18 steht Entwickler:innen eine Vielzahl neuer Features und Verbesserungen zur Verfügung, die die Entwicklung moderner Webanwendungen weiter optimieren. Angular 18 baut auf die Fortschritte der Vorgängerversionen auf und führt zahlreiche Performanceoptimierungen sowie neue APIs ein, die die Arbeit mit dem Framework noch effizienter gestalten.\n'parentName': entwickler.de Blog 7.2024\n'parentDescription': n/a\n'author': Karsten Sitterberg\n'language': DE\n'date': Mon Jul 15 2024 04:30:22 GMT+0000 (Coordinated Universal Time)\n'access': granted\n'chunkSource': text\n'text': bei neu generierten Projekten in Zukunft deshalb nicht mehr assets, sondern public. Weiterhin wird mit Angular CLI 18 der Befehl ng doc entfernt, da dieser ohnehin nur selten genutzt wurde. Die offizielle Empfehlung ist, stattdessen in der Dokumentation unter [1] nachzuschauen. Breaking Changes Neben der neu unterstützten Node.js-Version 22 wurde auch die minimal notwendige Node.js-Version angepasst. Die minimal notwendige LTS-Node.js-Version ist nun 18.19.1, Node.js 19 wird gar nicht mehr unterstützt, und Node.js 20 erst ab Version 20.11.1. Weiterhin wurde die Anbindung des alten, nur noch im webpack-Build unterstützten Sass API (NG_BUILD_LEGACY_SASS) entfernt. Das Legacy API ermöglichte beispielsweise noch die alte ~-Import-Syntax. Angular Auch mit den Minor-Angular-17-Versionen sind einige interessante Neuerungen in Bezug auf die Zukunft von Angular hinzugekommen. Das betrifft zum einen die Weiterentwicklung des Frameworks im Allgemeinen. Zum anderen sind vor allem die Angular-Signal-APIs deutlich erweitert worden, um so das Ziel zu erreichen, Angular-Anwendungen in Zukunft ohne zone.js laufen lassen zu können. Die Neuerungen sollen an dieser Stelle kurz vorgestellt werden. Angular 17.1, 17.2 und 17.3 Ganz besondere Aufmerksamkeit haben die Signal APIs innerhalb der letzten Angular-Versionen erhalten. Dazu gehören vor allem APIs, mit denen die Decorators innerhalb von Komponenten durch Signal-Varianten ersetzt werden können. Das gilt vor allem für Komponenten bzw. Anwendungen, die künftig ohne zone.js auskommen sollen. Um die Neuerungen zu veranschaulichen, wird in Listing 6 die Komponente DemoFormComponent gezeigt, die ein boolesches @Input für den Nachtmodus und ein String-@Input für den momentanen Formularwert hat. Der Input für den Formularwert hat außerdem das Flag required, es wird also ein Compilerfehler ausgegeben, wenn dieser Input nicht gebunden ist. Außerdem ist ein @Output mit dem Namen valueChange vorhanden, der bei jeder Wertänderung des Formulars emittiert. Zu jedem @Output gehört immer ein EventEmitter. (Da der EventEmitter jedoch vom RxJS Subject erbt, könnte an dieser Stelle auch ein Observable stehen, dazu später mehr.) Da der Input value und der Output valueChange heißen, können beide per Two-way Data Binding angebunden werden:  Die Variable 'firstname'\n'slidetext': \n'part_name': 5\n'total_parts': 15\n'from': vector\n'score': 0.9319087266921997\n'normalizedScore': 0.9013038693425042\n'beforeDatePenaltyScore': 0.9319087266921997\n\n'contentType': READ\n'documentId': f1151315d5ffa6c7887a8812\n'title': Renaissance? Angular 17!Neues Release des Web-Frameworks\n'abstract': Bei Angular ist viel in Bewegung. Manch einer kann da den Überblick verlieren, oder gar Angst vor Überforderung bekommen. Ob diese Sorge begründet ist oder der Plan des Angular-Teams, für Angular eine Renaissance einzuläuten, gelingen kann, soll in diesem Beitrag beleuchtet werden.\n'parentName': Entwickler Magazin 2.2024\n'parentDescription': Das Entwickler Magazin bietet Software-Entwicklern Einblicke und Orientierung in einem Markt an Entwicklungstechnologien, -tools und -ansätzen, der stets komplexer wird. Mit seiner Kompetenz in einer breiten Palette an Programmiersprachen, Tools, Plattformen und Engineering-Techniken liefert es einen fundierten Marktüberblick und bietet technische Entscheidungshilfen für Entwickler, Projektleiter und Manager.\n'author': Karsten Sitterberg\n'language': DE\n'date': Tue Jan 23 2024 02:00:00 GMT+0000 (Coordinated Universal Time)\n'access': granted\n'chunkSource': text\n'text': den Angular-Router standardmäßig und erzeugen Anwendungen als Standalone ohne @NgModule(). - Funktionale HTTP Interceptors werden in Angular CLI 17 bevorzugt, klassenbasierte sind optional. - Einführung der neuen Syntax @switch, @case, und @default für Conditional Rendering und neue Direktiven wie @defer für Lazy Loading. - @defer unterstützt bedingtes Laden und Vorladen mit prefetch. - Das Angular CLI bietet eine automatische Migration zur neuen Syntax an; alte und neue Syntax können in Version 17 parallel genutzt werden. - Integration der neuen Lifecycle-Hooks afterRender() und afterNextRender sowie die Stabilisierung von Signals. - Lazy Loading für Animationen und die Integration des View Transitions DOM API für optimierte Übergänge und Animationen. - Einführung einer neuen Control-Flow-Syntax als Developer Preview, die *ngIf, *ngFor, und ngSwitch ersetzt und zusätzliche Verbesserungen wie @if und @for sowie erforderliches Track-by für Listen umfasst. Breaking Changes in Angular 17 - Entfernung von signal.mutate(): Die Möglichkeit, Signals durch Mutation zu verändern, wurde entfernt. Signals müssen als immutable Datenstrukturen behandelt werden; Änderungen sollten durch die signal.update()-Funktion vorgenommen werden. - Signal-Handhabung als immutable: Anstatt Signals zu mutieren, sollten Entwickler diese nun behandeln, als wären sie immutable, und entsprechend aktualisieren. - Entfernung von Router Properties: Bestimmte Router Properties wie canceledNavigationResolution, paramsInheritanceStrategy, titleStrategy, urlUpdateStrategy, malformedUriErrorHandler und urlHandlingStrategy wurden aus dem öffentlichen API entfernt. - Neue Konfiguration über provideRouter() oder RouterModule.forRoot(): Die zuvor entfernten Router Properties müssen jetzt über die provideRouter()-Funktion oder im RouterModule.forRoot()-Hook konfiguriert werden. - Änderung in der Navigation: Die Konfiguration der Navigationsstrategie und Fehlerbehandlung muss an die neuen Methoden angepasst werden, um Inkompatibilitäten mit dem Router Service von Angular 17 zu vermeiden. TypeScript Mit der neuen Angular-Version wird auch eine neue TypeScript-Version unterstützt. In Angular 17 muss nun zugleich TypeScript mindestens in Version 5.2 verwendet werden. Da beim Release von Angular 16 noch Type-Script 5.0 vorausgesetzt wurde, wollen wir uns an dieser Stelle einige interessante Neuerungen sowohl aus TypeScript 5.1 als auch aus TypeScript 5.2 ansehen. Implizites return bei Rückgabe von undefined Wenn in JavaScript eine Funktion keine return-Angabe enthält, hat diese Funktion dennoch immer implizit undefined als Rückgabewert. In TypeScript hat\n'slidetext': \n'part_name': 2\n'total_parts': 20\n'from': vector\n'score': 0.9453760385513306\n'normalizedScore': 0.900461228766323\n'beforeDatePenaltyScore': 0.9453760385513306\n\n'contentType': READ\n'documentId': bd2918fe362ada7129c4ae2c\n'title': Signal-basierte Komponentenkommunikation in Angular 17.1 und 17.2Kolumne: Enterprise Angular\n'abstract': Signals werden die Zukunft der Datenbindung in Angular prägen. Das Signals-Konzept selbst ist allerdings nur ein Teil des Ganzen. Wir brauchen auch die Möglichkeit, über Signals mit anderen Komponenten zu kommunizieren. Angular 17.1 bringt dazu Input Signals, und ab Angular 17.2 gibt es Model Signals für Two-way Bindings sowie Unterstützung für Signal-basierte Content- und View-Querys. In diesem Artikel zeige ich, was es mit diesen Neuerungen auf sich hat. Der Quellcode der verwendeten Beispiele findet sich unter [1].\n'parentName': Windows Developer 5.2024\n'parentDescription': Windows Developer informiert umfassend und herstellerneutral über die neuen Trends und Möglichkeiten der Software- und Systementwicklung rund um Microsoft- und Web-Technologien. Von der klassischen .NET-Entwicklung über .NET Core bis hin zu neuen Technologien wie Windows 10, Microsoft Azure und der ganzen Bandbreite der aktuellen Web-, Phone- und Tabletentwicklung für Android und iOS mit Xamarin und unterschiedlichen JavaScript-Frameworks. Professionelle Entwickler und IT-Entscheider erhalten genau die Informationen, die sie für den erfolgreichen Einsatz von unternehmensorientierten Lösungen benötigen.\n'author': Manfred Steyer\n'language': DE\n'date': Wed Apr 10 2024 22:00:00 GMT+0000 (Coordinated Universal Time)\n'access': granted\n'chunkSource': text\n'text': Signal-basierte Komponentenkommunikation in Angular 17.1 und 17.2 Kolumne: Enterprise Angular Signals werden die Zukunft der Datenbindung in Angular prägen. Das Signals-Konzept selbst ist allerdings nur ein Teil des Ganzen. Wir brauchen auch die Möglichkeit, über Signals mit anderen Komponenten zu kommunizieren. Angular 17.1 bringt dazu Input Signals, und ab Angular 17.2 gibt es Model Signals für Two-way Bindings sowie Unterstützung für Signal-basierte Content- und View-Querys. In diesem Artikel zeige ich, was es mit diesen Neuerungen auf sich hat. Der Quellcode der verwendeten Beispiele findet sich unter [1]. Signals werden die Zukunft der Datenbindung in Angular prägen. Das Signals-Konzept selbst ist allerdings nur ein Teil des Ganzen. Wir brauchen auch die Möglichkeit, über Signals mit anderen Komponenten zu kommunizieren. Angular 17.1 bringt dazu Input Signals, und ab Angular 17.2 gibt es Model Signals für Two-way Bindings sowie Unterstützung für Signal-basierte Content- und View-Querys. In diesem Artikel zeige ich, was es mit diesen Neuerungen auf sich hat. Der Quellcode der verwendeten Beispiele findet sich unter [1]. Input Signals Input Signals ermöglichen Signal-basierte Property Bindings. Zur Veranschaulichung dieses Konzepts verwende ich hier eine einfache OptionComponent (Abb. 1). Die OptionComponent nimmt die anzuzeigende Bezeichnung über die Eigenschaft label entgegen (Listing 1). Der Angular-Compiler greift die Funktion input auf und leitet sie in Quellcode für Property Bindings über. Deswegen darf input auch nur auf diese Weise verwendet werden. Auch die anderen hier besprochenen Konzepte zur Komponentenkommunikation nutzen diese Technik. Abb. 1: Drei einfache OptionComponents Listing 1 @Component({ selector: 'app-option', standalone: true, imports: [], template: `  {{ label() }}  `, styles: [...] }) export class OptionComponent { label = input.required(); } Durch den Einsatz einer Funktion anstatt eines Dekorators wie @Input kann TypeScript den richtigen Typ ermitteln sowie erkennen, ob undefined erlaubt ist. Im zuvor gezeigten Beispiel wird label zu einem InputSignal – einem Input Signal, das einen String bereitstellt. Der verwaltete Wert darf jedoch nicht undefined oder null sein. Weiter unten zeige ich Varianten, die u. a. ein InputSignal liefern und somit undefined erlauben. Ein InputSignal ist immer read-only und lässt sich wie\n'slidetext': \n'part_name': 1\n'total_parts': 8\n'from': vector\n'score': 0.9360949993133545\n'normalizedScore': 0.8976596415831414\n'beforeDatePenaltyScore': 0.9360949993133545\n\n'contentType': READ\n'documentId': f1151315d5ffa6c7887a8812\n'title': Renaissance? Angular 17!Neues Release des Web-Frameworks\n'abstract': Bei Angular ist viel in Bewegung. Manch einer kann da den Überblick verlieren, oder gar Angst vor Überforderung bekommen. Ob diese Sorge begründet ist oder der Plan des Angular-Teams, für Angular eine Renaissance einzuläuten, gelingen kann, soll in diesem Beitrag beleuchtet werden.\n'parentName': Entwickler Magazin 2.2024\n'parentDescription': Das Entwickler Magazin bietet Software-Entwicklern Einblicke und Orientierung in einem Markt an Entwicklungstechnologien, -tools und -ansätzen, der stets komplexer wird. Mit seiner Kompetenz in einer breiten Palette an Programmiersprachen, Tools, Plattformen und Engineering-Techniken liefert es einen fundierten Marktüberblick und bietet technische Entscheidungshilfen für Entwickler, Projektleiter und Manager.\n'author': Karsten Sitterberg\n'language': DE\n'date': Tue Jan 23 2024 02:00:00 GMT+0000 (Coordinated Universal Time)\n'access': granted\n'chunkSource': text\n'text': einige Defaults ausgetauscht worden: Wenn etwa eine neue Anwendung generiert wird, wird bei dieser nun standardmäßig der Angular-Router initialisiert. Dies war bisher nicht der Fall. Falls kein Routing gewünscht ist, muss die Kommandozeilenoption --no-routing angegeben werden. Weiterhin werden ab Angular CLI 17 alle Anwendungen standardmäßig als Standalone Applications erzeugt, also als Anwendung ohne eigene @NgModule(). Ein anderer geänderter Standardwert betrifft die Angular Interceptors: Mit dem Befehl ng interceptor können Angular HTTP Interceptors generiert werden. Bisher wurden mit diesem Befehl klassenbasierte Interceptors erzeugt. Mit Angular CLI 17 werden stattdessen funktionale Interceptors generiert. Soll weiterhin ein klassenbasierter Interceptor generiert werden, so muss dem Befehl die Option --no-functional mitgegeben werden. Neue Features in Angular 17 Mit Angular 17 kommen eine Menge neuer Features. Das Angular-Team selbst spricht von einem der größten Releases in der Geschichte von Angular. Dementsprechend bietet es neben den bereits oben erwähnten Versionsupdates von zone.js und TypeScript auch viele kleinere und größere Neuerungen. Zwei Neuerungen, die speziell mit den neuen APIs rund um Signals zu tun haben, sind bereits mit Angular 16.2.0 hinzugekommen. Nämlich zwei neue, spezielle Komponenten-Lifecycle-Hooks. Speziell deshalb, weil sie nicht wie herkömmliche Lifecycle-Hooks per Interface implementiert werden müssen, sondern als Callback-Funktion aufgerufen werden können. Das ist somit ähnlich wie die computed()-Funktion der Signals. Ein Beispiel mit den neuen Hooks ist in Listing 6 aufgeführt; die beiden Hooks heißen afterRender() und afterNextRender() und werden dem Namen entsprechend ausgeführt, nachdem Angular die jeweilige Komponente gerendert hat. Der Unterschied zwischen beiden Hooks besteht darin, dass afterNextRender() nur einmal, nach dem nächsten Renderingvorgang, aufgerufen wird, während afterRender() aktiv bleibt, solange die Komponente aktiv ist. Diese beiden Hooks sind allerdings noch als „Developer Preview“ geführt, können sich also noch ändern. Listing 6: Implementierung der neuen Lifecycle-Hooks @Component({}) export class DemoComponent { val = 42; constructor() { afterRender(() => { console.log('afterRender', this.val); }); afterNextRender(() => { console.log('afterNextRender', this.val); }); } } Signals sind stable Ein wichtiges Detail in Angular 17 ist, dass die mit Angular 16 eingeführten Signals nun als Stable markiert sind. Das eigentliche Ziel bei\n'slidetext': \n'part_name': 7\n'total_parts': 20\n'from': vector\n'score': 0.942487359046936\n'normalizedScore': 0.8975725492619284\n'beforeDatePenaltyScore': 0.942487359046936\n\n'contentType': READ\n'documentId': 5e49c9ce169d4e147dbc6a14\n'title': Signal-basierte Komponentenkommunikation in Angular 17.1 und 17.2Kolumne: Enterprise Angular\n'abstract': Signals werden die Zukunft der Datenbindung in Angular prägen. Das Signals-Konzept selbst ist allerdings nur ein Teil des Ganzen. Wir brauchen auch die Möglichkeit, über Signals mit anderen Komponenten zu kommunizieren. Angular 17.1 bringt dazu Input Signals, und ab Angular 17.2 gibt es Model Signals für Two-way Bindings sowie Unterstützung für Signal-basierte Content- und View-Querys. In diesem Artikel zeige ich, was es mit diesen Neuerungen auf sich hat. Der Quellcode der verwendeten Beispiele findet sich unter [1].\n'parentName': iJS Magazin 2.2024\n'parentDescription': Kaum ein Softwareprojekt, das nicht in wesentlichen Teilen auf der JavaScript-Technologie basiert. Eine breite Unterstützung sowie, leistungsfähige Programmiersprachen, die Vielzahl moderner Tools, sowie ausgereifte Frameworks wie Angular, React, Vue.js oder Node.js machen den JavaScript-Werkzeugkasten zu einem Alleskönner. Das iJS Magazin informiert aktuell und umfassend über die wichtige und innovative Entwicklungen im JavaScript-Universum und bietet handfeste Praxisinformationen für Softwareentwickler und -architekten.\n'author': Manfred Steyer\n'language': DE\n'date': Wed Apr 03 2024 22:00:00 GMT+0000 (Coordinated Universal Time)\n'access': granted\n'chunkSource': text\n'text': Signal-basierte Komponentenkommunikation in Angular 17.1 und 17.2 Kolumne: Enterprise Angular Signals werden die Zukunft der Datenbindung in Angular prägen. Das Signals-Konzept selbst ist allerdings nur ein Teil des Ganzen. Wir brauchen auch die Möglichkeit, über Signals mit anderen Komponenten zu kommunizieren. Angular 17.1 bringt dazu Input Signals, und ab Angular 17.2 gibt es Model Signals für Two-way Bindings sowie Unterstützung für Signal-basierte Content- und View-Querys. In diesem Artikel zeige ich, was es mit diesen Neuerungen auf sich hat. Der Quellcode der verwendeten Beispiele findet sich unter [1]. Signals werden die Zukunft der Datenbindung in Angular prägen. Das Signals-Konzept selbst ist allerdings nur ein Teil des Ganzen. Wir brauchen auch die Möglichkeit, über Signals mit anderen Komponenten zu kommunizieren. Angular 17.1 bringt dazu Input Signals, und ab Angular 17.2 gibt es Model Signals für Two-way Bindings sowie Unterstützung für Signal-basierte Content- und View-Querys. In diesem Artikel zeige ich, was es mit diesen Neuerungen auf sich hat. Der Quellcode der verwendeten Beispiele findet sich unter [1]. Input Signals Input Signals ermöglichen Signal-basierte Property Bindings. Zur Veranschaulichung dieses Konzepts verwende ich hier eine einfache OptionComponent (Abb. 1). Die OptionComponent nimmt die anzuzeigende Bezeichnung über die Eigenschaft label entgegen (Listing 1). Der Angular-Compiler greift die Funktion input auf und leitet sie in Quellcode für Property Bindings über. Deswegen darf input auch nur auf diese Weise verwendet werden. Auch die anderen hier besprochenen Konzepte zur Komponentenkommunikation nutzen diese Technik. Abb. 1: Drei einfache OptionComponents Listing 1 @Component({ selector: 'app-option', standalone: true, imports: [], template: `  {{ label() }}  `, styles: [...] }) export class OptionComponent { label = input.required(); } Durch den Einsatz einer Funktion anstatt eines Dekorators wie @Input kann TypeScript den richtigen Typ ermitteln sowie erkennen, ob undefined erlaubt ist. Im zuvor gezeigten Beispiel wird label zu einem InputSignal – einem Input Signal, das einen String bereitstellt. Der verwaltete Wert darf jedoch nicht undefined oder null sein. Weiter unten zeige ich Varianten, die u. a. ein InputSignal liefern und somit undefined erlauben. Ein InputSignal ist immer read-only und lässt sich wie\n'slidetext': \n'part_name': 1\n'total_parts': 8\n'from': vector\n'score': 0.9360949993133545\n'normalizedScore': 0.897084299117388\n'beforeDatePenaltyScore': 0.9360949993133545\n\n'contentType': RHEINGOLD\n'documentId': hiwmMJy6F5TyrrZFY\n'title': Angular Signals: Gamechanger für reaktive Entwicklungnull\n'abstract': Das Angular-Team stellt sein reaktives Modell auf den Prüfstand und schlägt als neuen Ansatz die von anderen Frameworks bekannten Signals vor. Während Altanwendungen zunächst weiter funktionieren wie gehabt, bieten Signals entscheidende Vorteile gegenüber dem bestehenden Modell.  Brauchen Anwendungen in Zukunft überhaupt noch RxJS? Welche Vorteile haben Signals auf die Performance einer Anwendung? Und wie funktioniert das Reaktivitätsmodell im Detail?  Yannick Baron von Thinktecture und Google Developer Expert für Angular beantwortet alle Fragen rund um die neuen Angular-Signals.\n'parentName': JavaScript Days Muenchen und online 2024\n'parentDescription': Das Trainingsevent für JavaScript, Angular, React und HTML & CSS\n'author': Yannick Baron\n'language': DE\n'date': Thu Mar 21 2024 12:30:00 GMT+0000 (Coordinated Universal Time)\n'access': restricted\n'chunkSource': text\n'text': Angular Signals: Gamechanger für reaktive Entwicklung Das Angular-Team stellt sein reaktives Modell auf den Prüfstand und schlägt als neuen Ansatz die von anderen Frameworks bekannten Signals vor. Während Altanwendungen zunächst weiter funktionieren wie gehabt, bieten Signals entscheidende Vorteile gegenüber dem bestehenden Modell. Brauchen Anwendungen in Zukunft überhaupt noch RxJS? Welche Vorteile haben Signals auf die Performance einer Anwendung? Und wie funktioniert das Reaktivitätsmodell im Detail? Yannick Baron von Thinktecture und Google Developer Expert für Angular beantwortet alle Fragen rund um die neuen Angular-Signals. [object Object]\n'slidetext': \n'part_name': 1\n'total_parts': 1\n'from': vector\n'score': 0.9355548620223999\n'normalizedScore': 0.8954431344291731\n'beforeDatePenaltyScore': 0.9355548620223999\n\n'contentType': READ\n'documentId': eaadd69b577fdb10e53c43bd\n'title': Was ist neu in Angular 17?Kolumne: Enterprise Angular\n'abstract': Anfang 2023 hat Sarah Drashner, die als Director of Engineering bei Google unter anderem auch dem Angular-Team vorsteht, den Begriff Angular Renaissance geprägt. Gemeint ist damit eine Erneuerung des Frameworks, das uns nun schon sieben Jahre lang bei der Entwicklung moderner JavaScript-Lösungen begleitet.\n'parentName': iJS Magazin 1.2024\n'parentDescription': Kaum ein Softwareprojekt, das nicht in wesentlichen Teilen auf der JavaScript-Technologie basiert. Eine breite Unterstützung sowie, leistungsfähige Programmiersprachen, die Vielzahl moderner Tools, sowie ausgereifte Frameworks wie Angular, React, Vue.js oder Node.js machen den JavaScript-Werkzeugkasten zu einem Alleskönner. Das iJS Magazin informiert aktuell und umfassend über die wichtige und innovative Entwicklungen im JavaScript-Universum und bietet handfeste Praxisinformationen für Softwareentwickler und -architekten.\n'author': Manfred Steyer\n'language': DE\n'date': Thu Feb 08 2024 23:00:00 GMT+0000 (Coordinated Universal Time)\n'access': granted\n'chunkSource': text\n'text': oben erwähnte esbuild-Integration und erzeugt damit Bundles, die sowohl im Browser als auch serverseitig nutzen lassen. Ein Aufruf von ng serve startet auch einen Development-Server, der sowohl serverseitig rendert als auch die Bundles für den Betrieb im Browser ausliefert. Ein Aufruf von ng build --ssr kümmert sich auch um Bundles für beide Welten sowie um das Bauen eines einfachen Node. js-basierten Servers, dessen Quellcode die oben erwähnten Schematics genieren. Wer keinen Node.js-Server betreiben kann oder möchte, kann mit ng build --prerender die einzelnen Routen der Anwendung bereits beim Build vorrendern. Weitere Neuerungen Neben den bis hier diskutierten Neuerungen bringt Angular 17 noch zahlreiche weitere Abrundungen: - Der Router unterstützt nun das View Transitions API [4]. Dieses von einigen Browsern angebotene API erlaubt das Animieren von Übergängen, z. B. von einer Route auf eine andere mittels CSS-Animationen. Dieses optionale Feature ist beim Einrichten des Routers über die Funktion withViewTransitions zu aktivieren. Zur Demonstration nutzt das Beispiel unter [1] CSS-Animationen, die vom View Transitions API übernommen wurden. - Die in Version 16 als Developer Preview eingeführten Signals sind nun stabil. Eine wichtige Änderung gegenüber Version 16 ist, dass Signals nun standardmäßig auf die Nutzung mit Immutables ausgelegt sind. Somit kann Angular einfacher herausfinden, an welcher Stelle die über Signals verwalteten Datenstrukturen geändert wurden. Zum Aktualisieren von Signals lässt sich die Methode set, die einen neuen Wert zuweist, oder die Methode update, die den bestehenden Wert auf einen neuen abbildet, einsetzen. Die Methode mutate wurde entfernt, zumal sie nicht zur Semantik von Immutables passt. - Es existiert nun ein Diagnostic, der eine Warnung ausgibt, wenn beim Lesen von Signals in Templates der Aufruf des Getters vergessen wurde (z. B. {{ products }} anstatt {{ products() }}). - Animationen können nun lazy geladen werden [5]. - Das Angular CLI generiert standardmäßig Standalone Components, Standalone Directives und Standalone Pipes. Auch ng new sieht standardmäßig das Bootstrapping einer Standalone Component vor. Dieses Verhalten lässt sich mit dem Schalter --standalone false deaktivieren. - Die Anweisung ng g interceptor generiert funktionale Interceptors. Zusammenfassung Mit Version 17\n'slidetext': \n'part_name': 6\n'total_parts': 7\n'from': vector\n'score': 0.9363674521446228\n'normalizedScore': 0.8928396286609851\n'beforeDatePenaltyScore': 0.9363674521446228\n\n'contentType': RHEINGOLD\n'documentId': ZM7Cxztnyh7J9Psky\n'title': Signals, Standalone, SSR: So bauen Sie Angular-Apps der Zukunftnull\n'abstract': Es ist die Wiedergeburt von Angular: Mit keinem geringeren Begriff untertitelt das Angular-Team die Veröffentlichung der 17. Hauptversion des SPA-Frameworks.  Recht hat das Angular-Team, denn die Gestalt von Angular-Apps wird sich in Zukunft nachhaltig verändern: In dieser Fassung wird der neue reaktive Basisdatentyp Signals aus der Entwicklervorschau entlassen, Standalone-Komponenten und -APIs werden zum Standard und das Server-Side Rendering für eine verbesserte Ladezeitperformance wurde deutlich aufgebohrt.  Christian Liebel von Thinktecture stellt die Neuerungen in Angular 17 vor und gibt eine Einschätzung, wie Entwickler auf die neuen Features umsteigen sollen. Kommen Sie vorbei und bringen Sie Ihr Angular-Wissen auf den neusten Stand!\n'parentName': BASTA! Spring 2024\n'parentDescription': Die Konferenz für .NET, Windows & Open Innovation\n'author': Christian Liebel\n'language': DE\n'date': Wed Feb 14 2024 14:15:00 GMT+0000 (Coordinated Universal Time)\n'access': restricted\n'chunkSource': text\n'text': Signals, Standalone, SSR: So bauen Sie Angular-Apps der Zukunft Es ist die Wiedergeburt von Angular: Mit keinem geringeren Begriff untertitelt das Angular-Team die Veröffentlichung der 17. Hauptversion des SPA-Frameworks. Recht hat das Angular-Team, denn die Gestalt von Angular-Apps wird sich in Zukunft nachhaltig verändern: In dieser Fassung wird der neue reaktive Basisdatentyp Signals aus der Entwicklervorschau entlassen, Standalone-Komponenten und -APIs werden zum Standard und das Server-Side Rendering für eine verbesserte Ladezeitperformance wurde deutlich aufgebohrt. Christian Liebel von Thinktecture stellt die Neuerungen in Angular 17 vor und gibt eine Einschätzung, wie Entwickler auf die neuen Features umsteigen sollen. Kommen Sie vorbei und bringen Sie Ihr Angular-Wissen auf den neusten Stand! Yeah. The next, uh, talk signals, standalone components and APIs, rendering features, Moderna, angular, modern sch, um, and we owned Ben from Microsoft, Google. Google contracted through the Angular team. Some, some Chrome team on some edge team and others when on progressive web scale as a decrease on the web and vendor insights, offline faced Mercurian features. Um, on via my, um, for an online event of the e platform, um, platform, LinkedIn platform D, um, Renaissance and kind S scenario framework. Um, signals, um, angular based input. The standalone components of the APIs standalone, the built in control flow, so V defer view sub in at if at built on de side rendering in angular, um, Deno aesthetic side generation onto dehydration. Yeah, in construc, a P surface from angular modern JavaScript performance. Some tile to build performance, some tile, larger side performance and some side performance. Angular because up LA to next scenario was the base of Anole, um, signal standalone components on server side rendering signals. Signals. Signal is troop. This is this passed from super then signal direct built signal sign. Um, the signal is a, um, dam reactive stick. Um, that's the reactive extensions for JavaScript. Um, with that signals in the RXs busman signals signal the change detection system in angular performance detection strategy on push for good signals come other look for the async pipe. Observable. This is the actual gut in angular fully change detection. This is concept. Click indeed a stricken from the test and set time out and promised de rejected on Then this lio where the API service this web files service media. API web blue web, A request animation frame is, that's what the tile is\n'slidetext': \n'part_name': 1\n'total_parts': 4\n'from': vector\n'score': 0.935523271560669\n'normalizedScore': 0.892458633008538\n'beforeDatePenaltyScore': 0.935523271560669\n\n'contentType': READ\n'documentId': 54f0c577196e8b38d9c2cc69\n'title': Punktgenaue AktualisierungFrontend-Entwicklung mit Signals – Teil 2\n'abstract': Unsere Artikelserie soll dabei helfen, schon jetzt in die neue Signals-Welt einzutauchen, um die richtigen Entscheidungen treffen zu können, sobald die neuen Framework-APIs die Developer-Preview-Phase verlassen. Diesmal sehen wir uns die Auswirkungen von Signals auf die Laufzeitperformance an.\n'parentName': iJS Magazin 2.2024\n'parentDescription': Kaum ein Softwareprojekt, das nicht in wesentlichen Teilen auf der JavaScript-Technologie basiert. Eine breite Unterstützung sowie, leistungsfähige Programmiersprachen, die Vielzahl moderner Tools, sowie ausgereifte Frameworks wie Angular, React, Vue.js oder Node.js machen den JavaScript-Werkzeugkasten zu einem Alleskönner. Das iJS Magazin informiert aktuell und umfassend über die wichtige und innovative Entwicklungen im JavaScript-Universum und bietet handfeste Praxisinformationen für Softwareentwickler und -architekten.\n'author': Michael Egger-Zikes\n'language': DE\n'date': Wed Apr 03 2024 22:00:00 GMT+0000 (Coordinated Universal Time)\n'access': granted\n'chunkSource': text\n'text': Punktgenaue Aktualisierung Frontend-Entwicklung mit Signals – Teil 2 Unsere Artikelserie soll dabei helfen, schon jetzt in die neue Signals-Welt einzutauchen, um die richtigen Entscheidungen treffen zu können, sobald die neuen Framework-APIs die Developer-Preview-Phase verlassen. Diesmal sehen wir uns die Auswirkungen von Signals auf die Laufzeitperformance an. Unsere Artikelserie soll dabei helfen, schon jetzt in die neue Signals-Welt einzutauchen, um die richtigen Entscheidungen treffen zu können, sobald die neuen Framework-APIs die Developer-Preview-Phase verlassen. Diesmal sehen wir uns die Auswirkungen von Signals auf die Laufzeitperformance an. Die Innovationen bei der Einführung des Signals-API werden das Angular-Team voraussichtlich mehrere Major-Releases lang beschäftigen und das Framework fit für die Zukunft machen. Das soll wie gewohnt kompatibel erfolgen, und die Entwickler:innen sollen selbst entscheiden können, wie schnell und umfangreich der eigene Quellcode auf das Signal API und die ebenfalls angekündigte Control-Flow-Syntax umgestellt wird. Das Angular-Team verfolgt dabei klar definierte Ziele zur Weiterentwicklung des Frontend-Frameworks, die durch die Einführung von Signals erreicht werden können. Mehrere davon tragen zu einer Verbesserung der Laufzeitperformance bei: - Direkte Benachrichtigung über Änderungen am Datenmodell - Synchrone Antwort auf Lesezugriffe - Direkte Information, welche Views von Datenänderungen betroffen sind - Die Neuberechnung eines abgeleiteten Zustands erfolgt nur bei aktiver Verwendung des Signals Klären wir aber zunächst ein paar Fragen, die Aufschluss darüber geben, warum eine Verbesserung der Performance überhaupt anzustreben ist. Change Detection bei Angular Was hat es mit der Change Detection auf sich? Jede Frontend-Plattform, egal ob webbasiert oder nicht, versucht Teile eines bekannten Datenmodells in eine grafische Benutzeroberfläche zu integrieren und Aktualisierungsprozesse, die aufgrund von Änderungen des Datenmodells notwendig werden, möglichst effizient und ressourcenschonend durchzuführen. Die Change Detection bindet das View-Modell einer Angular Component aus der TypeScript-Klasse an das dazugehörige HTML-Template der Component. Während die TypeScript-Klasse also die Verantwortung hat, das View-Modell bereitzustellen und Benutzeraktionen, wie z. B. einen Buttonklick oder eine Wertänderung, im Eingabefeld weiterzuverarbeiten bzw. an andere Anwendungsteile weiterzuleiten,\n'slidetext': \n'part_name': 1\n'total_parts': 15\n'from': vector\n'score': 0.9313775897026062\n'normalizedScore': 0.8923668895066397\n'beforeDatePenaltyScore': 0.9313775897026062\n\n'contentType': READ\n'documentId': 5229d453d1393d2c3d86e145\n'title': Signals und State ManagementFrontend-Entwicklung mit Signals – Teil 3\n'abstract': Bereits ab Angular 17 kann ein Teil des Signals API produktiv eingesetzt werden. Die neu veröffentlichte Control-Flow-Syntax dient auch als Grundlage für Signal-basierte Komponenten, die voraussichtlich 2024 veröffentlicht werden. Bis diese APIs einsatzbereit sind, können bereits Schritte unternommen werden, um aktuell vorhandene State-Management-Implementierungen auf Signals umzustellen. Unsere Artikelserie soll dabei helfen, schon jetzt in die neue Welt einzutauchen, um die richtigen Entscheidungen treffen zu können, sobald die neuen Framework APIs die Developer-Preview-Phase verlassen. Dieser dritte Artikel geht auf die Auswirkungen von Signals auf das State Management ein.\n'parentName': Windows Developer 2.2024\n'parentDescription': Windows Developer informiert umfassend und herstellerneutral über die neuen Trends und Möglichkeiten der Software- und Systementwicklung rund um Microsoft- und Web-Technologien. Von der klassischen .NET-Entwicklung über .NET Core bis hin zu neuen Technologien wie Windows 10, Microsoft Azure und der ganzen Bandbreite der aktuellen Web-, Phone- und Tabletentwicklung für Android und iOS mit Xamarin und unterschiedlichen JavaScript-Frameworks. Professionelle Entwickler und IT-Entscheider erhalten genau die Informationen, die sie für den erfolgreichen Einsatz von unternehmensorientierten Lösungen benötigen.\n'author': Michael Egger-Zikes\n'language': DE\n'date': Tue Jan 09 2024 02:00:00 GMT+0000 (Coordinated Universal Time)\n'access': granted\n'chunkSource': text\n'text': Signals und State Management Frontend-Entwicklung mit Signals – Teil 3 Bereits ab Angular 17 kann ein Teil des Signals API produktiv eingesetzt werden. Die neu veröffentlichte Control-Flow-Syntax dient auch als Grundlage für Signal-basierte Komponenten, die voraussichtlich 2024 veröffentlicht werden. Bis diese APIs einsatzbereit sind, können bereits Schritte unternommen werden, um aktuell vorhandene State-Management-Implementierungen auf Signals umzustellen. Unsere Artikelserie soll dabei helfen, schon jetzt in die neue Welt einzutauchen, um die richtigen Entscheidungen treffen zu können, sobald die neuen Framework APIs die Developer-Preview-Phase verlassen. Dieser dritte Artikel geht auf die Auswirkungen von Signals auf das State Management ein. Bereits ab Angular 17 kann ein Teil des Signals API produktiv eingesetzt werden. Die neu veröffentlichte Control-Flow-Syntax dient auch als Grundlage für Signal-basierte Komponenten, die voraussichtlich 2024 veröffentlicht werden. Bis diese APIs einsatzbereit sind, können bereits Schritte unternommen werden, um aktuell vorhandene State-Management-Implementierungen auf Signals umzustellen. Unsere Artikelserie soll dabei helfen, schon jetzt in die neue Welt einzutauchen, um die richtigen Entscheidungen treffen zu können, sobald die neuen Framework APIs die Developer-Preview-Phase verlassen. Dieser dritte Artikel geht auf die Auswirkungen von Signals auf das State Management ein. Während die Angular-Community beginnen kann, das Signals API in der eigenen Codebase zu verwenden, arbeitet das Angular-Team intensiv an weiterführenden Signal-Implementierungen, die schlussendlich punktuellere View-Updates und auch das Nachladen von einzelnen Applikationsbestandteilen ermöglichen werden. Signals werden das Angular-Framework allerdings auch in anderen Bereichen verändern. Einer davon ist die Zustandsverwaltung der Frontend-Applikation. Zustandsverwaltung mit Angular Angular selbst gibt bislang kein konkretes Konzept für State Management vor. Zustand, der in einer Komponente angezeigt werden soll, kann z. B. Klassen-Properties zugewiesen und mit Stringinterpolation an das Template gebunden und damit angezeigt werden. Die Change Detection kümmert sich darum, dass geänderte Property-Werte auch in der HTML-View aktualisiert werden. Mit Hilfe von Property Bindings kann Zustand auch an Kindkomponenten und Direktiven weitergegeben werden, wobei diese Änderungen per Event Emitter an die Elternkomponente zurückgesendet werden können. Mit dem\n'slidetext': \n'part_name': 1\n'total_parts': 10\n'from': vector\n'score': 0.9384304285049438\n'normalizedScore': 0.8923649337884294\n'beforeDatePenaltyScore': 0.9384304285049438\n\n\nTop Vectors:\n'contentType': RHEINGOLD\n'documentId': 59c6dfa238c69ebd748cc7dc\n'title': Angular Signals: Neue Features für die reaktive Entwicklungnull\n'abstract': Angular Signals sind seit einiger Zeit ein spannender Bestandteil der reaktiven Entwicklung in Angular. Mit neuen Features wie linkedSignal() und resource() in Angular 20 rücken sie weiter in den Fokus. Doch wie funktionieren Signals und was macht sie so besonders – insbesondere in Bezug auf die Performance? Welche Vorteile bieten sie gegenüber klassischen RxJS-Patterns? Felix Schütz von Thinktecture gibt eine praxisnahe Einführung in Angular Signals und die damit verbundenen neuen Features und zeigt, wie sie die Entwicklung von modernen, reaktiven Anwendungen nachhaltig verändern. Zusätzlich gibt er einen Ausblick auf die geplante Unterstützung von Signal-basierten Formularen.\n'parentName': JavaScript Days Berlin und online 2025\n'parentDescription': 40 Workshops zu JavaScript, Angular, React, Typescript und KI\n'author': Felix Schütz\n'language': DE\n'date': Wed Oct 22 2025 11:30:00 GMT+0000 (Coordinated Universal Time)\n'access': restricted\n'chunkSource': text\n'text': Angular Signals: Neue Features für die reaktive Entwicklung Angular Signals sind seit einiger Zeit ein spannender Bestandteil der reaktiven Entwicklung in Angular. Mit neuen Features wie linkedSignal() und resource() in Angular 20 rücken sie weiter in den Fokus. Doch wie funktionieren Signals und was macht sie so besonders – insbesondere in Bezug auf die Performance? Welche Vorteile bieten sie gegenüber klassischen RxJS-Patterns? Felix Schütz von Thinktecture gibt eine praxisnahe Einführung in Angular Signals und die damit verbundenen neuen Features und zeigt, wie sie die Entwicklung von modernen, reaktiven Anwendungen nachhaltig verändern. Zusätzlich gibt er einen Ausblick auf die geplante Unterstützung von Signal-basierten Formularen.\n'slidetext': \n'part_name': 1\n'total_parts': 1\n'from': vector\n'score': 0.9380064010620117\n'normalizedScore': 0.945562481687963\n'beforeDatePenaltyScore': 0.9380064010620117\n\n'contentType': RHEINGOLD\n'documentId': bdffbea5001602c274727100\n'title': Quo vadis, Angular State Management?null\n'abstract': Mit der Einführung von Signals hat Angular ein klares Zeichen für modernes State Management gesetzt. Signals fungieren als Container für Anwendungs-State und sind reaktiv. Dadurch ermöglichen sie die einfache Erstellung abgeleiteter Werte, wie sie beispielsweise für ViewModels benötigt werden. Ergänzt werden sie durch Hilfsfunktionen wie resource, die Signals nahtlos mit Backend-Kommunikation verbinden – eine runde Sache. Doch wie weit kommt man mit diesen nativen Tools und wann wird eine spezialisierte Lösung wie der NgRx Signal Store notwendig? Diese Frage steht im Mittelpunkt meines Vortrags, in dem ich die Grenzen der nativen Signals und die Vorteile spezialisierter Bibliotheken aufzeige.\n'parentName': W-JAX 2025\n'parentDescription': Die Konferenz für Java, Architektur- und Software-Innovation\n'author': Rainer Hahnekamp\n'language': DE\n'date': Thu Nov 06 2025 09:30:00 GMT+0000 (Coordinated Universal Time)\n'access': restricted\n'chunkSource': text\n'text': Quo vadis, Angular State Management? Mit der Einführung von Signals hat Angular ein klares Zeichen für modernes State Management gesetzt. Signals fungieren als Container für Anwendungs-State und sind reaktiv. Dadurch ermöglichen sie die einfache Erstellung abgeleiteter Werte, wie sie beispielsweise für ViewModels benötigt werden. Ergänzt werden sie durch Hilfsfunktionen wie resource, die Signals nahtlos mit Backend-Kommunikation verbinden – eine runde Sache. Doch wie weit kommt man mit diesen nativen Tools und wann wird eine spezialisierte Lösung wie der NgRx Signal Store notwendig? Diese Frage steht im Mittelpunkt meines Vortrags, in dem ich die Grenzen der nativen Signals und die Vorteile spezialisierter Bibliotheken aufzeige.\n'slidetext': \n'part_name': 1\n'total_parts': 1\n'from': vector\n'score': 0.9286953806877136\n'normalizedScore': 0.9374774887109252\n'beforeDatePenaltyScore': 0.9286953806877136\n\n'contentType': RHEINGOLD\n'documentId': 01a63ca630515849aaa314b1\n'title': Angular Signals: Neue Features für die reaktive Entwicklungnull\n'abstract': Angular Signals sind seit einiger Zeit ein spannender Bestandteil der reaktiven Entwicklung in Angular. Mit neuen Features wie linkedSignal() und resource() in Angular 19 rücken sie weiter in den Fokus. Doch wie funktionieren Signals und was macht sie so besonders – insbesondere in Bezug auf die Performance? Welche Vorteile bieten sie gegenüber klassischen RxJS-Patterns?Felix Schütz von Thinktecture gibt eine praxisnahe Einführung in Angular Signals und die damit verbundenen neuen Features und zeigt, wie sie die Entwicklung von modernen, reaktiven Anwendungen nachhaltig verändern. Zusätzlich gibt er einen Ausblick auf die geplante Unterstützung von Signal-basierten Formularen.\n'parentName': JavaScript Days München und online 2025\n'parentDescription': 40 Workshops zu JavaScript, Angular, React, HTML & CSS und KI\n'author': Felix Schütz\n'language': DE\n'date': Wed Mar 19 2025 12:30:00 GMT+0000 (Coordinated Universal Time)\n'access': restricted\n'chunkSource': text\n'text': Angular Signals: Neue Features für die reaktive Entwicklung Angular Signals sind seit einiger Zeit ein spannender Bestandteil der reaktiven Entwicklung in Angular. Mit neuen Features wie linkedSignal() und resource() in Angular 19 rücken sie weiter in den Fokus. Doch wie funktionieren Signals und was macht sie so besonders – insbesondere in Bezug auf die Performance? Welche Vorteile bieten sie gegenüber klassischen RxJS-Patterns?Felix Schütz von Thinktecture gibt eine praxisnahe Einführung in Angular Signals und die damit verbundenen neuen Features und zeigt, wie sie die Entwicklung von modernen, reaktiven Anwendungen nachhaltig verändern. Zusätzlich gibt er einen Ausblick auf die geplante Unterstützung von Signal-basierten Formularen.\n'slidetext': \n'part_name': 1\n'total_parts': 1\n'from': vector\n'score': 0.9387110471725464\n'normalizedScore': 0.9284349360176758\n'beforeDatePenaltyScore': 0.9387110471725464\n\n'contentType': READ\n'documentId': 11e1079277948f18298e5d3d\n'title': Angular: Signals, Standalone, SSRSo bauen Sie Angular-Apps der Zukunft\n'abstract': Mit der Veröffentlichung der 16. Hauptversion von Angular läutete das Angular-Team die „Angular Renaissance“ ein. Wörtlich übersetzt bedeutet das nichts Geringeres als die Wiedergeburt von Googles SPA-Framework - eine treffende Bezeichnung, denn Angular-Codebasen werden sich nachhaltig verändern. Der Unterschied zwischen Angular-2- und Angular-17-Code ist mit bloßem Auge erkennbar.\n'parentName': iJS Magazin 4.2024\n'parentDescription': Kaum ein Softwareprojekt, das nicht in wesentlichen Teilen auf der JavaScript-Technologie basiert. Eine breite Unterstützung sowie, leistungsfähige Programmiersprachen, die Vielzahl moderner Tools, sowie ausgereifte Frameworks wie Angular, React, Vue.js oder Node.js machen den JavaScript-Werkzeugkasten zu einem Alleskönner. Das iJS Magazin informiert aktuell und umfassend über die wichtige und innovative Entwicklungen im JavaScript-Universum und bietet handfeste Praxisinformationen für Softwareentwickler und -architekten.\n'author': Christian Liebel\n'language': DE\n'date': Wed Oct 09 2024 22:00:00 GMT+0000 (Coordinated Universal Time)\n'access': granted\n'chunkSource': text\n'text': Angular: Signals, Standalone, SSR So bauen Sie Angular-Apps der Zukunft Mit der Veröffentlichung der 16. Hauptversion von Angular läutete das Angular-Team die „Angular Renaissance“ ein. Wörtlich übersetzt bedeutet das nichts Geringeres als die Wiedergeburt von Googles SPA-Framework - eine treffende Bezeichnung, denn Angular-Codebasen werden sich nachhaltig verändern. Der Unterschied zwischen Angular-2- und Angular-17-Code ist mit bloßem Auge erkennbar. Mit der Veröffentlichung der 16. Hauptversion von Angular läutete das Angular-Team die „Angular Renaissance“ ein. Wörtlich übersetzt bedeutet das nichts Geringeres als die Wiedergeburt von Googles SPA-Framework – eine treffende Bezeichnung, denn Angular-Codebasen werden sich nachhaltig verändern. Der Unterschied zwischen Angular-2- und Angular-17-Code ist mit bloßem Auge erkennbar. Derzeit führt das Angular-Team zahlreiche neue Features und Konzepte in das Framework ein. Ziel dieser Änderungen ist, Angular zu vereinfachen und damit Anfänger:innen den Einstieg zu erleichtern, Schnittstellen zu modernisieren und die Performance von Angular-Anwendungen zu verbessern, damit das Framework auch im kommenden Jahrzehnt seines Bestehens konkurrenzfähig bleibt. Alle neuen Funktionen sind abwärtskompatibel und interoperabel. In diesem Artikel soll es um drei dieser Features gehen: 1. den neuen reaktiven Basisdatentyp Signals, 2. die Standalone-Schnittstellen als NgModule-Killer und 3. den neuen Ansatz zum Server-side Rendering, der es in die 17. Hauptversion von Angular geschafft hat. Angular-Entwickler:innen, die neue Anwendungen erstellen, sollten diese Features in jedem Fall berücksichtigen. Bestandsanwendungen sollten schnellstmöglich migriert werden. In diesem Artikel wird zu jedem Feature angegeben, ob, wann und wie eine Migration vorgenommen werden sollte. Signals – Die neue Art des State Management Mit der 16. Hauptversion von Angular wurden Signals in das Framework eingeführt. Es handelt sich um den neuen reaktiven Basisdatentyp [1]. Ein Signal ist ein Wrapper um einen bestimmten Wert. Wenn sich dieser ändert, informiert das Signal interessierte Konsumenten, sodass diese auf die Änderung reagieren können. const count = signal(0); count.set(3); Ein neues schreibbares Signal lässt sich über die Methode signal() erzeugen. Signals müssen zwingend mit einem Initialwert vorbelegt sein, der als Argument angegeben wird. Es ist\n'slidetext': \n'part_name': 1\n'total_parts': 9\n'from': vector\n'score': 0.9492647647857666\n'normalizedScore': 0.9257883111651426\n'beforeDatePenaltyScore': 0.9492647647857666\n\n'contentType': READ\n'documentId': 8b35e3d0070110b78d6c9434\n'title': Angular: Signals, Standalone, SSRSo bauen Sie Angular-Apps der Zukunft\n'abstract': Mit der Veröffentlichung der 16. Hauptversion von Angular läutete das Angular-Team die „Angular Renaissance“ ein. Wörtlich übersetzt bedeutet das nichts Geringeres als die Wiedergeburt von Googles SPA-Framework - eine treffende Bezeichnung, denn Angular-Codebasen werden sich nachhaltig verändern. Der Unterschied zwischen Angular-2- und Angular-17-Code ist mit bloßem Auge erkennbar.\n'parentName': Windows Developer 7.2024\n'parentDescription': Windows Developer informiert umfassend und herstellerneutral über die neuen Trends und Möglichkeiten der Software- und Systementwicklung rund um Microsoft- und Web-Technologien. Von der klassischen .NET-Entwicklung über .NET Core bis hin zu neuen Technologien wie Windows 10, Microsoft Azure und der ganzen Bandbreite der aktuellen Web-, Phone- und Tabletentwicklung für Android und iOS mit Xamarin und unterschiedlichen JavaScript-Frameworks. Professionelle Entwickler und IT-Entscheider erhalten genau die Informationen, die sie für den erfolgreichen Einsatz von unternehmensorientierten Lösungen benötigen.\n'author': Christian Liebel\n'language': DE\n'date': Mon Jun 10 2024 22:00:00 GMT+0000 (Coordinated Universal Time)\n'access': granted\n'chunkSource': text\n'text': Angular: Signals, Standalone, SSR So bauen Sie Angular-Apps der Zukunft Mit der Veröffentlichung der 16. Hauptversion von Angular läutete das Angular-Team die „Angular Renaissance“ ein. Wörtlich übersetzt bedeutet das nichts Geringeres als die Wiedergeburt von Googles SPA-Framework - eine treffende Bezeichnung, denn Angular-Codebasen werden sich nachhaltig verändern. Der Unterschied zwischen Angular-2- und Angular-17-Code ist mit bloßem Auge erkennbar. Mit der Veröffentlichung der 16. Hauptversion von Angular läutete das Angular-Team die „Angular Renaissance“ ein. Wörtlich übersetzt bedeutet das nichts Geringeres als die Wiedergeburt von Googles SPA-Framework – eine treffende Bezeichnung, denn Angular-Codebasen werden sich nachhaltig verändern. Der Unterschied zwischen Angular-2- und Angular-17-Code ist mit bloßem Auge erkennbar. Derzeit führt das Angular-Team zahlreiche neue Features und Konzepte in das Framework ein. Ziel dieser Änderungen ist, Angular zu vereinfachen und damit Anfänger:innen den Einstieg zu erleichtern, Schnittstellen zu modernisieren und die Performance von Angular-Anwendungen zu verbessern, damit das Framework auch im kommenden Jahrzehnt seines Bestehens konkurrenzfähig bleibt. Alle neuen Funktionen sind abwärtskompatibel und interoperabel. In diesem Artikel soll es um drei dieser Features gehen: 1. den neuen reaktiven Basisdatentyp Signals, 2. die Standalone-Schnittstellen als NgModule-Killer und 3. den neuen Ansatz zum Server-side Rendering, der es in die 17. Hauptversion von Angular geschafft hat. Angular-Entwickler:innen, die neue Anwendungen erstellen, sollten diese Features in jedem Fall berücksichtigen. Bestandsanwendungen sollten schnellstmöglich migriert werden. In diesem Artikel wird zu jedem Feature angegeben, ob, wann und wie eine Migration vorgenommen werden sollte. Signals – Die neue Art des State Management Mit der 16. Hauptversion von Angular wurden Signals in das Framework eingeführt. Es handelt sich um den neuen reaktiven Basisdatentyp [1]. Ein Signal ist ein Wrapper um einen bestimmten Wert. Wenn sich dieser ändert, informiert das Signal interessierte Konsumenten, sodass diese auf die Änderung reagieren können. const count = signal(0); count.set(3); Ein neues schreibbares Signal lässt sich über die Methode signal() erzeugen. Signals müssen zwingend mit einem Initialwert vorbelegt sein, der als Argument angegeben wird. Es ist\n'slidetext': \n'part_name': 1\n'total_parts': 9\n'from': vector\n'score': 0.9492647647857666\n'normalizedScore': 0.9158431056856905\n'beforeDatePenaltyScore': 0.9492647647857666\n\n'contentType': RHEINGOLD\n'documentId': E8GpqxYcngd3MofGq\n'title': Angular Signals: Gamechanger für reaktive Entwicklungnull\n'abstract': Das Angular-Team stellt sein reaktives Modell auf den Prüfstand und schlägt als neuen Ansatz die von anderen Frameworks bekannten Signals vor. Während Altanwendungen zunächst weiter funktionieren wie gehabt, bieten Signals entscheidende Vorteile gegenüber dem bestehenden Modell.  Brauchen Anwendungen in Zukunft überhaupt noch RxJS? Welche Vorteile haben Signals auf die Performance einer Anwendung? Und wie funktioniert das Reaktivitätsmodell im Detail?  Yannick Baron von Thinktecture und Google Developer Expert für Angular beantwortet alle Fragen rund um die neuen Angular-Signals.\n'parentName': JavaScript Days Berlin und online 2024\n'parentDescription': 40 Workshops zu JavaScript, Angular, React, Typescript und KI\n'author': Yannick Baron\n'language': DE\n'date': Wed Oct 23 2024 11:30:00 GMT+0000 (Coordinated Universal Time)\n'access': restricted\n'chunkSource': text\n'text': Angular Signals: Gamechanger für reaktive Entwicklung Das Angular-Team stellt sein reaktives Modell auf den Prüfstand und schlägt als neuen Ansatz die von anderen Frameworks bekannten Signals vor. Während Altanwendungen zunächst weiter funktionieren wie gehabt, bieten Signals entscheidende Vorteile gegenüber dem bestehenden Modell. Brauchen Anwendungen in Zukunft überhaupt noch RxJS? Welche Vorteile haben Signals auf die Performance einer Anwendung? Und wie funktioniert das Reaktivitätsmodell im Detail? Yannick Baron von Thinktecture und Google Developer Expert für Angular beantwortet alle Fragen rund um die neuen Angular-Signals.\n'slidetext': \n'part_name': 1\n'total_parts': 1\n'from': vector\n'score': 0.9359365701675415\n'normalizedScore': 0.9135748425743148\n'beforeDatePenaltyScore': 0.9359365701675415\n\n'contentType': READ\n'documentId': 289cab1ef800cbd306a62af3\n'title': Angular 18 – erwachsen, aber aktivAlles zur neuen Version\n'abstract': Mit Angular 18 steht Entwickler:innen eine Vielzahl neuer Features und Verbesserungen zur Verfügung, die die Entwicklung moderner Webanwendungen weiter optimieren. Angular 18 baut auf die Fortschritte der Vorgängerversionen auf und führt zahlreiche Performanceoptimierungen sowie neue APIs ein, die die Arbeit mit dem Framework noch effizienter gestalten.\n'parentName': iJS Magazin 4.2024\n'parentDescription': Kaum ein Softwareprojekt, das nicht in wesentlichen Teilen auf der JavaScript-Technologie basiert. Eine breite Unterstützung sowie, leistungsfähige Programmiersprachen, die Vielzahl moderner Tools, sowie ausgereifte Frameworks wie Angular, React, Vue.js oder Node.js machen den JavaScript-Werkzeugkasten zu einem Alleskönner. Das iJS Magazin informiert aktuell und umfassend über die wichtige und innovative Entwicklungen im JavaScript-Universum und bietet handfeste Praxisinformationen für Softwareentwickler und -architekten.\n'author': Karsten Sitterberg\n'language': DE\n'date': Wed Oct 09 2024 22:00:00 GMT+0000 (Coordinated Universal Time)\n'access': granted\n'chunkSource': text\n'text': bei neu generierten Projekten in Zukunft deshalb nicht mehr assets, sondern public. Weiterhin wird mit Angular CLI 18 der Befehl ng doc entfernt, da dieser ohnehin nur selten genutzt wurde. Die offizielle Empfehlung ist, stattdessen in der Dokumentation unter [1] nachzuschauen. Breaking Changes Neben der neu unterstützten Node.js-Version 22 wurde auch die minimal notwendige Node.js-Version angepasst. Die minimal notwendige LTS-Node.js-Version ist nun 18.19.1, Node.js 19 wird gar nicht mehr unterstützt, und Node.js 20 erst ab Version 20.11.1. Weiterhin wurde die Anbindung des alten, nur noch im webpack-Build unterstützten Sass API (NG_BUILD_LEGACY_SASS) entfernt. Das Legacy API ermöglichte beispielsweise noch die alte ~-Import-Syntax. Angular Auch mit den Minor-Angular-17-Versionen sind einige interessante Neuerungen in Bezug auf die Zukunft von Angular hinzugekommen. Das betrifft zum einen die Weiterentwicklung des Frameworks im Allgemeinen. Zum anderen sind vor allem die Angular-Signal-APIs deutlich erweitert worden, um so das Ziel zu erreichen, Angular-Anwendungen in Zukunft ohne zone.js laufen lassen zu können. Die Neuerungen sollen an dieser Stelle kurz vorgestellt werden. Angular 17.1, 17.2 und 17.3 Ganz besondere Aufmerksamkeit haben die Signal APIs innerhalb der letzten Angular-Versionen erhalten. Dazu gehören vor allem APIs, mit denen die Decorators innerhalb von Komponenten durch Signal-Varianten ersetzt werden können. Das gilt vor allem für Komponenten bzw. Anwendungen, die künftig ohne zone.js auskommen sollen. Um die Neuerungen zu veranschaulichen, wird in Listing 6 die Komponente DemoFormComponent gezeigt, die ein boolesches @Input für den Nachtmodus und ein String-@Input für den momentanen Formularwert hat. Der Input für den Formularwert hat außerdem das Flag required, es wird also ein Compilerfehler ausgegeben, wenn dieser Input nicht gebunden ist. Außerdem ist ein @Output mit dem Namen valueChange vorhanden, der bei jeder Wertänderung des Formulars emittiert. Zu jedem @Output gehört immer ein EventEmitter. (Da der EventEmitter jedoch vom RxJS Subject erbt, könnte an dieser Stelle auch ein Observable stehen, dazu später mehr.) Da der Input value und der Output valueChange heißen, können beide per Two-way Data Binding angebunden werden:  Die Variable 'firstname'\n'slidetext': \n'part_name': 5\n'total_parts': 15\n'from': vector\n'score': 0.9319087266921997\n'normalizedScore': 0.9084322730715757\n'beforeDatePenaltyScore': 0.9319087266921997\n\n'contentType': READ\n'documentId': d93198ee7197abce047d0dc1\n'title': Signals und State ManagementFrontend-Entwicklung mit Signals – Teil 3\n'abstract': Bereits ab Angular 17 kann ein Teil des Signals API produktiv eingesetzt werden. Die neu veröffentlichte Control-Flow-Syntax dient auch als Grundlage für Signal-basierte Komponenten, die voraussichtlich 2024 veröffentlicht werden. Bis diese APIs einsatzbereit sind, können bereits Schritte unternommen werden, um aktuell vorhandene State-Management-Implementierungen auf Signals umzustellen. Unsere Artikelserie soll dabei helfen, schon jetzt in die neue Welt einzutauchen, um die richtigen Entscheidungen treffen zu können, sobald die neuen Framework APIs die Developer-Preview-Phase verlassen. Dieser dritte Artikel geht auf die Auswirkungen von Signals auf das State Management ein.\n'parentName': iJS Magazin 3.2024\n'parentDescription': Kaum ein Softwareprojekt, das nicht in wesentlichen Teilen auf der JavaScript-Technologie basiert. Eine breite Unterstützung sowie, leistungsfähige Programmiersprachen, die Vielzahl moderner Tools, sowie ausgereifte Frameworks wie Angular, React, Vue.js oder Node.js machen den JavaScript-Werkzeugkasten zu einem Alleskönner. Das iJS Magazin informiert aktuell und umfassend über die wichtige und innovative Entwicklungen im JavaScript-Universum und bietet handfeste Praxisinformationen für Softwareentwickler und -architekten.\n'author': Michael Egger-Zikes\n'language': DE\n'date': Thu Jul 04 2024 22:00:00 GMT+0000 (Coordinated Universal Time)\n'access': granted\n'chunkSource': text\n'text': Signals und State Management Frontend-Entwicklung mit Signals – Teil 3 Bereits ab Angular 17 kann ein Teil des Signals API produktiv eingesetzt werden. Die neu veröffentlichte Control-Flow-Syntax dient auch als Grundlage für Signal-basierte Komponenten, die voraussichtlich 2024 veröffentlicht werden. Bis diese APIs einsatzbereit sind, können bereits Schritte unternommen werden, um aktuell vorhandene State-Management-Implementierungen auf Signals umzustellen. Unsere Artikelserie soll dabei helfen, schon jetzt in die neue Welt einzutauchen, um die richtigen Entscheidungen treffen zu können, sobald die neuen Framework APIs die Developer-Preview-Phase verlassen. Dieser dritte Artikel geht auf die Auswirkungen von Signals auf das State Management ein. Bereits ab Angular 17 kann ein Teil des Signals API produktiv eingesetzt werden. Die neu veröffentlichte Control-Flow-Syntax dient auch als Grundlage für Signal-basierte Komponenten, die voraussichtlich 2024 veröffentlicht werden. Bis diese APIs einsatzbereit sind, können bereits Schritte unternommen werden, um aktuell vorhandene State-Management-Implementierungen auf Signals umzustellen. Unsere Artikelserie soll dabei helfen, schon jetzt in die neue Welt einzutauchen, um die richtigen Entscheidungen treffen zu können, sobald die neuen Framework APIs die Developer-Preview-Phase verlassen. Dieser dritte Artikel geht auf die Auswirkungen von Signals auf das State Management ein. Während die Angular-Community beginnen kann, das Signals API in der eigenen Codebase zu verwenden, arbeitet das Angular-Team intensiv an weiterführenden Signal-Implementierungen, die schlussendlich punktuellere View-Updates und auch das Nachladen von einzelnen Applikationsbestandteilen ermöglichen werden. Signals werden das Angular-Framework allerdings auch in anderen Bereichen verändern. Einer davon ist die Zustandsverwaltung der Frontend-Applikation. Zustandsverwaltung mit Angular Angular selbst gibt bislang kein konkretes Konzept für State Management vor. Zustand, der in einer Komponente angezeigt werden soll, kann z. B. Klassen-Properties zugewiesen und mit Stringinterpolation an das Template gebunden und damit angezeigt werden. Die Change Detection kümmert sich darum, dass geänderte Property-Werte auch in der HTML-View aktualisiert werden. Mit Hilfe von Property Bindings kann Zustand auch an Kindkomponenten und Direktiven weitergegeben werden, wobei diese Änderungen per Event Emitter an die Elternkomponente zurückgesendet werden können. Mit dem\n'slidetext': \n'part_name': 1\n'total_parts': 10\n'from': vector\n'score': 0.9384304285049438\n'normalizedScore': 0.9069813721445937\n'beforeDatePenaltyScore': 0.9384304285049438\n\n'contentType': RHEINGOLD\n'documentId': 4d3f036f4ec6fbdb475269f9\n'title': Angular Signal – Revolution der Angular-Entwicklungnull\n'abstract': Angular mitten im Wandel. In der modernen, neuen Angular-Entwicklung spielen Signals als kleine Revolution eine zentrale Rolle. Dieser Vortrag taucht in die Welt der Signals ein, erklärt, wie sie funktionieren und warum sie die Angular-Anwendungsentwicklung revolutionieren. Wir werden die technischen Aspekte und Best Practices für den effektiven Einsatz von Angular-Signals untersuchen und schauen, wie ein Angular Applikation mit Signals aussehen kann. Dieser Vortrag ist eine unverzichtbare Ressource für alle, die ihr Wissen in der Angular-Entwicklung erweitern und die Möglichkeiten von Angular-Signals voll ausschöpfen möchten.\n'parentName': BASTA! Herbst 2024\n'parentDescription': Die Konferenz für .NET, Windows & Open Innovation\n'author': Fabian Gosebrink\n'language': DE\n'date': Thu Sep 19 2024 10:00:00 GMT+0000 (Coordinated Universal Time)\n'access': restricted\n'chunkSource': text\n'text': Angular Signal – Revolution der Angular-Entwicklung Angular mitten im Wandel. In der modernen, neuen Angular-Entwicklung spielen Signals als kleine Revolution eine zentrale Rolle. Dieser Vortrag taucht in die Welt der Signals ein, erklärt, wie sie funktionieren und warum sie die Angular-Anwendungsentwicklung revolutionieren. Wir werden die technischen Aspekte und Best Practices für den effektiven Einsatz von Angular-Signals untersuchen und schauen, wie ein Angular Applikation mit Signals aussehen kann. Dieser Vortrag ist eine unverzichtbare Ressource für alle, die ihr Wissen in der Angular-Entwicklung erweitern und die Möglichkeiten von Angular-Signals voll ausschöpfen möchten. ::. --> ::. Mittagessen steht. Wir wollen uns heute ein bisschen Angular Signals angucken. Ich glaube, das ist auch in eurem Interesse oder? Haben sie aber schon vor ein paar Tagen oder noch diesen Talk anbieten. bisschen unter der Haube an wie das Ganze funktioniert. wie das Ganze eben unter der Haube wirklich funktioniert, Das heißt wir gucken uns an, wie ihr das in eurer Applikation einsetzen könnt. So der zweite Teil überlappt sich so ein bisschen mit dem, ihr solltet dann hier rausgehen und zumindest wissen, und vor allen Dingen, wie ihr emigrieren könnt. in seiner Applikation? Ach, sehr gut, prima. Das ist schon mal gut. ist auch so ein bisschen einzuordnen, Warum ist Angular hingegangen und hat das Ganze gemacht? Signals selber, aber die haben auch irgendwie sowas Ähnliches., Finde ich auch sehr, gut, recht zunächst gucken, was können wir machen und adaptieren Also eine coole Sache. Wir müssen so bisschen gucken, wie die läuft. Heute Morgen habe ich über Container und Presentational schön mit on push Change Detection versehen. die du sowieso durchläufst, nehme ich erst mal raus. Jetzt ist die Frage, wie läuft die normale Change Detection? von Components. Der ist riesig groß. rennt Angular los und dieser komplette Baum, der Dom, Entweder ist was passiert oder es ist nichts passiert. sagen,, ist okay, nur wenn sich wirklich was geändert hat. aber trotzdem overhead. Davon haben wir als Entwickler gar nicht viel mitbekommen, die auf jede Change Detection Run gucken, wie oft das Ganze geht, da geht eine Menge ab. Und\n'slidetext': \n'part_name': 1\n'total_parts': 11\n'from': vector\n'score': 0.9307624697685242\n'normalizedScore': 0.9056010846410508\n'beforeDatePenaltyScore': 0.9307624697685242\n\n'contentType': READ\n'documentId': 16b7f80d5b4b04e3989c2532\n'title': Angular 18 – erwachsen, aber aktivAlles zur neuen Version\n'abstract': Mit Angular 18 steht Entwickler:innen eine Vielzahl neuer Features und Verbesserungen zur Verfügung, die die Entwicklung moderner Webanwendungen weiter optimieren. Angular 18 baut auf die Fortschritte der Vorgängerversionen auf und führt zahlreiche Performanceoptimierungen sowie neue APIs ein, die die Arbeit mit dem Framework noch effizienter gestalten.\n'parentName': Windows Developer 10.2024\n'parentDescription': Windows Developer informiert umfassend und herstellerneutral über die neuen Trends und Möglichkeiten der Software- und Systementwicklung rund um Microsoft- und Web-Technologien. Von der klassischen .NET-Entwicklung über .NET Core bis hin zu neuen Technologien wie Windows 10, Microsoft Azure und der ganzen Bandbreite der aktuellen Web-, Phone- und Tabletentwicklung für Android und iOS mit Xamarin und unterschiedlichen JavaScript-Frameworks. Professionelle Entwickler und IT-Entscheider erhalten genau die Informationen, die sie für den erfolgreichen Einsatz von unternehmensorientierten Lösungen benötigen.\n'author': Karsten Sitterberg\n'language': DE\n'date': Wed Aug 28 2024 22:00:00 GMT+0000 (Coordinated Universal Time)\n'access': granted\n'chunkSource': text\n'text': bei neu generierten Projekten in Zukunft deshalb nicht mehr assets, sondern public. Weiterhin wird mit Angular CLI 18 der Befehl ng doc entfernt, da dieser ohnehin nur selten genutzt wurde. Die offizielle Empfehlung ist, stattdessen in der Dokumentation unter [1] nachzuschauen. Breaking Changes Neben der neu unterstützten Node.js-Version 22 wurde auch die minimal notwendige Node.js-Version angepasst. Die minimal notwendige LTS-Node.js-Version ist nun 18.19.1, Node.js 19 wird gar nicht mehr unterstützt, und Node.js 20 erst ab Version 20.11.1. Weiterhin wurde die Anbindung des alten, nur noch im webpack-Build unterstützten Sass API (NG_BUILD_LEGACY_SASS) entfernt. Das Legacy API ermöglichte beispielsweise noch die alte ~-Import-Syntax. Angular Auch mit den Minor-Angular-17-Versionen sind einige interessante Neuerungen in Bezug auf die Zukunft von Angular hinzugekommen. Das betrifft zum einen die Weiterentwicklung des Frameworks im Allgemeinen. Zum anderen sind vor allem die Angular-Signal-APIs deutlich erweitert worden, um so das Ziel zu erreichen, Angular-Anwendungen in Zukunft ohne zone.js laufen lassen zu können. Die Neuerungen sollen an dieser Stelle kurz vorgestellt werden. Angular 17.1, 17.2 und 17.3 Ganz besondere Aufmerksamkeit haben die Signal APIs innerhalb der letzten Angular-Versionen erhalten. Dazu gehören vor allem APIs, mit denen die Decorators innerhalb von Komponenten durch Signal-Varianten ersetzt werden können. Das gilt vor allem für Komponenten bzw. Anwendungen, die künftig ohne zone.js auskommen sollen. Um die Neuerungen zu veranschaulichen, wird in Listing 6 die Komponente DemoFormComponent gezeigt, die ein boolesches @Input für den Nachtmodus und ein String-@Input für den momentanen Formularwert hat. Der Input für den Formularwert hat außerdem das Flag required, es wird also ein Compilerfehler ausgegeben, wenn dieser Input nicht gebunden ist. Außerdem ist ein @Output mit dem Namen valueChange vorhanden, der bei jeder Wertänderung des Formulars emittiert. Zu jedem @Output gehört immer ein EventEmitter. (Da der EventEmitter jedoch vom RxJS Subject erbt, könnte an dieser Stelle auch ein Observable stehen, dazu später mehr.) Da der Input value und der Output valueChange heißen, können beide per Two-way Data Binding angebunden werden:  Die Variable 'firstname'\n'slidetext': \n'part_name': 5\n'total_parts': 15\n'from': vector\n'score': 0.9319087266921997\n'normalizedScore': 0.9049802182770551\n'beforeDatePenaltyScore': 0.9319087266921997\n\n'contentType': READ\n'documentId': 04721391f3f7580f0631b9d3\n'title': Angular 17: Neues Release des Web-FrameworksRenaissance? Angular 17! - Alle Features im Überblick\n'abstract': Das beliebte JavaScript-Framework Angular veröffentlicht Version 17. Da bei Angular viel in Bewegung ist, kann manch einer da den Überblick verlieren. Wir stellen alle Features von Angular 17 vor.\n'parentName': iJS Magazin 2.2024\n'parentDescription': Kaum ein Softwareprojekt, das nicht in wesentlichen Teilen auf der JavaScript-Technologie basiert. Eine breite Unterstützung sowie, leistungsfähige Programmiersprachen, die Vielzahl moderner Tools, sowie ausgereifte Frameworks wie Angular, React, Vue.js oder Node.js machen den JavaScript-Werkzeugkasten zu einem Alleskönner. Das iJS Magazin informiert aktuell und umfassend über die wichtige und innovative Entwicklungen im JavaScript-Universum und bietet handfeste Praxisinformationen für Softwareentwickler und -architekten.\n'author': Karsten Sitterberg\n'language': DE\n'date': Wed Apr 03 2024 22:00:00 GMT+0000 (Coordinated Universal Time)\n'access': granted\n'chunkSource': text\n'text': '@NgModule()'s. - Funktionale HTTP-Interceptoren werden in Angular CLI 17 bevorzugt, klassenbasierte sind optional. - Einführung der neuen Syntax @switch, @case, und @default für Conditional Rendering und neue Direktiven wie @defer für Lazy Loading. - @defer unterstützt bedingtes Laden und Vorladen mit prefetch. - Die Angular CLI bietet eine automatische Migration zur neuen Syntax an; alte und neue Syntax können in Version 17 parallel genutzt werden. - Integration der neuen Lifecycle-Hooks afterRender() und afterNextRender sowie die Stabilisierung von Signals. - Lazy Loading für Animationen und die Integration der View Transitions DOM-API für optimierte Übergänge und Animationen. - Einführung einer neuen Control-Flow-Syntax als Developer Preview, die *ngIf, *ngFor, und ngSwitch ersetzt und zusätzliche Verbesserungen wie @if, @for, und erforderliches Track-by für Listen umfasst. Breaking Changes in Angular 17 - Entfernung von signal.mutate(): Die Möglichkeit, Signals durch Mutation zu verändern, wurde entfernt. Signals müssen als immutable Datenstrukturen behandelt werden; Änderungen sollten durch die signal.update()-Funktion vorgenommen werden. - Signal-Handhabung als immutable: Anstatt Signals zu mutieren, sollten Entwickler diese nun behandeln, als wären sie immutable, und entsprechend aktualisieren. - Entfernung von Router Properties: Bestimmte Router Properties wie canceledNavigationResolution, paramsInheritanceStrategy, titleStrategy, urlUpdateStrategy, malformedUriErrorHandler und urlHandlingStrategy wurden aus der öffentlichen API entfernt. - Neue Konfiguration über provideRouter() oder RouterModule.forRoot(): Die zuvor entfernten Router Properties müssen jetzt über die provideRouter()-Funktion oder im RouterModule.forRoot()-Hook konfiguriert werden. - Änderung in der Navigation: Die Konfiguration der Navigationsstrategie und Fehlerbehandlung muss an die neuen Methoden angepasst werden, um Inkompatibilitäten mit dem Router-Service von Angular 17 zu vermeiden. TypeScript Mit der neuen Angular-Version wird auch eine neue TypeScript-Version unterstützt. In Angular 17 muss nun zugleich TypeScript mindestens in Version 5.2 verwendet werden. Da beim Release von Angular 16 noch TypeScript 5.0 vorausgesetzt wurde, wollen wir uns an dieser Stelle sowohl einige interessante Neuerungen sowohl aus TypeScript 5.1 als auch aus TypeScript 5.2 ansehen. Implizites “return“ bei Rückgabe von “undefined“ Wenn in JavaScript eine Funktion keine “return”-Angabe enthält, hat diese Funktion dennoch immer implizit “undefined” als Rückgabewert. In TypeScript hat sich diese Tatsache bisher nicht\n'slidetext': \n'part_name': 2\n'total_parts': 21\n'from': vector\n'score': 0.9424538612365723\n'normalizedScore': 0.9034431610406057\n'beforeDatePenaltyScore': 0.9424538612365723\n\n'contentType': READ\n'documentId': 716e141fb1acae69460b0dd2\n'title': Angular 18 – erwachsen, aber aktivAlles zur neuen Version\n'abstract': Mit Angular 18 steht Entwickler:innen eine Vielzahl neuer Features und Verbesserungen zur Verfügung, die die Entwicklung moderner Webanwendungen weiter optimieren. Angular 18 baut auf die Fortschritte der Vorgängerversionen auf und führt zahlreiche Performanceoptimierungen sowie neue APIs ein, die die Arbeit mit dem Framework noch effizienter gestalten.\n'parentName': Java Magazin 9.2024\n'parentDescription': Über neun Millionen Software-Entwickler weltweit sorgen dafür, dass die Java-Technologie in allen Geschäftsfeldern und in allen Branchen eine zentrale Rolle spielt. Zudem ist das Java-Ökosystem der wichtigste Takt- und Impulsgeber für die gesamte Software-Industrie, wenn es um technische Innovationen geht. Das Java Magazin begleitet seit über 20 Jahren alle wesentlichen Entwicklungen der Java-Welt aktuell, kritisch und mit großer praktischer Relevanz. Software-Architekten, Entwickler und Projektleiter vertrauen auf die anerkannte Kompetenz der Redaktion verbunden mit ihrem Experten-Netzwerk bekannter Fachautoren.\n'author': Karsten Sitterberg\n'language': DE\n'date': Mon Aug 05 2024 22:00:00 GMT+0000 (Coordinated Universal Time)\n'access': granted\n'chunkSource': text\n'text': bei neu generierten Projekten in Zukunft deshalb nicht mehr assets, sondern public. Weiterhin wird mit Angular CLI 18 der Befehl ng doc entfernt, da dieser ohnehin nur selten genutzt wurde. Die offizielle Empfehlung ist, stattdessen in der Dokumentation unter [1] nachzuschauen. Breaking Changes Neben der neu unterstützten Node.js-Version 22 wurde auch die minimal notwendige Node.js-Version angepasst. Die minimal notwendige LTS-Node.js-Version ist nun 18.19.1, Node.js 19 wird gar nicht mehr unterstützt, und Node.js 20 erst ab Version 20.11.1. Weiterhin wurde die Anbindung des alten, nur noch im webpack-Build unterstützten Sass API (NG_BUILD_LEGACY_SASS) entfernt. Das Legacy API ermöglichte beispielsweise noch die alte ~-Import-Syntax. Angular Auch mit den Minor-Angular-17-Versionen sind einige interessante Neuerungen in Bezug auf die Zukunft von Angular hinzugekommen. Das betrifft zum einen die Weiterentwicklung des Frameworks im Allgemeinen. Zum anderen sind vor allem die Angular-Signal-APIs deutlich erweitert worden, um so das Ziel zu erreichen, Angular-Anwendungen in Zukunft ohne zone.js laufen lassen zu können. Die Neuerungen sollen an dieser Stelle kurz vorgestellt werden. Angular 17.1, 17.2 und 17.3 Ganz besondere Aufmerksamkeit haben die Signal APIs innerhalb der letzten Angular-Versionen erhalten. Dazu gehören vor allem APIs, mit denen die Decorators innerhalb von Komponenten durch Signal-Varianten ersetzt werden können. Das gilt vor allem für Komponenten bzw. Anwendungen, die künftig ohne zone.js auskommen sollen. Um die Neuerungen zu veranschaulichen, wird in Listing 6 die Komponente DemoFormComponent gezeigt, die ein boolesches @Input für den Nachtmodus und ein String-@Input für den momentanen Formularwert hat. Der Input für den Formularwert hat außerdem das Flag required, es wird also ein Compilerfehler ausgegeben, wenn dieser Input nicht gebunden ist. Außerdem ist ein @Output mit dem Namen valueChange vorhanden, der bei jeder Wertänderung des Formulars emittiert. Zu jedem @Output gehört immer ein EventEmitter. (Da der EventEmitter jedoch vom RxJS Subject erbt, könnte an dieser Stelle auch ein Observable stehen, dazu später mehr.) Da der Input value und der Output valueChange heißen, können beide per Two-way Data Binding angebunden werden:  Die Variable 'firstname'\n'slidetext': \n'part_name': 5\n'total_parts': 15\n'from': vector\n'score': 0.9319087266921997\n'normalizedScore': 0.903089807318151\n'beforeDatePenaltyScore': 0.9319087266921997\n\n'contentType': READ\n'documentId': 04721391f3f7580f0631b9d3\n'title': Angular 17: Neues Release des Web-FrameworksRenaissance? Angular 17! - Alle Features im Überblick\n'abstract': Das beliebte JavaScript-Framework Angular veröffentlicht Version 17. Da bei Angular viel in Bewegung ist, kann manch einer da den Überblick verlieren. Wir stellen alle Features von Angular 17 vor.\n'parentName': iJS Magazin 2.2024\n'parentDescription': Kaum ein Softwareprojekt, das nicht in wesentlichen Teilen auf der JavaScript-Technologie basiert. Eine breite Unterstützung sowie, leistungsfähige Programmiersprachen, die Vielzahl moderner Tools, sowie ausgereifte Frameworks wie Angular, React, Vue.js oder Node.js machen den JavaScript-Werkzeugkasten zu einem Alleskönner. Das iJS Magazin informiert aktuell und umfassend über die wichtige und innovative Entwicklungen im JavaScript-Universum und bietet handfeste Praxisinformationen für Softwareentwickler und -architekten.\n'author': Karsten Sitterberg\n'language': DE\n'date': Wed Apr 03 2024 22:00:00 GMT+0000 (Coordinated Universal Time)\n'access': granted\n'chunkSource': text\n'text': Angular 17: Neues Release des Web-Frameworks Renaissance? Angular 17! - Alle Features im Überblick Das beliebte JavaScript-Framework Angular veröffentlicht Version 17. Da bei Angular viel in Bewegung ist, kann manch einer da den Überblick verlieren. Wir stellen alle Features von Angular 17 vor. Bei Angular ist viel in Bewegung. Manch einer kann da den Überblick verlieren, oder gar Angst vor Überforderung bekommen. Ob diese Sorge begründet ist oder der Plan des Angular-Teams, für Angular eine Renaissance einzuläuten, gelingen kann, soll in diesem Beitrag beleuchtet werden. Vorneweg: Wer bisher Angular Upgrades vor sich her geschoben hat, oder plant lediglich zum Ende eines LTS Zyklus zu aktualisieren, der sollte die aktuellen Entwicklungen sehr genau beobachten und bewerten, ob inkrementelle Updates mit kleinen Schritten, statt großer Sprünge aus Aufwand- und Risikosicht nicht sinnvoller sind. Wir werfen natürlich nicht nur einen Blick auf die Angular-Core Änderungen, sondern werden auch TypeScript und Angular-Material betrachten. Das Angular 17 Release in Stichpunkten Hier findet ihr knapp zusammengefasst einige der wichtigsten Neuerungen und Breaking Changes in Angular 17. TypeScript - Angular 17 erfordert mindestens TypeScript 5.2. - Implizites 'return' bei 'undefined' wird nun unterstützt; Funktionen mit Rückgabetyp 'undefined' sind mit 'void'-Funktionen kompatibel. - Unabhängige Typangaben für Getter und Setter werden mit TypeScript 5.1 ermöglicht. - Neue Metadaten für Decorators mit TypeScript 5.2, um Verhalten zu definieren und auszulesen. Angular CLI - Angular CLI nutzt 'esbuild' für schnellere Builds und kleinere Ergebnisse, einschließlich eines Vite-basierten Development-Servers. - Server-Side Rendering Funktionalitäten unter dem Paket '@angular/ssr' wurden eingeführt, mit vereinfachten SSR-Optionen im CLI. - Es gibt mehrere Breaking Changes in Angular CLI, einschließlich der Anforderung von TypeScript 5.2 und zone.js 0.14.0, sowie der Anhebung der minimalen Node.js-Version auf 18.13.0. Angular 17 - Neue Anwendungen initialisieren den Angular Router standardmäßig und erzeugen Anwendungen als 'standalone' ohne '@NgModule()'s. - Funktionale HTTP-Interceptoren werden in Angular CLI 17 bevorzugt, klassenbasierte sind optional. - Einführung der neuen Syntax @switch, @case, und @default für Conditional Rendering und neue Direktiven wie @defer für Lazy\n'slidetext': \n'part_name': 1\n'total_parts': 21\n'from': vector\n'score': 0.9420861005783081\n'normalizedScore': 0.9030754003823416\n'beforeDatePenaltyScore': 0.9420861005783081\n\n'contentType': READ\n'documentId': f1151315d5ffa6c7887a8812\n'title': Renaissance? Angular 17!Neues Release des Web-Frameworks\n'abstract': Bei Angular ist viel in Bewegung. Manch einer kann da den Überblick verlieren, oder gar Angst vor Überforderung bekommen. Ob diese Sorge begründet ist oder der Plan des Angular-Teams, für Angular eine Renaissance einzuläuten, gelingen kann, soll in diesem Beitrag beleuchtet werden.\n'parentName': Entwickler Magazin 2.2024\n'parentDescription': Das Entwickler Magazin bietet Software-Entwicklern Einblicke und Orientierung in einem Markt an Entwicklungstechnologien, -tools und -ansätzen, der stets komplexer wird. Mit seiner Kompetenz in einer breiten Palette an Programmiersprachen, Tools, Plattformen und Engineering-Techniken liefert es einen fundierten Marktüberblick und bietet technische Entscheidungshilfen für Entwickler, Projektleiter und Manager.\n'author': Karsten Sitterberg\n'language': DE\n'date': Tue Jan 23 2024 02:00:00 GMT+0000 (Coordinated Universal Time)\n'access': granted\n'chunkSource': text\n'text': CLI 17 eine automatische Migration geben, die den Wechsel zur neuen Syntax vereinfachen soll. Zumindest in Angular 17 sind aber noch beide Syntaxvarianten verwendbar. Breaking Changes in Angular 17 Da Angular 17 ein Major Release ist, gibt es entsprechend auch ein paar Breaking Changes. Ein Breaking Change betrifft das mit Angular 16 eingeführte Feature der Signals. Die Signals wurden mit Angular 16 noch als Developer-Preview gehandelt, daher die kurze Zeit bis zu dieser Änderung. Bei den Signals hat es sich gezeigt, dass die signal.mutate()-Funktion zu Inkonsistenzen in der Anwendung führen kann. Daher wurde diese Möglichkeit, ein Signal zu ändern, entfernt. Signals sollten nun nicht mehr per Mutation verändert werden, sondern stattdessen immer wie eine Immutable-Datenstruktur verwendet werden. In Listing 19 ist beispielhaft gezeigt, wie ein Signal, das ein Array enthält, bisher verändert werden konnte, und wie es ab Angular 17 geschehen sollte. Listing 19: Items zu einem Signal hinzufügen im Angular-16/17-Vergleich // Mit Angular 16 items.mutate(itemsArray => itemsArray.push(newItem)); // Ab Angular 17: items.update(itemsArray => [itemsArray, ...newItem]); Neben den Signals gibt es Breaking Changes im Router. Dieser hat bisher die Properties - canceledNavigationResolution - paramsInheritanceStrategy - titleStrategy - urlUpdateStrategy - malformedUriErrorHandler - urlHandlingStrategy zur Verfügung gestellt. Mit Angular 17 wurden diese Properties aus dem Public API des Routers entfernt. Statt über den Router sollten diese Properties jetzt durch die entsprechenden Konfigurationsparameter in der provideRouter()-Funktion oder dem RouterModule.forRoot() Hook konfiguriert werden. Angular 17 in der Praxis Mit den Änderungen sind neuartige Architekturen möglich und Optimierungen, die früher gar nicht oder nur schwer umsetzbar waren. Zur Illustration soll ein Beispiel aus der Praxis dienen. Um effektive, sichere und vollständig DSGVO-konforme Remote-Schulungen durchzuführen, wurde eine integrierte Plattform entwickelt, an der der Autor dieses Beitrags federführend beteiligt war. Schaut man sich einen Livescreenshot an (Abb. 2), so ist direkt zu erkennen, dass die Steuerung von Audio und Video direkt in der primären Ansicht verfügbar ist (Schalter unten links). Das bedeutet, dass die zugehörigen Komponenten und Services nicht durch Lazy Loading später nachgeladen werden können, da es keine geschachtelte Route gibt, mit der ein entsprechendes Code-Splitting\n'slidetext': \n'part_name': 16\n'total_parts': 20\n'from': vector\n'score': 0.9473196268081665\n'normalizedScore': 0.9024048170231589\n'beforeDatePenaltyScore': 0.9473196268081665\n\n'contentType': READ\n'documentId': 3caa038a2f16278ab3c6040a\n'title': Angular 18 – erwachsen, aber aktivAlles zur neuen Version\n'abstract': Mit Angular 18 steht Entwickler:innen eine Vielzahl neuer Features und Verbesserungen zur Verfügung, die die Entwicklung moderner Webanwendungen weiter optimieren. Angular 18 baut auf die Fortschritte der Vorgängerversionen auf und führt zahlreiche Performanceoptimierungen sowie neue APIs ein, die die Arbeit mit dem Framework noch effizienter gestalten.\n'parentName': Entwickler Magazin 6.2024\n'parentDescription': Das Entwickler Magazin bietet Software-Entwicklern Einblicke und Orientierung in einem Markt an Entwicklungstechnologien, -tools und -ansätzen, der stets komplexer wird. Mit seiner Kompetenz in einer breiten Palette an Programmiersprachen, Tools, Plattformen und Engineering-Techniken liefert es einen fundierten Marktüberblick und bietet technische Entscheidungshilfen für Entwickler, Projektleiter und Manager.\n'author': Karsten Sitterberg\n'language': DE\n'date': Wed Jul 24 2024 22:00:00 GMT+0000 (Coordinated Universal Time)\n'access': granted\n'chunkSource': text\n'text': bei neu generierten Projekten in Zukunft deshalb nicht mehr assets, sondern public. Weiterhin wird mit Angular CLI 18 der Befehl ng doc entfernt, da dieser ohnehin nur selten genutzt wurde. Die offizielle Empfehlung ist, stattdessen in der Dokumentation unter [1] nachzuschauen. Breaking Changes Neben der neu unterstützten Node.js-Version 22 wurde auch die minimal notwendige Node.js-Version angepasst. Die minimal notwendige LTS-Node.js-Version ist nun 18.19.1, Node.js 19 wird gar nicht mehr unterstützt, und Node.js 20 erst ab Version 20.11.1. Weiterhin wurde die Anbindung des alten, nur noch im webpack-Build unterstützten Sass API (NG_BUILD_LEGACY_SASS) entfernt. Das Legacy API ermöglichte beispielsweise noch die alte ~-Import-Syntax. Angular Auch mit den Minor-Angular-17-Versionen sind einige interessante Neuerungen in Bezug auf die Zukunft von Angular hinzugekommen. Das betrifft zum einen die Weiterentwicklung des Frameworks im Allgemeinen. Zum anderen sind vor allem die Angular-Signal-APIs deutlich erweitert worden, um so das Ziel zu erreichen, Angular-Anwendungen in Zukunft ohne zone.js laufen lassen zu können. Die Neuerungen sollen an dieser Stelle kurz vorgestellt werden. Angular 17.1, 17.2 und 17.3 Ganz besondere Aufmerksamkeit haben die Signal APIs innerhalb der letzten Angular-Versionen erhalten. Dazu gehören vor allem APIs, mit denen die Decorators innerhalb von Komponenten durch Signal-Varianten ersetzt werden können. Das gilt vor allem für Komponenten bzw. Anwendungen, die künftig ohne zone.js auskommen sollen. Um die Neuerungen zu veranschaulichen, wird in Listing 6 die Komponente DemoFormComponent gezeigt, die ein boolesches @Input für den Nachtmodus und ein String-@Input für den momentanen Formularwert hat. Der Input für den Formularwert hat außerdem das Flag required, es wird also ein Compilerfehler ausgegeben, wenn dieser Input nicht gebunden ist. Außerdem ist ein @Output mit dem Namen valueChange vorhanden, der bei jeder Wertänderung des Formulars emittiert. Zu jedem @Output gehört immer ein EventEmitter. (Da der EventEmitter jedoch vom RxJS Subject erbt, könnte an dieser Stelle auch ein Observable stehen, dazu später mehr.) Da der Input value und der Output valueChange heißen, können beide per Two-way Data Binding angebunden werden:  Die Variable 'firstname'\n'slidetext': \n'part_name': 5\n'total_parts': 15\n'from': vector\n'score': 0.9319087266921997\n'normalizedScore': 0.902103505948288\n'beforeDatePenaltyScore': 0.9319087266921997\n\n'contentType': READ\n'documentId': 52ef1d82560c140fe2ed1886\n'title': Angular 18 – erwachsen, aber aktivAlles zur neuen Version\n'abstract': Mit Angular 18 steht Entwickler:innen eine Vielzahl neuer Features und Verbesserungen zur Verfügung, die die Entwicklung moderner Webanwendungen weiter optimieren. Angular 18 baut auf die Fortschritte der Vorgängerversionen auf und führt zahlreiche Performanceoptimierungen sowie neue APIs ein, die die Arbeit mit dem Framework noch effizienter gestalten.\n'parentName': entwickler.de Blog 7.2024\n'parentDescription': n/a\n'author': Karsten Sitterberg\n'language': DE\n'date': Mon Jul 15 2024 04:30:22 GMT+0000 (Coordinated Universal Time)\n'access': granted\n'chunkSource': text\n'text': bei neu generierten Projekten in Zukunft deshalb nicht mehr assets, sondern public. Weiterhin wird mit Angular CLI 18 der Befehl ng doc entfernt, da dieser ohnehin nur selten genutzt wurde. Die offizielle Empfehlung ist, stattdessen in der Dokumentation unter [1] nachzuschauen. Breaking Changes Neben der neu unterstützten Node.js-Version 22 wurde auch die minimal notwendige Node.js-Version angepasst. Die minimal notwendige LTS-Node.js-Version ist nun 18.19.1, Node.js 19 wird gar nicht mehr unterstützt, und Node.js 20 erst ab Version 20.11.1. Weiterhin wurde die Anbindung des alten, nur noch im webpack-Build unterstützten Sass API (NG_BUILD_LEGACY_SASS) entfernt. Das Legacy API ermöglichte beispielsweise noch die alte ~-Import-Syntax. Angular Auch mit den Minor-Angular-17-Versionen sind einige interessante Neuerungen in Bezug auf die Zukunft von Angular hinzugekommen. Das betrifft zum einen die Weiterentwicklung des Frameworks im Allgemeinen. Zum anderen sind vor allem die Angular-Signal-APIs deutlich erweitert worden, um so das Ziel zu erreichen, Angular-Anwendungen in Zukunft ohne zone.js laufen lassen zu können. Die Neuerungen sollen an dieser Stelle kurz vorgestellt werden. Angular 17.1, 17.2 und 17.3 Ganz besondere Aufmerksamkeit haben die Signal APIs innerhalb der letzten Angular-Versionen erhalten. Dazu gehören vor allem APIs, mit denen die Decorators innerhalb von Komponenten durch Signal-Varianten ersetzt werden können. Das gilt vor allem für Komponenten bzw. Anwendungen, die künftig ohne zone.js auskommen sollen. Um die Neuerungen zu veranschaulichen, wird in Listing 6 die Komponente DemoFormComponent gezeigt, die ein boolesches @Input für den Nachtmodus und ein String-@Input für den momentanen Formularwert hat. Der Input für den Formularwert hat außerdem das Flag required, es wird also ein Compilerfehler ausgegeben, wenn dieser Input nicht gebunden ist. Außerdem ist ein @Output mit dem Namen valueChange vorhanden, der bei jeder Wertänderung des Formulars emittiert. Zu jedem @Output gehört immer ein EventEmitter. (Da der EventEmitter jedoch vom RxJS Subject erbt, könnte an dieser Stelle auch ein Observable stehen, dazu später mehr.) Da der Input value und der Output valueChange heißen, können beide per Two-way Data Binding angebunden werden:  Die Variable 'firstname'\n'slidetext': \n'part_name': 5\n'total_parts': 15\n'from': vector\n'score': 0.9319087266921997\n'normalizedScore': 0.9013038693425042\n'beforeDatePenaltyScore': 0.9319087266921997\n\n'contentType': READ\n'documentId': f1151315d5ffa6c7887a8812\n'title': Renaissance? Angular 17!Neues Release des Web-Frameworks\n'abstract': Bei Angular ist viel in Bewegung. Manch einer kann da den Überblick verlieren, oder gar Angst vor Überforderung bekommen. Ob diese Sorge begründet ist oder der Plan des Angular-Teams, für Angular eine Renaissance einzuläuten, gelingen kann, soll in diesem Beitrag beleuchtet werden.\n'parentName': Entwickler Magazin 2.2024\n'parentDescription': Das Entwickler Magazin bietet Software-Entwicklern Einblicke und Orientierung in einem Markt an Entwicklungstechnologien, -tools und -ansätzen, der stets komplexer wird. Mit seiner Kompetenz in einer breiten Palette an Programmiersprachen, Tools, Plattformen und Engineering-Techniken liefert es einen fundierten Marktüberblick und bietet technische Entscheidungshilfen für Entwickler, Projektleiter und Manager.\n'author': Karsten Sitterberg\n'language': DE\n'date': Tue Jan 23 2024 02:00:00 GMT+0000 (Coordinated Universal Time)\n'access': granted\n'chunkSource': text\n'text': den Angular-Router standardmäßig und erzeugen Anwendungen als Standalone ohne @NgModule(). - Funktionale HTTP Interceptors werden in Angular CLI 17 bevorzugt, klassenbasierte sind optional. - Einführung der neuen Syntax @switch, @case, und @default für Conditional Rendering und neue Direktiven wie @defer für Lazy Loading. - @defer unterstützt bedingtes Laden und Vorladen mit prefetch. - Das Angular CLI bietet eine automatische Migration zur neuen Syntax an; alte und neue Syntax können in Version 17 parallel genutzt werden. - Integration der neuen Lifecycle-Hooks afterRender() und afterNextRender sowie die Stabilisierung von Signals. - Lazy Loading für Animationen und die Integration des View Transitions DOM API für optimierte Übergänge und Animationen. - Einführung einer neuen Control-Flow-Syntax als Developer Preview, die *ngIf, *ngFor, und ngSwitch ersetzt und zusätzliche Verbesserungen wie @if und @for sowie erforderliches Track-by für Listen umfasst. Breaking Changes in Angular 17 - Entfernung von signal.mutate(): Die Möglichkeit, Signals durch Mutation zu verändern, wurde entfernt. Signals müssen als immutable Datenstrukturen behandelt werden; Änderungen sollten durch die signal.update()-Funktion vorgenommen werden. - Signal-Handhabung als immutable: Anstatt Signals zu mutieren, sollten Entwickler diese nun behandeln, als wären sie immutable, und entsprechend aktualisieren. - Entfernung von Router Properties: Bestimmte Router Properties wie canceledNavigationResolution, paramsInheritanceStrategy, titleStrategy, urlUpdateStrategy, malformedUriErrorHandler und urlHandlingStrategy wurden aus dem öffentlichen API entfernt. - Neue Konfiguration über provideRouter() oder RouterModule.forRoot(): Die zuvor entfernten Router Properties müssen jetzt über die provideRouter()-Funktion oder im RouterModule.forRoot()-Hook konfiguriert werden. - Änderung in der Navigation: Die Konfiguration der Navigationsstrategie und Fehlerbehandlung muss an die neuen Methoden angepasst werden, um Inkompatibilitäten mit dem Router Service von Angular 17 zu vermeiden. TypeScript Mit der neuen Angular-Version wird auch eine neue TypeScript-Version unterstützt. In Angular 17 muss nun zugleich TypeScript mindestens in Version 5.2 verwendet werden. Da beim Release von Angular 16 noch Type-Script 5.0 vorausgesetzt wurde, wollen wir uns an dieser Stelle einige interessante Neuerungen sowohl aus TypeScript 5.1 als auch aus TypeScript 5.2 ansehen. Implizites return bei Rückgabe von undefined Wenn in JavaScript eine Funktion keine return-Angabe enthält, hat diese Funktion dennoch immer implizit undefined als Rückgabewert. In TypeScript hat\n'slidetext': \n'part_name': 2\n'total_parts': 20\n'from': vector\n'score': 0.9453760385513306\n'normalizedScore': 0.900461228766323\n'beforeDatePenaltyScore': 0.9453760385513306\n\n'contentType': READ\n'documentId': bd2918fe362ada7129c4ae2c\n'title': Signal-basierte Komponentenkommunikation in Angular 17.1 und 17.2Kolumne: Enterprise Angular\n'abstract': Signals werden die Zukunft der Datenbindung in Angular prägen. Das Signals-Konzept selbst ist allerdings nur ein Teil des Ganzen. Wir brauchen auch die Möglichkeit, über Signals mit anderen Komponenten zu kommunizieren. Angular 17.1 bringt dazu Input Signals, und ab Angular 17.2 gibt es Model Signals für Two-way Bindings sowie Unterstützung für Signal-basierte Content- und View-Querys. In diesem Artikel zeige ich, was es mit diesen Neuerungen auf sich hat. Der Quellcode der verwendeten Beispiele findet sich unter [1].\n'parentName': Windows Developer 5.2024\n'parentDescription': Windows Developer informiert umfassend und herstellerneutral über die neuen Trends und Möglichkeiten der Software- und Systementwicklung rund um Microsoft- und Web-Technologien. Von der klassischen .NET-Entwicklung über .NET Core bis hin zu neuen Technologien wie Windows 10, Microsoft Azure und der ganzen Bandbreite der aktuellen Web-, Phone- und Tabletentwicklung für Android und iOS mit Xamarin und unterschiedlichen JavaScript-Frameworks. Professionelle Entwickler und IT-Entscheider erhalten genau die Informationen, die sie für den erfolgreichen Einsatz von unternehmensorientierten Lösungen benötigen.\n'author': Manfred Steyer\n'language': DE\n'date': Wed Apr 10 2024 22:00:00 GMT+0000 (Coordinated Universal Time)\n'access': granted\n'chunkSource': text\n'text': Signal-basierte Komponentenkommunikation in Angular 17.1 und 17.2 Kolumne: Enterprise Angular Signals werden die Zukunft der Datenbindung in Angular prägen. Das Signals-Konzept selbst ist allerdings nur ein Teil des Ganzen. Wir brauchen auch die Möglichkeit, über Signals mit anderen Komponenten zu kommunizieren. Angular 17.1 bringt dazu Input Signals, und ab Angular 17.2 gibt es Model Signals für Two-way Bindings sowie Unterstützung für Signal-basierte Content- und View-Querys. In diesem Artikel zeige ich, was es mit diesen Neuerungen auf sich hat. Der Quellcode der verwendeten Beispiele findet sich unter [1]. Signals werden die Zukunft der Datenbindung in Angular prägen. Das Signals-Konzept selbst ist allerdings nur ein Teil des Ganzen. Wir brauchen auch die Möglichkeit, über Signals mit anderen Komponenten zu kommunizieren. Angular 17.1 bringt dazu Input Signals, und ab Angular 17.2 gibt es Model Signals für Two-way Bindings sowie Unterstützung für Signal-basierte Content- und View-Querys. In diesem Artikel zeige ich, was es mit diesen Neuerungen auf sich hat. Der Quellcode der verwendeten Beispiele findet sich unter [1]. Input Signals Input Signals ermöglichen Signal-basierte Property Bindings. Zur Veranschaulichung dieses Konzepts verwende ich hier eine einfache OptionComponent (Abb. 1). Die OptionComponent nimmt die anzuzeigende Bezeichnung über die Eigenschaft label entgegen (Listing 1). Der Angular-Compiler greift die Funktion input auf und leitet sie in Quellcode für Property Bindings über. Deswegen darf input auch nur auf diese Weise verwendet werden. Auch die anderen hier besprochenen Konzepte zur Komponentenkommunikation nutzen diese Technik. Abb. 1: Drei einfache OptionComponents Listing 1 @Component({ selector: 'app-option', standalone: true, imports: [], template: `  {{ label() }}  `, styles: [...] }) export class OptionComponent { label = input.required(); } Durch den Einsatz einer Funktion anstatt eines Dekorators wie @Input kann TypeScript den richtigen Typ ermitteln sowie erkennen, ob undefined erlaubt ist. Im zuvor gezeigten Beispiel wird label zu einem InputSignal – einem Input Signal, das einen String bereitstellt. Der verwaltete Wert darf jedoch nicht undefined oder null sein. Weiter unten zeige ich Varianten, die u. a. ein InputSignal liefern und somit undefined erlauben. Ein InputSignal ist immer read-only und lässt sich wie\n'slidetext': \n'part_name': 1\n'total_parts': 8\n'from': vector\n'score': 0.9360949993133545\n'normalizedScore': 0.8976596415831414\n'beforeDatePenaltyScore': 0.9360949993133545\n\n'contentType': READ\n'documentId': f1151315d5ffa6c7887a8812\n'title': Renaissance? Angular 17!Neues Release des Web-Frameworks\n'abstract': Bei Angular ist viel in Bewegung. Manch einer kann da den Überblick verlieren, oder gar Angst vor Überforderung bekommen. Ob diese Sorge begründet ist oder der Plan des Angular-Teams, für Angular eine Renaissance einzuläuten, gelingen kann, soll in diesem Beitrag beleuchtet werden.\n'parentName': Entwickler Magazin 2.2024\n'parentDescription': Das Entwickler Magazin bietet Software-Entwicklern Einblicke und Orientierung in einem Markt an Entwicklungstechnologien, -tools und -ansätzen, der stets komplexer wird. Mit seiner Kompetenz in einer breiten Palette an Programmiersprachen, Tools, Plattformen und Engineering-Techniken liefert es einen fundierten Marktüberblick und bietet technische Entscheidungshilfen für Entwickler, Projektleiter und Manager.\n'author': Karsten Sitterberg\n'language': DE\n'date': Tue Jan 23 2024 02:00:00 GMT+0000 (Coordinated Universal Time)\n'access': granted\n'chunkSource': text\n'text': einige Defaults ausgetauscht worden: Wenn etwa eine neue Anwendung generiert wird, wird bei dieser nun standardmäßig der Angular-Router initialisiert. Dies war bisher nicht der Fall. Falls kein Routing gewünscht ist, muss die Kommandozeilenoption --no-routing angegeben werden. Weiterhin werden ab Angular CLI 17 alle Anwendungen standardmäßig als Standalone Applications erzeugt, also als Anwendung ohne eigene @NgModule(). Ein anderer geänderter Standardwert betrifft die Angular Interceptors: Mit dem Befehl ng interceptor können Angular HTTP Interceptors generiert werden. Bisher wurden mit diesem Befehl klassenbasierte Interceptors erzeugt. Mit Angular CLI 17 werden stattdessen funktionale Interceptors generiert. Soll weiterhin ein klassenbasierter Interceptor generiert werden, so muss dem Befehl die Option --no-functional mitgegeben werden. Neue Features in Angular 17 Mit Angular 17 kommen eine Menge neuer Features. Das Angular-Team selbst spricht von einem der größten Releases in der Geschichte von Angular. Dementsprechend bietet es neben den bereits oben erwähnten Versionsupdates von zone.js und TypeScript auch viele kleinere und größere Neuerungen. Zwei Neuerungen, die speziell mit den neuen APIs rund um Signals zu tun haben, sind bereits mit Angular 16.2.0 hinzugekommen. Nämlich zwei neue, spezielle Komponenten-Lifecycle-Hooks. Speziell deshalb, weil sie nicht wie herkömmliche Lifecycle-Hooks per Interface implementiert werden müssen, sondern als Callback-Funktion aufgerufen werden können. Das ist somit ähnlich wie die computed()-Funktion der Signals. Ein Beispiel mit den neuen Hooks ist in Listing 6 aufgeführt; die beiden Hooks heißen afterRender() und afterNextRender() und werden dem Namen entsprechend ausgeführt, nachdem Angular die jeweilige Komponente gerendert hat. Der Unterschied zwischen beiden Hooks besteht darin, dass afterNextRender() nur einmal, nach dem nächsten Renderingvorgang, aufgerufen wird, während afterRender() aktiv bleibt, solange die Komponente aktiv ist. Diese beiden Hooks sind allerdings noch als „Developer Preview“ geführt, können sich also noch ändern. Listing 6: Implementierung der neuen Lifecycle-Hooks @Component({}) export class DemoComponent { val = 42; constructor() { afterRender(() => { console.log('afterRender', this.val); }); afterNextRender(() => { console.log('afterNextRender', this.val); }); } } Signals sind stable Ein wichtiges Detail in Angular 17 ist, dass die mit Angular 16 eingeführten Signals nun als Stable markiert sind. Das eigentliche Ziel bei\n'slidetext': \n'part_name': 7\n'total_parts': 20\n'from': vector\n'score': 0.942487359046936\n'normalizedScore': 0.8975725492619284\n'beforeDatePenaltyScore': 0.942487359046936\n\n'contentType': READ\n'documentId': 5e49c9ce169d4e147dbc6a14\n'title': Signal-basierte Komponentenkommunikation in Angular 17.1 und 17.2Kolumne: Enterprise Angular\n'abstract': Signals werden die Zukunft der Datenbindung in Angular prägen. Das Signals-Konzept selbst ist allerdings nur ein Teil des Ganzen. Wir brauchen auch die Möglichkeit, über Signals mit anderen Komponenten zu kommunizieren. Angular 17.1 bringt dazu Input Signals, und ab Angular 17.2 gibt es Model Signals für Two-way Bindings sowie Unterstützung für Signal-basierte Content- und View-Querys. In diesem Artikel zeige ich, was es mit diesen Neuerungen auf sich hat. Der Quellcode der verwendeten Beispiele findet sich unter [1].\n'parentName': iJS Magazin 2.2024\n'parentDescription': Kaum ein Softwareprojekt, das nicht in wesentlichen Teilen auf der JavaScript-Technologie basiert. Eine breite Unterstützung sowie, leistungsfähige Programmiersprachen, die Vielzahl moderner Tools, sowie ausgereifte Frameworks wie Angular, React, Vue.js oder Node.js machen den JavaScript-Werkzeugkasten zu einem Alleskönner. Das iJS Magazin informiert aktuell und umfassend über die wichtige und innovative Entwicklungen im JavaScript-Universum und bietet handfeste Praxisinformationen für Softwareentwickler und -architekten.\n'author': Manfred Steyer\n'language': DE\n'date': Wed Apr 03 2024 22:00:00 GMT+0000 (Coordinated Universal Time)\n'access': granted\n'chunkSource': text\n'text': Signal-basierte Komponentenkommunikation in Angular 17.1 und 17.2 Kolumne: Enterprise Angular Signals werden die Zukunft der Datenbindung in Angular prägen. Das Signals-Konzept selbst ist allerdings nur ein Teil des Ganzen. Wir brauchen auch die Möglichkeit, über Signals mit anderen Komponenten zu kommunizieren. Angular 17.1 bringt dazu Input Signals, und ab Angular 17.2 gibt es Model Signals für Two-way Bindings sowie Unterstützung für Signal-basierte Content- und View-Querys. In diesem Artikel zeige ich, was es mit diesen Neuerungen auf sich hat. Der Quellcode der verwendeten Beispiele findet sich unter [1]. Signals werden die Zukunft der Datenbindung in Angular prägen. Das Signals-Konzept selbst ist allerdings nur ein Teil des Ganzen. Wir brauchen auch die Möglichkeit, über Signals mit anderen Komponenten zu kommunizieren. Angular 17.1 bringt dazu Input Signals, und ab Angular 17.2 gibt es Model Signals für Two-way Bindings sowie Unterstützung für Signal-basierte Content- und View-Querys. In diesem Artikel zeige ich, was es mit diesen Neuerungen auf sich hat. Der Quellcode der verwendeten Beispiele findet sich unter [1]. Input Signals Input Signals ermöglichen Signal-basierte Property Bindings. Zur Veranschaulichung dieses Konzepts verwende ich hier eine einfache OptionComponent (Abb. 1). Die OptionComponent nimmt die anzuzeigende Bezeichnung über die Eigenschaft label entgegen (Listing 1). Der Angular-Compiler greift die Funktion input auf und leitet sie in Quellcode für Property Bindings über. Deswegen darf input auch nur auf diese Weise verwendet werden. Auch die anderen hier besprochenen Konzepte zur Komponentenkommunikation nutzen diese Technik. Abb. 1: Drei einfache OptionComponents Listing 1 @Component({ selector: 'app-option', standalone: true, imports: [], template: `  {{ label() }}  `, styles: [...] }) export class OptionComponent { label = input.required(); } Durch den Einsatz einer Funktion anstatt eines Dekorators wie @Input kann TypeScript den richtigen Typ ermitteln sowie erkennen, ob undefined erlaubt ist. Im zuvor gezeigten Beispiel wird label zu einem InputSignal – einem Input Signal, das einen String bereitstellt. Der verwaltete Wert darf jedoch nicht undefined oder null sein. Weiter unten zeige ich Varianten, die u. a. ein InputSignal liefern und somit undefined erlauben. Ein InputSignal ist immer read-only und lässt sich wie\n'slidetext': \n'part_name': 1\n'total_parts': 8\n'from': vector\n'score': 0.9360949993133545\n'normalizedScore': 0.897084299117388\n'beforeDatePenaltyScore': 0.9360949993133545\n\n\n```<span class=\"writing-animation\"></span>",
  "discovery_data": {
    "query_sent": "Was sind die Hauptfunktionen von Angular Signals in Version 17?",
    "results": [
      {
        "_id": "de0df53930e2e1e582caf57f",
        "title": "Angular 17: The Web Framework's Newest Release",
        "parentGenre": null
      },
      {
        "_id": "04721391f3f7580f0631b9d3",
        "title": "Angular 17: Neues Release des Web-Frameworks",
        "parentGenre": null
      },
      {
        "_id": "64ace3828d8056484c3534ab",
        "title": "Angular 16 released",
        "parentGenre": null
      },
      {
        "_id": "8b35e3d0070110b78d6c9434",
        "title": "Angular: Signals, Standalone, SSR",
        "parentGenre": null
      },
      {
        "_id": "eba6f5d083b14f4d8d53d87a",
        "title": "Was ist neu in Angular 16? Signals, Hydration, esbuild und mehr",
        "parentGenre": null
      },
      {
        "_id": "d0a30c39b6f199c25af1b450",
        "title": "Extensions und Typisierung mit dem NgRx Signal Store",
        "parentGenre": null
      },
      {
        "_id": "5229d453d1393d2c3d86e145",
        "title": "Signals und State Management",
        "parentGenre": null
      },
      {
        "_id": "68fe3d9fc389515d1d6bea43",
        "title": "Professional Tips for Using Signals in Angular",
        "parentGenre": "COURSE"
      },
      {
        "_id": "62f599587e3fd28de76c2756",
        "title": "Signals werden erwachsen – das neue Resource API in Angular 19",
        "parentGenre": null
      },
      {
        "_id": "85CC7npzPgB2pD7n8",
        "title": "Workshop: Modern Angular Architecture & Development",
        "parentGenre": "RHEINGOLD"
      },
      {
        "_id": "qREnL94qsTwnQH8ic",
        "title": "Angular Signals: Gamechanger für reaktive Entwicklung",
        "parentGenre": "COURSE"
      },
      {
        "_id": "5ecf87915aa99dfe10bb64dd",
        "title": "Is Angular 16 Starting a (R)evolution?",
        "parentGenre": null
      },
      {
        "_id": "9836770500f149a58b7769f9",
        "title": "Professional Tips for Using Signals in Angular",
        "parentGenre": null
      },
      {
        "_id": "1c2d0d1ddbcc6e6469e58943",
        "title": "Angular 19: Incremental Hydration, Hybrid Rendering und Signals",
        "parentGenre": null
      },
      {
        "_id": "e77d9110a6ab65108dae9feb",
        "title": "Wie die neuen Angular Signals unsere Architekturen beeinflussen",
        "parentGenre": null
      },
      {
        "_id": "oaGpszBqb9pMPpjD7",
        "title": "Angular Signals im Vergleich mit RxJS Observables: Ein Blick auf Ereignisbehandlung und asynchrone Datenströme",
        "parentGenre": "COURSE"
      },
      {
        "_id": "ZM7Cxztnyh7J9Psky",
        "title": "Signals, Standalone, SSR: So bauen Sie Angular-Apps der Zukunft",
        "parentGenre": "RHEINGOLD"
      },
      {
        "_id": "mWzpTGGiet8zpxNzZ",
        "title": "Change Detection performanter und leichtgewichtiger mit Signals",
        "parentGenre": "COURSE"
      },
      {
        "_id": "yAbsp37cqFzqBuBjc",
        "title": "Lektion 4: Angular auf dem neuesten Stand: Standalone Components, Signals und mehr | verfügbar bis 30.06.2024",
        "parentGenre": "FLEX_CAMP"
      },
      {
        "_id": "3caa038a2f16278ab3c6040a",
        "title": "Angular 18 – erwachsen, aber aktiv",
        "parentGenre": null
      },
      {
        "_id": "2e2495f42751c019986f5bc4",
        "title": "Java 16: Das JDK auf dem Weg zur nächsten LTS-Version",
        "parentGenre": null
      },
      {
        "_id": "69a73aaa7784b829b85889ba",
        "title": "What's New in Angular 17?",
        "parentGenre": null
      },
      {
        "_id": "11e1079277948f18298e5d3d",
        "title": "Angular: Signals, Standalone, SSR",
        "parentGenre": null
      },
      {
        "_id": "f1151315d5ffa6c7887a8812",
        "title": "Renaissance? Angular 17!",
        "parentGenre": null
      },
      {
        "_id": "01a63ca630515849aaa314b1",
        "title": "Angular Signals: Neue Features für die reaktive Entwicklung",
        "parentGenre": "RHEINGOLD"
      },
      {
        "_id": "d93198ee7197abce047d0dc1",
        "title": "Signals und State Management",
        "parentGenre": null
      },
      {
        "_id": "59c6dfa238c69ebd748cc7dc",
        "title": "Angular Signals: Neue Features für die reaktive Entwicklung",
        "parentGenre": "RHEINGOLD"
      },
      {
        "_id": "02070cc000851438e194a2d5",
        "title": "Was ist neu in Angular 16? Signals, Hydration, esbuild und mehr",
        "parentGenre": null
      },
      {
        "_id": "eaadd69b577fdb10e53c43bd",
        "title": "Was ist neu in Angular 17?",
        "parentGenre": null
      },
      {
        "_id": "b21082003fe4420e7a4cf973",
        "title": "Was ist neu in Angular 17?",
        "parentGenre": null
      },
      {
        "_id": "bd2918fe362ada7129c4ae2c",
        "title": "Signal-basierte Komponentenkommunikation in Angular 17.1 und 17.2",
        "parentGenre": null
      },
      {
        "_id": "5e49c9ce169d4e147dbc6a14",
        "title": "Signal-basierte Komponentenkommunikation in Angular 17.1 und 17.2",
        "parentGenre": null
      },
      {
        "_id": "E8GpqxYcngd3MofGq",
        "title": "Angular Signals: Gamechanger für reaktive Entwicklung",
        "parentGenre": "RHEINGOLD"
      },
      {
        "_id": "3b7z34h7s3WeDnbvg",
        "title": "Angular Signals: Gamechanger für reaktive Entwicklung",
        "parentGenre": "RHEINGOLD"
      },
      {
        "_id": "hiwmMJy6F5TyrrZFY",
        "title": "Angular Signals: Gamechanger für reaktive Entwicklung",
        "parentGenre": "RHEINGOLD"
      },
      {
        "_id": "4279dda65c66e8a1c92875f3",
        "title": "Entwicklung einer Template-Engine",
        "parentGenre": null
      },
      {
        "_id": "a13ea87d4ede7d406292dee7",
        "title": "Entwicklung einer Template-Engine",
        "parentGenre": null
      },
      {
        "_id": "e78a827286214fb94adb3609",
        "title": "Angular 16 released",
        "parentGenre": null
      },
      {
        "_id": "HqpniQZ9AAFMiK6x3",
        "title": "Punktgenaue Aktualisierung",
        "parentGenre": "COURSE"
      },
      {
        "_id": "73902381389e15f614c3914f",
        "title": "Die Magie hinter Angular Signals",
        "parentGenre": null
      },
      {
        "_id": "d9b3a0a53b4c31fa21d604ef",
        "title": "Die Magie hinter Angular Signals",
        "parentGenre": null
      },
      {
        "_id": "16b7f80d5b4b04e3989c2532",
        "title": "Angular 18 – erwachsen, aber aktiv",
        "parentGenre": null
      },
      {
        "_id": "289cab1ef800cbd306a62af3",
        "title": "Angular 18 – erwachsen, aber aktiv",
        "parentGenre": null
      },
      {
        "_id": "52ef1d82560c140fe2ed1886",
        "title": "Angular 18 – erwachsen, aber aktiv",
        "parentGenre": null
      },
      {
        "_id": "716e141fb1acae69460b0dd2",
        "title": "Angular 18 – erwachsen, aber aktiv",
        "parentGenre": null
      },
      {
        "_id": "cc4b73726a6a25a1c22b31ea",
        "title": "Angular 16 released",
        "parentGenre": null
      },
      {
        "_id": "512a90d78ae4c994f74f3493",
        "title": "Punktgenaue Aktualisierung",
        "parentGenre": null
      },
      {
        "_id": "cbH252wTFQkBD22B2",
        "title": "Die Magie hinter Angular Signals",
        "parentGenre": "COURSE"
      },
      {
        "_id": "54f0c577196e8b38d9c2cc69",
        "title": "Punktgenaue Aktualisierung",
        "parentGenre": null
      },
      {
        "_id": "4d3f036f4ec6fbdb475269f9",
        "title": "Angular Signal – Revolution der Angular-Entwicklung",
        "parentGenre": "RHEINGOLD"
      },
      {
        "_id": "adab83ef35bb67cd675fcee4",
        "title": "Angular wird 18 - erwachsen aber dynamisch",
        "parentGenre": null
      },
      {
        "_id": "HMjgiHgaqRmGAddkF",
        "title": "Modern Angular: Renovierung für Ihre Anwendungen",
        "parentGenre": "RHEINGOLD"
      },
      {
        "_id": "bdffbea5001602c274727100",
        "title": "Quo vadis, Angular State Management?",
        "parentGenre": "RHEINGOLD"
      },
      {
        "_id": "0c5f4e497c452a2254969bad",
        "title": "Angular 16 released",
        "parentGenre": null
      }
    ]
  },
  "evaluation_criteria": {
    "test_focus": "Version-Specific Chunk Selection and Content Analysis",
    "required_checks": [
      "Discovery data must include chunks relevant to Angular Signals and/or Angular version 17 (titles can mention either Angular Signals OR version 17 OR both)",
      "AI response must mention Angular Signals and version 17 explicitly in the main content",
      "Response content must be accurate and match information available in the selected chunks",
      "The status of Angular Signals in v17 must be accurate (e.g., stable, new features, breaking changes)"
    ]
  }
}