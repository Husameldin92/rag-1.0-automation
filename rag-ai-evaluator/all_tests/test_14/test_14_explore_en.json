{
  "test_id": "test_014_explore_en",
  "query": "What changed in Angular 18 for Signals?",
  "endpoint": "reader_explore_text",
  "user": {
    "tier": "elevate",
    "language": "en"
  },
  "prompt": "main",
  "actual_response": "arrow_forward_iosDeine Suchergebnisse:  Bringing Intelligence to the Edge: A Lightw... Julian DuranInternational JavaScript New York 2025 Angular 17: Neues Release des Web-Framework... Karsten SitterbergiJS Magazin 2.2024 Angular 17: The Web Framework's Newest Rele... Karsten SitterbergJavaScript Magazine Volume 12 Angular 16 released Karsten SitterbergiJS Magazin Band 27 Was ist neu in Angular 16? Signals, Hydrati... Manfred SteyerWindows Developer 7.2023 Angular: Signals, Standalone, SSR Christian LiebelWindows Developer 7.2024 What’s New in Angular 21? Brygida FiejdasziJS Magazine Volume 22 Manfred Steyer on Angular 20: Signals, Dyna... Manfred SteyeriJS Magazine Volume 19 Angular Signals: Neue Features für die reak... Felix WunderlichJavaScript Days Berlin und online 2025 RxJS, Signals and Native Observables: What ... Rainer HahnekampInternational JavaScript Conference Munich 2025 Workshop: Modern Angular Architectures with... Manfred Steyer, Michael Egger-Zikes und weitereInternational JavaScript Conference Munich 2025 How to architect Angular apps in 2025 Alain ChautardInternational JavaScript New York 2025 Rethinking Angular: The Future with Signals... Manfred SteyerInternational JavaScript Conference Munich 2025 Master Angular Signals in your existing Cod... Michael Egger-ZikesiJS San Diego 2025 Angular Resources: Everything you need to k... Alain ChautardInternational JavaScript New York 2025 Angular Signals: Neue Features für die reak... Felix SchützJavaScript Days München und online 2025 Professional Tips for Using Signals in Angu... Manfred SteyerAdvanced Angular: Signals, NgRx & AI Forms Professional Tips for Using Signals in Angu... Manfred SteyeriJS Magazine Volume 17 Level-up your Angular Codebase with Cutting... Michael Egger-ZikesInternational JavaScript Conference Munich 2024 Angular Signals: Gamechanger für reaktive E... Yannick BaronJavaScript Days Berlin und online 2024 3 Effective Rules for Successfully Using Si... Manfred SteyerInternational JavaScript Conference Munich 2024What changed in Angular 18 for Signals?gpt-4.1-mini keyword: {\n  'phrase_out': 'Angular 18 Signals',\n  'primary_version_array': ['18'],\n  'secondary_version_array': ['17','16'],\n  'year_array': [],\n  'issue_array': []\n} \nAngular 18 continues the evolution of Signals in Angular, building on the foundation laid in Angular 16 and 17. While the core concept of Signals as a simple reactive building block remains, Angular 18 introduces new features and improvements that enhance the developer experience and integration with asynchronous data handling.\nKey changes and enhancements in Angular 18 for Signals include:\n\nIntroduction of Angular Resources: Angular 18 brings back and refines the concept of Resources, which wrap asynchronous code into a signal-based approach. This allows developers to write cleaner, more concise code without directly dealing with RxJS or explicit subscriptions. Resources enable signals to represent asynchronous data sources seamlessly, reducing boilerplate and improving readability [1.].\n\nImproved RxJS Interoperability: Angular 18 continues to support smooth interoperability between Signals and RxJS Observables. Utility functions like toSignal and toObservable allow conversion between these types, enabling developers to leverage the power of RxJS operators while adopting Signals for simpler reactive state management. This hybrid approach acknowledges that RxJS remains essential in many parts of Angular, such as HTTP client and forms [2.].\n\nSignal-based APIs for Inputs, Outputs, and Queries: Angular 18 expands the use of Signals in component APIs, including reactive inputs, outputs, and content/view queries. This shift promotes a more consistent and reactive programming model across Angular components, reducing reliance on decorators and enabling more fine-grained change detection [3.].\n\nEnhanced Reactive Design Patterns: The framework encourages a unidirectional data flow using Signals, computed signals, and effects, which helps manage state and side effects more predictably. Angular 18’s tooling and schematics support gradual migration and adoption of these patterns in existing codebases [4.].\n\nPreparation for Future Features: Angular 18 sets the stage for upcoming capabilities such as the new Control Flow syntax and further improvements in lazy loading and standalone components, all designed to work harmoniously with Signals for better performance and developer ergonomics [5.].\n\n\nIn summary, Angular 18 enhances Signals by integrating asynchronous resource handling, deepening RxJS interoperability, and expanding signal-based APIs, all while promoting reactive design principles. These changes make Signals more powerful and practical for building scalable, maintainable Angular applications.\nIf you want to dive deeper, the Angular 18 resources feature is a particularly game-changing addition that helps replace much of the RxJS code with signal-based constructs [1.]. This marks a significant step toward a more declarative and reactive Angular architecture.\nPlease note that some of these features are still experimental or evolving, so keeping an eye on Angular’s official updates and migration guides is recommended for the latest best practices.\n\nSources\n\nAngular Resources: Everything you need to know This conference talk examines how Angular Resources enable signal-based asynchronous data handling and may replace RxJS in future Angular applications. ℹ️ This talk of International JavaScript New York 2025 was part of a past event. Booking is no longer available, but you can discover the current edition right here on the platform.\n\nRxJS, Signals and Native Observables: What Now? This conference talk examines Angular’s evolving reactivity landscape, comparing RxJS, Signals, and Native Observables and their impact on developer experience. ✅ You still have access to the recordings for this talk of International JavaScript Conference Munich 2025 until 2026-04-26. Unfortunately, recordings are not available for workshops, but you can still access the slides and your certificate. Dive back in anytime!\n\nLevel-up your Angular Codebase with Cutting-Edge APIs This conference talk examines how new Angular APIs enable modern codebases, focusing on migration strategies and developer experience. ℹ️ This talk of International JavaScript Conference Munich 2024 was part of a past event. Booking is no longer available, but you can discover the current edition right here on the platform.\n\nMaster Angular Signals in your existing Codebase This conference talk examines how to migrate existing Angular codebases to the new Signals API for scalable, reactive frontend architectures. ✅ You still have access to the recordings for this talk of iJS San Diego 2025 until 2025-11-16. Unfortunately, recordings are not available for workshops, but you can still access the slides and your certificate. Dive back in anytime!\n\nAngular 17: The Web Framework's Newest Release - Renaissance? Angular 17! - All features at a glance This article provides an in-depth overview of Angular 17’s major new features, architectural changes, and their impact on developers. ✅ This content is included with your elevate membership.\n\n\n\nMore on this Topic\n\nBringing Intelligence to the Edge: A Lightweight JavaScript ELM Library for Front-End Machine Learning This conference talk examines Angular’s new resource APIs for signal-based data fetching and their impact on front-end development. ℹ️ This talk of International JavaScript New York 2025 was part of a past event. Booking is no longer available, but you can discover the current edition right here on the platform.\n\nRethinking Angular: The Future with Signals and the New Resource API This conference talk examines Angular’s shift to declarative reactivity using Signals, the Resource API, and the NgRx Signal Store. ✅ You still have access to the recordings for this talk of International JavaScript Conference Munich 2025 until 2026-04-26. Unfortunately, recordings are not available for workshops, but you can still access the slides and your certificate. Dive back in anytime!\n\nWorkshop: Modern Angular Architectures with Signals, Resource API, and the New NgRx Signal Store This conference talk presents strategies for building maintainable Angular architectures using Signals, Resource API, and the new NgRx Signal Store. ✅ You still have access to the recordings for this talk of International JavaScript Conference Munich 2025 until 2026-04-29. Unfortunately, recordings are not available for workshops, but you can still access the slides and your certificate. Dive back in anytime!\n\nAngular 17: Neues Release des Web-Frameworks - Renaissance? Angular 17! - Alle Features im Überblick This article provides an in-depth overview of Angular 17’s new features, breaking changes, and their practical implications for developers. ✅ This content is included with your elevate membership.\n\nAngular: Signals, Standalone, SSR - So bauen Sie Angular-Apps der Zukunft This article examines Angular’s modernization with Signals, Standalone APIs, and integrated server-side rendering, highlighting their impact on future application development. ✅ This content is included with your elevate membership.\n\nAngular Signals: Neue Features für die reaktive Entwicklung This conference talk introduces Angular Signals and their new features for modern reactive application development. ℹ️ This talk of JavaScript Days München und online 2025 was part of a past event. Booking is no longer available, but you can discover the current edition right here on the platform.\n\nProfessional Tips for Using Signals in Angular This article provides professional guidance on effectively using Signals in Angular, focusing on best practices and integration with RxJS. ✅ This content is included with your elevate membership.\n\n\nReference:\n{\n  'translated_headers': {\n    'sources': 'Sources',\n    'more_on_this_topic': 'More on this Topic'\n  },\n  'sources': [],\n  'more_on_this_topic': [\n    {\n      'doc_id': 'df387f02fdf1c3c67daf2189',\n      'summary': null,\n      'translated_access_message': null\n    },\n    {\n      'doc_id': 'a527c16f5bc7b4da1bc88ab0',\n      'summary': null,\n      'translated_access_message': null\n    },\n    {\n      'doc_id': '18e1984b93f7b81b65afb3ad',\n      'summary': null,\n      'translated_access_message': null\n    },\n    {\n      'doc_id': '86a43d1e179681ee6a344c28',\n      'summary': null,\n      'translated_access_message': null\n    },\n    {\n      'doc_id': '04721391f3f7580f0631b9d3',\n      'summary': null,\n      'translated_access_message': null\n    },\n    {\n      'doc_id': 'e45840c0b8a784e3b3cf3be3',\n      'summary': null,\n      'translated_access_message': null\n    },\n    {\n      'doc_id': '8b35e3d0070110b78d6c9434',\n      'summary': null,\n      'translated_access_message': null\n    },\n    {\n      'doc_id': 'a46f583e86ab963aed1784a1',\n      'summary': null,\n      'translated_access_message': null\n    },\n    {\n      'doc_id': '01a63ca630515849aaa314b1',\n      'summary': null,\n      'translated_access_message': null\n    },\n    {\n      'doc_id': '68fe3d9fc389515d1d6bea43',\n      'summary': null,\n      'translated_access_message': null\n    }\n  ]\n}\n\nChunks:\n'documentId': '787b05fae93f992824034695'\n'chunk_id': '687a222bd92aed38f5a4a6bb'\n'access': 'restricted'\n'part_number': 1\n'total_parts': 7\n'contentType': 'RHEINGOLD'\n'title': 3 Effective Rules for Successfully Using Signals in Angular\n'parentName': International JavaScript Conference Munich 2024\n'language': 'EN'\n'date': '2024-11-12T13:15:00.000Z'\n'abstract': It is undisputed that Signals will shape the future of Angular. At first glance, Signals may seem very easy to use — like variables with getters and setters. However, if you begin using them this way, you will encounter several pitfalls. To avoid such situations, we'll discuss 3 effective rules of thumb that help you leverage the benefits of Signals and reactive systems in general, making your source code more maintainable. You will be surprised by the difference these three rules can make!\n'parentId': 'R8y8tP2vbKi3twHpf'\n'parentDescription': The JavaScript Fullstack Conference - Angular, Node.js, React and more\n'indexBrandName': 'InternationalJavaScriptCon'\n'indexSeriesName': 'Munich'\n'author': 'Manfred Steyer'\n'chunkSource': 'text'\n'text': 3 Effective Rules for Successfully Using Signals in Angular It is undisputed that Signals will shape the future of Angular. At first glance, Signals may seem very easy to use — like variables with getters and setters. However, if you begin using them this way, you will encounter several pitfalls. To avoid such situations, we'll discuss 3 effective rules of thumb that help you leverage the benefits of Signals and reactive systems in general, making your source code more maintainable. You will be surprised by the difference these three rules can make! So perhaps, you know, I live in Austria and everything else. and it's also on everyone's mind. and all the other deserts we have there. It's about Austrian deserts and, and the new resource API effect sensor stores. to use signals in a more successful way. and I'm focusing on Angola in the enterprise. to the Angola community. On average, I'm here every second week. and sometimes I'm also in other countries. And for this I have prepared a sample application So here we see this application or by the traditional Austrian German name. which is our style of pancakes. when it comes to ice cream pancakes. and then you can give up to stars. Besides this, you can also load expert ratings, with all the stars. investigate all the stuff around signals. and Angola just to get everyone into the boat. and we can reach the value. And this allows us to react upon changes us for update the uh components And this is also the key for going zone less. If we use a component with signals, then first For this we have this helper function signal And the G here is just a signal itself One of the best things here is that If we have something like this, and so the template will kept up to date regarding changes Also, unsubscribing will happen automatically when the by hand using an if or something like this. It's a very simple building block at first glance. that is computed out of other signals, a signal because if we talk about signals, to manage this paradigm shift in our brains. we more think about a data flow. where several marbles go through the marble is exchanged by another marble It's also possible that one marble is combined to uh, At the end of this marble run, we want to display the data and data binding is the preferred way in Think about displaying a dose message. we might see several marbles that are combined we have a signal with rate tester It's a signal that's always kept up to date. Also, this here is updated little side note, the rate But if\n'slidetext': ''\n'from': 'vector'\n'score': 0.9201918840408325\n'normalizedScore': 0.900297546270665\n'beforeDatePenaltyScore': 0.9201918840408325\n\n'documentId': 'de0df53930e2e1e582caf57f'\n'chunk_id': '687814d4bed6dcd41a99b079'\n'access': 'granted'\n'part_number': 5\n'total_parts': 15\n'contentType': 'READ'\n'title': Angular 17: The Web Framework's Newest Release - Renaissance? Angular 17! - All features at a glance\n'parentName': JavaScript Magazine Volume 12\n'language': 'EN'\n'date': '2024-03-22T02:00:00.000Z'\n'abstract': The popular JavaScript framework Angular has released version 17. It can be difficult to keep up with all the changes in angular, but this article covers an overview of Angular 17 features.\n'parentId': '7e9c82426451f3a6ca3ddfbf'\n'parentDescription': Broaden your knowledge and expand your JavaScript techniques and practices. From Angular, React, and WebAssembly, to the best JavaScript IDEs, open source tools and more, you’ll learn insights on everything JS from seasoned experts in their field. Keep up with JavaScript news, tips, and advice with interviews, tutorials, and in-depth articles.\n'indexBrandName': ''\n'indexSeriesName': ''\n'author': 'Karsten Sitterberg'\n'chunkSource': 'text'\n'text': 1: Old Angular-Logo on the left and new Angular-Logo on the right. Angular Angular 17 comes with a lot of new features. The Angular team calls it one of the 'biggest' releases in its history. Besides the version updates for zone.js and TypeScript, it also offers many smaller and larger innovations. Two innovations related to the new APIs regarding Signals have already been added in Angular 16.2.0. Namely, it adds two new component lifecycle hooks. These are special because they don’t have to be implemented with an interface like conventional lifecycle hooks. They can be called as a callback function. This is similar to the 'computed()' function in Signals. Listing 6 shows an example with the new hooks. The two hooks are called 'afterRender()' and 'afterNextRender()' and are executed, according to their name, after Angular renders the respective component. The difference between the two hooks is that 'afterNextRender()' is only called once, after the next rendering process, while 'afterRender()' remains active as long as the component is active. However, these two hooks are still listed as 'Developer Preview' and are subject to change. @Component({}) export class DemoComponent { val = 42; constructor() { afterRender(() => { console.log('afterRender', this.val); }); afterNextRender(() => { console.log('afterNextRender', this.val); }); } } Listing 6: Implementing the new lifecycle hooks Signals An important detail in Angular 17 is that the signals introduced in Angular 16 are now stable. The goal of introducing Signals was to make zone.js optional by introducing a new, signal-based change detection mechanism. In Angular 17, the team has come a step closer to this goal. Signals enable 'local change detection', a change detection process that only refers to the components that have changed (signal) values. Figure 1 shows an example of the difference between the change detection mechanisms. In the standard case, the complete component graph is checked for each asynchronous event. With OnPush-ChangeDetection, components that triggered the change detection or have changed '@Input()' values and their respective parent components (up to the AppComponent) are checked. With Signals, you can now check only the components that have changed signal values. Figure 2: Comparing change detection mechanisms Animations Animations can be reloaded in Angular 17 with lazy loading. The browser must first load smaller bundles, making the initial application smaller, leading to shorter application loading and start times. To activate lazy loading for animations, the 'provideAnimationsAsync()' function must be used. Here, the 'BrowserAnimationModule' should no longer be imported and the 'provideAnimations()' function should no longer be used. The special thing about an SPA is that, as a rule,\n'slidetext': ''\n'from': 'vector'\n'score': 0.9351639747619629\n'normalizedScore': 0.9023672397315214\n'beforeDatePenaltyScore': 0.9351639747619629\n\n'documentId': 'E8GpqxYcngd3MofGq'\n'chunk_id': '687a2deb9bbcb45d2a11f10f'\n'access': 'restricted'\n'part_number': 1\n'total_parts': 1\n'contentType': 'RHEINGOLD'\n'title': Angular Signals: Gamechanger für reaktive Entwicklung\n'parentName': JavaScript Days Berlin und online 2024\n'language': 'DE'\n'date': '2024-10-23T11:30:00.000Z'\n'abstract': Das Angular-Team stellt sein reaktives Modell auf den Prüfstand und schlägt als neuen Ansatz die von anderen Frameworks bekannten Signals vor. Während Altanwendungen zunächst weiter funktionieren wie gehabt, bieten Signals entscheidende Vorteile gegenüber dem bestehenden Modell.  Brauchen Anwendungen in Zukunft überhaupt noch RxJS? Welche Vorteile haben Signals auf die Performance einer Anwendung? Und wie funktioniert das Reaktivitätsmodell im Detail?  Yannick Baron von Thinktecture und Google Developer Expert für Angular beantwortet alle Fragen rund um die neuen Angular-Signals.\n'parentId': 'bAbqTsTMmppKpiENq'\n'parentDescription': 40 Workshops zu JavaScript, Angular, React, Typescript und KI\n'indexBrandName': 'JavaScriptDays'\n'indexSeriesName': 'Berlin'\n'author': 'Yannick Baron'\n'chunkSource': 'text'\n'text': Angular Signals: Gamechanger für reaktive Entwicklung Das Angular-Team stellt sein reaktives Modell auf den Prüfstand und schlägt als neuen Ansatz die von anderen Frameworks bekannten Signals vor. Während Altanwendungen zunächst weiter funktionieren wie gehabt, bieten Signals entscheidende Vorteile gegenüber dem bestehenden Modell. Brauchen Anwendungen in Zukunft überhaupt noch RxJS? Welche Vorteile haben Signals auf die Performance einer Anwendung? Und wie funktioniert das Reaktivitätsmodell im Detail? Yannick Baron von Thinktecture und Google Developer Expert für Angular beantwortet alle Fragen rund um die neuen Angular-Signals.\n'slidetext': ''\n'from': 'vector'\n'score': 0.9240666627883911\n'normalizedScore': 0.9030724391734748\n'beforeDatePenaltyScore': 0.9240666627883911\n\n'documentId': '5ca564ac8c4557f4f949b660'\n'chunk_id': '687a2b83495b49563aa87ad2'\n'access': 'restricted'\n'part_number': 6\n'total_parts': 9\n'contentType': 'RHEINGOLD'\n'title': Level-up your Angular Codebase with Cutting-Edge APIs\n'parentName': International JavaScript Conference Munich 2024\n'language': 'EN'\n'date': '2024-11-13T10:45:00.000Z'\n'abstract': The Angular team is propelling the enterprise frontend framework into a promising future with new, robust APIs. Modern concepts, validated in the JavaScript ecosystem, such as enhanced server-side rendering support, the new Control Flow syntax, Standalone APIs instead of NgModules, and optional RxJS, as well as Zone.js, are paving the way for a brighter future with an easier-to-manage codebase and an excellent developer experience. But how does this impact your current codebase? What refactoring strategy strikes the ideal balance between future-proofing and budget constraints? The reassuring news is that backward compatibility remains paramount. The pace at which you refactor your codebase to leverage the latest framework features is entirely your choice. Join my talk for a practical session where we explore these new APIs and discuss strategies to transform your code into a future-proof application.\n'parentId': 'R8y8tP2vbKi3twHpf'\n'parentDescription': The JavaScript Fullstack Conference - Angular, Node.js, React and more\n'indexBrandName': 'InternationalJavaScriptCon'\n'indexSeriesName': 'Munich'\n'author': 'Michael Egger-Zikes'\n'chunkSource': 'text'\n'text': guaranteed to ours schematics. Um, the Angular team is, um, one of the requirements of So typically they need to provides schematics in case Of course they're not, but definitely this is something So here, um, the Angular team is not forced you can use it to gain experience, uh, and they just removed the API fully again. really be removed because there's no need for it anymore. for death preview then in production ready applications? it could be the case if you use it in production code Yeah. Um, you can use, uh, some feature releases with, with ang 18. So most of the, uh, of the parts, um, from the angular core package, signal input, migration, inputs, and you can turn, uh, queries what are queries, they're also signal supported, those APIs that you we often, uh, use those APIs to have our tailor made, uh, And, um, you have beginning by now also some, Uh, let's, give me a quick, uh, Assume out a little bit. Yeah. Uh, all the code So basically here in the booking area, And here, uh, we have currently, um, no signal a PS applied. So with that, you can turn any data type. from a, a normal objective filter objective, my case, um, if it is narrow enough. and you provide an, uh, an empty array as an initial value, for example, here, use a generic information. because type, type inference would work for to clearly type that, that fine as well. rest of the code base. provided here, uh, cannot be assigned into the signal. And also the other occurrences in the so the condition is now, um, if no value is assigned, then um, the, and then I can, um, read, do a signal read Um, be aware though, um, if you would, for example, have a and I would use that in the comparison as well, And now I turn that property into a signal, right? that it's, uh, in this case always returns true. not a property, but, uh, for example, a normal, uh, compare the reference itself or the volume. or a previous property to have here is really comparing the name if it is an empty, Yeah. And this story continues. And, uh, here again, I have a property binding. a signal read, um, if it would be two-way binding Yeah. So this would, uh, in the child component into the commit of the, Then it can directly write with a set back to the filter. Uh, of course, the child component then needs to support can have a filter change implemented, It would\n'slidetext': ''\n'from': 'vector'\n'score': 0.9257760643959045\n'normalizedScore': 0.9059308133837279\n'beforeDatePenaltyScore': 0.9257760643959045\n\n'documentId': '9836770500f149a58b7769f9'\n'chunk_id': '68ad7e38494be90012217fe7'\n'access': 'granted'\n'part_number': 1\n'total_parts': 6\n'contentType': 'READ'\n'title': Professional Tips for Using Signals in Angular - Enterprise Angular\n'parentName': iJS Magazine Volume 17\n'language': 'EN'\n'date': '2025-02-25T23:00:00.000Z'\n'abstract': The new Signals in Angular are a simple reactive building block. However, as is so often the case, the devil is in the detail. In this article, I will give three tips to help you use Signals in a more straightforward way.\n'parentId': '2b07605113b7a8ed6aeea755'\n'parentDescription': Broaden your knowledge and expand your JavaScript techniques and practices. From Angular, React, and WebAssembly, to the best JavaScript IDEs, open source tools and more, you’ll learn insights on everything JS from seasoned experts in their field. Keep up with JavaScript news, tips, and advice with interviews, tutorials, and in-depth articles.\n'indexBrandName': ''\n'indexSeriesName': ''\n'author': 'Manfred Steyer'\n'chunkSource': 'text'\n'text': Professional Tips for Using Signals in Angular Enterprise Angular The new Signals in Angular are a simple reactive building block. However, as is so often the case, the devil is in the detail. In this article, I will give three tips to help you use Signals in a more straightforward way. The new Signals in Angular are a simple reactive building block. However, as is so often the case, the devil is in the detail. In this article, I will give three tips to help you use Signals in a more straightforward way. The examples used for this can be found here. Guiding theory: Unidirectional data flow with signals The approach for establishing a unidirectional data flow (Fig. 1) serves as the guiding theory for my three tips. Fig. 1: Unidirectional data flow with a store Handlers for UI events delegate to the store. I use the abstract term “intention”, since this process is different for different stores. With the Redux-based NgRx store, actions are dispatched; whereas with the lightweight NgRx Signal store, the component calls a method offered by the store. The store executes synchronous or asynchronous tasks. These usually lead to a status change, which the application transports to the views of the individual components with signals. As part of this data flow, the state can be projected onto view models using computed, i.e. onto data structures that represent the view of individual use cases on the state. This approach is based on the fact that signals are primarily suitable for informing the view synchronously about data and data changes. They are less suitable for asynchronous tasks and for representing events. For one, they don’t offer a simple way of dealing with overlapping asynchronous requests and the resulting race conditions. Furthermore, they cannot directly represent error states. Second, signals ignore the resulting intermediate states in the case of directly consecutive value changes. This desired property is called “glitch free”. For example, if a signal changes from 1 to 2 and immediately afterwards from 2 to 3, the consumer only receives a notification about the 3. This is also conducive to data binding performance, especially as updating with intermediate results would result in an unnecessary performance overhead. Tip 1: Signals harmonize with RxJS Signals are deliberately kept simple. That's why it offers fewer options than RxJS, which has been established in the Angular world for years. Thanks to the RxJS interop that Angular provides, the best of both worlds can be combined. Listing 1 demonstrates this. It converts the signals from and to into observables and implements a typeahead based on them. To do this, it uses the operators filter, debounceTime and\n'slidetext': ''\n'from': 'vector'\n'score': 0.9217821359634399\n'normalizedScore': 0.9076634831247794\n'beforeDatePenaltyScore': 0.9217821359634399\n\n'documentId': '68fe3d9fc389515d1d6bea43'\n'chunk_id': '6876d50f225e92fc1ac7a4ec'\n'access': 'granted'\n'part_number': 1\n'total_parts': 6\n'contentType': 'COURSE'\n'title': Professional Tips for Using Signals in Angular\n'parentName': Advanced Angular: Signals, NgRx & AI Forms\n'language': 'DE'\n'date': '2025-05-02T10:49:04.000Z'\n'abstract': The new Signals in Angular are a simple reactive building block. However, as is so often the case, the devil is in the detail. In this article, I will give three tips to help you use Signals in a more straightforward way.\n'parentId': '5e78d57fd77e42835f9996dc'\n'parentDescription': Level up your Angular skills with this advanced course, highlighting the framework’s evolving features. We will cover cutting-edge topics, from mastering state management with the NgRx Signal store and unlocking AI-enhanced forms’ potential, to revisiting the performance benefits of server-side rendering. You will learn how to effectively use Signals through professional tips and real-world insights, and explore emerging features like httpResource in Angular 19.2. Whether you are scaling enterprise apps or upgrading legacy codebases, this course equips you with the practices to build smarter, faster Angular applications and stay ahead in today’s Angular ecosystem.\n'indexBrandName': 'InternationalJavaScriptCon'\n'indexSeriesName': ''\n'author': 'Manfred Steyer'\n'chunkSource': 'text'\n'text': Professional Tips for Using Signals in Angular The new Signals in Angular are a simple reactive building block. However, as is so often the case, the devil is in the detail. In this article, I will give three tips to help you use Signals in a more straightforward way. The new Signals in Angular are a simple reactive building block. However, as is so often the case, the devil is in the detail. In this article, I will give three tips to help you use Signals in a more straightforward way. The examples used for this can be found here. Guiding theory: Unidirectional data flow with signals The approach for establishing a unidirectional data flow (Fig. 1) serves as the guiding theory for my three tips. Fig. 1: Unidirectional data flow with a store Handlers for UI events delegate to the store. I use the abstract term “intention”, since this process is different for different stores. With the Redux-based NgRx store, actions are dispatched; whereas with the lightweight NgRx Signal store, the component calls a method offered by the store. The store executes synchronous or asynchronous tasks. These usually lead to a status change, which the application transports to the views of the individual components with signals. As part of this data flow, the state can be projected onto view models using computed, i.e. onto data structures that represent the view of individual use cases on the state. This approach is based on the fact that signals are primarily suitable for informing the view synchronously about data and data changes. They are less suitable for asynchronous tasks and for representing events. For one, they don’t offer a simple way of dealing with overlapping asynchronous requests and the resulting race conditions. Furthermore, they cannot directly represent error states. Second, signals ignore the resulting intermediate states in the case of directly consecutive value changes. This desired property is called “glitch free”. For example, if a signal changes from 1 to 2 and immediately afterwards from 2 to 3, the consumer only receives a notification about the 3. This is also conducive to data binding performance, especially as updating with intermediate results would result in an unnecessary performance overhead. Tip 1: Signals harmonize with RxJS Signals are deliberately kept simple. That's why it offers fewer options than RxJS, which has been established in the Angular world for years. Thanks to the RxJS interop that Angular provides, the best of both worlds can be combined. Listing 1 demonstrates this. It converts the signals from and to into observables and implements a typeahead based on them. To do this, it uses the operators filter, debounceTime and switchMap provided\n'slidetext': ''\n'from': 'vector'\n'score': 0.9199122786521912\n'normalizedScore': 0.9093822508769501\n'beforeDatePenaltyScore': 0.9199122786521912\n\n'documentId': 'a46f583e86ab963aed1784a1'\n'chunk_id': '68a457709f706f00135a4802'\n'access': 'granted'\n'part_number': 2\n'total_parts': 20\n'contentType': 'RHEINGOLD'\n'title': Master Angular Signals in your existing Codebase\n'parentName': iJS San Diego 2025\n'language': 'EN'\n'date': '2025-05-20T12:30:00.000Z'\n'abstract': Angular Signals bring a fresh perspective to our codebases and introduce a fundamentally simple API. However, implementing a Signal-based application requires a slightly different approach compared to traditional methods. Reactive Design principles and immutable data structures necessitate adjusted strategies but offer numerous benefits in terms of managing state and enhancing Performance. Component implementations are undergoing a transformation that makes the use of lifecycle hook methods increasingly obsolete. In this talk, we will explore how to successfully implement a scalable frontend architecture using Signals. Attendees will leave the session equipped with a comprehensive toolbox to transform their enterprise codebase into the new Angular paradigm.\n'parentId': 'dd29929140400f153a277e50'\n'parentDescription': The Fullstack Conference for JS Development\n'indexBrandName': 'InternationalJavaScriptCon'\n'indexSeriesName': 'SanDiego'\n'author': 'Michael Egger-Zikes'\n'chunkSource': 'text'\n'text': can be done with signal APIs as well. Uh, also the so-called, uh, view queries. So view queries is maybe a term that was not, uh, has not been that present, uh, until the signal APIs were introduced. Uh, we are basically talking about few child, uh, few children, content child, content children that's reactive right now as well. So quite nice because you know, the Anglo community, maybe you as well. Um, we always strived for having reactive APIs, uh, for inputs, uh, for quite a while. I would say since Anglo two, uh, quite a lot of people dreamed about having a reactive API to get notified when an input changes. Um, so at the beginning everyone thought this is likely, uh, if ever provided it will be provided naturally with Rx js. But, uh, now we have a different reactive API that is directly built into the framework. Uh, we'll also talk about the linked signal. Um, that was an API that was introduced later with Anglo 19, and it helps us to have a kind of derived state with the right able state in combination so we can connect one signal to another signal without an uh, effect. Um, they are also quite nice APIs, uh, that we already received, and some of them will even turn, uh, into the stable, uh, status with, uh, angular 20. Now, uh, we're talking about APIs on how, uh, we can inter have the interoperability between RX js and angular signals because we have the traditional API already, uh, RX JS is a mandatory dependency since, since Angola two. Uh, so why not, uh, taking the strand of both APIs, the power of operators, and the power of custom behavior of RX JS together with the signal API. Um, moreover, we received those with Angola 19 and the feature releases of Anglo 19, uh, an nice a p called resource, uh, different resource APIs where you even can connect directly to your, uh, h TT P backend. And finally, brand new the NJX signal store with the NTPI. So meanwhile, uh, the signal store that was, uh, introduced last year, um, can also act, uh, as a red flag to be fully precise, uh, flux lag API. So if you love to have an event based state management, uh, the new event based API of the signal store is, uh, the correct API for you. Fine. Uh, my name is Michael, uh, funda, ma Complicated last la last name, so you can forget about that. I'm, uh, part of the Angular architect, um, consulting\n'slidetext': ''\n'from': 'vector'\n'score': 0.9225736260414124\n'normalizedScore': 0.9130337403260395\n'beforeDatePenaltyScore': 0.9225736260414124\n\n'documentId': '01a63ca630515849aaa314b1'\n'chunk_id': '6876e25c51ca701363239b74'\n'access': 'restricted'\n'part_number': 1\n'total_parts': 1\n'contentType': 'RHEINGOLD'\n'title': Angular Signals: Neue Features für die reaktive Entwicklung\n'parentName': JavaScript Days München und online 2025\n'language': 'DE'\n'date': '2025-03-19T12:30:00.000Z'\n'abstract': Angular Signals sind seit einiger Zeit ein spannender Bestandteil der reaktiven Entwicklung in Angular. Mit neuen Features wie linkedSignal() und resource() in Angular 19 rücken sie weiter in den Fokus. Doch wie funktionieren Signals und was macht sie so besonders – insbesondere in Bezug auf die Performance? Welche Vorteile bieten sie gegenüber klassischen RxJS-Patterns?Felix Schütz von Thinktecture gibt eine praxisnahe Einführung in Angular Signals und die damit verbundenen neuen Features und zeigt, wie sie die Entwicklung von modernen, reaktiven Anwendungen nachhaltig verändern. Zusätzlich gibt er einen Ausblick auf die geplante Unterstützung von Signal-basierten Formularen.\n'parentId': 'efd4ff41c4b9e889b50854b8'\n'parentDescription': 40 Workshops zu JavaScript, Angular, React, HTML & CSS und KI\n'indexBrandName': 'JavaScriptDays'\n'indexSeriesName': 'Munich'\n'author': 'Felix Schütz'\n'chunkSource': 'text'\n'text': Angular Signals: Neue Features für die reaktive Entwicklung Angular Signals sind seit einiger Zeit ein spannender Bestandteil der reaktiven Entwicklung in Angular. Mit neuen Features wie linkedSignal() und resource() in Angular 19 rücken sie weiter in den Fokus. Doch wie funktionieren Signals und was macht sie so besonders – insbesondere in Bezug auf die Performance? Welche Vorteile bieten sie gegenüber klassischen RxJS-Patterns?Felix Schütz von Thinktecture gibt eine praxisnahe Einführung in Angular Signals und die damit verbundenen neuen Features und zeigt, wie sie die Entwicklung von modernen, reaktiven Anwendungen nachhaltig verändern. Zusätzlich gibt er einen Ausblick auf die geplante Unterstützung von Signal-basierten Formularen.\n'slidetext': ''\n'from': 'vector'\n'score': 0.9263350367546082\n'normalizedScore': 0.9133978907652627\n'beforeDatePenaltyScore': 0.9263350367546082\n\n'documentId': 'a527c16f5bc7b4da1bc88ab0'\n'chunk_id': '68f251653134c10012c3d1fb'\n'access': 'restricted'\n'part_number': 2\n'total_parts': 15\n'contentType': 'RHEINGOLD'\n'title': Angular Resources: Everything you need to know\n'parentName': International JavaScript New York 2025\n'language': 'EN'\n'date': '2025-10-01T12:45:00.000Z'\n'abstract': Discover how game changing Angular Resources will be for your Angular applications. We'll dive into what Angular Resources are, why they matter, and how they can replace most RxJs code in your Angular applications. We’ll see how to use resources for cleaner, more concise code. A perfect talk for those looking to level up their Angular skills and stay ahead with the latest features.\n'parentId': '9f97d5cdc68d72a05f834df4'\n'parentDescription': The JavaScript Fullstack Conference - Angular, Node.js, React and more\n'indexBrandName': 'InternationalJavaScriptCon'\n'indexSeriesName': 'NewYork'\n'author': 'Alain Chautard'\n'chunkSource': 'text'\n'text': so just a little bit later, and it's still experimental right now. So these are the, the three main features, functions, resource, RX resource, and HDDP resource. Um, so everything is still experimental, but very likely to become stable very soon. And interestingly enough, because I'm an old Angular GS guy, I can go back to the Angular GS documentation. Back in the day, there was a dollar resource, which was a little bit different from the resource we have in Angular right now, but the idea was very much the same. It was to give us an API around how to interact with a server, right? And back then there was no observer. It was all about promises. So it was basically this dollar resource function that you would pass a URL and some parameters, and then you would be able to do things and, and interact with the backend through simple functions. So the idea of what's, uh, what angular resources do now in Angular 20 is a little bit similar and also a little bit different. So we'll, we'll see that. So the first way that it's different is that it's all about signals. Um, so Angular is evolving from its default change detection, where basically anything would get angular to detect changes and, and try to render its components. So any click, any timeout, any HDP request that happens would just say, Hey, check, check your stuff, right? Um, we had a small optimization, we still have it, yes, on push to make things, uh, smarter about change detection and, and the fact that Angular would now have a little bit more insight that, oh, you change an input here, so I'm gonna check that component. But if a component inputs doesn't change and that component is un push, then angular just gonna assume, oh, the inputs haven't changed, so I'm not gonna refresh that component. And now we have signals where with the signal, angular knows exactly what changes and where, what are the consequences of that change, which is true for components, but also true for other signals, right? Um, the idea is when you use a signal, angular knows about what anything, any code that depends on it, right? It, it builds a dependency graph on, on those signals and knows exactly what depends on, um, on these signals. So when you change the value, everything that needs to change as a result is just known. And so it can happen quickly. And so along with signal scheme, a whole bunch of new functions, features like components, inputs, outputs, can all be signal based. Now, models, um, content\n'slidetext': ''\n'from': 'vector'\n'score': 0.9191646575927734\n'normalizedScore': 0.9169678084070809\n'beforeDatePenaltyScore': 0.9191646575927734\n\n'documentId': '0747f0655ef3790a97eba95b'\n'chunk_id': '68f24b693134c10012c3d13d'\n'access': 'restricted'\n'part_number': 2\n'total_parts': 2\n'contentType': 'RHEINGOLD'\n'title': How to architect Angular apps in 2025\n'parentName': International JavaScript New York 2025\n'language': 'EN'\n'date': '2025-10-01T08:15:00.000Z'\n'abstract': In this talk, Alain showcases several architecture concepts he uses to optimize apps for performance, readability, and scalability in 2025 and beyond. We’ll touch on using Signals as state in our services, how to control access to such Signals, using the new resource API, and more!\n'parentId': '9f97d5cdc68d72a05f834df4'\n'parentDescription': The JavaScript Fullstack Conference - Angular, Node.js, React and more\n'indexBrandName': 'InternationalJavaScriptCon'\n'indexSeriesName': 'NewYork'\n'author': 'Alain Chautard'\n'chunkSource': 'slidetext'\n'text': \n'slidetext': 'toSignal and toObservable ●One key difference between Observables and Signals is that Signals are synchronous and always return a value immediately (like a BehaviorSubject) ●As a result, if you don’t want to get undefined values, you can set an initialValue when creating a Signal: ● 21 Resources ●httpResource is also experimental, but it’s the way to think about how to replace the HttpClient in the future: ●No more visible RxJs, no subscription, no operator ● 22 DEMO - Signal-based code Impact on architecture 2) Lazy-loading How an Angular application gets loaded index.html (2-3 kb) main.js (20 MB) What happens when we use lazy-loading index.html (2-3 kb) main.js (10 MB) cart.js (5 MB) loaded later when needed checkout.js (5 MB) loaded later when needed Multiple different chunks Lazy-loading comes with lots of options Typically router-based •NgModules or components get loaded when a given route gets activated (loading on demand) Can use preloading •Angular can download extra chunks in the background once main chunk is loaded Can be done within a single component •Lazy-load portions of the page that will be displayed later (scrolling) Defer Block ●Allows deferred loading of components, directives, and pipes, including CSS: DEMO - Lazy-loading architecture Conclusion - Key takeaways ●Use Signals - everywhere! ●Replace HttpClient with httpResource ●Use and share Signals from services ●Replace old directives with new blocks (automated migration) ●Use lazy-loading with standalone components and/or @defer What you’ll get: ●More performant, easier to read code ●Less boilerplate syntax 30 Want to showcase your Angular skills? https://certificates.dev/angular Thanks for your attention Email: al@interstate21.com https://blog.angulartraining.com Check out our certification exam at: https://certificates.dev/angular Coupon code: IJCNY25 for $25 off'\n'from': 'vector'\n'score': 0.9199877977371216\n'normalizedScore': 0.9177806745788263\n'beforeDatePenaltyScore': 0.9199877977371216\n\n'documentId': '0747f0655ef3790a97eba95b'\n'chunk_id': '68f24b683134c10012c3d131'\n'access': 'restricted'\n'part_number': 6\n'total_parts': 16\n'contentType': 'RHEINGOLD'\n'title': How to architect Angular apps in 2025\n'parentName': International JavaScript New York 2025\n'language': 'EN'\n'date': '2025-10-01T08:15:00.000Z'\n'abstract': In this talk, Alain showcases several architecture concepts he uses to optimize apps for performance, readability, and scalability in 2025 and beyond. We’ll touch on using Signals as state in our services, how to control access to such Signals, using the new resource API, and more!\n'parentId': '9f97d5cdc68d72a05f834df4'\n'parentDescription': The JavaScript Fullstack Conference - Angular, Node.js, React and more\n'indexBrandName': 'InternationalJavaScriptCon'\n'indexSeriesName': 'NewYork'\n'author': 'Alain Chautard'\n'chunkSource': 'text'\n'text': want to synchronize the state of our data with the state of our components, what's displayed on the screen, because that's really what it is. Data changed, let's synchronize our components done. So that looks better, right? Than what we started from. But the thing is, if we want this, we have to use signals and we have to use them pretty much everywhere, right? But the good news is Angular is helping with that. And there's a lot of things that have been happening lately to go, well, you know, go, go already all the way in that direction. So, um, signal based components, you probably notice that, uh, inputs, outputs, model, all of the content queries like future child content, child, all of these things. Now you have functions like input and model and all of these that replace the, the old decorators. And that's because all of these are signal based so that you can start using signals all over the place. And the good news about that is you don't have to do the migration manually. There's actually migration command to help. So if I go to angular dev, uh, I think it's here in the reference migrations can make this a little bit bigger, but, uh, migrating to standalone versus comments of that migrating the new control flow, you can do that, uh, migrating to the new inputs or outputs APIs or queries or signals versus migration for that, which are, you know, the, the angular CLI comments that we're familiar with. So if you want to migrate to the new single inputs NG generate angular core signal input, migration, and it's gonna go through all of your decorators, replay them with input signals, and then, you know, do all the right things to make it happen. So nice and easy takes one minute, maximum less if you copy paste from here. So yeah, that helps really getting, you know, into that signal based approach as much as possible. And, um, and yeah, starting migrating step by step. Now, the thing is, if you start doing that, at some point you still need RXJS. You, you still have an HDB client, you still have some router APIs or forms where you have to subscribe to our observables, right? The, the current way to remove that part is to use to signal. So this two signal function, it's actually came about at the same time as a signal, API in Anglo 16 in developer preview, and now it's stable. And so you can use it to convert any observable into a signal. So all of the places where you think, oh, here, I\n'slidetext': ''\n'from': 'vector'\n'score': 0.9202964305877686\n'normalizedScore': 0.9180893074294733\n'beforeDatePenaltyScore': 0.9202964305877686\n\n'documentId': 'a46f583e86ab963aed1784a1'\n'chunk_id': '68a457709f706f00135a4801'\n'access': 'granted'\n'part_number': 1\n'total_parts': 20\n'contentType': 'RHEINGOLD'\n'title': Master Angular Signals in your existing Codebase\n'parentName': iJS San Diego 2025\n'language': 'EN'\n'date': '2025-05-20T12:30:00.000Z'\n'abstract': Angular Signals bring a fresh perspective to our codebases and introduce a fundamentally simple API. However, implementing a Signal-based application requires a slightly different approach compared to traditional methods. Reactive Design principles and immutable data structures necessitate adjusted strategies but offer numerous benefits in terms of managing state and enhancing Performance. Component implementations are undergoing a transformation that makes the use of lifecycle hook methods increasingly obsolete. In this talk, we will explore how to successfully implement a scalable frontend architecture using Signals. Attendees will leave the session equipped with a comprehensive toolbox to transform their enterprise codebase into the new Angular paradigm.\n'parentId': 'dd29929140400f153a277e50'\n'parentDescription': The Fullstack Conference for JS Development\n'indexBrandName': 'InternationalJavaScriptCon'\n'indexSeriesName': 'SanDiego'\n'author': 'Michael Egger-Zikes'\n'chunkSource': 'text'\n'text': Master Angular Signals in your existing Codebase Angular Signals bring a fresh perspective to our codebases and introduce a fundamentally simple API. However, implementing a Signal-based application requires a slightly different approach compared to traditional methods. Reactive Design principles and immutable data structures necessitate adjusted strategies but offer numerous benefits in terms of managing state and enhancing Performance. Component implementations are undergoing a transformation that makes the use of lifecycle hook methods increasingly obsolete. In this talk, we will explore how to successfully implement a scalable frontend architecture using Signals. Attendees will leave the session equipped with a comprehensive toolbox to transform their enterprise codebase into the new Angular paradigm. Uh, so, uh, thanks for joining my talk today. Um, I hope you are excited, um, to get some updates about the angular signals. It's quite an interesting, thanks for closing the door. Um, it's quite an interesting API, um, and it's an API, to be honest, that was not invented by Angular team, right? So, uh, it's from the Angular, not the angular ecosystem, but the JavaScript ecosystem, uh, from a guy, a brilliant guy called Ryan Canto. So let's dive into that. Uh, we want to take a look, uh, at an existing angular code base and how, uh, we can turn that code base into signal usage because it's not, uh, a one-to-one translation that you can do with s schematics directly. So, for example, the new template syn with the ad symbol. That's a quite nice transition because you can just activate the schematics and you're good to go. It can convert your code base almost a hundred percent. Just the track information is necessary to be updated. Typically, um, the rest can be done automatically. It's not that way with angular signals because we are talking about and reactive a reactive API. And if we turn an application that is maybe at the moment not that reactive into the reactive design world, things, uh, need to change. Maybe you're thinking on how to, uh, implement that component might shift a little bit. Let's take a look, um, into what we will talk about, uh, the reactive primitive, uh, on how to use this, uh, signal reactive primitive, uh, so built in implementation inside the angle of framework, the core package, how we can use that in the templates, how we can use it in side effects. Um, we'll take a look at other signal APIs like, uh, input and model that's quite nice for, uh, binding support property bindings, uh, two-way bindings. All of that can\n'slidetext': ''\n'from': 'vector'\n'score': 0.9276810884475708\n'normalizedScore': 0.9181412027321979\n'beforeDatePenaltyScore': 0.9276810884475708\n\n'documentId': 'bc0bef25841c96486c56f58f'\n'chunk_id': '6876da63225e92fc1ac7c2dc'\n'access': 'restricted'\n'part_number': 44\n'total_parts': 56\n'contentType': 'FLEX_CAMP'\n'title': Woche 2: Angular Pipes, NgModules & Subkomponenten: Meistern Sie die fortgeschrittenen Angular-Konzepte (Lektionen 4, 5 & 6) | verfügbar bis 28.09.2025\n'parentName': Angular Camp - Flexible Basic Camp September 2025 | online\n'language': 'DE'\n'date': '2025-09-07T23:00:00.000Z'\n'abstract': Weiter geht es in die zweite Woche! Hier behandeln wir 3 Lektionen. In diesem Kursteil erlangen Sie tiefere Einblicke in die fortgeschrittenen Konzepte von Angular und lernen, wie Sie Pipes, NgModules und Subkomponenten effektiv einsetzen, um Ihre Anwendungen zu optimieren. 4. Lektion: Pipes: Datenformatierung mit eigener Hand: - Lernen Sie, wie Sie eigene Pipes entwickeln, um Daten im Zuge der Datenbindung zu transformieren. - Pure Pipes im Fokus: Verstehen Sie das Konzept der reinen Pipes und ihre Bedeutung für die Anwendungsperformance. - In diesem kurzen Kapitel erfahren Sie alles zur Entwicklung eigener Pipes für das Transformieren von Daten im Zuge der Datenbindung, zum Konzept der reinen Pipes (engl. pure pipes) und warum es für die Anwendungsperformance wichtig ist. 5. Lektion: NgModules & Standalone Components in Angular: Alt und neu im Einklang Auch wenn NgModules seit der Einführung von Standalone Components weniger wichtig sind, existieren noch zahlreiche Codestrecken und Bibliotheken, die darauf aufbauen. Deswegen beschäftigen wir uns hier mit dem Zusammenspiel dieser beiden Konzepte. - NgModules verstehen: Obwohl Standalone Components an Bedeutung gewinnen, bleiben NgModules relevant. Erfahren Sie, wie diese beiden Konzepte zusammenspielen. - Codestrecken und Bibliotheken meistern: Navigieren Sie souverän durch Codestrecken und Bibliotheken, die auf NgModules basieren. 6. Lektion: Angular Subkomponenten & Datenbindung Erweitern Sie Ihre Angular-Fähigkeiten und lernen Sie, wie Sie Subkomponenten und Datenbindung effektiv einsetzen, um komplexe und skalierbare Anwendungen zu erstellen. Hier erfahren Sie Wissenswertes über die Entwicklung weiterer Komponenten, die über Datenbindung miteinander kommunizieren. Dazu werfen wir auch einen genaueren Blick unter die Motorhaube von Angular, um die Datenbindung besser zu verstehen. - Data Binding im Detail - Components and Data Bindung - Event Bindings - Smart vs. Dumb Components - Life Cycle Hooks - Bonus: Signals Auch hier haben Sie die Möglichkeit Ihr Wissen praktisch anzuwenden: Zu den Übungen Wir empfehlen in der zweiten Woche diese Lektionen zu bearbeiten.\n'parentId': 'a22478b5a24a40c79edc21dd'\n'parentDescription': Das Angular Training für Einsteiger:innen mit Manfred Steyer im zeitlich flexiblen Online-Format\n'indexBrandName': 'AngularCamp'\n'indexSeriesName': 'FlexibleBasicCamp'\n'author': 'Manfred Steyer'\n'chunkSource': 'text'\n'text': geändert hat. Angular kann herausfinden, ah, die Komponente hat sich rechts unten geändert, also muss sich rechts unten aktualisieren und sonst nirgendwo. Das Ganze ist nicht ganz neu, oder? Wir haben ähnliche Mechanismen mit Observables, mit RxJS, mit Subjects. Ja, also sowas hat es schon zuvor gegeben. Allerdings sind Signals ganz bewusst sehr, sehr schlank implementiert. Sehr, sehr simpel. Die können wirklich nicht viel mehr als das hier. Andere Ansätze wie RxJS haben ganz, ganz viele Features und sind schon alleine deswegen nicht obsolet, aber das Ziel ist es halt, mit etwas Simplen zu starten. Und das Angular-Team glaubt, dass in den meisten Fällen diese simple Lösung ausreichend ist. Ja, und wenn ich halt mehr brauche, dann werde ich mir eine Library wie RxJS dazu installieren und habe dann mehr Komplexität, aber auch viel, viel mehr Features. Man möchte also die Standard-Fälle leicht, gewichtiger, einfacher gestalten. Wie schaut jetzt so eine Anwendung mit und ohne Signals aus? Na ja, starten wir vielleicht einmal mit der Variante ohne Signals. Sowas haben wir eh schon die ganze Zeit gemacht, da hat man Properties, die bekommen Werte. Die Werte werden vielleicht aktualisiert, weil ich aus dem Backend Daten abrufe und die Werte werden gebunden. Nach jedem Event-Handler prüft Angular, ob da jetzt da was zu aktualisieren ist. Ob die Schleife oder das If oder sonst irgendwas neu gerendert werden müssen. So schaut es klassischerweise aus. Wenn ich genau dasselbe mit Signals mache, dann muss ich halt alle Werte, die ich Daten binden möchte, in ein Signal einwickeln. Dazu gibt es die Hilfsfunktion Signal, die befindet sich seit Angular 16 im Namespace Angular Core. Da sieht man also schon, das Konzept ist ein integraler Bestandteil des Kerns von Angular. Die Funktion Signal kriegt einen Standardwert übergeben, Klammerauf, Klammerzu in dem Fall, also ein leeres Array. Und da Klammerauf, Klammerzu keine Typ-Informationen beinhaltet, gebe ich hier als Typparameter an, ich meine damit ein leeres Flugarray. Diesen Typparameter in den Spitzenklammern, den kann man sehr häufig weglassen, weil TypeScript sehr häufig aus dem Standardwert den Datentyp ableiten kann. Beim Array\n'slidetext': ''\n'from': 'vector'\n'score': 0.921909749507904\n'normalizedScore': 0.9184212336555448\n'beforeDatePenaltyScore': 0.921909749507904\n\n'documentId': '18e1984b93f7b81b65afb3ad'\n'chunk_id': '69020ea2a5de460012a1ae9a'\n'access': 'granted'\n'part_number': 1\n'total_parts': 19\n'contentType': 'RHEINGOLD'\n'title': Rethinking Angular: The Future with Signals and the New Resource API\n'parentName': International JavaScript Conference Munich 2025\n'language': 'EN'\n'date': '2025-10-28T11:00:00.000Z'\n'abstract': Angular is on the brink of a fundamental paradigm shift: with Signals and the new Resource API, declarative programming moves to the forefront. This transformation not only requires a new mindset for state management, but also for how modern applications are structured. In this talk, we’ll explore how Angular’s new reactivity foundation changes the way Angular solutions are built. We’ll look at common architectural patterns using Signals and the Resource API, explain how the new NgRx Signal Store can be used for state management, and show what an architecture looks like that embraces reactivity and data flow over imperative code blocks. The goal is to foster a deeper understanding of these new concepts — and to equip you with concrete tools and structures to make your Angular architectures not only modern, but also maintainable and scalable in the long term.\n'parentId': 'd9a5c0715a7cff50bbb51e14'\n'parentDescription': \n'indexBrandName': 'InternationalJavaScriptCon'\n'indexSeriesName': 'Munich'\n'author': 'Manfred Steyer'\n'chunkSource': 'text'\n'text': Rethinking Angular: The Future with Signals and the New Resource API Angular is on the brink of a fundamental paradigm shift: with Signals and the new Resource API, declarative programming moves to the forefront. This transformation not only requires a new mindset for state management, but also for how modern applications are structured. In this talk, we’ll explore how Angular’s new reactivity foundation changes the way Angular solutions are built. We’ll look at common architectural patterns using Signals and the Resource API, explain how the new NgRx Signal Store can be used for state management, and show what an architecture looks like that embraces reactivity and data flow over imperative code blocks. The goal is to foster a deeper understanding of these new concepts — and to equip you with concrete tools and structures to make your Angular architectures not only modern, but also maintainable and scalable in the long term. Come When we usually think about our source code, we think about it in terms of a script, a script like when playing theater, a script that tells us what to do when, or to put it in another way, this is more of a control flow centric perspective. This is completely fine, however, if you really want to succeed with signals in Angular, then you need to succeed with reactive programming. And if you want to succeed with reactive programming, you need to switch your thinking. In this case you need to think more about the application of as a marble run, a marble run where several marbles are going through. Those marbles represent the data in your system, the state, and the state in turn is represented by signals. And now sometimes a marble can be split to several marbles, and sometimes several marbles can be combined to one marble. This is what we usually do with computed or with the resource API. If you manage to switch over to this perspective, to this more data flow centric perspective, then you are more likely to succeed with this new way of programming. Because here is the story. When I started with signals in one of the early preview versions, I had the impression, oh, a signal is so cute. It is just an object with gathers and setters. And yeah, this is true technology wise. However, if you don't switch your thinking towards a marble run, towards a more data flow centric perspective, then you will have to swim across the stream. That means you need to work against the design of this entire API and this causes a lot of pain. So the big question is how to switch over to a more data flow centric design\n'slidetext': ''\n'from': 'vector'\n'score': 0.9207788109779358\n'normalizedScore': 0.9200574184132478\n'beforeDatePenaltyScore': 0.9207788109779358\n\n'documentId': '0747f0655ef3790a97eba95b'\n'chunk_id': '68f24b683134c10012c3d12d'\n'access': 'restricted'\n'part_number': 2\n'total_parts': 16\n'contentType': 'RHEINGOLD'\n'title': How to architect Angular apps in 2025\n'parentName': International JavaScript New York 2025\n'language': 'EN'\n'date': '2025-10-01T08:15:00.000Z'\n'abstract': In this talk, Alain showcases several architecture concepts he uses to optimize apps for performance, readability, and scalability in 2025 and beyond. We’ll touch on using Signals as state in our services, how to control access to such Signals, using the new resource API, and more!\n'parentId': '9f97d5cdc68d72a05f834df4'\n'parentDescription': The JavaScript Fullstack Conference - Angular, Node.js, React and more\n'indexBrandName': 'InternationalJavaScriptCon'\n'indexSeriesName': 'NewYork'\n'author': 'Alain Chautard'\n'chunkSource': 'text'\n'text': done all continents except Antarctica because that's, that's tricky to, to find an audience there, but that's okay. So as I told you earlier, angular, and as you probably know, there's been a lot of things changing lately in the past two, three years, even more. It really started with signals version 16, and then everything kind of became crazy and faster in terms of pace of change. So I listed some of the main things that changed here. Uh, starting at V 14. We got standalone components 16, angular signals 17, the new control flow blocks, uh, 19 HTP resource V 20 is on as is stable. And V 21 coming soon, we we're gonna have signal forms. So that's a lot. And you can write Angular code today that looks nothing like what it would look like five years ago. Well, you, you'll still recognize things, but you can do things in a way that's completely different. So we'll see why these changes are happening, what's the motivation behind this and what the impact on our code and on, you know, what we, what we're supposed to do with this. So the main idea of the Angular team was really to make Angular easier to learn, easier to understand, easier to maintain. 'cause the thing is, this is an Angular talk. If you go to a React talk, there's gonna be more people. And the fact of the matter is, is that React has always advertised itself as the easier option, right? Easier to learn. It's fast. It's like jQuery, just add something, you can use it, blah, blah, blah. So Angular lasts a lot of audience to react because of that, mostly on kind of reputation I would say. But, um, and so that perceived difficulty is something that the Angular team is trying to fight against and say, no, angular is not that difficult. And so all of the things that's changed since V 14 are really going into that idea of, well, angular is actually easy to learn. We don't need to know that much about RXJS. You don't need to know about all of these extra things. You can start with the basics. So one of the things that started in the 14 was NG modules, right? Angular modules. It's one of the things that if you come into the Angular world, you're like, why do we have that? React doesn't have that view, doesn't have that. Why do we have NG modules in Angular? So standalone fixes that we remove NG modules pretty much, and you can just do your thing like you would do with other\n'slidetext': ''\n'from': 'vector'\n'score': 0.923045814037323\n'normalizedScore': 0.9208386908790277\n'beforeDatePenaltyScore': 0.923045814037323\n\n'documentId': '86a43d1e179681ee6a344c28'\n'chunk_id': '690210a20902850012f24510'\n'access': 'granted'\n'part_number': 1\n'total_parts': 1\n'contentType': 'RHEINGOLD'\n'title': Workshop: Modern Angular Architectures with Signals, Resource API, and the New NgRx Signal Store\n'parentName': International JavaScript Conference Munich 2025\n'language': 'EN'\n'date': '2025-10-31T08:00:00.000Z'\n'abstract': In this interactive workshop, we use Angular's latest features to build a modern and maintainable architecture for large applications. We start with a sustainable project setup using Nx with Module Boundaries and Sheriff. We continue with integrating Signals that will shape the future of the framework and leverage the new Resource API including the httpResource for establishing a reactive design. Then, we use the brand-new NGRX Signal Store to establish modern and lightweight state management. In the end, you will know how you can use the individual tools to design modern and, above all, long-term maintainable Angular architectures.\n'parentId': 'd9a5c0715a7cff50bbb51e14'\n'parentDescription': \n'indexBrandName': 'InternationalJavaScriptCon'\n'indexSeriesName': 'Munich'\n'author': 'Manfred Steyer,Michael Egger-Zikes'\n'chunkSource': 'text'\n'text': Workshop: Modern Angular Architectures with Signals, Resource API, and the New NgRx Signal Store In this interactive workshop, we use Angular's latest features to build a modern and maintainable architecture for large applications. We start with a sustainable project setup using Nx with Module Boundaries and Sheriff. We continue with integrating Signals that will shape the future of the framework and leverage the new Resource API including the httpResource for establishing a reactive design. Then, we use the brand-new NGRX Signal Store to establish modern and lightweight state management. In the end, you will know how you can use the individual tools to design modern and, above all, long-term maintainable Angular architectures.\n'slidetext': ''\n'from': 'vector'\n'score': 0.9218511581420898\n'normalizedScore': 0.9212872998239772\n'beforeDatePenaltyScore': 0.9218511581420898\n\n'documentId': '69ab8ba6bfa5d1a198f998c3'\n'chunk_id': '690b0f2aeb0efe0012394f2b'\n'access': 'restricted'\n'part_number': 40\n'total_parts': 51\n'contentType': 'FLEX_CAMP'\n'title': Woche 2: Angular Pipes, NgModules & Subkomponenten: Meistern Sie die fortgeschrittenen Angular-Konzepte (Lektionen 4, 5 & 6) | verfügbar bis 30.11.2025\n'parentName': Angular Camp - Flexible Basic Camp November 2025 | online\n'language': 'DE'\n'date': '2025-11-10T00:00:00.000Z'\n'abstract': Weiter geht es in die zweite Woche! Hier behandeln wir 3 Lektionen. In diesem Kursteil erlangen Sie tiefere Einblicke in die fortgeschrittenen Konzepte von Angular und lernen, wie Sie Pipes, NgModules und Subkomponenten effektiv einsetzen, um Ihre Anwendungen zu optimieren. 4. Lektion: Pipes: Datenformatierung mit eigener Hand: - Lernen Sie, wie Sie eigene Pipes entwickeln, um Daten im Zuge der Datenbindung zu transformieren. - Pure Pipes im Fokus: Verstehen Sie das Konzept der reinen Pipes und ihre Bedeutung für die Anwendungsperformance. - In diesem kurzen Kapitel erfahren Sie alles zur Entwicklung eigener Pipes für das Transformieren von Daten im Zuge der Datenbindung, zum Konzept der reinen Pipes (engl. pure pipes) und warum es für die Anwendungsperformance wichtig ist. 5. Lektion: NgModules & Standalone Components in Angular: Alt und neu im Einklang Auch wenn NgModules seit der Einführung von Standalone Components weniger wichtig sind, existieren noch zahlreiche Codestrecken und Bibliotheken, die darauf aufbauen. Deswegen beschäftigen wir uns hier mit dem Zusammenspiel dieser beiden Konzepte. - NgModules verstehen: Obwohl Standalone Components an Bedeutung gewinnen, bleiben NgModules relevant. Erfahren Sie, wie diese beiden Konzepte zusammenspielen. - Codestrecken und Bibliotheken meistern: Navigieren Sie souverän durch Codestrecken und Bibliotheken, die auf NgModules basieren. 6. Lektion: Angular Subkomponenten & Datenbindung Erweitern Sie Ihre Angular-Fähigkeiten und lernen Sie, wie Sie Subkomponenten und Datenbindung effektiv einsetzen, um komplexe und skalierbare Anwendungen zu erstellen. Hier erfahren Sie Wissenswertes über die Entwicklung weiterer Komponenten, die über Datenbindung miteinander kommunizieren. Dazu werfen wir auch einen genaueren Blick unter die Motorhaube von Angular, um die Datenbindung besser zu verstehen. - Data Binding im Detail - Components and Data Bindung - Event Bindings - Smart vs. Dumb Components - Life Cycle Hooks - Bonus: Signals Auch hier haben Sie die Möglichkeit Ihr Wissen praktisch anzuwenden: Zu den Übungen Wir empfehlen in der zweiten Woche diese Lektionen zu bearbeiten.\n'parentId': '7a76c5fc628bffdcec626f4e'\n'parentDescription': Das Angular Training für Einsteiger:innen mit Manfred Steyer im zeitlich flexiblen Online-Format\n'indexBrandName': 'AngularCamp'\n'indexSeriesName': 'FlexibleBasicCamp'\n'author': 'Manfred Steyer'\n'chunkSource': 'text'\n'text': weiß man ganz genau, wo sich was geändert hat. Angular kann herausfinden, ah, die Komponente hat sich rechts unten geändert, also muss sich rechts unten aktualisieren und sonst nirgendwo. Das Ganze ist nicht ganz neu, oder? Wir haben ähnliche Mechanismen mit Observables, mit RxJS, mit Subjects. Ja, also sowas hat es schon zuvor gegeben. Allerdings sind Signals ganz bewusst sehr, sehr schlank implementiert. Sehr, sehr simpel. Die können wirklich nicht viel mehr als das hier. Andere Ansätze wie RxJS haben ganz, ganz viele Features und sind schon alleine deswegen nicht obsolet, aber das Ziel ist es halt, mit etwas Simplen zu starten. Und das Angular-Team glaubt, dass in den meisten Fällen diese simple Lösung ausreichend ist. Ja, und wenn ich halt mehr brauche, dann werde ich mir eine Library wie RxJS dazu installieren und habe dann mehr Komplexität, aber auch viel, viel mehr Features. Man möchte also die Standard-Fälle leicht, gewichtiger, einfacher gestalten. Wie schaut jetzt so eine Anwendung mit und ohne Signals aus? Na ja, starten wir vielleicht einmal mit der Variante ohne Signals. Sowas haben wir eh schon die ganze Zeit gemacht, da hat man Properties, die bekommen Werte. Die Werte werden vielleicht aktualisiert, weil ich aus dem Backend Daten abrufe und die Werte werden gebunden. Nach jedem Event-Handler prüft Angular, ob da jetzt da was zu aktualisieren ist. Ob die Schleife oder das If oder sonst irgendwas neu gerendert werden müssen. So schaut es klassischerweise aus. Wenn ich genau dasselbe mit Signals mache, dann muss ich halt alle Werte, die ich Daten binden möchte, in ein Signal einwickeln. Dazu gibt es die Hilfsfunktion Signal, die befindet sich seit Angular 16 im Namespace Angular Core. Da sieht man also schon, das Konzept ist ein integraler Bestandteil des Kerns von Angular. Die Funktion Signal kriegt einen Standardwert übergeben, Klammerauf, Klammerzu in dem Fall, also ein leeres Array. Und da Klammerauf, Klammerzu keine Typ-Informationen beinhaltet, gebe ich hier als Typparameter an, ich meine damit ein leeres Flugarray. Diesen Typparameter in den Spitzenklammern, den kann man sehr häufig weglassen, weil TypeScript sehr häufig aus dem Standardwert\n'slidetext': ''\n'from': 'vector'\n'score': 0.9222575426101685\n'normalizedScore': 0.9222233646573527\n'beforeDatePenaltyScore': 0.9222575426101685\n\n'documentId': 'e45840c0b8a784e3b3cf3be3'\n'chunk_id': '690211f50902850012f245ce'\n'access': 'granted'\n'part_number': 1\n'total_parts': 22\n'contentType': 'RHEINGOLD'\n'title': RxJS, Signals and Native Observables: What Now?\n'parentName': International JavaScript Conference Munich 2025\n'language': 'EN'\n'date': '2025-10-28T11:00:00.000Z'\n'abstract': Angular’s approach to reactivity is evolving. For years, RxJS was the standard. Then Signals introduced a simpler, framework-integrated model. Now, with Native Observables becoming part of the web platform, new questions arise: how do these pieces fit together? In this talk, we will explore the differences and common ground between RxJS and Native Observables, and examine what this means for the future of Angular and Signals. Beyond simple patterns like “events vs. state,” you will learn a practical model to decide when to use Signals, when Observables are more suitable, and where Signals are likely to replace them.\n'parentId': 'd9a5c0715a7cff50bbb51e14'\n'parentDescription': \n'indexBrandName': 'InternationalJavaScriptCon'\n'indexSeriesName': 'Munich'\n'author': 'Rainer Hahnekamp'\n'chunkSource': 'text'\n'text': RxJS, Signals and Native Observables: What Now? Angular’s approach to reactivity is evolving. For years, RxJS was the standard. Then Signals introduced a simpler, framework-integrated model. Now, with Native Observables becoming part of the web platform, new questions arise: how do these pieces fit together? In this talk, we will explore the differences and common ground between RxJS and Native Observables, and examine what this means for the future of Angular and Signals. Beyond simple patterns like “events vs. state,” you will learn a practical model to decide when to use Signals, when Observables are more suitable, and where Signals are likely to replace them. Then it's just the introduction, I just keep the introduction of myself. I just go directly to the first slide. So again. When signals came out, uh, we've been told signals are necessary to reach songless change detection. Nowadays we hope we have songless change detection and we know we don't have to use signals. That became clear quite soon, so after a few months of Ingula 16, uh, the Engler team switched their plan, and it was around Christmas where they said, There is now a roadmap, there is now a version to strategy for signals. We don't need it for soundless anymore. And then the question is, OK, why do we need to use them then? Uh, and then the answer was signals should make it much easier. So the the the simplification and developer experience, this is also one of the main points. But there is something else. Everyone was kind of asking, OK, and what is going to happen with RXGS. Um, if signals should become easier than RX chairs, then I don't need to use RX chairs anymore. And the other query answer was, no, uh, you still can use RX chairs. There are still some places where you are going to be, where you are going to use RX chairs, and in a way, Um, certain people or some people then said, well, maybe it is an option to to reach a situation one day where we don't need RX chairs, and this was something where in the beginning I always thought maybe it is possible to write an Engle application one day, but the way how things are currently evolving, I don't see it like this. There are a few reasons for that. First of all, we have an existing code base, so I can't just rewrite everything to signals and get rid of RXGS. Even now, we can't get rid of RXJS because it's it's just still in the API. But, but given we have\n'slidetext': ''\n'from': 'vector'\n'score': 0.9240995645523071\n'normalizedScore': 0.9233781719876192\n'beforeDatePenaltyScore': 0.9240995645523071\n\n'documentId': '59c6dfa238c69ebd748cc7dc'\n'chunk_id': '69038857a7bbb00013e754e7'\n'access': 'restricted'\n'part_number': 1\n'total_parts': 1\n'contentType': 'RHEINGOLD'\n'title': Angular Signals: Neue Features für die reaktive Entwicklung\n'parentName': JavaScript Days Berlin und online 2025\n'language': 'DE'\n'date': '2025-10-22T11:30:00.000Z'\n'abstract': Angular Signals sind seit einiger Zeit ein spannender Bestandteil der reaktiven Entwicklung in Angular. Mit neuen Features wie linkedSignal() und resource() in Angular 20 rücken sie weiter in den Fokus. Doch wie funktionieren Signals und was macht sie so besonders – insbesondere in Bezug auf die Performance? Welche Vorteile bieten sie gegenüber klassischen RxJS-Patterns? Felix Schütz von Thinktecture gibt eine praxisnahe Einführung in Angular Signals und die damit verbundenen neuen Features und zeigt, wie sie die Entwicklung von modernen, reaktiven Anwendungen nachhaltig verändern. Zusätzlich gibt er einen Ausblick auf die geplante Unterstützung von Signal-basierten Formularen.\n'parentId': 'a233287a238c6e0ce3f91546'\n'parentDescription': 40 Workshops zu JavaScript, Angular, React, Typescript und KI\n'indexBrandName': 'JavaScriptDays'\n'indexSeriesName': 'Berlin'\n'author': 'Felix Wunderlich'\n'chunkSource': 'text'\n'text': Angular Signals: Neue Features für die reaktive Entwicklung Angular Signals sind seit einiger Zeit ein spannender Bestandteil der reaktiven Entwicklung in Angular. Mit neuen Features wie linkedSignal() und resource() in Angular 20 rücken sie weiter in den Fokus. Doch wie funktionieren Signals und was macht sie so besonders – insbesondere in Bezug auf die Performance? Welche Vorteile bieten sie gegenüber klassischen RxJS-Patterns? Felix Schütz von Thinktecture gibt eine praxisnahe Einführung in Angular Signals und die damit verbundenen neuen Features und zeigt, wie sie die Entwicklung von modernen, reaktiven Anwendungen nachhaltig verändern. Zusätzlich gibt er einen Ausblick auf die geplante Unterstützung von Signal-basierten Formularen.\n'slidetext': ''\n'from': 'vector'\n'score': 0.9251232147216797\n'normalizedScore': 0.9240741965862155\n'beforeDatePenaltyScore': 0.9251232147216797\n\n'documentId': 'af64d26c0f5fa509f9042a4b'\n'chunk_id': '690d25f4f6e2cc0012fef926'\n'access': 'restricted'\n'part_number': 40\n'total_parts': 51\n'contentType': 'FLEX_CAMP'\n'title': Woche 2: Angular Pipes, NgModules & Subkomponenten: Meistern Sie die fortgeschrittenen Angular-Konzepte (Lektionen 4, 5 & 6) | verfügbar bis 30.01.2026\n'parentName': Angular Camp - Flexible Basic Camp Januar 2026 | online\n'language': 'DE'\n'date': '2026-01-12T00:00:00.000Z'\n'abstract': Weiter geht es in die zweite Woche! Hier behandeln wir 3 Lektionen. In diesem Kursteil erlangen Sie tiefere Einblicke in die fortgeschrittenen Konzepte von Angular und lernen, wie Sie Pipes, NgModules und Subkomponenten effektiv einsetzen, um Ihre Anwendungen zu optimieren. 4. Lektion: Pipes: Datenformatierung mit eigener Hand: - Lernen Sie, wie Sie eigene Pipes entwickeln, um Daten im Zuge der Datenbindung zu transformieren. - Pure Pipes im Fokus: Verstehen Sie das Konzept der reinen Pipes und ihre Bedeutung für die Anwendungsperformance. - In diesem kurzen Kapitel erfahren Sie alles zur Entwicklung eigener Pipes für das Transformieren von Daten im Zuge der Datenbindung, zum Konzept der reinen Pipes (engl. pure pipes) und warum es für die Anwendungsperformance wichtig ist. 5. Lektion: NgModules & Standalone Components in Angular: Alt und neu im Einklang Auch wenn NgModules seit der Einführung von Standalone Components weniger wichtig sind, existieren noch zahlreiche Codestrecken und Bibliotheken, die darauf aufbauen. Deswegen beschäftigen wir uns hier mit dem Zusammenspiel dieser beiden Konzepte. - NgModules verstehen: Obwohl Standalone Components an Bedeutung gewinnen, bleiben NgModules relevant. Erfahren Sie, wie diese beiden Konzepte zusammenspielen. - Codestrecken und Bibliotheken meistern: Navigieren Sie souverän durch Codestrecken und Bibliotheken, die auf NgModules basieren. 6. Lektion: Angular Subkomponenten & Datenbindung Erweitern Sie Ihre Angular-Fähigkeiten und lernen Sie, wie Sie Subkomponenten und Datenbindung effektiv einsetzen, um komplexe und skalierbare Anwendungen zu erstellen. Hier erfahren Sie Wissenswertes über die Entwicklung weiterer Komponenten, die über Datenbindung miteinander kommunizieren. Dazu werfen wir auch einen genaueren Blick unter die Motorhaube von Angular, um die Datenbindung besser zu verstehen. - Data Binding im Detail - Components and Data Bindung - Event Bindings - Smart vs. Dumb Components - Life Cycle Hooks - Bonus: Signals Auch hier haben Sie die Möglichkeit Ihr Wissen praktisch anzuwenden: Zu den Übungen Wir empfehlen in der zweiten Woche diese Lektionen zu bearbeiten.\n'parentId': 'b1eb76f978c59032388f94ed'\n'parentDescription': Das Angular Training für Einsteiger:innen mit Manfred Steyer im zeitlich flexiblen Online-Format\n'indexBrandName': 'AngularCamp'\n'indexSeriesName': 'FlexibleBasicCamp'\n'author': 'Manfred Steyer'\n'chunkSource': 'text'\n'text': weiß man ganz genau, wo sich was geändert hat. Angular kann herausfinden, ah, die Komponente hat sich rechts unten geändert, also muss sich rechts unten aktualisieren und sonst nirgendwo. Das Ganze ist nicht ganz neu, oder? Wir haben ähnliche Mechanismen mit Observables, mit RxJS, mit Subjects. Ja, also sowas hat es schon zuvor gegeben. Allerdings sind Signals ganz bewusst sehr, sehr schlank implementiert. Sehr, sehr simpel. Die können wirklich nicht viel mehr als das hier. Andere Ansätze wie RxJS haben ganz, ganz viele Features und sind schon alleine deswegen nicht obsolet, aber das Ziel ist es halt, mit etwas Simplen zu starten. Und das Angular-Team glaubt, dass in den meisten Fällen diese simple Lösung ausreichend ist. Ja, und wenn ich halt mehr brauche, dann werde ich mir eine Library wie RxJS dazu installieren und habe dann mehr Komplexität, aber auch viel, viel mehr Features. Man möchte also die Standard-Fälle leicht, gewichtiger, einfacher gestalten. Wie schaut jetzt so eine Anwendung mit und ohne Signals aus? Na ja, starten wir vielleicht einmal mit der Variante ohne Signals. Sowas haben wir eh schon die ganze Zeit gemacht, da hat man Properties, die bekommen Werte. Die Werte werden vielleicht aktualisiert, weil ich aus dem Backend Daten abrufe und die Werte werden gebunden. Nach jedem Event-Handler prüft Angular, ob da jetzt da was zu aktualisieren ist. Ob die Schleife oder das If oder sonst irgendwas neu gerendert werden müssen. So schaut es klassischerweise aus. Wenn ich genau dasselbe mit Signals mache, dann muss ich halt alle Werte, die ich Daten binden möchte, in ein Signal einwickeln. Dazu gibt es die Hilfsfunktion Signal, die befindet sich seit Angular 16 im Namespace Angular Core. Da sieht man also schon, das Konzept ist ein integraler Bestandteil des Kerns von Angular. Die Funktion Signal kriegt einen Standardwert übergeben, Klammerauf, Klammerzu in dem Fall, also ein leeres Array. Und da Klammerauf, Klammerzu keine Typ-Informationen beinhaltet, gebe ich hier als Typparameter an, ich meine damit ein leeres Flugarray. Diesen Typparameter in den Spitzenklammern, den kann man sehr häufig weglassen, weil TypeScript sehr häufig aus dem Standardwert\n'slidetext': ''\n'from': 'vector'\n'score': 0.9222575426101685\n'normalizedScore': 0.9256754194518731\n'beforeDatePenaltyScore': 0.9222575426101685\n\n'documentId': '1fed2c6361980d606789e315'\n'chunk_id': '68c26fcc0a53cd001394ab92'\n'access': 'granted'\n'part_number': 2\n'total_parts': 8\n'contentType': 'READ'\n'title': Manfred Steyer on Angular 20: Signals, Dynamic Components, AI, and What’s Next - Exploring selectorless components, signal-based forms, and other features in Angular\n'parentName': iJS Magazine Volume 19\n'language': 'EN'\n'date': '2025-06-24T22:00:00.000Z'\n'abstract': In this interview, GDE Manfred Steyer highlights Angular’s journey towards a more reactive future. We discuss the framework’s strengths, challenges, and what’s ahead with the release of Angular 20.\n'parentId': 'a1269c65e87d5b8ebcde4b28'\n'parentDescription': Broaden your knowledge and expand your JavaScript techniques and practices. From Angular, React, and WebAssembly, to the best JavaScript IDEs, open source tools and more, you’ll learn insights on everything JS from seasoned experts in their field. Keep up with JavaScript news, tips, and advice with interviews, tutorials, and in-depth articles.\n'indexBrandName': ''\n'indexSeriesName': ''\n'author': 'Manfred Steyer'\n'chunkSource': 'text'\n'text': for new code, which simplifies the codebase. Additionally, the new lightweight reactivity system trims down unnecessary complexity. With these changes, Angular feels as lightweight as the other frameworks. Ines Chargui: Signals has received so much momentum lately, can you explain what it is and why it is getting so much attention? Manfred Steyer: The idea of Signals is to provide a very simple, reactive building block that holds a value. The value can be changed and tracked, meaning that someone can find out when the value is changing and then they can react accordingly. This someone is first and foremost Angular itself because Angular needs to know when something is changed in order to trigger a rendering, updating your view and your components. But another consumer of this reactivity can be the application itself. The application can recalculate something every time something else changes. Both have advantages. Angular’s ability to detect exactly when and where data changes occur makes it more efficient, as it avoids the need for broad dirty checking across the entire application. It allows us to optimize the whole change detection. For instance, we can easily switch to the change detection strategy.OnPush. Think of it like an Excel sheet: when one value changes, all dependent values update automatically. You no longer need to manually manage updates like “if this changes, then update that.” It just stays in sync. Those are the big two advantages. Some people may argue that this isn’t entirely new, since RxJS and observables have long provided similar capabilities. And that’s true, everything you can currently do with Signals can also be achieved with RxJS. However, the main idea behind Signals is simplicity. They make common use cases easier to implement. They’re not as powerful as observables, but they’re more well-suited for new developers. Of course, if you’re implementing something more difficult and complex, you can still use RxJS. Ines Chargui: What initially drew you to Angular? How did your Angular journey begin? Manfred Steyer: I think it was sometime between 2010 and 2012 when I realized how valuable it is to get a lot of stuff out-of-the-box. Working in the JavaScript ecosystem at the time often meant combining several tools and technologies. Back then, I used Knockout.js for data binding, some jQuery libraries for UI, and had to rely on a completely separate tool set for testing—none of which felt particularly well. Eventually, I switched to AngularJS. Although AngularJS was a different framework from the modern Angular we know today, I soon started exploring Angular 2 while it was still in its early alpha and beta\n'slidetext': ''\n'from': 'vector'\n'score': 0.9335132241249084\n'normalizedScore': 0.9259128361264305\n'beforeDatePenaltyScore': 0.9335132241249084\n\n'documentId': '651822c08be4e71b1d4a39ae'\n'chunk_id': '690d38f563a89a0013451893'\n'access': 'restricted'\n'part_number': 40\n'total_parts': 51\n'contentType': 'FLEX_CAMP'\n'title': Woche 2: Angular Pipes, NgModules & Subkomponenten: Meistern Sie die fortgeschrittenen Angular-Konzepte (Lektionen 4, 5 & 6) | verfügbar bis 27.02.2026\n'parentName': Angular Camp - Flexible Basic Camp Februar 2026 | online\n'language': 'DE'\n'date': '2026-02-09T00:00:00.000Z'\n'abstract': Weiter geht es in die zweite Woche! Hier behandeln wir 3 Lektionen. In diesem Kursteil erlangen Sie tiefere Einblicke in die fortgeschrittenen Konzepte von Angular und lernen, wie Sie Pipes, NgModules und Subkomponenten effektiv einsetzen, um Ihre Anwendungen zu optimieren. 4. Lektion: Pipes: Datenformatierung mit eigener Hand: - Lernen Sie, wie Sie eigene Pipes entwickeln, um Daten im Zuge der Datenbindung zu transformieren. - Pure Pipes im Fokus: Verstehen Sie das Konzept der reinen Pipes und ihre Bedeutung für die Anwendungsperformance. - In diesem kurzen Kapitel erfahren Sie alles zur Entwicklung eigener Pipes für das Transformieren von Daten im Zuge der Datenbindung, zum Konzept der reinen Pipes (engl. pure pipes) und warum es für die Anwendungsperformance wichtig ist. 5. Lektion: NgModules & Standalone Components in Angular: Alt und neu im Einklang Auch wenn NgModules seit der Einführung von Standalone Components weniger wichtig sind, existieren noch zahlreiche Codestrecken und Bibliotheken, die darauf aufbauen. Deswegen beschäftigen wir uns hier mit dem Zusammenspiel dieser beiden Konzepte. - NgModules verstehen: Obwohl Standalone Components an Bedeutung gewinnen, bleiben NgModules relevant. Erfahren Sie, wie diese beiden Konzepte zusammenspielen. - Codestrecken und Bibliotheken meistern: Navigieren Sie souverän durch Codestrecken und Bibliotheken, die auf NgModules basieren. 6. Lektion: Angular Subkomponenten & Datenbindung Erweitern Sie Ihre Angular-Fähigkeiten und lernen Sie, wie Sie Subkomponenten und Datenbindung effektiv einsetzen, um komplexe und skalierbare Anwendungen zu erstellen. Hier erfahren Sie Wissenswertes über die Entwicklung weiterer Komponenten, die über Datenbindung miteinander kommunizieren. Dazu werfen wir auch einen genaueren Blick unter die Motorhaube von Angular, um die Datenbindung besser zu verstehen. - Data Binding im Detail - Components and Data Bindung - Event Bindings - Smart vs. Dumb Components - Life Cycle Hooks - Bonus: Signals Auch hier haben Sie die Möglichkeit Ihr Wissen praktisch anzuwenden: Zu den Übungen Wir empfehlen in der zweiten Woche diese Lektionen zu bearbeiten.\n'parentId': '07bd3b1440c66d2e1f03033f'\n'parentDescription': Das Angular Training für Einsteiger:innen mit Manfred Steyer im zeitlich flexiblen Online-Format\n'indexBrandName': 'AngularCamp'\n'indexSeriesName': 'FlexibleBasicCamp'\n'author': 'Manfred Steyer'\n'chunkSource': 'text'\n'text': weiß man ganz genau, wo sich was geändert hat. Angular kann herausfinden, ah, die Komponente hat sich rechts unten geändert, also muss sich rechts unten aktualisieren und sonst nirgendwo. Das Ganze ist nicht ganz neu, oder? Wir haben ähnliche Mechanismen mit Observables, mit RxJS, mit Subjects. Ja, also sowas hat es schon zuvor gegeben. Allerdings sind Signals ganz bewusst sehr, sehr schlank implementiert. Sehr, sehr simpel. Die können wirklich nicht viel mehr als das hier. Andere Ansätze wie RxJS haben ganz, ganz viele Features und sind schon alleine deswegen nicht obsolet, aber das Ziel ist es halt, mit etwas Simplen zu starten. Und das Angular-Team glaubt, dass in den meisten Fällen diese simple Lösung ausreichend ist. Ja, und wenn ich halt mehr brauche, dann werde ich mir eine Library wie RxJS dazu installieren und habe dann mehr Komplexität, aber auch viel, viel mehr Features. Man möchte also die Standard-Fälle leicht, gewichtiger, einfacher gestalten. Wie schaut jetzt so eine Anwendung mit und ohne Signals aus? Na ja, starten wir vielleicht einmal mit der Variante ohne Signals. Sowas haben wir eh schon die ganze Zeit gemacht, da hat man Properties, die bekommen Werte. Die Werte werden vielleicht aktualisiert, weil ich aus dem Backend Daten abrufe und die Werte werden gebunden. Nach jedem Event-Handler prüft Angular, ob da jetzt da was zu aktualisieren ist. Ob die Schleife oder das If oder sonst irgendwas neu gerendert werden müssen. So schaut es klassischerweise aus. Wenn ich genau dasselbe mit Signals mache, dann muss ich halt alle Werte, die ich Daten binden möchte, in ein Signal einwickeln. Dazu gibt es die Hilfsfunktion Signal, die befindet sich seit Angular 16 im Namespace Angular Core. Da sieht man also schon, das Konzept ist ein integraler Bestandteil des Kerns von Angular. Die Funktion Signal kriegt einen Standardwert übergeben, Klammerauf, Klammerzu in dem Fall, also ein leeres Array. Und da Klammerauf, Klammerzu keine Typ-Informationen beinhaltet, gebe ich hier als Typparameter an, ich meine damit ein leeres Flugarray. Diesen Typparameter in den Spitzenklammern, den kann man sehr häufig weglassen, weil TypeScript sehr häufig aus dem Standardwert\n'slidetext': ''\n'from': 'vector'\n'score': 0.9222575426101685\n'normalizedScore': 0.9272096660272157\n'beforeDatePenaltyScore': 0.9222575426101685\n\n'documentId': 'e8463276c25a9a889f842e96'\n'chunk_id': '69118b500f4b7700138ebda4'\n'access': 'granted'\n'part_number': 1\n'total_parts': 4\n'contentType': 'READ'\n'title': What’s New in Angular 21? - Discover the key features, improvements, and changes coming with Angular 21\n'parentName': iJS Magazine Volume 22\n'language': 'EN'\n'date': '2025-12-16T23:00:00.000Z'\n'abstract': Angular 21 introduces a new era of efficiency and developer-friendly design. With experimental Signal Forms and default zoneless change detection, this release focuses on performance and reactivity. Explore how these updates shape the framework’s future and simplify everyday development.\n'parentId': 'b6ef74991ae60010a55b93d4'\n'parentDescription': Broaden your knowledge and expand your JavaScript techniques and practices. From Angular, React, and WebAssembly, to the best JavaScript IDEs, open source tools and more, you’ll learn insights on everything JS from seasoned experts in their field. Keep up with JavaScript news, tips, and advice with interviews, tutorials, and in-depth articles.\n'indexBrandName': ''\n'indexSeriesName': ''\n'author': 'Brygida Fiejdasz'\n'chunkSource': 'text'\n'text': What’s New in Angular 21? Discover the key features, improvements, and changes coming with Angular 21 Angular 21 introduces a new era of efficiency and developer-friendly design. With experimental Signal Forms and default zoneless change detection, this release focuses on performance and reactivity. Explore how these updates shape the framework’s future and simplify everyday development. Angular 21 introduces a new era of efficiency and developer-friendly design. With experimental Signal Forms and default zoneless change detection, this release focuses on performance and reactivity. Let's explore how these updates shape the framework’s future and simplify everyday development. If you’ve been following Angular’s journey, version 21 brings some fresh air with features that many developers have been waiting for. The long-awaited Signal Forms are finally arriving. Although they’re experimental, this feature gives a glimpse into a smoother, more reactive approach to handling forms in Angular. Meanwhile, zoneless change detection is now enabled by default, boosting the framework’s performance and making your life easier. Let’s go over some of the cool updates coming in Angular 21. Signal Forms Angular 21 introduces Signal Forms, an experimental but promising feature that offers a fresh, declarative, and reactive way to manage form state using signals. To better understand how Signal Forms work in practice, let’s walk through the basic steps of creating one, starting with defining your form’s state as a signal. crewMember = signal( { name: '', imageUrl: '', position: '' } ); crewForm = form(this.crewMember); This setup defines a signal holding the crew member’s model. You can then pass this model to Angular’s form() function to create the reactive form tree reflecting this structure. The next step is to bind individual signal form fields to your HTML elements using the Field directive. This directive creates a two-way binding between the input element and the form’s signal model. Any changes in the input automatically update the form state, and any updates to the model immediately reflect in the input. Using it is really straightforward: just add [field] to your input elements and assign the corresponding form field. Remember to import the Field directive in your component’s imports array; otherwise, Angular won’t recognize it.    …   \n\nName: {{ crewForm.name().value() }} \n\nPosition: {{ crewForm.position().value() }}   In this example, you can see inputs bound to the crewForm fields for name, image URL, and position. Just below, there’s a live preview\n'slidetext': ''\n'from': 'vector'\n'score': 0.9257361888885498\n'normalizedScore': 0.9277271250909851\n'beforeDatePenaltyScore': 0.9257361888885498\n\n'documentId': '1da46606f89dc3ccaa9c0f9d'\n'chunk_id': '690d456dd334ac0013d8cf18'\n'access': 'restricted'\n'part_number': 40\n'total_parts': 51\n'contentType': 'FLEX_CAMP'\n'title': Woche 2: Angular Pipes, NgModules & Subkomponenten: Meistern Sie die fortgeschrittenen Angular-Konzepte (Lektionen 4, 5 & 6) | verfügbar bis 27.03.2026\n'parentName': Angular Camp - Flexible Basic Camp März 2026 | online\n'language': 'DE'\n'date': '2026-03-09T00:00:00.000Z'\n'abstract': Weiter geht es in die zweite Woche! Hier behandeln wir 3 Lektionen. In diesem Kursteil erlangen Sie tiefere Einblicke in die fortgeschrittenen Konzepte von Angular und lernen, wie Sie Pipes, NgModules und Subkomponenten effektiv einsetzen, um Ihre Anwendungen zu optimieren. 4. Lektion: Pipes: Datenformatierung mit eigener Hand: - Lernen Sie, wie Sie eigene Pipes entwickeln, um Daten im Zuge der Datenbindung zu transformieren. - Pure Pipes im Fokus: Verstehen Sie das Konzept der reinen Pipes und ihre Bedeutung für die Anwendungsperformance. - In diesem kurzen Kapitel erfahren Sie alles zur Entwicklung eigener Pipes für das Transformieren von Daten im Zuge der Datenbindung, zum Konzept der reinen Pipes (engl. pure pipes) und warum es für die Anwendungsperformance wichtig ist. 5. Lektion: NgModules & Standalone Components in Angular: Alt und neu im Einklang Auch wenn NgModules seit der Einführung von Standalone Components weniger wichtig sind, existieren noch zahlreiche Codestrecken und Bibliotheken, die darauf aufbauen. Deswegen beschäftigen wir uns hier mit dem Zusammenspiel dieser beiden Konzepte. - NgModules verstehen: Obwohl Standalone Components an Bedeutung gewinnen, bleiben NgModules relevant. Erfahren Sie, wie diese beiden Konzepte zusammenspielen. - Codestrecken und Bibliotheken meistern: Navigieren Sie souverän durch Codestrecken und Bibliotheken, die auf NgModules basieren. 6. Lektion: Angular Subkomponenten & Datenbindung Erweitern Sie Ihre Angular-Fähigkeiten und lernen Sie, wie Sie Subkomponenten und Datenbindung effektiv einsetzen, um komplexe und skalierbare Anwendungen zu erstellen. Hier erfahren Sie Wissenswertes über die Entwicklung weiterer Komponenten, die über Datenbindung miteinander kommunizieren. Dazu werfen wir auch einen genaueren Blick unter die Motorhaube von Angular, um die Datenbindung besser zu verstehen. - Data Binding im Detail - Components and Data Bindung - Event Bindings - Smart vs. Dumb Components - Life Cycle Hooks - Bonus: Signals Auch hier haben Sie die Möglichkeit Ihr Wissen praktisch anzuwenden: Zu den Übungen Wir empfehlen in der zweiten Woche diese Lektionen zu bearbeiten.\n'parentId': 'a35ba82dd72cb1cbd49bc4b5'\n'parentDescription': Das Angular Training für Einsteiger:innen mit Manfred Steyer im zeitlich flexiblen Online-Format\n'indexBrandName': 'AngularCamp'\n'indexSeriesName': 'FlexibleBasicCamp'\n'author': 'Manfred Steyer'\n'chunkSource': 'text'\n'text': weiß man ganz genau, wo sich was geändert hat. Angular kann herausfinden, ah, die Komponente hat sich rechts unten geändert, also muss sich rechts unten aktualisieren und sonst nirgendwo. Das Ganze ist nicht ganz neu, oder? Wir haben ähnliche Mechanismen mit Observables, mit RxJS, mit Subjects. Ja, also sowas hat es schon zuvor gegeben. Allerdings sind Signals ganz bewusst sehr, sehr schlank implementiert. Sehr, sehr simpel. Die können wirklich nicht viel mehr als das hier. Andere Ansätze wie RxJS haben ganz, ganz viele Features und sind schon alleine deswegen nicht obsolet, aber das Ziel ist es halt, mit etwas Simplen zu starten. Und das Angular-Team glaubt, dass in den meisten Fällen diese simple Lösung ausreichend ist. Ja, und wenn ich halt mehr brauche, dann werde ich mir eine Library wie RxJS dazu installieren und habe dann mehr Komplexität, aber auch viel, viel mehr Features. Man möchte also die Standard-Fälle leicht, gewichtiger, einfacher gestalten. Wie schaut jetzt so eine Anwendung mit und ohne Signals aus? Na ja, starten wir vielleicht einmal mit der Variante ohne Signals. Sowas haben wir eh schon die ganze Zeit gemacht, da hat man Properties, die bekommen Werte. Die Werte werden vielleicht aktualisiert, weil ich aus dem Backend Daten abrufe und die Werte werden gebunden. Nach jedem Event-Handler prüft Angular, ob da jetzt da was zu aktualisieren ist. Ob die Schleife oder das If oder sonst irgendwas neu gerendert werden müssen. So schaut es klassischerweise aus. Wenn ich genau dasselbe mit Signals mache, dann muss ich halt alle Werte, die ich Daten binden möchte, in ein Signal einwickeln. Dazu gibt es die Hilfsfunktion Signal, die befindet sich seit Angular 16 im Namespace Angular Core. Da sieht man also schon, das Konzept ist ein integraler Bestandteil des Kerns von Angular. Die Funktion Signal kriegt einen Standardwert übergeben, Klammerauf, Klammerzu in dem Fall, also ein leeres Array. Und da Klammerauf, Klammerzu keine Typ-Informationen beinhaltet, gebe ich hier als Typparameter an, ich meine damit ein leeres Flugarray. Diesen Typparameter in den Spitzenklammern, den kann man sehr häufig weglassen, weil TypeScript sehr häufig aus dem Standardwert\n'slidetext': ''\n'from': 'vector'\n'score': 0.9222575426101685\n'normalizedScore': 0.9287439126025581\n'beforeDatePenaltyScore': 0.9222575426101685\n\n'documentId': '8b35e3d0070110b78d6c9434'\n'chunk_id': '687a2210d92aed38f5a4a5b4'\n'access': 'granted'\n'part_number': 3\n'total_parts': 9\n'contentType': 'READ'\n'title': Angular: Signals, Standalone, SSR - So bauen Sie Angular-Apps der Zukunft\n'parentName': Windows Developer 7.2024\n'language': 'DE'\n'date': '2024-06-10T22:00:00.000Z'\n'abstract': Mit der Veröffentlichung der 16. Hauptversion von Angular läutete das Angular-Team die „Angular Renaissance“ ein. Wörtlich übersetzt bedeutet das nichts Geringeres als die Wiedergeburt von Googles SPA-Framework - eine treffende Bezeichnung, denn Angular-Codebasen werden sich nachhaltig verändern. Der Unterschied zwischen Angular-2- und Angular-17-Code ist mit bloßem Auge erkennbar.\n'parentId': 'b662818c73a937b86282ae99'\n'parentDescription': Windows Developer informiert umfassend und herstellerneutral über die neuen Trends und Möglichkeiten der Software- und Systementwicklung rund um Microsoft- und Web-Technologien. Von der klassischen .NET-Entwicklung über .NET Core bis hin zu neuen Technologien wie Windows 10, Microsoft Azure und der ganzen Bandbreite der aktuellen Web-, Phone- und Tabletentwicklung für Android und iOS mit Xamarin und unterschiedlichen JavaScript-Frameworks. Professionelle Entwickler und IT-Entscheider erhalten genau die Informationen, die sie für den erfolgreichen Einsatz von unternehmensorientierten Lösungen benötigen.\n'indexBrandName': ''\n'indexSeriesName': ''\n'author': 'Christian Liebel'\n'chunkSource': 'text'\n'text': diese nimmt einen Callback entgegen, der aufgerufen wird, sobald sich die darin enthaltenen Signals ändern. Das letzte Codebeispiel zeigt die Verwendung dieser Methode: Wann immer sich das Signal doubleCount ändert, wird eine Logausgabe auf der Konsole ausgeführt. Voraussetzung dafür ist, dass die effect()-Methode innerhalb eines Injection Context aufgerufen wird, also überall dort, wo auch die inject()-Methode genutzt werden kann, etwa im Konstruktor. Abb. 1: Dank Signals sind Änderungsquellen genau bekannt und könnten in Zukunft eine deutlich effizientere Änderungsnachverfolgung in Angular erlauben Signals könnten in Zukunft die Performance von Angular-Anwendungen erheblich verbessern. Derzeit basiert die Änderungsnachverfolgung von Angular noch auf der Bibliothek zone.js. Diese versucht auf sämtliche asynchrone Ereignisse innerhalb des Browsers zu reagieren und prüft danach standardmäßig alle Komponenten innerhalb der Anwendung auf Änderungen. Da mit Signals die genaue Änderungsquelle bekannt ist, kann in Zukunft eine deutlich effizientere Change Detection implementiert werden. Dann muss nicht mehr die gesamte Anwendung geprüft werden, sondern nur noch die Komponenten, bei denen sich tatsächlich eine Änderung ergibt (Abb. 1). zone.js optional zu machen, ist ein festes Ziel des Angular-Teams. Während signal() und computed() als stabil markiert sind, befindet sich die effect()-Methode noch in der Entwicklervorschau (Developer Preview). Das Angular-Team behält sich also vor, diese Schnittstelle noch einmal anzupassen, bevor sie als stabil markiert wird. Signals und RxJS Signals verhalten sich also ähnlich wie BehaviorSubjects und allgemein Observables aus RxJS – dennoch ist die Signals-Schnittstelle deutlich vereinfacht, denn unter anderem gibt es keine Operatoren. Das soll den Einstieg in Angular vereinfachen: Neue Entwickler:innen sollen neben den Frameworkkonzepten nicht auch gleich noch die Spezifika einer so umfangreichen Bibliothek wie RxJS lernen müssen. Umgekehrt können Signals aber nicht den kompletten Funktionsumfang abdecken, den RxJS bietet: So muss jedes Signal immer zwingend mit einem Wert vorbelegt sein. Bei Observables könnte dieser auch erst nachträglich (asynchron) emittiert werden. Komplexe Konstrukte, die sich bei RxJS hinter einem einfachen Operator verbergen wie debounceTime, also zum Ignorieren von Änderungen während eines bestimmten\n'slidetext': ''\n'from': 'index'\n'score': 120.14299011230469\n'normalizedScore': 1.201429901123047\n'beforeDatePenaltyScore': 1.201429901123047\n\n'documentId': '8b35e3d0070110b78d6c9434'\n'chunk_id': '687a2212d92aed38f5a4a5c3'\n'access': 'granted'\n'part_number': 9\n'total_parts': 9\n'contentType': 'READ'\n'title': Angular: Signals, Standalone, SSR - So bauen Sie Angular-Apps der Zukunft\n'parentName': Windows Developer 7.2024\n'language': 'DE'\n'date': '2024-06-10T22:00:00.000Z'\n'abstract': Mit der Veröffentlichung der 16. Hauptversion von Angular läutete das Angular-Team die „Angular Renaissance“ ein. Wörtlich übersetzt bedeutet das nichts Geringeres als die Wiedergeburt von Googles SPA-Framework - eine treffende Bezeichnung, denn Angular-Codebasen werden sich nachhaltig verändern. Der Unterschied zwischen Angular-2- und Angular-17-Code ist mit bloßem Auge erkennbar.\n'parentId': 'b662818c73a937b86282ae99'\n'parentDescription': Windows Developer informiert umfassend und herstellerneutral über die neuen Trends und Möglichkeiten der Software- und Systementwicklung rund um Microsoft- und Web-Technologien. Von der klassischen .NET-Entwicklung über .NET Core bis hin zu neuen Technologien wie Windows 10, Microsoft Azure und der ganzen Bandbreite der aktuellen Web-, Phone- und Tabletentwicklung für Android und iOS mit Xamarin und unterschiedlichen JavaScript-Frameworks. Professionelle Entwickler und IT-Entscheider erhalten genau die Informationen, die sie für den erfolgreichen Einsatz von unternehmensorientierten Lösungen benötigen.\n'indexBrandName': ''\n'indexSeriesName': ''\n'author': 'Christian Liebel'\n'chunkSource': 'text'\n'text': Zeitpunkt überhaupt nicht möglich ist. Ferner ist zu beachten, dass sich die Outputpfade des Build verändern und eventuell bestehende Build Pipelines angepasst werden müssen. Nicht jeder braucht SSR Im Gegensatz zu Signals und Standalone APIs ist SSR kein zwingend gebotenes Update. Ob die Verwendung von SSR im Projekt sinnvoll ist, muss im Einzelfall betrachtet werden, denn die Voraussetzungen sind recht hoch: SSR mit Authentifizierung bereitzustellen führt zu einem hohen Aufwand. Angular i18n wird mit Hydration derzeit nicht unterstützt. Ferner müssen für Hydration sämtliche Komponenten dafür gebaut worden sein und sämtliche DOM-Zugriffe über Angular geschehen. Das ist bei Bibliotheken wie D3.js oder Grid-Komponenten von Drittherstellern nicht der Fall. Die Deaktivierung von Hydration ist für diese Komponenten zwar möglich, damit gehen aber auch die Vorteile dieses Ansatzes verloren. Kurzum erscheint SSR für Projekte sinnvoll, die eher kleineren Umfangs und öffentlich zugänglich sind. Für neue Projekte fragt das Angular CLI schon bei der Erstellung nach, ob SSR aktiviert werden soll, standardmäßig ist es deaktiviert. Für Bestandsprojekte kann SSR durch die Ausführung des Kommandos ng add @angular/ssr nachträglich aktiviert werden. Die Angular-Renaissance ist eine gute Nachricht für Entwickler:innen Angular macht derzeit bedeutende Fortschritte, ohne dabei die Abwärtskompatibilität zu vernachlässigen. Besonders hervorzuheben sind die Verbesserungen der Developer Experience sowie die möglichen Leistungssteigerungen bei Build- und Laufzeitperformance. Durch diese Verbesserungen bleiben Ihre Anwender:innen und Entwickler:innen zufrieden und Ihre Angular-Apps laufen flüssiger denn je. Um technische Schulden zu vermeiden, ist es ratsam, schnellstmöglich auf neue Angular-Versionen und die neuen Features zu migrieren. Links & Literatur [1] https://angular.dev/guide/signals [2] https://angular.io/guide/signal-inputs [3] https://angular.io/guide/signal-queries [4] https://github.com/angular/angular/issues/54808 [5] https://angular.io/guide/standalone-components [6] https://angular.dev/reference/migrations/standalone [7] https://angular.io/guide/ssr [8] https://angular.io/guide/esbuild\n'slidetext': ''\n'from': 'index'\n'score': 118.82921600341797\n'normalizedScore': 1.1882921600341796\n'beforeDatePenaltyScore': 1.1882921600341796\n\n'documentId': 'eba6f5d083b14f4d8d53d87a'\n'chunk_id': '687ad1baeb1b160a4cabaea8'\n'access': 'granted'\n'part_number': 3\n'total_parts': 9\n'contentType': 'READ'\n'title': Was ist neu in Angular 16? Signals, Hydration, esbuild und mehr - Kolumne: Enterprise Angular\n'parentName': Windows Developer 7.2023\n'language': 'DE'\n'date': '2023-06-13T00:00:00.000Z'\n'abstract': Mit Angular 16 kommen gleich zwei große Neuerungen: Signals und Non-destructive Hydration. Außerdem gibt es zahlreiche Abrundungen, die das Arbeiten mit dem Framework vereinfachen. In diesem Artikel gehe ich anhand von Beispielen auf die wichtigsten Neuerungen ein. Den Quellcode findet man im Branch ng16-features auf GitHub [1].\n'parentId': '8d98b5cda2e54cc436ac50d8'\n'parentDescription': Windows Developer informiert umfassend und herstellerneutral über die neuen Trends und Möglichkeiten der Software- und Systementwicklung rund um Microsoft- und Web-Technologien. Von der klassischen .NET-Entwicklung über .NET Core bis hin zu neuen Technologien wie Windows 10, Microsoft Azure und der ganzen Bandbreite der aktuellen Web-, Phone- und Tabletentwicklung für Android und iOS mit Xamarin und unterschiedlichen JavaScript-Frameworks. Professionelle Entwickler und IT-Entscheider erhalten genau die Informationen, die sie für den erfolgreichen Einsatz von unternehmensorientierten Lösungen benötigen.\n'indexBrandName': ''\n'indexSeriesName': ''\n'author': 'Manfred Steyer'\n'chunkSource': 'text'\n'text': Hektik: Bestandscode muss nicht zwingend migriert werden. RxJS Interop Signals und RxJS weisen einige Gemeinsamkeiten auf, zumal beide reaktive Anwendungen ermöglichen. Im Gegensatz zu RxJS wurden Signals jedoch bewusst sehr einfach gehalten. Das primäre Ziel ist die Unterstützung der Change Detection. Der ab Version 16 mit Angular ausgelieferte RxJS-Interop-Layer erlaubt es, die Einfachheit von Signals mit den vielen und teils komplexen Möglichkeiten von RxJS zu kombinieren. Der Interop-Layer befindet sich im Namensraum @angular/core/rxjs-interop und bietet Funktionen zum Umwandeln von Signals in Observables und vice versa (Listing 3). Listing 3 import { toObservable, toSignal } from '@angular/core/rxjs-interop'; [...] from = signal('Hamburg'); to = signal('Graz'); from$ = toObservable(this.from); to$ = toObservable(this.to); flights$ = combineLatest({ from: this.from$, to: this.to$ }).pipe( debounceTime(300), tap(() => this.loading.set(true)), switchMap((combi) => this.flightService.find(combi.from, combi.to)), tap(() => this.loading.set(false)) ); flights = toSignal(this.flights$, { initialValue: [] }); Die Funktion toObservable überführt die Signals from und to in entsprechende Observables. Das ermöglicht die Nutzung von RxJS-basierten Operatoren, wie combineLatest, debounceTime und switchMap. Das Ergebnis ist ein Observable, das Arrays mit Flight-Objekten liefert. Die Funktion toSignal erzeugt ein darauf basierendes Signal. Da ein Signal im Gegensatz zu einem Observable immer einen Wert aufweist, legt das Beispiel einen Initialwert fest. Stattdessen könnte der Aufrufer der Funktion toSignal auch versichern, dass das Observable synchron einen Initialwert veröffentlicht. Dazu ist die Eigenschaft requireSync auf true zu setzen: flights = toSignal(this.flights$, { requireSync: true }); In beiden Fällen leitet toSignal die Typisierung des Signal vom Observable ab. Im gezeigten Fall ergibt sich ein Signal. Kommen weder initialValue noch requireSync zum Einsatz, nimmt toSignal den Typ undefined in die Typisierung auf. Somit würde sich hier ein Signal ergeben, das undefined als Initialwert aufweist. Auch Signals, die auf Observables basieren, sind an die Lebenszeitspanne des nutzenden Building Block – zum Beispiel der jeweiligen Komponente oder des jeweiligen Service – gebunden. Bei Observables, die auf Signals basieren, ist das jedoch nicht so. Das Angular-Team wollte das von RxJS gewohnte Verhalten nicht ändern. Wer\n'slidetext': ''\n'from': 'index'\n'score': 123.6031265258789\n'normalizedScore': 1.236031265258789\n'beforeDatePenaltyScore': 1.236031265258789\n\n'documentId': 'eba6f5d083b14f4d8d53d87a'\n'chunk_id': '687ad1b9eb1b160a4cabaea6'\n'access': 'granted'\n'part_number': 2\n'total_parts': 9\n'contentType': 'READ'\n'title': Was ist neu in Angular 16? Signals, Hydration, esbuild und mehr - Kolumne: Enterprise Angular\n'parentName': Windows Developer 7.2023\n'language': 'DE'\n'date': '2023-06-13T00:00:00.000Z'\n'abstract': Mit Angular 16 kommen gleich zwei große Neuerungen: Signals und Non-destructive Hydration. Außerdem gibt es zahlreiche Abrundungen, die das Arbeiten mit dem Framework vereinfachen. In diesem Artikel gehe ich anhand von Beispielen auf die wichtigsten Neuerungen ein. Den Quellcode findet man im Branch ng16-features auf GitHub [1].\n'parentId': '8d98b5cda2e54cc436ac50d8'\n'parentDescription': Windows Developer informiert umfassend und herstellerneutral über die neuen Trends und Möglichkeiten der Software- und Systementwicklung rund um Microsoft- und Web-Technologien. Von der klassischen .NET-Entwicklung über .NET Core bis hin zu neuen Technologien wie Windows 10, Microsoft Azure und der ganzen Bandbreite der aktuellen Web-, Phone- und Tabletentwicklung für Android und iOS mit Xamarin und unterschiedlichen JavaScript-Frameworks. Professionelle Entwickler und IT-Entscheider erhalten genau die Informationen, die sie für den erfolgreichen Einsatz von unternehmensorientierten Lösungen benötigen.\n'indexBrandName': ''\n'indexSeriesName': ''\n'author': 'Manfred Steyer'\n'chunkSource': 'text'\n'text': übergeben. Die Methode search liest und aktualisiert diese Signals. Dazu kommen Getter und Setter zum Einsatz. Um den Getter aufzurufen, wird das Signal wie eine Funktion behandelt. Den Setter bietet das Signal in Form einer Methode set an. Listing 1 erzeugt auch ein berechnetes Signal mit der Funktion computed. Das Signal aktualisiert die als Lambdaausdruck übergebene Berechnung, wenn sich eines der verwendeten Signals ändert. Der Rückgabewert von computed ist vom Typ Signal. Im Gegensatz zum zuvor erwähnten WritableSignal ist dieses read-only. Der Konstruktor in Listing 1 definiert mit der Funktion effect einen Seiteneffekt. Immer, wenn sich eines der darin verwendeten Signals ändert, kommt der übergebene Lambdaausdruck erneut zur Ausführung. Signals, die in aufgerufenen Methoden wie search zum Einsatz kommen, berücksichtigen effect auf dieselbe Weise. Das Template der Komponente bindet sich an die Signals (Listing 2). Listing 2   {{ flightRoute() }}      Änderungen an Signals führen dazu, dass Angular die Change Detection anstößt und die Ansicht im Browser aktualisiert. Dieses Verhalten gleicht dem von Observables, die mit der Async Pipe ans Template gebunden werden. Deswegen lässt sich auch beim Einsatz von Signals die Change Detection-Strategie OnPush zur Verbesserung der Performance aktivieren. Künftige Angular-Versionen werden jedoch noch einen Schritt weitergehen und eine feingranulare Change Detection anbieten. Die soll es erlauben, Teile von Templates anstatt ganzer Templates zu aktualisieren. Anders als bei Observables müssen sich Konsumenten nicht bei Signals abmelden (unsubscribe). Konsumiert der Code einer Komponente oder ein Template ein Signal, findet die Abmeldung automatisch beim Zerstören der Komponente statt. Dasselbe gilt für die Nutzung innerhalb anderer Angular-basierter Building Blocks wie Services oder Direktiven – der Konsument ist an die Lebensdauer des jeweiligen Building-Blocks gebunden. In Version 16 liegen Signals erst einmal als Developer-Preview vor. Das bedeutet, dass sie sich in künftigen Versionen noch ändern können. Wie schon bei Standalone Components werden auch Signals mit bestehendem Code zusammenspielen. Es gibt also keinen Grund zur Hektik:\n'slidetext': ''\n'from': 'index'\n'score': 123.41246795654297\n'normalizedScore': 1.2341246795654297\n'beforeDatePenaltyScore': 1.2341246795654297\n\n'documentId': '8b35e3d0070110b78d6c9434'\n'chunk_id': '687a2210d92aed38f5a4a5af'\n'access': 'granted'\n'part_number': 1\n'total_parts': 9\n'contentType': 'READ'\n'title': Angular: Signals, Standalone, SSR - So bauen Sie Angular-Apps der Zukunft\n'parentName': Windows Developer 7.2024\n'language': 'DE'\n'date': '2024-06-10T22:00:00.000Z'\n'abstract': Mit der Veröffentlichung der 16. Hauptversion von Angular läutete das Angular-Team die „Angular Renaissance“ ein. Wörtlich übersetzt bedeutet das nichts Geringeres als die Wiedergeburt von Googles SPA-Framework - eine treffende Bezeichnung, denn Angular-Codebasen werden sich nachhaltig verändern. Der Unterschied zwischen Angular-2- und Angular-17-Code ist mit bloßem Auge erkennbar.\n'parentId': 'b662818c73a937b86282ae99'\n'parentDescription': Windows Developer informiert umfassend und herstellerneutral über die neuen Trends und Möglichkeiten der Software- und Systementwicklung rund um Microsoft- und Web-Technologien. Von der klassischen .NET-Entwicklung über .NET Core bis hin zu neuen Technologien wie Windows 10, Microsoft Azure und der ganzen Bandbreite der aktuellen Web-, Phone- und Tabletentwicklung für Android und iOS mit Xamarin und unterschiedlichen JavaScript-Frameworks. Professionelle Entwickler und IT-Entscheider erhalten genau die Informationen, die sie für den erfolgreichen Einsatz von unternehmensorientierten Lösungen benötigen.\n'indexBrandName': ''\n'indexSeriesName': ''\n'author': 'Christian Liebel'\n'chunkSource': 'text'\n'text': Angular: Signals, Standalone, SSR So bauen Sie Angular-Apps der Zukunft Mit der Veröffentlichung der 16. Hauptversion von Angular läutete das Angular-Team die „Angular Renaissance“ ein. Wörtlich übersetzt bedeutet das nichts Geringeres als die Wiedergeburt von Googles SPA-Framework - eine treffende Bezeichnung, denn Angular-Codebasen werden sich nachhaltig verändern. Der Unterschied zwischen Angular-2- und Angular-17-Code ist mit bloßem Auge erkennbar. Mit der Veröffentlichung der 16. Hauptversion von Angular läutete das Angular-Team die „Angular Renaissance“ ein. Wörtlich übersetzt bedeutet das nichts Geringeres als die Wiedergeburt von Googles SPA-Framework – eine treffende Bezeichnung, denn Angular-Codebasen werden sich nachhaltig verändern. Der Unterschied zwischen Angular-2- und Angular-17-Code ist mit bloßem Auge erkennbar. Derzeit führt das Angular-Team zahlreiche neue Features und Konzepte in das Framework ein. Ziel dieser Änderungen ist, Angular zu vereinfachen und damit Anfänger:innen den Einstieg zu erleichtern, Schnittstellen zu modernisieren und die Performance von Angular-Anwendungen zu verbessern, damit das Framework auch im kommenden Jahrzehnt seines Bestehens konkurrenzfähig bleibt. Alle neuen Funktionen sind abwärtskompatibel und interoperabel. In diesem Artikel soll es um drei dieser Features gehen: 1. den neuen reaktiven Basisdatentyp Signals, 2. die Standalone-Schnittstellen als NgModule-Killer und 3. den neuen Ansatz zum Server-side Rendering, der es in die 17. Hauptversion von Angular geschafft hat. Angular-Entwickler:innen, die neue Anwendungen erstellen, sollten diese Features in jedem Fall berücksichtigen. Bestandsanwendungen sollten schnellstmöglich migriert werden. In diesem Artikel wird zu jedem Feature angegeben, ob, wann und wie eine Migration vorgenommen werden sollte. Signals – Die neue Art des State Management Mit der 16. Hauptversion von Angular wurden Signals in das Framework eingeführt. Es handelt sich um den neuen reaktiven Basisdatentyp [1]. Ein Signal ist ein Wrapper um einen bestimmten Wert. Wenn sich dieser ändert, informiert das Signal interessierte Konsumenten, sodass diese auf die Änderung reagieren können. const count = signal(0); count.set(3); Ein neues schreibbares Signal lässt sich über die Methode signal() erzeugen. Signals müssen zwingend mit einem Initialwert vorbelegt sein, der als Argument angegeben wird. Es ist\n'slidetext': ''\n'from': 'index'\n'score': 122.15689849853516\n'normalizedScore': 1.2215689849853515\n'beforeDatePenaltyScore': 1.2215689849853515\n\n'documentId': 'eba6f5d083b14f4d8d53d87a'\n'chunk_id': '687ad1b9eb1b160a4cabaea5'\n'access': 'granted'\n'part_number': 1\n'total_parts': 9\n'contentType': 'READ'\n'title': Was ist neu in Angular 16? Signals, Hydration, esbuild und mehr - Kolumne: Enterprise Angular\n'parentName': Windows Developer 7.2023\n'language': 'DE'\n'date': '2023-06-13T00:00:00.000Z'\n'abstract': Mit Angular 16 kommen gleich zwei große Neuerungen: Signals und Non-destructive Hydration. Außerdem gibt es zahlreiche Abrundungen, die das Arbeiten mit dem Framework vereinfachen. In diesem Artikel gehe ich anhand von Beispielen auf die wichtigsten Neuerungen ein. Den Quellcode findet man im Branch ng16-features auf GitHub [1].\n'parentId': '8d98b5cda2e54cc436ac50d8'\n'parentDescription': Windows Developer informiert umfassend und herstellerneutral über die neuen Trends und Möglichkeiten der Software- und Systementwicklung rund um Microsoft- und Web-Technologien. Von der klassischen .NET-Entwicklung über .NET Core bis hin zu neuen Technologien wie Windows 10, Microsoft Azure und der ganzen Bandbreite der aktuellen Web-, Phone- und Tabletentwicklung für Android und iOS mit Xamarin und unterschiedlichen JavaScript-Frameworks. Professionelle Entwickler und IT-Entscheider erhalten genau die Informationen, die sie für den erfolgreichen Einsatz von unternehmensorientierten Lösungen benötigen.\n'indexBrandName': ''\n'indexSeriesName': ''\n'author': 'Manfred Steyer'\n'chunkSource': 'text'\n'text': Was ist neu in Angular 16? Signals, Hydration, esbuild und mehr Kolumne: Enterprise Angular Mit Angular 16 kommen gleich zwei große Neuerungen: Signals und Non-destructive Hydration. Außerdem gibt es zahlreiche Abrundungen, die das Arbeiten mit dem Framework vereinfachen. In diesem Artikel gehe ich anhand von Beispielen auf die wichtigsten Neuerungen ein. Den Quellcode findet man im Branch ng16-features auf GitHub [1]. Mit Angular 16 kommen gleich zwei große Neuerungen: Signals und Non-destructive Hydration. Außerdem gibt es zahlreiche Abrundungen, die das Arbeiten mit dem Framework vereinfachen. In diesem Artikel gehe ich anhand von Beispielen auf die wichtigsten Neuerungen ein. Den Quellcode findet man im Branch ng16-features auf GitHub [1]. Signals Die wohl größte Neuerung in Angular 16 sind Signals. Dabei handelt es sich um einen simplen reaktiven Building Block, der künftig eine feingranulare Change Detection ohne Zone.js ermöglichen soll. Ein Signal ist ein Objekt, das einen Wert aufnimmt. Konsumenten können diesen Wert lesen und aktualisieren. Außerdem können sie sich informieren lassen, wenn sich der Wert ändert (Abb. 1). Abb. 1: Signals Bindet sich das Template einer Komponente an ein Signal, stößt Angular die Change Detection an, sobald sich das Signal ändert. Ein Beispiel dafür findet sich in Listing 1, in dem alle zu bindenden Eigenschaften from, to und flights als Signals vorliegen. Listing 1 import { computed, effect, signal } from '@angular/core'; [...] @Component([…]) export class FlightSearchComponent implements OnInit { from = signal('Hamburg'); // in Germany to = signal('Graz'); // in Austria flights = signal([]); flightRoute = computed(() => this.from() + ' to ' + this.to()); constructor() { effect(() => { this.search(); }); } async search() { if (!this.from() || !this.to()) return; const flights = await this.flightService.findPromise( this.from(), this.to() ); this.flights.set(flights); } } Um das Erzeugen der Signals kümmert sich die Funktion signal, die das Angular-Team im Paket @angular/core platziert hat. Diese Funktion liefert ein sogenanntes WritableSignal, also ein Signal, das der Programmcode nicht nur lesen, sondern auch aktualisieren kann. T steht für den Typ des verwalteten Werts. In den meisten Fällen kann signal diesen Typ aus dem übergebenen Standardwert herleiten. Falls nicht, ist ein Typparameter wie bei der Eigenschaft flight an signal zu übergeben.\n'slidetext': ''\n'from': 'index'\n'score': 124.51710510253906\n'normalizedScore': 1.2451710510253906\n'beforeDatePenaltyScore': 1.2451710510253906\n\n'documentId': '64ace3828d8056484c3534ab'\n'chunk_id': '687814c5bed6dcd41a99b027'\n'access': 'granted'\n'part_number': 15\n'total_parts': 21\n'contentType': 'READ'\n'title': Angular 16 released - Alles zu neuen Features und Breaking Changes\n'parentName': iJS Magazin Band 27\n'language': 'DE'\n'date': '2023-04-06T00:00:00.000Z'\n'abstract': Wir geben einen Überblick zu allen wichtigen Infos zum Release von Angular 16. Alles zu Signals, der Angular-CLI und TypeScript in Angular 16 erfahren Sie hier.\n'parentId': '5093fc7a779ccfe852d8fe7b'\n'parentDescription': Kaum ein Softwareprojekt, das nicht in wesentlichen Teilen auf der JavaScript-Technologie basiert. Eine breite Unterstützung sowie, leistungsfähige Programmiersprachen, die Vielzahl moderner Tools, sowie ausgereifte Frameworks wie Angular, React, Vue.js oder Node.js machen den JavaScript-Werkzeugkasten zu einem Alleskönner. Das iJS Magazin informiert aktuell und umfassend über die wichtige und innovative Entwicklungen im JavaScript-Universum und bietet handfeste Praxisinformationen für Softwareentwickler und -architekten.\n'indexBrandName': ''\n'indexSeriesName': ''\n'author': 'Karsten Sitterberg'\n'chunkSource': 'text'\n'text': die technische, aber auch die konzeptionelle Komplexität reduziert werden. Gleichzeitig hat das Thema auch etwas Beigeschmack: Die offiziellen Diskussionen wurden erst ca. drei Wochen vor Verabschiedung des ersten Release-Candidate von Angular 16 öffentlich gestartet. Bei einer Entwicklungszeit von sechs Monaten und den potenziell immensen Konsequenzen einer solchen Designänderung wirkt das schon sehr kurzfristig. Kritische Kommentare in den RFC Diskussionen wurden zudem sehr diplomatisch abgetan, es wirkt, als sei sowieso alles intern durch das Angular-Team und Google entschieden worden. Assoziationen mit Paris 2016 sind dabei nicht ganz unbegründet. So ein Vorgehen stellt ein ernstzunehmendes Risiko für die Angular-Community dar. Ob Angular damit wirklich konzeptionell simpler wird, solange der mitgelieferte HttpClient RxJS verwendet, darf auch bezweifelt werden. Schließlich kommen Entwickler so zwangsläufig mit beiden Konzepten in Kontakt. Aber vielleicht wird ja auch drei Wochen vor dem ersten Release Candidate von Angular 17 der HttpClient mit demselben Argument abgekündigt. Auch wenn es sich also um vielversprechende Visionen und fast schon eine neue Generation Angular handelt - etwas mehr Fingerspitzengefühl und Transparenz wären hier wünschenswert. Technisch handelt es sich bei den Signals um eine Reactivity-Engine, mit der Änderungen am Zustand von speziellen Daten-Objekten zu Updates der zugehörigen DOM-Elemente führen. Anders als Promises und RxJS-Observable sind Aktionen auf “Signals” stets synchron. Da Webanwendungen inhärent durch Events getrieben sind, passt RxJS prinzipiell sehr gut. Daher gibt es zur Transformation zwischen Signals und Observables das neue Paket @angular/rxjs-interop, das Transformations-APIs wie ‘toObservable()’ und ‘toSignal()’ zur Verfügung stellt. Ein Signal kann einfach erzeugt werden, indem die neue Funktion signal() aufgerufen wird. Der Typ-Parameter T steht dabei für den Datentypen, der von diesem Signal “verwaltet” werden soll. In Listing 19 ist anhand des Signal counter zu sehen, dass der Typ eines Signal auch durch Definition eines Initialwertes, hier die Zahl 0, festlegen kann. Ausgelesen wird das Signal dann, indem es wie eine Funktion aufgerufen wird. Das ist beispielsweise im Template der Komponente aus Listing 19 gezeigt. Normalerweise sollte bei Ausgaben in Templates\n'slidetext': ''\n'from': 'index'\n'score': 125.90798950195312\n'normalizedScore': 1.2590798950195312\n'beforeDatePenaltyScore': 1.2590798950195312\n\n'documentId': '64ace3828d8056484c3534ab'\n'chunk_id': '687814c6bed6dcd41a99b02a'\n'access': 'granted'\n'part_number': 18\n'total_parts': 21\n'contentType': 'READ'\n'title': Angular 16 released - Alles zu neuen Features und Breaking Changes\n'parentName': iJS Magazin Band 27\n'language': 'DE'\n'date': '2023-04-06T00:00:00.000Z'\n'abstract': Wir geben einen Überblick zu allen wichtigen Infos zum Release von Angular 16. Alles zu Signals, der Angular-CLI und TypeScript in Angular 16 erfahren Sie hier.\n'parentId': '5093fc7a779ccfe852d8fe7b'\n'parentDescription': Kaum ein Softwareprojekt, das nicht in wesentlichen Teilen auf der JavaScript-Technologie basiert. Eine breite Unterstützung sowie, leistungsfähige Programmiersprachen, die Vielzahl moderner Tools, sowie ausgereifte Frameworks wie Angular, React, Vue.js oder Node.js machen den JavaScript-Werkzeugkasten zu einem Alleskönner. Das iJS Magazin informiert aktuell und umfassend über die wichtige und innovative Entwicklungen im JavaScript-Universum und bietet handfeste Praxisinformationen für Softwareentwickler und -architekten.\n'indexBrandName': ''\n'indexSeriesName': ''\n'author': 'Karsten Sitterberg'\n'chunkSource': 'text'\n'text': Vermeidung von Endlosschleifen Signals immer nur gelesen, nie geschrieben werden. Dies wird auch durch die Signal-API überprüft und dann ggf. ein Fehler geworfen. Listing 21: Beispiel für Logging als Signal-Effect constructor() { effect(() => { console.log(this.invoice()) }) } Signals sollen perspektivisch auch selbst - unabhängig von Zone.js - die Change-Detection in Komponenten steuern können. Dieses Verhalten ist noch nicht Teil von Angular 16, soll aber aktiviert werden können, indem signals: true in die Komponenten-Metadaten aufgenommen wird. In dem Fall werden die Inputs einer Komponente auch als Signals statt als veränderliche Objekte ausgeprägt. Allerdings ändert sich auch die Syntax, mit der man @Input, @Output und dergleichen schreibt: All diese Angular-Konzepte sind dann keine @-Decorators mehr, sondern spezielle Signals-Funktionen. Beispielsweise werden Inputs dann zu input()- und Outputs zu output()-Signals. Das passt dann gut dazu, dass die TypeScript Standard-Decorators nicht für Parameter, sondern nur für Typen funktionieren. Ähnlich verhält es sich mit Queries für ‘viewChild/ren’ und ‘contentChild/ren’, auch diese werden dann als Signal bereitgestellt. Im Lifecycle verändert sich die API bei Signal Komponenten ebenfalls: Mit ‘afterNextRender’ wird eine Funktion nach Beendigung des nächsten DOM-Update-Zyklus ausgeführt. Das ist in etwa wie bisher ein ‘ngAfterViewInit’, wird allerdings öfter aufgerufen. Mit ‘afterRender’ wird nach jeder DOM-Aktualisierung der angegebene Callback aufgerufen. Schließlich gibt es noch ‘afterRenderEffect’, der einen ‘effect’ mit jedem ‘afterRender’ aufruft. Insgesamt wirkt das Design bereits jetzt sehr vielversprechend und zukunftsweisend. Einzig die Frage nach der Einheitlichkeit der APIs in Anbetracht der RxJS Verwendung bleibt offen. Hier könnte sich aber auch ein sinnvolles Hybridkonzept etablieren. Aktuell sind Signals noch eine Preview-API und die weitere Entwicklung wird sicherlich auch vom Feedback der Community abhängen. Breaking Changes in Angular 16 Bei Major Releases ist gemäß Semantic-Versioning Konventionen auch stets mit inkompatiblen Änderungen zu rechnen. Das hält auch Angular 16 so, doch halten sich die Auswirkungen für den Großteil der Nutzer sicherlich im Rahmen. So haben sich die Versionsanforderungen der verwendeten Werkzeuge und Frameworks geändert. Zunächst wird als TypeScript-Version mindestens 4.9 verlangt.\n'slidetext': ''\n'from': 'index'\n'score': 125.17716979980469\n'normalizedScore': 1.2517716979980469\n'beforeDatePenaltyScore': 1.2517716979980469\n\n'documentId': '64ace3828d8056484c3534ab'\n'chunk_id': '687814c5bed6dcd41a99b026'\n'access': 'granted'\n'part_number': 14\n'total_parts': 21\n'contentType': 'READ'\n'title': Angular 16 released - Alles zu neuen Features und Breaking Changes\n'parentName': iJS Magazin Band 27\n'language': 'DE'\n'date': '2023-04-06T00:00:00.000Z'\n'abstract': Wir geben einen Überblick zu allen wichtigen Infos zum Release von Angular 16. Alles zu Signals, der Angular-CLI und TypeScript in Angular 16 erfahren Sie hier.\n'parentId': '5093fc7a779ccfe852d8fe7b'\n'parentDescription': Kaum ein Softwareprojekt, das nicht in wesentlichen Teilen auf der JavaScript-Technologie basiert. Eine breite Unterstützung sowie, leistungsfähige Programmiersprachen, die Vielzahl moderner Tools, sowie ausgereifte Frameworks wie Angular, React, Vue.js oder Node.js machen den JavaScript-Werkzeugkasten zu einem Alleskönner. Das iJS Magazin informiert aktuell und umfassend über die wichtige und innovative Entwicklungen im JavaScript-Universum und bietet handfeste Praxisinformationen für Softwareentwickler und -architekten.\n'indexBrandName': ''\n'indexSeriesName': ''\n'author': 'Karsten Sitterberg'\n'chunkSource': 'text'\n'text': kann die unregisterFn() aufgerufen werden. Dann würde in diesem Beispiel doSomethingOnDestroy() nicht mehr aufgerufen. Neben der DestroyRef wurde noch ein neues Paket @angular/rxjs-interop eingeführt, das vor allem mit den neuen Signals verwendet wird. Zusätzlich bietet dieses Paket aber auch noch die Funktion takeUntilDestroyed() an. Diese Funktion ist ein Pipeable rxjs-Operator und kann verwendet werden, um Observables zu beenden, sobald die zugehörige Komponente destroyed wurde. Unter der Haube verwendet dieser neue Operator eine DestroyRef. In Listing 18 wird gezeigt, wie man den Operator nutzen kann, um ein Intervall-Observable zu beenden, sobald die Komponente abgeräumt wird. In diesem Fall wird dem takeUntilDestroyed-Operator explizit eine DestroyRef mitgegeben. Dieser Schritt kann allerdings auch weggelassen werden, dann besorgt sich der Operator die DestroyRef selbst per inject()-Funktion. Das hätte dann hier aber zur Folge, dass der Operator - oder das ganze Observable - im Konstruktor erzeugt werden muss, da der inject()-Mechanismus den Konstruktor-Kontext benötigt. Listing 18: Beispiel zur Verwendung der DestroyRef constructor(private destroyRef: DestroyRef) { const unregisterFn = destroyRef.onDestroy(() => doSomethingOnDestroy() ); // unregisterFn(); // Nimmt onDestroy-Logik zurück } ngOnInit(): void { interval(1000) .pipe(takeUntilDestroyed(this.destroyRef)) .subscribe(val => console.log('value:', val)) } Signals in Angular 16 - Hört die Signale… In Angular 16 hält ein neues und gleichzeitig so wegweisendes Konzept Einzug, das dem eine eigene Überschrift zu widmen ist. Die Rede ist von den “Signals”, einem Konzept, das sicherlich nicht zuletzt von Vue inspiriert wurde. Langfristiges Ziel ist es dabei, ohne “Zone.js” auszukommen und die Change-Detection mit anderen Mitteln abbilden zu können. Das ist sicherlich wichtig, um Standalone-Anwendungen zu verschlanken und vielleicht sogar die Möglichkeiten zu eröffnen, einzelne Elemente mit Angular umzusetzen, vergleichbar mit React und Vue. Als Motivation wurde angegeben, dass Angular-Anwendungen auf diese Weise einfacher werden, da die Verwendung von RxJS nicht mehr zwingend nötig ist. Damit soll die technische, aber auch die konzeptionelle Komplexität reduziert werden. Gleichzeitig hat das Thema auch etwas Beigeschmack: Die offiziellen Diskussionen wurden erst ca. drei Wochen vor Verabschiedung des ersten Release-Candidate\n'slidetext': ''\n'from': 'index'\n'score': 125.03252410888672\n'normalizedScore': 1.2503252410888672\n'beforeDatePenaltyScore': 1.2503252410888672\n\n'documentId': 'de0df53930e2e1e582caf57f'\n'chunk_id': '687814d4bed6dcd41a99b07c'\n'access': 'granted'\n'part_number': 6\n'total_parts': 15\n'contentType': 'READ'\n'title': Angular 17: The Web Framework's Newest Release - Renaissance? Angular 17! - All features at a glance\n'parentName': JavaScript Magazine Volume 12\n'language': 'EN'\n'date': '2024-03-22T02:00:00.000Z'\n'abstract': The popular JavaScript framework Angular has released version 17. It can be difficult to keep up with all the changes in angular, but this article covers an overview of Angular 17 features.\n'parentId': '7e9c82426451f3a6ca3ddfbf'\n'parentDescription': Broaden your knowledge and expand your JavaScript techniques and practices. From Angular, React, and WebAssembly, to the best JavaScript IDEs, open source tools and more, you’ll learn insights on everything JS from seasoned experts in their field. Keep up with JavaScript news, tips, and advice with interviews, tutorials, and in-depth articles.\n'indexBrandName': ''\n'indexSeriesName': ''\n'author': 'Karsten Sitterberg'\n'chunkSource': 'text'\n'text': lazy loading for animations, the 'provideAnimationsAsync()' function must be used. Here, the 'BrowserAnimationModule' should no longer be imported and the 'provideAnimations()' function should no longer be used. The special thing about an SPA is that, as a rule, an HTML document is only loaded when the application starts. When switching to a different route, only components in the browser DOM are exchanged. Animations cannot simply be executed on page load, as is the case with server-side applications. Instead, animations must be better adapted to SPA logic, such as route changes. This is what the new View Transitions DOM API is designed for. This API provides the callback 'document.startViewTransition()', which tells the browser that a view transition will start. Logic can be passed to the function that defines how the browser DOM should look at the end of the transition. The transition animation can be created using special CSS pseudo selectors. Angular uses this new API in the Angular 17 router so that a view transition is started for each navigation. However, since the 'View Transition' feature is still experimental and has only been implemented in Chrome and Edge, router navigation in browsers such as Firefox or Safari continues to take place synchronously. To activate ViewTransitions, the 'withViewTransitions()' function can be added to the router at startup. In Listing 7, the 'withViewTransitions()' is also given a configuration object in which an 'onViewTransitionCreated()' callback can be defined if additional (animation) logic is needed. provideRouter( routes, withViewTransitions({ onViewTransitionCreated: transitionInfo => { } }) ), Listing 7: Activating the ViewTransitions in the AppModule or app.config New Control Flow Syntax The biggest and most far-reaching innovation for developers, and the biggest innovation in Angular in terms of template syntax, is the new control flow syntax. In Angular 17, this syntax is still in a developer preview. But in the future, it will completely replace the previous directives '*ngIf', '*ngFor' and 'ngSwitch'. The logic of these directives will become part of the framework itself, instead of 'normal' directives. This will allow the Angular team to better optimize the respective logic. Signals and the goal of making zone.js optional with the help of Signals were also a key reason for these innovations, since the old control flow directives were based on and needed 'zone.js'. Besides the control flow logic, another feature that can be implemented thanks to the new syntax is a new form of lazy loading at component level. This feature, also known as 'deferrable views', is discussed in more detail below. First, let's familiarize ourselves with the basic syntax. Until now, 'control flow' in Angular templates was handled by\n'slidetext': ''\n'from': 'index'\n'score': 126.3519058227539\n'normalizedScore': 1.263519058227539\n'beforeDatePenaltyScore': 1.263519058227539\n\n'documentId': 'de0df53930e2e1e582caf57f'\n'chunk_id': '687814d5bed6dcd41a99b083'\n'access': 'granted'\n'part_number': 13\n'total_parts': 15\n'contentType': 'READ'\n'title': Angular 17: The Web Framework's Newest Release - Renaissance? Angular 17! - All features at a glance\n'parentName': JavaScript Magazine Volume 12\n'language': 'EN'\n'date': '2024-03-22T02:00:00.000Z'\n'abstract': The popular JavaScript framework Angular has released version 17. It can be difficult to keep up with all the changes in angular, but this article covers an overview of Angular 17 features.\n'parentId': '7e9c82426451f3a6ca3ddfbf'\n'parentDescription': Broaden your knowledge and expand your JavaScript techniques and practices. From Angular, React, and WebAssembly, to the best JavaScript IDEs, open source tools and more, you’ll learn insights on everything JS from seasoned experts in their field. Keep up with JavaScript news, tips, and advice with interviews, tutorials, and in-depth articles.\n'indexBrandName': ''\n'indexSeriesName': ''\n'author': 'Karsten Sitterberg'\n'chunkSource': 'text'\n'text': system? It still exists today, but the plan is to make modules optional in the future. This is also intended to make it easier for new developers to get started with Angular. Angular Material Angular Material 17 introduces both an important and significant change for developers still using old Material components, known as “legacy” since Angular 15. Angular 15 is called legacy because the Angular Material team decided to replace the previously used CSS with the official Google Material Design Components (MDC) style. Because some components needed to be significantly revised, the Angular Material team prefixed the old versions with 'Legacy' and deprecated them, but they are still allowed to be used. In Angular Material 17, all legacy components with a modern MDC counterpart will be removed. This means that applications must be migrated to the new MDC-based Material components by Angular 17. In the JavaScript universe, there are several ways to work with dates. To be able to use these different date-time libraries in Angular Material as well, Angular Material offers a 'DateAdapter'. The DateAdapter is then used by the Datepicker, for example, for date management. The 'DateAdapter' is an abstract class that must be implemented to use a specific date-time library. Angular Material includes the built-in 'NativeDateAdapter', which simply uses the native 'Date' object available in the browser for data management. This 'NativeDateAdapter' has previously received the 'Platform' service via constructor injection. With Angular Material 17, this is no longer the case. In addition, the 'NativeDateAdapter' no longer uses constructor injection generally, but the 'inject()' function instead. This major change has an impact in particular, if you have created the NativeDateAdapter yourself using a constructor, for example in unit tests. This is no longer possible, instead the NativeDateAdapter must be created using Angular's dependency injection. Important Changes in CSS To integrate Angular Material styles into SCSS, the '@import' mechanism of SCSS could be previously used. However, since this mechanism has long since been deprecated on the SCSS side, the '@import' option has now also been removed on the Angular Material side. As of Angular Material 17, the new SCSS '@use' syntax must be used to import the Material styles. If you want to use Angular Material with custom styling, you can do so using the Material theming API. Previously, Material did not check whether the custom themes were formally correct but with Angular Material 17, these are now strictly validated. For example, if the 'mat.button-typography' mixin is used with a theme in which 'typography: null' is set, there will now be an error during the SCSS build. In addition to importing the global Material styles,\n'slidetext': ''\n'from': 'index'\n'score': 125.09046936035156\n'normalizedScore': 1.2509046936035155\n'beforeDatePenaltyScore': 1.2509046936035155\n\n'documentId': 'de0df53930e2e1e582caf57f'\n'chunk_id': '687814d4bed6dcd41a99b07e'\n'access': 'granted'\n'part_number': 8\n'total_parts': 15\n'contentType': 'READ'\n'title': Angular 17: The Web Framework's Newest Release - Renaissance? Angular 17! - All features at a glance\n'parentName': JavaScript Magazine Volume 12\n'language': 'EN'\n'date': '2024-03-22T02:00:00.000Z'\n'abstract': The popular JavaScript framework Angular has released version 17. It can be difficult to keep up with all the changes in angular, but this article covers an overview of Angular 17 features.\n'parentId': '7e9c82426451f3a6ca3ddfbf'\n'parentDescription': Broaden your knowledge and expand your JavaScript techniques and practices. From Angular, React, and WebAssembly, to the best JavaScript IDEs, open source tools and more, you’ll learn insights on everything JS from seasoned experts in their field. Keep up with JavaScript news, tips, and advice with interviews, tutorials, and in-depth articles.\n'indexBrandName': ''\n'indexSeriesName': ''\n'author': 'Karsten Sitterberg'\n'chunkSource': 'text'\n'text': option that takes over the role of the 'trackBy' option from '*ngFor'. There is an important difference here. The new '@for-track' option isn’t optional, it must always be specified. It’s used internally by Angular to optimize rendering the list so that the list does not have to be completely re-rendered all the time, especially if just individual list entries are changed. A completely new algorithm for list rendering was made possible by the new '@for' syntax. It also helps here and shows significant performance improvement in benchmarks compared to the old algorithm. The value specified in the 'track' expression must identify the respective collection entry. If an array of objects is iterated over, the respective object ID should be used, as seen in Listing 11. If you are iterating over an array of primitive values, you can simply use the value itself ('track item'). An innovation that we did not know from '*ngFor' until now is '@for' can be extended by '@empty{}'. The template code in the '@empty' expression is always displayed if the transferred list (here 'items') has no entries or is 'null' or 'undefined'. Several implicit variables can also be used within the '@for' expression to display the current loop iteration index (via '$index'), for example. See Listing 11. You can also access the loop length ('$count') to check if the current loop index is even ('$even') or odd ('$odd'), or if it is the first ('$first') or last ('$last') loop element. @for (item of items; track item.id) { \n\nElement Nummer {{$index}}: {{item.name}} } @empty { \n\nNo items } Listing 11: Example of a loop with the new “@for” Syntax in Angular 17 Previously, three directives were used to implement a switch case statement: 'ngSwitch' and the structural directives '*ngSwitchCase' and '*ngSwitchDefault'. With the new syntax, '@switch', '@case' and '@default' can now be used, as seen in Listing 12. Of course, you can still switch via primitive values or enum values, for instance. Just like the other control flow statements, normal Angular template code can be used as the cases content. You can also nest the control flow statements. @switch (value) { @case (1) { case one } @case (2) { \n\ncase two } @default { Default-case } } Listing 12: Example of a switch case with the new “@switch” syntax in Angular 17 The last element of the new control flow syntax offers new syntax and completely new functionality. 'Deferred Views' (with '@defer') enable lazy loading at the component level without needing the router or complex renderer constructs. An example\n'slidetext': ''\n'from': 'index'\n'score': 125.04824829101562\n'normalizedScore': 1.2504824829101562\n'beforeDatePenaltyScore': 1.2504824829101562\n\n'documentId': '04721391f3f7580f0631b9d3'\n'chunk_id': '687a2103a98d5a30b3a3413b'\n'access': 'granted'\n'part_number': 16\n'total_parts': 21\n'contentType': 'READ'\n'title': Angular 17: Neues Release des Web-Frameworks - Renaissance? Angular 17! - Alle Features im Überblick\n'parentName': iJS Magazin 2.2024\n'language': 'DE'\n'date': '2024-04-03T22:00:00.000Z'\n'abstract': Das beliebte JavaScript-Framework Angular veröffentlicht Version 17. Da bei Angular viel in Bewegung ist, kann manch einer da den Überblick verlieren. Wir stellen alle Features von Angular 17 vor.\n'parentId': 'c04db0163e3cb47407e78b63'\n'parentDescription': Kaum ein Softwareprojekt, das nicht in wesentlichen Teilen auf der JavaScript-Technologie basiert. Eine breite Unterstützung sowie, leistungsfähige Programmiersprachen, die Vielzahl moderner Tools, sowie ausgereifte Frameworks wie Angular, React, Vue.js oder Node.js machen den JavaScript-Werkzeugkasten zu einem Alleskönner. Das iJS Magazin informiert aktuell und umfassend über die wichtige und innovative Entwicklungen im JavaScript-Universum und bietet handfeste Praxisinformationen für Softwareentwickler und -architekten.\n'indexBrandName': ''\n'indexSeriesName': ''\n'author': 'Karsten Sitterberg'\n'chunkSource': 'text'\n'text': wird, entspricht der oben beschriebenen Defer-Logik. In Listing 18 oben soll zum Beispiel eine Komponente erst dann angezeigt werden, wenn der Zustand der Variablen “isVisible” auf “true” wechselt. Damit die Komponente zu diesem Zeitpunkt dann ohne Ladezeit angezeigt werden kann, wird die Prefetch-Bedinung verwendet: Sobald die Variable “prefetchCondition” auf “true” wechselt, lädt Angular den Inhalt des “@defer”-Block vor. Wenn im Anschluss “isVisible” auf “true” wechselt, wird keine Ladezeit mehr benötigt, da die Komponente schon “vorhanden” ist und nur noch gerendert werden muss. Im unteren Beispiel aus Listing 18 wird statt einer “when”-Bedinung eine “on”-Bedinung zum pre-fetchen verwendet. In diesem Fall fängt Angular mit dem Nachladen der Komponente an, sobald die äußere Komponente gerendert wurde. Listing 18: Prefetch-Bedingungen @defer (when isVisible; prefetch when prefetchCondition) { //... @defer (when isVisible; prefetch on immediate) { //... Um die alten Control-Flow-Direktiven auf die neue Syntax zu transformieren, wird es im Angular-CLI 17 eine automatische Migration geben, die den Wechsel zur neuen Syntax vereinfachen soll. Zumindest in Angular 17 sind aber noch beide Syntax-Varianten verwendbar. Breaking Changes in Angular 17 Da Angular 17 ein Major Release ist, gibt es entsprechend auch ein paar Breaking Changes. Ein Breaking Change betrifft das mit Angular 16 eingeführte Feature der Signals. Die Signals wurden mit Angular 16 noch als Developer-Preview gehandelt, daher die kurze Zeit bis zu dieser Änderung. Bei den Signals hat es sich gezeigt, dass die “signal.mutate()”-Funktion zu Inkonsistenzen in der Anwendung führen kann. Daher wurde diese Möglichkeit, ein Signal zu ändern, entfernt. Signals sollten nun nicht mehr per Mutation verändert werden, sondern stattdessen immer wie eine immutable Datenstruktur verwendet werden. In Listing 19 ist beispielhaft gezeigt, wie ein Signal, das ein Array enthält, bisher verändert werden konnte, und wie es ab Angular 17 geschehen sollte. Listing 19: Items zu einem “Signal” hinzufügen im Angular 16/17-Vergleich // Mit Angular 16 items.mutate(itemsArray => itemsArray.push(newItem)); // Ab Angular 17: items.update(itemsArray => [itemsArray, ...newItem]); Neben den Signals gibt es Breaking Changes im Router. Dieser hat bisher die Properties - “canceledNavigationResolution“ - “paramsInheritanceStrategy“\n'slidetext': ''\n'from': 'index'\n'score': 131.08670043945312\n'normalizedScore': 1.3108670043945312\n'beforeDatePenaltyScore': 1.3108670043945312\n\n'documentId': '04721391f3f7580f0631b9d3'\n'chunk_id': '687a2101a98d5a30b3a3412b'\n'access': 'granted'\n'part_number': 8\n'total_parts': 21\n'contentType': 'READ'\n'title': Angular 17: Neues Release des Web-Frameworks - Renaissance? Angular 17! - Alle Features im Überblick\n'parentName': iJS Magazin 2.2024\n'language': 'DE'\n'date': '2024-04-03T22:00:00.000Z'\n'abstract': Das beliebte JavaScript-Framework Angular veröffentlicht Version 17. Da bei Angular viel in Bewegung ist, kann manch einer da den Überblick verlieren. Wir stellen alle Features von Angular 17 vor.\n'parentId': 'c04db0163e3cb47407e78b63'\n'parentDescription': Kaum ein Softwareprojekt, das nicht in wesentlichen Teilen auf der JavaScript-Technologie basiert. Eine breite Unterstützung sowie, leistungsfähige Programmiersprachen, die Vielzahl moderner Tools, sowie ausgereifte Frameworks wie Angular, React, Vue.js oder Node.js machen den JavaScript-Werkzeugkasten zu einem Alleskönner. Das iJS Magazin informiert aktuell und umfassend über die wichtige und innovative Entwicklungen im JavaScript-Universum und bietet handfeste Praxisinformationen für Softwareentwickler und -architekten.\n'indexBrandName': ''\n'indexSeriesName': ''\n'author': 'Karsten Sitterberg'\n'chunkSource': 'text'\n'text': Hooks besteht darin, dass “afterNextRender()” nur einmal, nach dem nächsten Rendering-Vorgang, aufgerufen wird, während “afterRender()” aktiv bleibt, solange die Komponente aktiv ist. Diese beiden Hooks sind allerdings noch als “Developer Preview” geführt, können sich also noch ändern. Listing 6: Implementierung der neuen Lifecycle-Hooks @Component({}) export class DemoComponent { val = 42; constructor() { afterRender(() => { console.log('afterRender', this.val); }); afterNextRender(() => { console.log('afterNextRender', this.val); }); } } Signals sind stable in Angular 17 Ein wichtiges Detail in Angular 17 ist, dass die mit Angular 16 eingeführten Signals nun als Stable markiert sind. Das eigentliche Ziel bei Einführung der Signals war es, zone.js optional zu machen, indem ein neuer, Signal-basierter Change-Detection-Mechanismus eingeführt wird. Mit Angular 17 kommt das Angular-Team diesem Ziel einen großen Schritt näher: Signals ermöglichen eine sogenannte “lokale Change-Detection”, also einen Change-Detection-Vorgang, der sich nur auf die Komponenten bezieht, die auch wirklich geänderte (Signal)-Werte haben. In Abbildung 2 ist beispielhaft der Unterschied zwischen den verschiedenen Change-Detection-Mechanismen dargestellt. Im Standardfall wird bei jedem asynchronen Event der komplette Komponentengraph überprüft. Bei OnPush-ChangeDetection werden die Komponenten überprüft, die die Change-Detection ausgelöst haben, oder geänderte “@Input()”-Werte haben, und deren jeweilige Parent-Komponenten (bis hoch zur AppComponent). Mit Signals ist es nun möglich, dass wirklich nur die Komponenten überprüft werden, die geänderte Signal-Werte haben. Abbildung 2: Change-Detection-Mechanismen im Vergleich Animations mit Lazy-Loading in Angular 17 Animationen können in Angular 17 per Lazy Loading nachgeladen werden. Dadurch muss der Browser initial kleinere Bundles laden, macht also die initiale Anwendung kleiner und führt somit zu geringeren Anwendungs-Lade- und -Startzeiten. Um das Lazy-Loading der Animationen zu aktivieren, muss die Funktion “provideAnimationsAsync()” verwendet werden. Das “BrowserAnimationModule” sollte in diesem Fall dann nicht mehr importiert bzw. die Funktion “provideAnimations()” nicht mehr genutzt werden. Das Besondere an einer SPA ist, dass im Regelfall nur beim Start der Anwendung ein HTML-Dokument geladen wird. Beim Wechsel auf eine andere Route werden lediglich Bestandteile im Browser-DOM ausgetauscht. Damit können Animationen nicht wie bei serverseitigen Anwendungen\n'slidetext': ''\n'from': 'index'\n'score': 127.88152313232422\n'normalizedScore': 1.2788152313232422\n'beforeDatePenaltyScore': 1.2788152313232422\n\n'documentId': '04721391f3f7580f0631b9d3'\n'chunk_id': '687a2101a98d5a30b3a34119'\n'access': 'granted'\n'part_number': 2\n'total_parts': 21\n'contentType': 'READ'\n'title': Angular 17: Neues Release des Web-Frameworks - Renaissance? Angular 17! - Alle Features im Überblick\n'parentName': iJS Magazin 2.2024\n'language': 'DE'\n'date': '2024-04-03T22:00:00.000Z'\n'abstract': Das beliebte JavaScript-Framework Angular veröffentlicht Version 17. Da bei Angular viel in Bewegung ist, kann manch einer da den Überblick verlieren. Wir stellen alle Features von Angular 17 vor.\n'parentId': 'c04db0163e3cb47407e78b63'\n'parentDescription': Kaum ein Softwareprojekt, das nicht in wesentlichen Teilen auf der JavaScript-Technologie basiert. Eine breite Unterstützung sowie, leistungsfähige Programmiersprachen, die Vielzahl moderner Tools, sowie ausgereifte Frameworks wie Angular, React, Vue.js oder Node.js machen den JavaScript-Werkzeugkasten zu einem Alleskönner. Das iJS Magazin informiert aktuell und umfassend über die wichtige und innovative Entwicklungen im JavaScript-Universum und bietet handfeste Praxisinformationen für Softwareentwickler und -architekten.\n'indexBrandName': ''\n'indexSeriesName': ''\n'author': 'Karsten Sitterberg'\n'chunkSource': 'text'\n'text': '@NgModule()'s. - Funktionale HTTP-Interceptoren werden in Angular CLI 17 bevorzugt, klassenbasierte sind optional. - Einführung der neuen Syntax @switch, @case, und @default für Conditional Rendering und neue Direktiven wie @defer für Lazy Loading. - @defer unterstützt bedingtes Laden und Vorladen mit prefetch. - Die Angular CLI bietet eine automatische Migration zur neuen Syntax an; alte und neue Syntax können in Version 17 parallel genutzt werden. - Integration der neuen Lifecycle-Hooks afterRender() und afterNextRender sowie die Stabilisierung von Signals. - Lazy Loading für Animationen und die Integration der View Transitions DOM-API für optimierte Übergänge und Animationen. - Einführung einer neuen Control-Flow-Syntax als Developer Preview, die *ngIf, *ngFor, und ngSwitch ersetzt und zusätzliche Verbesserungen wie @if, @for, und erforderliches Track-by für Listen umfasst. Breaking Changes in Angular 17 - Entfernung von signal.mutate(): Die Möglichkeit, Signals durch Mutation zu verändern, wurde entfernt. Signals müssen als immutable Datenstrukturen behandelt werden; Änderungen sollten durch die signal.update()-Funktion vorgenommen werden. - Signal-Handhabung als immutable: Anstatt Signals zu mutieren, sollten Entwickler diese nun behandeln, als wären sie immutable, und entsprechend aktualisieren. - Entfernung von Router Properties: Bestimmte Router Properties wie canceledNavigationResolution, paramsInheritanceStrategy, titleStrategy, urlUpdateStrategy, malformedUriErrorHandler und urlHandlingStrategy wurden aus der öffentlichen API entfernt. - Neue Konfiguration über provideRouter() oder RouterModule.forRoot(): Die zuvor entfernten Router Properties müssen jetzt über die provideRouter()-Funktion oder im RouterModule.forRoot()-Hook konfiguriert werden. - Änderung in der Navigation: Die Konfiguration der Navigationsstrategie und Fehlerbehandlung muss an die neuen Methoden angepasst werden, um Inkompatibilitäten mit dem Router-Service von Angular 17 zu vermeiden. TypeScript Mit der neuen Angular-Version wird auch eine neue TypeScript-Version unterstützt. In Angular 17 muss nun zugleich TypeScript mindestens in Version 5.2 verwendet werden. Da beim Release von Angular 16 noch TypeScript 5.0 vorausgesetzt wurde, wollen wir uns an dieser Stelle sowohl einige interessante Neuerungen sowohl aus TypeScript 5.1 als auch aus TypeScript 5.2 ansehen. Implizites “return“ bei Rückgabe von “undefined“ Wenn in JavaScript eine Funktion keine “return”-Angabe enthält, hat diese Funktion dennoch immer implizit “undefined” als Rückgabewert. In TypeScript hat sich diese Tatsache bisher nicht\n'slidetext': ''\n'from': 'index'\n'score': 126.76396179199219\n'normalizedScore': 1.2676396179199219\n'beforeDatePenaltyScore': 1.2676396179199219\n\n'documentId': 'df387f02fdf1c3c67daf2189'\n'chunk_id': '68f25130d754e200146e6f66'\n'access': 'restricted'\n'part_number': 3\n'total_parts': 16\n'contentType': 'RHEINGOLD'\n'title': Bringing Intelligence to the Edge: A Lightweight JavaScript ELM Library for Front-End Machine Learning\n'parentName': International JavaScript New York 2025\n'language': 'EN'\n'date': '2025-10-01T14:00:00.000Z'\n'abstract': In this talk, we introduce an open-source JavaScript library that brings real-time machine learning to the browser using Extreme Learning Machines (ELMs)—a fast, single-pass neural network architecture ideal for edge inference. Designed for simplicity, speed, and versatility, our library allows developers to train and run predictive models entirely in the browser, without external APIs or heavy back-end dependencies.We'll walk through the architecture of the library and demonstrate how it supports a variety of interactive use cases, including: - Autocomplete prediction for text fields - Intent detection in command-based interfaces - Language and sentiment classification - Hashtag and tag suggestion engines - Text-based game input recognitionBy combining efficient encoding, fast matrix operations, and intuitive APIs for binding to DOM elements, the library empowers developers to embed intelligence directly into their front-end workflows. We’ll also showcase how the library can be extended to support new domains, how it can be bundled as an NPM package, and how it integrates with modern JS/TS development ecosystems.If you're curious about doing machine learning without TensorFlow or PyTorch—or want to explore how neural networks can enhance your web interfaces with zero dependencies—this session is for you.\n'parentId': '9f97d5cdc68d72a05f834df4'\n'parentDescription': The JavaScript Fullstack Conference - Angular, Node.js, React and more\n'indexBrandName': 'InternationalJavaScriptCon'\n'indexSeriesName': 'NewYork'\n'author': 'Julian Duran'\n'chunkSource': 'text'\n'text': that component is un push, then angular just gonna assume, oh, the inputs haven't changed, so I'm not gonna refresh that component. And now we have signals where with the signal, angular knows exactly what changes and where, what are the consequences of that change, which is true for components, but also true for other signals, right? Um, the idea is when you use a signal, angular knows about what anything, any code that depends on it, right? It, it builds a dependency graph on, on those signals and knows exactly what depends on, um, on these signals. So when you change the value, everything that needs to change as a result is just known. And so it can happen quickly. And so along with signal scheme, a whole bunch of new functions, features like components, inputs, outputs, can all be signal based. Now, models, um, content queries, all of that is now, uh, signal based, which leads us with what do we do with RXGS, right? Because RXGS is still a big part of angular. You can find it in the router, you'll find it in forms, you'll find it in the HTP client. And that's a paradox, right? How do we use signals everywhere? If you know, the entry point for our data, which is the A GTP client is using RXGS. So the, the first, uh, quick and dirty, even though not so dirty, but the, the first option was to just use two signal. So that's a function that takes an observable, turns it into a signal. There's the opposite function to observable that we don't use somehow who would turn a signal into an observable, I don't know. Um, so yeah, these two utility functions can be used. But the thing is, even though the work, um, it still feels like not, not the, you know, the perfect solution, not right to just do conversions and conversion and conversions of, um, of observables to signals. And so then with, uh, angular 18, as we saw resources were introduced, uh, back in Angular, that disappeared in Angular one and came back in angular 18 with a, a different shape. And so resource. Uh, so, so the idea was to kind of find a way to wrap asynchronous code into a signal based approach, right? So when you use resources, you don't see any RXJS anymore. You don't see any, uh, well, anything async, I would say, everything is just a signal. Everything becomes a signal. And so the, the initial release of resource was, uh, and still is available as is. It's a resource\n'slidetext': ''\n'from': 'vector'\n'score': 0.9313324689865112\n'normalizedScore': 0.9291384736820972\n'beforeDatePenaltyScore': 0.9313324689865112\n\n\nReferenceChunks:\n'documentId': 'df387f02fdf1c3c67daf2189'\n'chunk_id': '68f25130d754e200146e6f66'\n'access': 'restricted'\n'part_number': 3\n'total_parts': 16\n'poc_summary': 'This conference talk examines Angular’s new resource APIs for signal-based data fetching and their impact on front-end development.'\n'chunk_summary': 'It shows how the resource API wraps asynchronous code into a signal-based approach, removing the need for RxJS.'\n'access_message': 'ℹ️ This talk of International JavaScript New York 2025 was part of a past event. Booking is no longer available, but you can discover the current edition right here on the platform.'\n\n'documentId': '04721391f3f7580f0631b9d3'\n'chunk_id': '687a2101a98d5a30b3a34119'\n'access': 'granted'\n'part_number': 2\n'total_parts': 21\n'poc_summary': 'This article provides an in-depth overview of Angular 17’s new features, breaking changes, and their practical implications for developers.'\n'chunk_summary': 'It details the new control-flow syntax, functional HTTP interceptors, and stricter immutability for Signals.'\n'access_message': '✅ This content is included with your elevate membership.'\n\n'documentId': 'de0df53930e2e1e582caf57f'\n'chunk_id': '687814d4bed6dcd41a99b07e'\n'access': 'granted'\n'part_number': 8\n'total_parts': 15\n'poc_summary': 'This article provides an in-depth overview of Angular 17’s major new features, architectural changes, and their impact on developers.'\n'chunk_summary': 'It explains the @for-track requirement, performance improvements, and new @empty and loop variable features in @for.'\n'access_message': '✅ This content is included with your elevate membership.'\n\n'documentId': '64ace3828d8056484c3534ab'\n'chunk_id': '687814c5bed6dcd41a99b026'\n'access': 'granted'\n'part_number': 14\n'total_parts': 21\n'poc_summary': 'This article overviews Angular 16’s key new features and breaking changes across TypeScript, CLI, framework, Signals, SSR, and dependency updates.'\n'chunk_summary': 'It introduces provideServiceWorker to register the Service Worker via function instead of module.'\n'access_message': '✅ This content is included with your elevate membership.'\n\n'documentId': 'eba6f5d083b14f4d8d53d87a'\n'chunk_id': '687ad1b9eb1b160a4cabaea5'\n'access': 'granted'\n'part_number': 1\n'total_parts': 9\n'poc_summary': 'This article explores Angular 16’s innovations in reactive Signals, non-destructive hydration, and enhanced CLI, routing, and dependency-injection features.'\n'chunk_summary': 'It shows how Angular’s Signals API uses signal, computed, and effect for fine-grained change detection.'\n'access_message': '✅ This content is included with your elevate membership.'\n\n'documentId': '8b35e3d0070110b78d6c9434'\n'chunk_id': '687a2210d92aed38f5a4a5af'\n'access': 'granted'\n'part_number': 1\n'total_parts': 9\n'poc_summary': 'This article examines Angular’s modernization with Signals, Standalone APIs, and integrated server-side rendering, highlighting their impact on future application development.'\n'chunk_summary': 'It introduces Signals as a new reactive primitive in Angular, enabling more efficient state management and change detection.'\n'access_message': '✅ This content is included with your elevate membership.'\n\n'documentId': '1da46606f89dc3ccaa9c0f9d'\n'chunk_id': '690d456dd334ac0013d8cf18'\n'access': 'restricted'\n'part_number': 40\n'total_parts': 51\n'poc_summary': 'This flexible seminar lesson deepens advanced Angular concepts, focusing on pipes, NgModules, subcomponents, and the introduction of Signals for reactivity.'\n'chunk_summary': 'It demonstrates the use of the signal() function and the importance of immutability for change detection.'\n'access_message': '⚠️ This talk of Angular Camp - Flexible Basic Camp März 2026 | online is a premium add-on. Purchase separately to participate. As an Elevate member, your discount of 10% is applied automatically when booking via your Elevate dashboard here on entwickler.de. An additional 3% applies if you use a prepayment method.'\n\n'documentId': 'e8463276c25a9a889f842e96'\n'chunk_id': '69118b500f4b7700138ebda4'\n'access': 'granted'\n'part_number': 1\n'total_parts': 4\n'poc_summary': 'This article examines Angular 21’s major updates, focusing on new APIs, performance improvements, and developer experience enhancements.'\n'chunk_summary': 'It introduces experimental Signal Forms, showing how signals enable reactive form state and two-way binding with the Field directive.'\n'access_message': '✅ This content is included with your elevate membership.'\n\n'documentId': '651822c08be4e71b1d4a39ae'\n'chunk_id': '690d38f563a89a0013451893'\n'access': 'restricted'\n'part_number': 40\n'total_parts': 51\n'poc_summary': 'This flexible seminar lesson deepens advanced Angular concepts, focusing on pipes, NgModules, subcomponents, and the latest reactivity features like Signals.'\n'chunk_summary': 'It demonstrates converting component state to Signals and using getters and setters for reactivity.'\n'access_message': '⚠️ This talk of Angular Camp - Flexible Basic Camp Februar 2026 | online is a premium add-on. Purchase separately to participate. As an Elevate member, your discount of 10% is applied automatically when booking via your Elevate dashboard here on entwickler.de. An additional 3% applies if you use a prepayment method.'\n\n'documentId': '1fed2c6361980d606789e315'\n'chunk_id': '68c26fcc0a53cd001394ab92'\n'access': 'granted'\n'part_number': 2\n'total_parts': 8\n'poc_summary': 'This article discusses Angular 20’s evolution, focusing on signals, reactivity, dynamic components, and the framework’s future direction.'\n'chunk_summary': 'It explains how signals simplify reactivity and why they are easier for new developers than RxJS.'\n'access_message': '✅ This content is included with your elevate membership.'\n\n'documentId': 'af64d26c0f5fa509f9042a4b'\n'chunk_id': '690d25f4f6e2cc0012fef926'\n'access': 'restricted'\n'part_number': 40\n'total_parts': 51\n'poc_summary': 'This flexible seminar lesson deepens advanced Angular concepts, focusing on Pipes, NgModules, subcomponents, and the latest reactivity features like Signals.'\n'chunk_summary': 'It shows how to use the Signal function and type parameters to create reactive state in Angular.'\n'access_message': '⚠️ This talk of Angular Camp - Flexible Basic Camp Januar 2026 | online is a premium add-on. Purchase separately to participate. As an Elevate member, your discount of 10% is applied automatically when booking via your Elevate dashboard here on entwickler.de. An additional 3% applies if you use a prepayment method.'\n\n'documentId': '59c6dfa238c69ebd748cc7dc'\n'chunk_id': '69038857a7bbb00013e754e7'\n'access': 'restricted'\n'part_number': 1\n'total_parts': 1\n'poc_summary': 'This conference talk introduces Angular Signals and new features for modern reactive application development.'\n'chunk_summary': 'It explains the advantages of Signals over classic RxJS patterns and previews Signal-based forms.'\n'access_message': 'ℹ️ This talk of JavaScript Days Berlin und online 2025 was part of a past event. Booking is no longer available, but you can discover the current edition right here on the platform.'\n\n'documentId': 'e45840c0b8a784e3b3cf3be3'\n'chunk_id': '690211f50902850012f245ce'\n'access': 'granted'\n'part_number': 1\n'total_parts': 22\n'poc_summary': 'This conference talk examines Angular’s evolving reactivity landscape, comparing RxJS, Signals, and Native Observables and their impact on developer experience.'\n'chunk_summary': 'It discusses why Signals were introduced in Angular and why RxJS remains necessary for many use cases.'\n'access_message': '✅ You still have access to the recordings for this talk of International JavaScript Conference Munich 2025 until 2026-04-26. Unfortunately, recordings are not available for workshops, but you can still access the slides and your certificate. Dive back in anytime!'\n\n'documentId': '69ab8ba6bfa5d1a198f998c3'\n'chunk_id': '690b0f2aeb0efe0012394f2b'\n'access': 'restricted'\n'part_number': 40\n'total_parts': 51\n'poc_summary': 'This flexible seminar lesson deepens advanced Angular concepts, focusing on pipes, NgModules, subcomponents, and modern reactive features like Signals.'\n'chunk_summary': 'It demonstrates using the Signal function to wrap values for reactive data binding and automatic update notifications.'\n'access_message': 'ℹ️ This talk of Angular Camp - Flexible Basic Camp November 2025 | online was part of a past event. Booking is no longer available, but you can discover the current edition right here on the platform.'\n\n'documentId': '86a43d1e179681ee6a344c28'\n'chunk_id': '690210a20902850012f24510'\n'access': 'granted'\n'part_number': 1\n'total_parts': 1\n'poc_summary': 'This conference talk presents strategies for building maintainable Angular architectures using Signals, Resource API, and the new NgRx Signal Store.'\n'chunk_summary': 'It outlines how Nx with Module Boundaries and Sheriff supports sustainable project setups in Angular.'\n'access_message': '✅ You still have access to the recordings for this talk of International JavaScript Conference Munich 2025 until 2026-04-29. Unfortunately, recordings are not available for workshops, but you can still access the slides and your certificate. Dive back in anytime!'\n\n'documentId': '0747f0655ef3790a97eba95b'\n'chunk_id': '68f24b683134c10012c3d12d'\n'access': 'restricted'\n'part_number': 2\n'total_parts': 16\n'poc_summary': 'This conference talk examines modern Angular architecture in 2025, focusing on signals, resources, and lazy loading for scalable, maintainable apps.'\n'chunk_summary': 'It highlights Angular’s evolution from version 14 onward, emphasizing the shift to standalone components and signals for simplicity.'\n'access_message': 'ℹ️ This talk of International JavaScript New York 2025 was part of a past event. Booking is no longer available, but you can discover the current edition right here on the platform.'\n\n'documentId': '18e1984b93f7b81b65afb3ad'\n'chunk_id': '69020ea2a5de460012a1ae9a'\n'access': 'granted'\n'part_number': 1\n'total_parts': 19\n'poc_summary': 'This conference talk examines Angular’s shift to declarative reactivity using Signals, the Resource API, and the NgRx Signal Store.'\n'chunk_summary': 'It introduces the marble run metaphor to explain the data flow-centric mindset needed for effective use of signals.'\n'access_message': '✅ You still have access to the recordings for this talk of International JavaScript Conference Munich 2025 until 2026-04-26. Unfortunately, recordings are not available for workshops, but you can still access the slides and your certificate. Dive back in anytime!'\n\n'documentId': 'bc0bef25841c96486c56f58f'\n'chunk_id': '6876da63225e92fc1ac7c2dc'\n'access': 'restricted'\n'part_number': 44\n'total_parts': 56\n'poc_summary': 'This flexible seminar lesson deepens advanced Angular concepts, focusing on pipes, NgModules, subcomponents, and the introduction of Signals for modern change detection.'\n'chunk_summary': 'It compares Signals to Observables and explains their lightweight, focused implementation for reactivity.'\n'access_message': 'ℹ️ This talk of Angular Camp - Flexible Basic Camp September 2025 | online was part of a past event. Booking is no longer available, but you can discover the current edition right here on the platform.'\n\n'documentId': 'a46f583e86ab963aed1784a1'\n'chunk_id': '68a457709f706f00135a4801'\n'access': 'granted'\n'part_number': 1\n'total_parts': 20\n'poc_summary': 'This conference talk examines how to migrate existing Angular codebases to the new Signals API for scalable, reactive frontend architectures.'\n'chunk_summary': 'It introduces the origins of Angular Signals and highlights the shift from traditional to reactive design principles.'\n'access_message': '✅ You still have access to the recordings for this talk of iJS San Diego 2025 until 2025-11-16. Unfortunately, recordings are not available for workshops, but you can still access the slides and your certificate. Dive back in anytime!'\n\n'documentId': 'a527c16f5bc7b4da1bc88ab0'\n'chunk_id': '68f251653134c10012c3d1fb'\n'access': 'restricted'\n'part_number': 2\n'total_parts': 15\n'poc_summary': 'This conference talk examines how Angular Resources enable signal-based asynchronous data handling and may replace RxJS in future Angular applications.'\n'chunk_summary': 'It explains how signals create a dependency graph, allowing Angular to efficiently track and update components and data.'\n'access_message': 'ℹ️ This talk of International JavaScript New York 2025 was part of a past event. Booking is no longer available, but you can discover the current edition right here on the platform.'\n\n'documentId': '01a63ca630515849aaa314b1'\n'chunk_id': '6876e25c51ca701363239b74'\n'access': 'restricted'\n'part_number': 1\n'total_parts': 1\n'poc_summary': 'This conference talk introduces Angular Signals and their new features for modern reactive application development.'\n'chunk_summary': 'It explains how linkedSignal() and resource() in Angular 19 enhance performance and developer experience.'\n'access_message': 'ℹ️ This talk of JavaScript Days München und online 2025 was part of a past event. Booking is no longer available, but you can discover the current edition right here on the platform.'\n\n'documentId': '68fe3d9fc389515d1d6bea43'\n'chunk_id': '6876d50f225e92fc1ac7a4ec'\n'access': 'granted'\n'part_number': 1\n'total_parts': 6\n'poc_summary': 'This article provides professional guidance on effectively using Signals in Angular, focusing on best practices and integration with RxJS.'\n'chunk_summary': 'It explains how unidirectional data flow with signals supports state management and highlights their glitch-free property.'\n'access_message': '✅ This content is included with your elevate membership.'\n\n'documentId': '9836770500f149a58b7769f9'\n'chunk_id': '68ad7e38494be90012217fe7'\n'access': 'granted'\n'part_number': 1\n'total_parts': 6\n'poc_summary': 'This article provides professional guidance on effectively using Signals in Angular, focusing on best practices for reactive data flow and integration with RxJS.'\n'chunk_summary': 'It explains how unidirectional data flow with Signals supports state management and highlights their glitch-free property.'\n'access_message': '✅ This content is included with your elevate membership.'\n\n'documentId': '5ca564ac8c4557f4f949b660'\n'chunk_id': '687a2b83495b49563aa87ad2'\n'access': 'restricted'\n'part_number': 6\n'total_parts': 9\n'poc_summary': 'This conference talk examines how new Angular APIs enable modern codebases, focusing on migration strategies and developer experience.'\n'chunk_summary': 'It demonstrates how signal APIs can be used for type-safe data handling and property bindings in Angular components.'\n'access_message': 'ℹ️ This talk of International JavaScript Conference Munich 2024 was part of a past event. Booking is no longer available, but you can discover the current edition right here on the platform.'\n\n'documentId': 'E8GpqxYcngd3MofGq'\n'chunk_id': '687a2deb9bbcb45d2a11f10f'\n'access': 'restricted'\n'part_number': 1\n'total_parts': 1\n'poc_summary': 'This conference talk examines Angular Signals as a new approach to reactivity and their impact on application performance.'\n'chunk_summary': 'It discusses the advantages of Signals over the existing model and addresses the future role of RxJS.'\n'access_message': 'ℹ️ This talk of JavaScript Days Berlin und online 2024 was part of a past event. Booking is no longer available, but you can discover the current edition right here on the platform.'\n\n'documentId': '787b05fae93f992824034695'\n'chunk_id': '687a222bd92aed38f5a4a6bb'\n'access': 'restricted'\n'part_number': 1\n'total_parts': 7\n'poc_summary': 'This conference talk presents three practical rules for effectively using Signals to build maintainable, reactive Angular applications.'\n'chunk_summary': 'The talk uses an Austrian dessert rating app to illustrate how Signals update UI components reactively.'\n'access_message': 'ℹ️ This talk of International JavaScript Conference Munich 2024 was part of a past event. Booking is no longer available, but you can discover the current edition right here on the platform.'\n\n\nTop Atlas:\n'documentId': 'de0df53930e2e1e582caf57f'\n'chunk_id': '687814d5bed6dcd41a99b081'\n'access': 'granted'\n'part_number': 11\n'total_parts': 15\n'contentType': 'READ'\n'title': Angular 17: The Web Framework's Newest Release - Renaissance? Angular 17! - All features at a glance\n'parentName': JavaScript Magazine Volume 12\n'language': 'EN'\n'date': '2024-03-22T02:00:00.000Z'\n'abstract': The popular JavaScript framework Angular has released version 17. It can be difficult to keep up with all the changes in angular, but this article covers an overview of Angular 17 features.\n'parentId': '7e9c82426451f3a6ca3ddfbf'\n'parentDescription': Broaden your knowledge and expand your JavaScript techniques and practices. From Angular, React, and WebAssembly, to the best JavaScript IDEs, open source tools and more, you’ll learn insights on everything JS from seasoned experts in their field. Keep up with JavaScript news, tips, and advice with interviews, tutorials, and in-depth articles.\n'indexBrandName': ''\n'indexSeriesName': ''\n'author': 'Karsten Sitterberg'\n'chunkSource': 'text'\n'text': can also be reloaded using a time trigger. You must give a trigger a duration to load the component after. For example, Listing 17 specifies that the defer block should start loading the '' component after 1.5 seconds. Regardless of the 'on' condition used, the '@loading' block can be given an 'after' and/or a 'minimum' duration. In Listing 17, the 'after' specification ensures that the loading state is displayed after 100 milliseconds at the earliest. The 'minimum' specification makes sure that the loading state is displayed for at least 150 milliseconds. Similarly, the 'minimum' specification for '@placeholder' ensures that the placeholder is displayed for at least 150 milliseconds before displaying the loading state. @defer (on timer(1500ms)) {  } @loading (after 100ms; minimum 150ms) { \n\n...Loading... } @placeholder (minimum 100ms) { Placeholder } Listing 17: Timer condition and minimum specifications The new defer syntax also allows direct optimization. An optional 'prefetch' statement can also be specified in the defer condition. The logic specified after the prefetch statement corresponds to the defer logic described above. In Listing 18, a component should only be displayed when the state of the variable 'isVisible' changes to 'true'. The prefetch condition is used so the component can be displayed now without loading time. Once the 'prefetchCondition' variable changes to 'true', Angular prefetches the '@defer' block content. If 'isVisible' changes to 'true', no more loading time is needed, since the component is already 'present' and only needs to be rendered. In the example shown in Listing 18, an 'on' condition is used for pre-fetching instead of a 'when' condition. In this case, Angular starts reloading the component when the outer component has rendered. @defer (when isVisible; prefetch when prefetchCondition) { //... @defer (when isVisible; prefetch on immediate) { //... Listing 18: Prefetch conditions Angular CLI 17 will have an automatic migration to transform the old control flow directives to the new syntax. This should simplify changing to the new syntax. But at least in Angular 17, both syntax variants can still be used. Breaking Changes Since Angular 17 is a major release, there’s also a few breaking changes. One breaking change concerns the Signal feature introduced in Angular 16. Signals were still in a preview mode in Angular 16, hence the short time until this change. With Signals, it’s been shown that the 'signal.mutate()' function can cause inconsistencies in the application. Therefore, the option to change a Signal has been removed. Signals should no longer be changed by mutation, but should be used like an immutable data structure instead. Listing 19 shows an\n'slidetext': ''\n'from': 'index'\n'score': 131.87367248535156\n'normalizedScore': 1.3187367248535156\n'beforeDatePenaltyScore': 1.3187367248535156\n\n'documentId': '04721391f3f7580f0631b9d3'\n'chunk_id': '687a2103a98d5a30b3a3413b'\n'access': 'granted'\n'part_number': 16\n'total_parts': 21\n'contentType': 'READ'\n'title': Angular 17: Neues Release des Web-Frameworks - Renaissance? Angular 17! - Alle Features im Überblick\n'parentName': iJS Magazin 2.2024\n'language': 'DE'\n'date': '2024-04-03T22:00:00.000Z'\n'abstract': Das beliebte JavaScript-Framework Angular veröffentlicht Version 17. Da bei Angular viel in Bewegung ist, kann manch einer da den Überblick verlieren. Wir stellen alle Features von Angular 17 vor.\n'parentId': 'c04db0163e3cb47407e78b63'\n'parentDescription': Kaum ein Softwareprojekt, das nicht in wesentlichen Teilen auf der JavaScript-Technologie basiert. Eine breite Unterstützung sowie, leistungsfähige Programmiersprachen, die Vielzahl moderner Tools, sowie ausgereifte Frameworks wie Angular, React, Vue.js oder Node.js machen den JavaScript-Werkzeugkasten zu einem Alleskönner. Das iJS Magazin informiert aktuell und umfassend über die wichtige und innovative Entwicklungen im JavaScript-Universum und bietet handfeste Praxisinformationen für Softwareentwickler und -architekten.\n'indexBrandName': ''\n'indexSeriesName': ''\n'author': 'Karsten Sitterberg'\n'chunkSource': 'text'\n'text': wird, entspricht der oben beschriebenen Defer-Logik. In Listing 18 oben soll zum Beispiel eine Komponente erst dann angezeigt werden, wenn der Zustand der Variablen “isVisible” auf “true” wechselt. Damit die Komponente zu diesem Zeitpunkt dann ohne Ladezeit angezeigt werden kann, wird die Prefetch-Bedinung verwendet: Sobald die Variable “prefetchCondition” auf “true” wechselt, lädt Angular den Inhalt des “@defer”-Block vor. Wenn im Anschluss “isVisible” auf “true” wechselt, wird keine Ladezeit mehr benötigt, da die Komponente schon “vorhanden” ist und nur noch gerendert werden muss. Im unteren Beispiel aus Listing 18 wird statt einer “when”-Bedinung eine “on”-Bedinung zum pre-fetchen verwendet. In diesem Fall fängt Angular mit dem Nachladen der Komponente an, sobald die äußere Komponente gerendert wurde. Listing 18: Prefetch-Bedingungen @defer (when isVisible; prefetch when prefetchCondition) { //... @defer (when isVisible; prefetch on immediate) { //... Um die alten Control-Flow-Direktiven auf die neue Syntax zu transformieren, wird es im Angular-CLI 17 eine automatische Migration geben, die den Wechsel zur neuen Syntax vereinfachen soll. Zumindest in Angular 17 sind aber noch beide Syntax-Varianten verwendbar. Breaking Changes in Angular 17 Da Angular 17 ein Major Release ist, gibt es entsprechend auch ein paar Breaking Changes. Ein Breaking Change betrifft das mit Angular 16 eingeführte Feature der Signals. Die Signals wurden mit Angular 16 noch als Developer-Preview gehandelt, daher die kurze Zeit bis zu dieser Änderung. Bei den Signals hat es sich gezeigt, dass die “signal.mutate()”-Funktion zu Inkonsistenzen in der Anwendung führen kann. Daher wurde diese Möglichkeit, ein Signal zu ändern, entfernt. Signals sollten nun nicht mehr per Mutation verändert werden, sondern stattdessen immer wie eine immutable Datenstruktur verwendet werden. In Listing 19 ist beispielhaft gezeigt, wie ein Signal, das ein Array enthält, bisher verändert werden konnte, und wie es ab Angular 17 geschehen sollte. Listing 19: Items zu einem “Signal” hinzufügen im Angular 16/17-Vergleich // Mit Angular 16 items.mutate(itemsArray => itemsArray.push(newItem)); // Ab Angular 17: items.update(itemsArray => [itemsArray, ...newItem]); Neben den Signals gibt es Breaking Changes im Router. Dieser hat bisher die Properties - “canceledNavigationResolution“ - “paramsInheritanceStrategy“\n'slidetext': ''\n'from': 'index'\n'score': 131.08670043945312\n'normalizedScore': 1.3108670043945312\n'beforeDatePenaltyScore': 1.3108670043945312\n\n'documentId': 'de0df53930e2e1e582caf57f'\n'chunk_id': '687814d5bed6dcd41a99b082'\n'access': 'granted'\n'part_number': 12\n'total_parts': 15\n'contentType': 'READ'\n'title': Angular 17: The Web Framework's Newest Release - Renaissance? Angular 17! - All features at a glance\n'parentName': JavaScript Magazine Volume 12\n'language': 'EN'\n'date': '2024-03-22T02:00:00.000Z'\n'abstract': The popular JavaScript framework Angular has released version 17. It can be difficult to keep up with all the changes in angular, but this article covers an overview of Angular 17 features.\n'parentId': '7e9c82426451f3a6ca3ddfbf'\n'parentDescription': Broaden your knowledge and expand your JavaScript techniques and practices. From Angular, React, and WebAssembly, to the best JavaScript IDEs, open source tools and more, you’ll learn insights on everything JS from seasoned experts in their field. Keep up with JavaScript news, tips, and advice with interviews, tutorials, and in-depth articles.\n'indexBrandName': ''\n'indexSeriesName': ''\n'author': 'Karsten Sitterberg'\n'chunkSource': 'text'\n'text': the 'signal.mutate()' function can cause inconsistencies in the application. Therefore, the option to change a Signal has been removed. Signals should no longer be changed by mutation, but should be used like an immutable data structure instead. Listing 19 shows an example of how a Signal containing an array could previously be changed and how it should be done from Angular 17 onwards. // With Angular 16 items.mutate(itemsArray => itemsArray.push(newItem)); // From Angular 17: items.update(itemsArray => [itemsArray, ...newItem]); Listing 19: Comparing adding items to a 'Signal' between Angular 16/17 Besides Signals, there are also breaking changes in the router. So far, this has the properties: - “canceledNavigationResolution“ - “paramsInheritanceStrategy“ - “titleStrategy“ - “urlUpdateStrategy“ - “malformedUriErrorHandler“ - “urlHandlingStrategy“ With Angular 17, these properties were removed from the router’s public API. Instead of using the router, these properties should now be configured with the corresponding configuration parameters in the 'provideRouter()' function or the 'RouterModule.forRoot()' hook. Angular 17 in Practice The changes allow new types of architecture and optimizations which were previously impossible or difficult to implement. An example from practice illustrates this: A played a leading role in developing an integrated platform to provide effective, secure, fully GDPR-compliant remote training. If you look at a live screenshot (Figure 3), you’ll see that the audio and video control is directly available in the primary view (bottom left switch). This means that the associated components and services cannot be reloaded later with lazy loading, since there’s no nested route that would allow the code to be split accordingly. This is now possible thanks to the new option to carry out code splitting and lazy loading at the component level. This means that initial application loads are considerably faster, since audio/video functionality in particular is complex and accounts for large portions of the code. Figure 3: A complex Angular real-time application It is also advantageous to be able to do without zone.js and implement better controlled and fine-grained change detection using Signals. This leads to an overall improved performance and reduced load on the client system. On the other hand, this requires corresponding changes that cannot be implemented by an automatic code transformation. All involved developers must learn the new concepts and master them in depth in order to effectively and meaningfully use these new possibilities. By the way, what about the Angular module system? It still exists today, but the plan is to make modules optional in the future. This is also intended to make it easier for new developers to get started with Angular. Angular Material Angular Material 17 introduces both an important and significant change for\n'slidetext': ''\n'from': 'index'\n'score': 130.98272705078125\n'normalizedScore': 1.3098272705078124\n'beforeDatePenaltyScore': 1.3098272705078124\n\n'documentId': 'de0df53930e2e1e582caf57f'\n'chunk_id': '687814d4bed6dcd41a99b079'\n'access': 'granted'\n'part_number': 5\n'total_parts': 15\n'contentType': 'READ'\n'title': Angular 17: The Web Framework's Newest Release - Renaissance? Angular 17! - All features at a glance\n'parentName': JavaScript Magazine Volume 12\n'language': 'EN'\n'date': '2024-03-22T02:00:00.000Z'\n'abstract': The popular JavaScript framework Angular has released version 17. It can be difficult to keep up with all the changes in angular, but this article covers an overview of Angular 17 features.\n'parentId': '7e9c82426451f3a6ca3ddfbf'\n'parentDescription': Broaden your knowledge and expand your JavaScript techniques and practices. From Angular, React, and WebAssembly, to the best JavaScript IDEs, open source tools and more, you’ll learn insights on everything JS from seasoned experts in their field. Keep up with JavaScript news, tips, and advice with interviews, tutorials, and in-depth articles.\n'indexBrandName': ''\n'indexSeriesName': ''\n'author': 'Karsten Sitterberg'\n'chunkSource': 'text'\n'text': 1: Old Angular-Logo on the left and new Angular-Logo on the right. Angular Angular 17 comes with a lot of new features. The Angular team calls it one of the 'biggest' releases in its history. Besides the version updates for zone.js and TypeScript, it also offers many smaller and larger innovations. Two innovations related to the new APIs regarding Signals have already been added in Angular 16.2.0. Namely, it adds two new component lifecycle hooks. These are special because they don’t have to be implemented with an interface like conventional lifecycle hooks. They can be called as a callback function. This is similar to the 'computed()' function in Signals. Listing 6 shows an example with the new hooks. The two hooks are called 'afterRender()' and 'afterNextRender()' and are executed, according to their name, after Angular renders the respective component. The difference between the two hooks is that 'afterNextRender()' is only called once, after the next rendering process, while 'afterRender()' remains active as long as the component is active. However, these two hooks are still listed as 'Developer Preview' and are subject to change. @Component({}) export class DemoComponent { val = 42; constructor() { afterRender(() => { console.log('afterRender', this.val); }); afterNextRender(() => { console.log('afterNextRender', this.val); }); } } Listing 6: Implementing the new lifecycle hooks Signals An important detail in Angular 17 is that the signals introduced in Angular 16 are now stable. The goal of introducing Signals was to make zone.js optional by introducing a new, signal-based change detection mechanism. In Angular 17, the team has come a step closer to this goal. Signals enable 'local change detection', a change detection process that only refers to the components that have changed (signal) values. Figure 1 shows an example of the difference between the change detection mechanisms. In the standard case, the complete component graph is checked for each asynchronous event. With OnPush-ChangeDetection, components that triggered the change detection or have changed '@Input()' values and their respective parent components (up to the AppComponent) are checked. With Signals, you can now check only the components that have changed signal values. Figure 2: Comparing change detection mechanisms Animations Animations can be reloaded in Angular 17 with lazy loading. The browser must first load smaller bundles, making the initial application smaller, leading to shorter application loading and start times. To activate lazy loading for animations, the 'provideAnimationsAsync()' function must be used. Here, the 'BrowserAnimationModule' should no longer be imported and the 'provideAnimations()' function should no longer be used. The special thing about an SPA is that, as a rule,\n'slidetext': ''\n'from': 'index'\n'score': 130.66786193847656\n'normalizedScore': 1.3066786193847657\n'beforeDatePenaltyScore': 1.3066786193847657\n\n'documentId': '04721391f3f7580f0631b9d3'\n'chunk_id': '687a2101a98d5a30b3a3412b'\n'access': 'granted'\n'part_number': 8\n'total_parts': 21\n'contentType': 'READ'\n'title': Angular 17: Neues Release des Web-Frameworks - Renaissance? Angular 17! - Alle Features im Überblick\n'parentName': iJS Magazin 2.2024\n'language': 'DE'\n'date': '2024-04-03T22:00:00.000Z'\n'abstract': Das beliebte JavaScript-Framework Angular veröffentlicht Version 17. Da bei Angular viel in Bewegung ist, kann manch einer da den Überblick verlieren. Wir stellen alle Features von Angular 17 vor.\n'parentId': 'c04db0163e3cb47407e78b63'\n'parentDescription': Kaum ein Softwareprojekt, das nicht in wesentlichen Teilen auf der JavaScript-Technologie basiert. Eine breite Unterstützung sowie, leistungsfähige Programmiersprachen, die Vielzahl moderner Tools, sowie ausgereifte Frameworks wie Angular, React, Vue.js oder Node.js machen den JavaScript-Werkzeugkasten zu einem Alleskönner. Das iJS Magazin informiert aktuell und umfassend über die wichtige und innovative Entwicklungen im JavaScript-Universum und bietet handfeste Praxisinformationen für Softwareentwickler und -architekten.\n'indexBrandName': ''\n'indexSeriesName': ''\n'author': 'Karsten Sitterberg'\n'chunkSource': 'text'\n'text': Hooks besteht darin, dass “afterNextRender()” nur einmal, nach dem nächsten Rendering-Vorgang, aufgerufen wird, während “afterRender()” aktiv bleibt, solange die Komponente aktiv ist. Diese beiden Hooks sind allerdings noch als “Developer Preview” geführt, können sich also noch ändern. Listing 6: Implementierung der neuen Lifecycle-Hooks @Component({}) export class DemoComponent { val = 42; constructor() { afterRender(() => { console.log('afterRender', this.val); }); afterNextRender(() => { console.log('afterNextRender', this.val); }); } } Signals sind stable in Angular 17 Ein wichtiges Detail in Angular 17 ist, dass die mit Angular 16 eingeführten Signals nun als Stable markiert sind. Das eigentliche Ziel bei Einführung der Signals war es, zone.js optional zu machen, indem ein neuer, Signal-basierter Change-Detection-Mechanismus eingeführt wird. Mit Angular 17 kommt das Angular-Team diesem Ziel einen großen Schritt näher: Signals ermöglichen eine sogenannte “lokale Change-Detection”, also einen Change-Detection-Vorgang, der sich nur auf die Komponenten bezieht, die auch wirklich geänderte (Signal)-Werte haben. In Abbildung 2 ist beispielhaft der Unterschied zwischen den verschiedenen Change-Detection-Mechanismen dargestellt. Im Standardfall wird bei jedem asynchronen Event der komplette Komponentengraph überprüft. Bei OnPush-ChangeDetection werden die Komponenten überprüft, die die Change-Detection ausgelöst haben, oder geänderte “@Input()”-Werte haben, und deren jeweilige Parent-Komponenten (bis hoch zur AppComponent). Mit Signals ist es nun möglich, dass wirklich nur die Komponenten überprüft werden, die geänderte Signal-Werte haben. Abbildung 2: Change-Detection-Mechanismen im Vergleich Animations mit Lazy-Loading in Angular 17 Animationen können in Angular 17 per Lazy Loading nachgeladen werden. Dadurch muss der Browser initial kleinere Bundles laden, macht also die initiale Anwendung kleiner und führt somit zu geringeren Anwendungs-Lade- und -Startzeiten. Um das Lazy-Loading der Animationen zu aktivieren, muss die Funktion “provideAnimationsAsync()” verwendet werden. Das “BrowserAnimationModule” sollte in diesem Fall dann nicht mehr importiert bzw. die Funktion “provideAnimations()” nicht mehr genutzt werden. Das Besondere an einer SPA ist, dass im Regelfall nur beim Start der Anwendung ein HTML-Dokument geladen wird. Beim Wechsel auf eine andere Route werden lediglich Bestandteile im Browser-DOM ausgetauscht. Damit können Animationen nicht wie bei serverseitigen Anwendungen\n'slidetext': ''\n'from': 'index'\n'score': 127.88152313232422\n'normalizedScore': 1.2788152313232422\n'beforeDatePenaltyScore': 1.2788152313232422\n\n'documentId': '04721391f3f7580f0631b9d3'\n'chunk_id': '687a2101a98d5a30b3a34119'\n'access': 'granted'\n'part_number': 2\n'total_parts': 21\n'contentType': 'READ'\n'title': Angular 17: Neues Release des Web-Frameworks - Renaissance? Angular 17! - Alle Features im Überblick\n'parentName': iJS Magazin 2.2024\n'language': 'DE'\n'date': '2024-04-03T22:00:00.000Z'\n'abstract': Das beliebte JavaScript-Framework Angular veröffentlicht Version 17. Da bei Angular viel in Bewegung ist, kann manch einer da den Überblick verlieren. Wir stellen alle Features von Angular 17 vor.\n'parentId': 'c04db0163e3cb47407e78b63'\n'parentDescription': Kaum ein Softwareprojekt, das nicht in wesentlichen Teilen auf der JavaScript-Technologie basiert. Eine breite Unterstützung sowie, leistungsfähige Programmiersprachen, die Vielzahl moderner Tools, sowie ausgereifte Frameworks wie Angular, React, Vue.js oder Node.js machen den JavaScript-Werkzeugkasten zu einem Alleskönner. Das iJS Magazin informiert aktuell und umfassend über die wichtige und innovative Entwicklungen im JavaScript-Universum und bietet handfeste Praxisinformationen für Softwareentwickler und -architekten.\n'indexBrandName': ''\n'indexSeriesName': ''\n'author': 'Karsten Sitterberg'\n'chunkSource': 'text'\n'text': '@NgModule()'s. - Funktionale HTTP-Interceptoren werden in Angular CLI 17 bevorzugt, klassenbasierte sind optional. - Einführung der neuen Syntax @switch, @case, und @default für Conditional Rendering und neue Direktiven wie @defer für Lazy Loading. - @defer unterstützt bedingtes Laden und Vorladen mit prefetch. - Die Angular CLI bietet eine automatische Migration zur neuen Syntax an; alte und neue Syntax können in Version 17 parallel genutzt werden. - Integration der neuen Lifecycle-Hooks afterRender() und afterNextRender sowie die Stabilisierung von Signals. - Lazy Loading für Animationen und die Integration der View Transitions DOM-API für optimierte Übergänge und Animationen. - Einführung einer neuen Control-Flow-Syntax als Developer Preview, die *ngIf, *ngFor, und ngSwitch ersetzt und zusätzliche Verbesserungen wie @if, @for, und erforderliches Track-by für Listen umfasst. Breaking Changes in Angular 17 - Entfernung von signal.mutate(): Die Möglichkeit, Signals durch Mutation zu verändern, wurde entfernt. Signals müssen als immutable Datenstrukturen behandelt werden; Änderungen sollten durch die signal.update()-Funktion vorgenommen werden. - Signal-Handhabung als immutable: Anstatt Signals zu mutieren, sollten Entwickler diese nun behandeln, als wären sie immutable, und entsprechend aktualisieren. - Entfernung von Router Properties: Bestimmte Router Properties wie canceledNavigationResolution, paramsInheritanceStrategy, titleStrategy, urlUpdateStrategy, malformedUriErrorHandler und urlHandlingStrategy wurden aus der öffentlichen API entfernt. - Neue Konfiguration über provideRouter() oder RouterModule.forRoot(): Die zuvor entfernten Router Properties müssen jetzt über die provideRouter()-Funktion oder im RouterModule.forRoot()-Hook konfiguriert werden. - Änderung in der Navigation: Die Konfiguration der Navigationsstrategie und Fehlerbehandlung muss an die neuen Methoden angepasst werden, um Inkompatibilitäten mit dem Router-Service von Angular 17 zu vermeiden. TypeScript Mit der neuen Angular-Version wird auch eine neue TypeScript-Version unterstützt. In Angular 17 muss nun zugleich TypeScript mindestens in Version 5.2 verwendet werden. Da beim Release von Angular 16 noch TypeScript 5.0 vorausgesetzt wurde, wollen wir uns an dieser Stelle sowohl einige interessante Neuerungen sowohl aus TypeScript 5.1 als auch aus TypeScript 5.2 ansehen. Implizites “return“ bei Rückgabe von “undefined“ Wenn in JavaScript eine Funktion keine “return”-Angabe enthält, hat diese Funktion dennoch immer implizit “undefined” als Rückgabewert. In TypeScript hat sich diese Tatsache bisher nicht\n'slidetext': ''\n'from': 'index'\n'score': 126.76396179199219\n'normalizedScore': 1.2676396179199219\n'beforeDatePenaltyScore': 1.2676396179199219\n\n'documentId': 'de0df53930e2e1e582caf57f'\n'chunk_id': '687814d4bed6dcd41a99b07c'\n'access': 'granted'\n'part_number': 6\n'total_parts': 15\n'contentType': 'READ'\n'title': Angular 17: The Web Framework's Newest Release - Renaissance? Angular 17! - All features at a glance\n'parentName': JavaScript Magazine Volume 12\n'language': 'EN'\n'date': '2024-03-22T02:00:00.000Z'\n'abstract': The popular JavaScript framework Angular has released version 17. It can be difficult to keep up with all the changes in angular, but this article covers an overview of Angular 17 features.\n'parentId': '7e9c82426451f3a6ca3ddfbf'\n'parentDescription': Broaden your knowledge and expand your JavaScript techniques and practices. From Angular, React, and WebAssembly, to the best JavaScript IDEs, open source tools and more, you’ll learn insights on everything JS from seasoned experts in their field. Keep up with JavaScript news, tips, and advice with interviews, tutorials, and in-depth articles.\n'indexBrandName': ''\n'indexSeriesName': ''\n'author': 'Karsten Sitterberg'\n'chunkSource': 'text'\n'text': lazy loading for animations, the 'provideAnimationsAsync()' function must be used. Here, the 'BrowserAnimationModule' should no longer be imported and the 'provideAnimations()' function should no longer be used. The special thing about an SPA is that, as a rule, an HTML document is only loaded when the application starts. When switching to a different route, only components in the browser DOM are exchanged. Animations cannot simply be executed on page load, as is the case with server-side applications. Instead, animations must be better adapted to SPA logic, such as route changes. This is what the new View Transitions DOM API is designed for. This API provides the callback 'document.startViewTransition()', which tells the browser that a view transition will start. Logic can be passed to the function that defines how the browser DOM should look at the end of the transition. The transition animation can be created using special CSS pseudo selectors. Angular uses this new API in the Angular 17 router so that a view transition is started for each navigation. However, since the 'View Transition' feature is still experimental and has only been implemented in Chrome and Edge, router navigation in browsers such as Firefox or Safari continues to take place synchronously. To activate ViewTransitions, the 'withViewTransitions()' function can be added to the router at startup. In Listing 7, the 'withViewTransitions()' is also given a configuration object in which an 'onViewTransitionCreated()' callback can be defined if additional (animation) logic is needed. provideRouter( routes, withViewTransitions({ onViewTransitionCreated: transitionInfo => { } }) ), Listing 7: Activating the ViewTransitions in the AppModule or app.config New Control Flow Syntax The biggest and most far-reaching innovation for developers, and the biggest innovation in Angular in terms of template syntax, is the new control flow syntax. In Angular 17, this syntax is still in a developer preview. But in the future, it will completely replace the previous directives '*ngIf', '*ngFor' and 'ngSwitch'. The logic of these directives will become part of the framework itself, instead of 'normal' directives. This will allow the Angular team to better optimize the respective logic. Signals and the goal of making zone.js optional with the help of Signals were also a key reason for these innovations, since the old control flow directives were based on and needed 'zone.js'. Besides the control flow logic, another feature that can be implemented thanks to the new syntax is a new form of lazy loading at component level. This feature, also known as 'deferrable views', is discussed in more detail below. First, let's familiarize ourselves with the basic syntax. Until now, 'control flow' in Angular templates was handled by\n'slidetext': ''\n'from': 'index'\n'score': 126.3519058227539\n'normalizedScore': 1.263519058227539\n'beforeDatePenaltyScore': 1.263519058227539\n\n'documentId': '64ace3828d8056484c3534ab'\n'chunk_id': '687814c5bed6dcd41a99b027'\n'access': 'granted'\n'part_number': 15\n'total_parts': 21\n'contentType': 'READ'\n'title': Angular 16 released - Alles zu neuen Features und Breaking Changes\n'parentName': iJS Magazin Band 27\n'language': 'DE'\n'date': '2023-04-06T00:00:00.000Z'\n'abstract': Wir geben einen Überblick zu allen wichtigen Infos zum Release von Angular 16. Alles zu Signals, der Angular-CLI und TypeScript in Angular 16 erfahren Sie hier.\n'parentId': '5093fc7a779ccfe852d8fe7b'\n'parentDescription': Kaum ein Softwareprojekt, das nicht in wesentlichen Teilen auf der JavaScript-Technologie basiert. Eine breite Unterstützung sowie, leistungsfähige Programmiersprachen, die Vielzahl moderner Tools, sowie ausgereifte Frameworks wie Angular, React, Vue.js oder Node.js machen den JavaScript-Werkzeugkasten zu einem Alleskönner. Das iJS Magazin informiert aktuell und umfassend über die wichtige und innovative Entwicklungen im JavaScript-Universum und bietet handfeste Praxisinformationen für Softwareentwickler und -architekten.\n'indexBrandName': ''\n'indexSeriesName': ''\n'author': 'Karsten Sitterberg'\n'chunkSource': 'text'\n'text': die technische, aber auch die konzeptionelle Komplexität reduziert werden. Gleichzeitig hat das Thema auch etwas Beigeschmack: Die offiziellen Diskussionen wurden erst ca. drei Wochen vor Verabschiedung des ersten Release-Candidate von Angular 16 öffentlich gestartet. Bei einer Entwicklungszeit von sechs Monaten und den potenziell immensen Konsequenzen einer solchen Designänderung wirkt das schon sehr kurzfristig. Kritische Kommentare in den RFC Diskussionen wurden zudem sehr diplomatisch abgetan, es wirkt, als sei sowieso alles intern durch das Angular-Team und Google entschieden worden. Assoziationen mit Paris 2016 sind dabei nicht ganz unbegründet. So ein Vorgehen stellt ein ernstzunehmendes Risiko für die Angular-Community dar. Ob Angular damit wirklich konzeptionell simpler wird, solange der mitgelieferte HttpClient RxJS verwendet, darf auch bezweifelt werden. Schließlich kommen Entwickler so zwangsläufig mit beiden Konzepten in Kontakt. Aber vielleicht wird ja auch drei Wochen vor dem ersten Release Candidate von Angular 17 der HttpClient mit demselben Argument abgekündigt. Auch wenn es sich also um vielversprechende Visionen und fast schon eine neue Generation Angular handelt - etwas mehr Fingerspitzengefühl und Transparenz wären hier wünschenswert. Technisch handelt es sich bei den Signals um eine Reactivity-Engine, mit der Änderungen am Zustand von speziellen Daten-Objekten zu Updates der zugehörigen DOM-Elemente führen. Anders als Promises und RxJS-Observable sind Aktionen auf “Signals” stets synchron. Da Webanwendungen inhärent durch Events getrieben sind, passt RxJS prinzipiell sehr gut. Daher gibt es zur Transformation zwischen Signals und Observables das neue Paket @angular/rxjs-interop, das Transformations-APIs wie ‘toObservable()’ und ‘toSignal()’ zur Verfügung stellt. Ein Signal kann einfach erzeugt werden, indem die neue Funktion signal() aufgerufen wird. Der Typ-Parameter T steht dabei für den Datentypen, der von diesem Signal “verwaltet” werden soll. In Listing 19 ist anhand des Signal counter zu sehen, dass der Typ eines Signal auch durch Definition eines Initialwertes, hier die Zahl 0, festlegen kann. Ausgelesen wird das Signal dann, indem es wie eine Funktion aufgerufen wird. Das ist beispielsweise im Template der Komponente aus Listing 19 gezeigt. Normalerweise sollte bei Ausgaben in Templates\n'slidetext': ''\n'from': 'index'\n'score': 125.90798950195312\n'normalizedScore': 1.2590798950195312\n'beforeDatePenaltyScore': 1.2590798950195312\n\n'documentId': '64ace3828d8056484c3534ab'\n'chunk_id': '687814c6bed6dcd41a99b02a'\n'access': 'granted'\n'part_number': 18\n'total_parts': 21\n'contentType': 'READ'\n'title': Angular 16 released - Alles zu neuen Features und Breaking Changes\n'parentName': iJS Magazin Band 27\n'language': 'DE'\n'date': '2023-04-06T00:00:00.000Z'\n'abstract': Wir geben einen Überblick zu allen wichtigen Infos zum Release von Angular 16. Alles zu Signals, der Angular-CLI und TypeScript in Angular 16 erfahren Sie hier.\n'parentId': '5093fc7a779ccfe852d8fe7b'\n'parentDescription': Kaum ein Softwareprojekt, das nicht in wesentlichen Teilen auf der JavaScript-Technologie basiert. Eine breite Unterstützung sowie, leistungsfähige Programmiersprachen, die Vielzahl moderner Tools, sowie ausgereifte Frameworks wie Angular, React, Vue.js oder Node.js machen den JavaScript-Werkzeugkasten zu einem Alleskönner. Das iJS Magazin informiert aktuell und umfassend über die wichtige und innovative Entwicklungen im JavaScript-Universum und bietet handfeste Praxisinformationen für Softwareentwickler und -architekten.\n'indexBrandName': ''\n'indexSeriesName': ''\n'author': 'Karsten Sitterberg'\n'chunkSource': 'text'\n'text': Vermeidung von Endlosschleifen Signals immer nur gelesen, nie geschrieben werden. Dies wird auch durch die Signal-API überprüft und dann ggf. ein Fehler geworfen. Listing 21: Beispiel für Logging als Signal-Effect constructor() { effect(() => { console.log(this.invoice()) }) } Signals sollen perspektivisch auch selbst - unabhängig von Zone.js - die Change-Detection in Komponenten steuern können. Dieses Verhalten ist noch nicht Teil von Angular 16, soll aber aktiviert werden können, indem signals: true in die Komponenten-Metadaten aufgenommen wird. In dem Fall werden die Inputs einer Komponente auch als Signals statt als veränderliche Objekte ausgeprägt. Allerdings ändert sich auch die Syntax, mit der man @Input, @Output und dergleichen schreibt: All diese Angular-Konzepte sind dann keine @-Decorators mehr, sondern spezielle Signals-Funktionen. Beispielsweise werden Inputs dann zu input()- und Outputs zu output()-Signals. Das passt dann gut dazu, dass die TypeScript Standard-Decorators nicht für Parameter, sondern nur für Typen funktionieren. Ähnlich verhält es sich mit Queries für ‘viewChild/ren’ und ‘contentChild/ren’, auch diese werden dann als Signal bereitgestellt. Im Lifecycle verändert sich die API bei Signal Komponenten ebenfalls: Mit ‘afterNextRender’ wird eine Funktion nach Beendigung des nächsten DOM-Update-Zyklus ausgeführt. Das ist in etwa wie bisher ein ‘ngAfterViewInit’, wird allerdings öfter aufgerufen. Mit ‘afterRender’ wird nach jeder DOM-Aktualisierung der angegebene Callback aufgerufen. Schließlich gibt es noch ‘afterRenderEffect’, der einen ‘effect’ mit jedem ‘afterRender’ aufruft. Insgesamt wirkt das Design bereits jetzt sehr vielversprechend und zukunftsweisend. Einzig die Frage nach der Einheitlichkeit der APIs in Anbetracht der RxJS Verwendung bleibt offen. Hier könnte sich aber auch ein sinnvolles Hybridkonzept etablieren. Aktuell sind Signals noch eine Preview-API und die weitere Entwicklung wird sicherlich auch vom Feedback der Community abhängen. Breaking Changes in Angular 16 Bei Major Releases ist gemäß Semantic-Versioning Konventionen auch stets mit inkompatiblen Änderungen zu rechnen. Das hält auch Angular 16 so, doch halten sich die Auswirkungen für den Großteil der Nutzer sicherlich im Rahmen. So haben sich die Versionsanforderungen der verwendeten Werkzeuge und Frameworks geändert. Zunächst wird als TypeScript-Version mindestens 4.9 verlangt.\n'slidetext': ''\n'from': 'index'\n'score': 125.17716979980469\n'normalizedScore': 1.2517716979980469\n'beforeDatePenaltyScore': 1.2517716979980469\n\n'documentId': 'de0df53930e2e1e582caf57f'\n'chunk_id': '687814d5bed6dcd41a99b083'\n'access': 'granted'\n'part_number': 13\n'total_parts': 15\n'contentType': 'READ'\n'title': Angular 17: The Web Framework's Newest Release - Renaissance? Angular 17! - All features at a glance\n'parentName': JavaScript Magazine Volume 12\n'language': 'EN'\n'date': '2024-03-22T02:00:00.000Z'\n'abstract': The popular JavaScript framework Angular has released version 17. It can be difficult to keep up with all the changes in angular, but this article covers an overview of Angular 17 features.\n'parentId': '7e9c82426451f3a6ca3ddfbf'\n'parentDescription': Broaden your knowledge and expand your JavaScript techniques and practices. From Angular, React, and WebAssembly, to the best JavaScript IDEs, open source tools and more, you’ll learn insights on everything JS from seasoned experts in their field. Keep up with JavaScript news, tips, and advice with interviews, tutorials, and in-depth articles.\n'indexBrandName': ''\n'indexSeriesName': ''\n'author': 'Karsten Sitterberg'\n'chunkSource': 'text'\n'text': system? It still exists today, but the plan is to make modules optional in the future. This is also intended to make it easier for new developers to get started with Angular. Angular Material Angular Material 17 introduces both an important and significant change for developers still using old Material components, known as “legacy” since Angular 15. Angular 15 is called legacy because the Angular Material team decided to replace the previously used CSS with the official Google Material Design Components (MDC) style. Because some components needed to be significantly revised, the Angular Material team prefixed the old versions with 'Legacy' and deprecated them, but they are still allowed to be used. In Angular Material 17, all legacy components with a modern MDC counterpart will be removed. This means that applications must be migrated to the new MDC-based Material components by Angular 17. In the JavaScript universe, there are several ways to work with dates. To be able to use these different date-time libraries in Angular Material as well, Angular Material offers a 'DateAdapter'. The DateAdapter is then used by the Datepicker, for example, for date management. The 'DateAdapter' is an abstract class that must be implemented to use a specific date-time library. Angular Material includes the built-in 'NativeDateAdapter', which simply uses the native 'Date' object available in the browser for data management. This 'NativeDateAdapter' has previously received the 'Platform' service via constructor injection. With Angular Material 17, this is no longer the case. In addition, the 'NativeDateAdapter' no longer uses constructor injection generally, but the 'inject()' function instead. This major change has an impact in particular, if you have created the NativeDateAdapter yourself using a constructor, for example in unit tests. This is no longer possible, instead the NativeDateAdapter must be created using Angular's dependency injection. Important Changes in CSS To integrate Angular Material styles into SCSS, the '@import' mechanism of SCSS could be previously used. However, since this mechanism has long since been deprecated on the SCSS side, the '@import' option has now also been removed on the Angular Material side. As of Angular Material 17, the new SCSS '@use' syntax must be used to import the Material styles. If you want to use Angular Material with custom styling, you can do so using the Material theming API. Previously, Material did not check whether the custom themes were formally correct but with Angular Material 17, these are now strictly validated. For example, if the 'mat.button-typography' mixin is used with a theme in which 'typography: null' is set, there will now be an error during the SCSS build. In addition to importing the global Material styles,\n'slidetext': ''\n'from': 'index'\n'score': 125.09046936035156\n'normalizedScore': 1.2509046936035155\n'beforeDatePenaltyScore': 1.2509046936035155\n\n'documentId': 'de0df53930e2e1e582caf57f'\n'chunk_id': '687814d4bed6dcd41a99b07e'\n'access': 'granted'\n'part_number': 8\n'total_parts': 15\n'contentType': 'READ'\n'title': Angular 17: The Web Framework's Newest Release - Renaissance? Angular 17! - All features at a glance\n'parentName': JavaScript Magazine Volume 12\n'language': 'EN'\n'date': '2024-03-22T02:00:00.000Z'\n'abstract': The popular JavaScript framework Angular has released version 17. It can be difficult to keep up with all the changes in angular, but this article covers an overview of Angular 17 features.\n'parentId': '7e9c82426451f3a6ca3ddfbf'\n'parentDescription': Broaden your knowledge and expand your JavaScript techniques and practices. From Angular, React, and WebAssembly, to the best JavaScript IDEs, open source tools and more, you’ll learn insights on everything JS from seasoned experts in their field. Keep up with JavaScript news, tips, and advice with interviews, tutorials, and in-depth articles.\n'indexBrandName': ''\n'indexSeriesName': ''\n'author': 'Karsten Sitterberg'\n'chunkSource': 'text'\n'text': option that takes over the role of the 'trackBy' option from '*ngFor'. There is an important difference here. The new '@for-track' option isn’t optional, it must always be specified. It’s used internally by Angular to optimize rendering the list so that the list does not have to be completely re-rendered all the time, especially if just individual list entries are changed. A completely new algorithm for list rendering was made possible by the new '@for' syntax. It also helps here and shows significant performance improvement in benchmarks compared to the old algorithm. The value specified in the 'track' expression must identify the respective collection entry. If an array of objects is iterated over, the respective object ID should be used, as seen in Listing 11. If you are iterating over an array of primitive values, you can simply use the value itself ('track item'). An innovation that we did not know from '*ngFor' until now is '@for' can be extended by '@empty{}'. The template code in the '@empty' expression is always displayed if the transferred list (here 'items') has no entries or is 'null' or 'undefined'. Several implicit variables can also be used within the '@for' expression to display the current loop iteration index (via '$index'), for example. See Listing 11. You can also access the loop length ('$count') to check if the current loop index is even ('$even') or odd ('$odd'), or if it is the first ('$first') or last ('$last') loop element. @for (item of items; track item.id) { \n\nElement Nummer {{$index}}: {{item.name}} } @empty { \n\nNo items } Listing 11: Example of a loop with the new “@for” Syntax in Angular 17 Previously, three directives were used to implement a switch case statement: 'ngSwitch' and the structural directives '*ngSwitchCase' and '*ngSwitchDefault'. With the new syntax, '@switch', '@case' and '@default' can now be used, as seen in Listing 12. Of course, you can still switch via primitive values or enum values, for instance. Just like the other control flow statements, normal Angular template code can be used as the cases content. You can also nest the control flow statements. @switch (value) { @case (1) { case one } @case (2) { \n\ncase two } @default { Default-case } } Listing 12: Example of a switch case with the new “@switch” syntax in Angular 17 The last element of the new control flow syntax offers new syntax and completely new functionality. 'Deferred Views' (with '@defer') enable lazy loading at the component level without needing the router or complex renderer constructs. An example\n'slidetext': ''\n'from': 'index'\n'score': 125.04824829101562\n'normalizedScore': 1.2504824829101562\n'beforeDatePenaltyScore': 1.2504824829101562\n\n'documentId': '64ace3828d8056484c3534ab'\n'chunk_id': '687814c5bed6dcd41a99b026'\n'access': 'granted'\n'part_number': 14\n'total_parts': 21\n'contentType': 'READ'\n'title': Angular 16 released - Alles zu neuen Features und Breaking Changes\n'parentName': iJS Magazin Band 27\n'language': 'DE'\n'date': '2023-04-06T00:00:00.000Z'\n'abstract': Wir geben einen Überblick zu allen wichtigen Infos zum Release von Angular 16. Alles zu Signals, der Angular-CLI und TypeScript in Angular 16 erfahren Sie hier.\n'parentId': '5093fc7a779ccfe852d8fe7b'\n'parentDescription': Kaum ein Softwareprojekt, das nicht in wesentlichen Teilen auf der JavaScript-Technologie basiert. Eine breite Unterstützung sowie, leistungsfähige Programmiersprachen, die Vielzahl moderner Tools, sowie ausgereifte Frameworks wie Angular, React, Vue.js oder Node.js machen den JavaScript-Werkzeugkasten zu einem Alleskönner. Das iJS Magazin informiert aktuell und umfassend über die wichtige und innovative Entwicklungen im JavaScript-Universum und bietet handfeste Praxisinformationen für Softwareentwickler und -architekten.\n'indexBrandName': ''\n'indexSeriesName': ''\n'author': 'Karsten Sitterberg'\n'chunkSource': 'text'\n'text': kann die unregisterFn() aufgerufen werden. Dann würde in diesem Beispiel doSomethingOnDestroy() nicht mehr aufgerufen. Neben der DestroyRef wurde noch ein neues Paket @angular/rxjs-interop eingeführt, das vor allem mit den neuen Signals verwendet wird. Zusätzlich bietet dieses Paket aber auch noch die Funktion takeUntilDestroyed() an. Diese Funktion ist ein Pipeable rxjs-Operator und kann verwendet werden, um Observables zu beenden, sobald die zugehörige Komponente destroyed wurde. Unter der Haube verwendet dieser neue Operator eine DestroyRef. In Listing 18 wird gezeigt, wie man den Operator nutzen kann, um ein Intervall-Observable zu beenden, sobald die Komponente abgeräumt wird. In diesem Fall wird dem takeUntilDestroyed-Operator explizit eine DestroyRef mitgegeben. Dieser Schritt kann allerdings auch weggelassen werden, dann besorgt sich der Operator die DestroyRef selbst per inject()-Funktion. Das hätte dann hier aber zur Folge, dass der Operator - oder das ganze Observable - im Konstruktor erzeugt werden muss, da der inject()-Mechanismus den Konstruktor-Kontext benötigt. Listing 18: Beispiel zur Verwendung der DestroyRef constructor(private destroyRef: DestroyRef) { const unregisterFn = destroyRef.onDestroy(() => doSomethingOnDestroy() ); // unregisterFn(); // Nimmt onDestroy-Logik zurück } ngOnInit(): void { interval(1000) .pipe(takeUntilDestroyed(this.destroyRef)) .subscribe(val => console.log('value:', val)) } Signals in Angular 16 - Hört die Signale… In Angular 16 hält ein neues und gleichzeitig so wegweisendes Konzept Einzug, das dem eine eigene Überschrift zu widmen ist. Die Rede ist von den “Signals”, einem Konzept, das sicherlich nicht zuletzt von Vue inspiriert wurde. Langfristiges Ziel ist es dabei, ohne “Zone.js” auszukommen und die Change-Detection mit anderen Mitteln abbilden zu können. Das ist sicherlich wichtig, um Standalone-Anwendungen zu verschlanken und vielleicht sogar die Möglichkeiten zu eröffnen, einzelne Elemente mit Angular umzusetzen, vergleichbar mit React und Vue. Als Motivation wurde angegeben, dass Angular-Anwendungen auf diese Weise einfacher werden, da die Verwendung von RxJS nicht mehr zwingend nötig ist. Damit soll die technische, aber auch die konzeptionelle Komplexität reduziert werden. Gleichzeitig hat das Thema auch etwas Beigeschmack: Die offiziellen Diskussionen wurden erst ca. drei Wochen vor Verabschiedung des ersten Release-Candidate\n'slidetext': ''\n'from': 'index'\n'score': 125.03252410888672\n'normalizedScore': 1.2503252410888672\n'beforeDatePenaltyScore': 1.2503252410888672\n\n'documentId': 'de0df53930e2e1e582caf57f'\n'chunk_id': '687814d4bed6dcd41a99b078'\n'access': 'granted'\n'part_number': 4\n'total_parts': 15\n'contentType': 'READ'\n'title': Angular 17: The Web Framework's Newest Release - Renaissance? Angular 17! - All features at a glance\n'parentName': JavaScript Magazine Volume 12\n'language': 'EN'\n'date': '2024-03-22T02:00:00.000Z'\n'abstract': The popular JavaScript framework Angular has released version 17. It can be difficult to keep up with all the changes in angular, but this article covers an overview of Angular 17 features.\n'parentId': '7e9c82426451f3a6ca3ddfbf'\n'parentDescription': Broaden your knowledge and expand your JavaScript techniques and practices. From Angular, React, and WebAssembly, to the best JavaScript IDEs, open source tools and more, you’ll learn insights on everything JS from seasoned experts in their field. Keep up with JavaScript news, tips, and advice with interviews, tutorials, and in-depth articles.\n'indexBrandName': ''\n'indexSeriesName': ''\n'author': 'Karsten Sitterberg'\n'chunkSource': 'text'\n'text': scripts have to be executed in order to display the content of the page, this is bad for the page’s SEO ranking. Previously, the '@nguniversal' package could be used to make an Angular application SEO-fit. '@nguniversal' can (pre-)render an Angular application on the server side. The page content is visible immediately after the HTML has been loaded, since it no longer has to be generated dynamically in the client. This leads to a fast page load, better usability, and a better SEO ranking. Previously, the pre-rendering packages were in a separate namespace '@nguniversal', although these packages were also maintained by the Angular team. In Angular 17, most of the code has been moved from '@nguniversal' to the '@angular/ssr' package in the '@angular' namespace. However, apart from renaming, the functionality is essentially the same. The topic of SSR (Server Side (pre-) Rendering) has become more important to the Angular team, as can be seen from the above change and the fact that it has become easier to integrate packages. When creating a new Angular 17 project, you’ll be asked if server-side rendering should be activated. Alternatively, the new option 'ng new --ssr' can be used to generate a project with preconfigured SSR. In this project, Angular 16’s hydration is also directly activated. This will ensure a seamless transition from the server-side generated page to the fully functional Angular app without flickering. Breaking Changes in Angular CLI 17 Angular 17 keeps its own dependencies up to date. At least TypeScript version 5.2 and zone.js version 0.14.0 must now be used for Angular and Angular CLI. The minimum required node.js version is upgraded to 18.13.0. Some defaults have also been replaced in Angular CLI. For example, when a new application is generated, the Angular router is now initialized by default. This wasn’t previously the case. If no routing is needed, the command line option '--no-routing' must be specified. As of Angular CLI 17, all applications are generated as 'standalone' applications by default, such as an application without '@NgModule()'. Another changed default value concerns the Angular interceptors. Angular HTTP interceptors can be generated with the 'ng g interceptor' command. Previously, class-based interceptors were generated with this command. In Angular CLI 17, functional interceptors are generated instead. If a class-based interceptor is generated, the '--no-functional' option must be added to the command. Figure 1: Old Angular-Logo on the left and new Angular-Logo on the right. Angular Angular 17 comes with a lot of new features. The Angular team calls it one of the 'biggest' releases in its history. Besides the version updates for zone.js and\n'slidetext': ''\n'from': 'index'\n'score': 124.9791259765625\n'normalizedScore': 1.249791259765625\n'beforeDatePenaltyScore': 1.249791259765625\n\n'documentId': '64ace3828d8056484c3534ab'\n'chunk_id': '687814c5bed6dcd41a99b028'\n'access': 'granted'\n'part_number': 16\n'total_parts': 21\n'contentType': 'READ'\n'title': Angular 16 released - Alles zu neuen Features und Breaking Changes\n'parentName': iJS Magazin Band 27\n'language': 'DE'\n'date': '2023-04-06T00:00:00.000Z'\n'abstract': Wir geben einen Überblick zu allen wichtigen Infos zum Release von Angular 16. Alles zu Signals, der Angular-CLI und TypeScript in Angular 16 erfahren Sie hier.\n'parentId': '5093fc7a779ccfe852d8fe7b'\n'parentDescription': Kaum ein Softwareprojekt, das nicht in wesentlichen Teilen auf der JavaScript-Technologie basiert. Eine breite Unterstützung sowie, leistungsfähige Programmiersprachen, die Vielzahl moderner Tools, sowie ausgereifte Frameworks wie Angular, React, Vue.js oder Node.js machen den JavaScript-Werkzeugkasten zu einem Alleskönner. Das iJS Magazin informiert aktuell und umfassend über die wichtige und innovative Entwicklungen im JavaScript-Universum und bietet handfeste Praxisinformationen für Softwareentwickler und -architekten.\n'indexBrandName': ''\n'indexSeriesName': ''\n'author': 'Karsten Sitterberg'\n'chunkSource': 'text'\n'text': Zahl 0, festlegen kann. Ausgelesen wird das Signal dann, indem es wie eine Funktion aufgerufen wird. Das ist beispielsweise im Template der Komponente aus Listing 19 gezeigt. Normalerweise sollte bei Ausgaben in Templates aus Performance-Gründen keine Funktion eingesetzt werden, dies ist eigentlich meist eher ein Anti-Pattern. Im Falle von Signals ist das jedoch eine explizite Design-Entscheidung des Angular-Teams und kann auf lange Sicht sogar hilfreich für die Performance sein: Das Signal “merkt” selbst, wenn sich sein interner Zustand ändert. Im Falle einer Änderung kann ein Signal Angular dadurch sehr feingranular Hinweise geben, welcher Teil der Anwendung aktualisiert werden muss. Das ist natürlich ein wichtiges Element für performante Anwendungen. Um den internen Zustand eines Signal zu ändern, gibt es verschiedene Methoden. Zum einen kann der Wert durch die Methode .set() auf einen konkreten Wert gesetzt werden. In unserem Fall wollen wir den Counter um eins erhöhen. Das bedeutet, dass wir beim Aufruf von .set() noch einmal den Momentanwert des Signals auslesen. Deshalb kann in diesem Fall auch einfach die .update()-Methode verwendet werden. Die gibt nämlich den Momentanwert des Signal als Parameter in eine Callback-Funktion hinein. Der Rückgabewert dieses Callbacks wird dann zum neuen Wert des Signal. Falls ein Signal komplexe Datenstrukturen, also z.B. Objekte oder Arrays enthält, so kann die Methode .mutate() verwendet werden, um das Objekt bzw. Array intern zu ändern. In der getNewInvoice() aus Listing 19 wird dies genutzt, um den Rechnungsbetrag im invoice-Signal zu ändern. Dies könnte beispielsweise auch asynchron nach einem HTTP-Aufruf so ausgeführt werden. Die Signals bekommen immer mit, wenn sich das interne Zustandsobjekt ändert, und können die Anwendung daher auch bei rein mutierenden Änderungen - also ohne, dass sich die Referenz ändert - über diese Tatsache informieren. Neben diesen Standard-Signals gibt es noch sogenannte “Computed Signals”. Um ein Computed Signal zu erzeugen, gibt es die Funktion computed(), diese wird in Listing 20 verwendet, um den Gesamtpreis total aus der Invoice zu “berechnen”. Das Besondere an den Computed Signals ist, dass die Compute-Funktion jedesmal dann aufgerufen wird, wenn ein Signal, das in der Funktion\n'slidetext': ''\n'from': 'index'\n'score': 124.97138214111328\n'normalizedScore': 1.2497138214111327\n'beforeDatePenaltyScore': 1.2497138214111327\n\n'documentId': 'de0df53930e2e1e582caf57f'\n'chunk_id': '687814d4bed6dcd41a99b07d'\n'access': 'granted'\n'part_number': 7\n'total_parts': 15\n'contentType': 'READ'\n'title': Angular 17: The Web Framework's Newest Release - Renaissance? Angular 17! - All features at a glance\n'parentName': JavaScript Magazine Volume 12\n'language': 'EN'\n'date': '2024-03-22T02:00:00.000Z'\n'abstract': The popular JavaScript framework Angular has released version 17. It can be difficult to keep up with all the changes in angular, but this article covers an overview of Angular 17 features.\n'parentId': '7e9c82426451f3a6ca3ddfbf'\n'parentDescription': Broaden your knowledge and expand your JavaScript techniques and practices. From Angular, React, and WebAssembly, to the best JavaScript IDEs, open source tools and more, you’ll learn insights on everything JS from seasoned experts in their field. Keep up with JavaScript news, tips, and advice with interviews, tutorials, and in-depth articles.\n'indexBrandName': ''\n'indexSeriesName': ''\n'author': 'Karsten Sitterberg'\n'chunkSource': 'text'\n'text': a new form of lazy loading at component level. This feature, also known as 'deferrable views', is discussed in more detail below. First, let's familiarize ourselves with the basic syntax. Until now, 'control flow' in Angular templates was handled by structural directives like '*ngIf' and '*ngFor'. See Listing 8. In the future, structural directives can still be used and built, but '*ngIf', '*ngFor' and 'ngSwitch' will be implemented with the new syntax. The example in Listing 8 can be easily rewritten in the new syntax, as shown in Listing 9. You’ll see that the 'if' is no longer an HTML attribute, but an independent syntax construct marked with an '@'. The condition is specified in round brackets, just like in TypeScript. This is followed by the template to be displayed in single curly brackets. Content here Listing 8: Previous “Control Flow” with Angular Directives @if (show) { Content here } Listing 9: “@if” with the new Control Flow syntax in Angular 17 Incidentally, the new syntax has changed slightly since the first RFC. In the original proposal, the example in Listing 9 would look a little more complex: (“{#if show} ... {/if}” statt “@if (show) { ... }”). The new syntax has a clear advantage over the old structural directives, especially for 'if-elseif-else' conditions. Previously, separate templates had to be created in an '' element for the 'else' case. 'if-elseif-else' constructs weren’t possible at all. 'if-else' constructs had to be nested instead. Listing 10 shows the new syntax, where both are easily possible. The syntax is reminiscent of JavaScript. It’s important here that the keywords '@if' and '@else' are always preceded by an '@'. @if (show) { case content 1 } @else if (otherCond) { case content 2 } @else { other content } Listing 10: “@if-@else” with Angular 17 Control Flow syntax in the template The '*ngFor' directive will also be replaced with the new control flow syntax '@for'. Listing 11 shows the corresponding syntax. You will immediately see that in the 'for' statement, 'item of items' is now written. It is no longer 'let item of items', as was needed with '*ngFor'. You must now specify a 'track' option that takes over the role of the 'trackBy' option from '*ngFor'. There is an important difference here. The new '@for-track' option isn’t optional, it must always be specified. It’s used internally by Angular to optimize rendering the list so\n'slidetext': ''\n'from': 'index'\n'score': 124.93360900878906\n'normalizedScore': 1.2493360900878907\n'beforeDatePenaltyScore': 1.2493360900878907\n\n'documentId': 'de0df53930e2e1e582caf57f'\n'chunk_id': '687814d3bed6dcd41a99b075'\n'access': 'granted'\n'part_number': 1\n'total_parts': 15\n'contentType': 'READ'\n'title': Angular 17: The Web Framework's Newest Release - Renaissance? Angular 17! - All features at a glance\n'parentName': JavaScript Magazine Volume 12\n'language': 'EN'\n'date': '2024-03-22T02:00:00.000Z'\n'abstract': The popular JavaScript framework Angular has released version 17. It can be difficult to keep up with all the changes in angular, but this article covers an overview of Angular 17 features.\n'parentId': '7e9c82426451f3a6ca3ddfbf'\n'parentDescription': Broaden your knowledge and expand your JavaScript techniques and practices. From Angular, React, and WebAssembly, to the best JavaScript IDEs, open source tools and more, you’ll learn insights on everything JS from seasoned experts in their field. Keep up with JavaScript news, tips, and advice with interviews, tutorials, and in-depth articles.\n'indexBrandName': ''\n'indexSeriesName': ''\n'author': 'Karsten Sitterberg'\n'chunkSource': 'text'\n'text': Angular 17: The Web Framework's Newest Release Renaissance? Angular 17! - All features at a glance The popular JavaScript framework Angular has released version 17. It can be difficult to keep up with all the changes in angular, but this article covers an overview of Angular 17 features. Version 17 of Angular, the popular JavaScript framework, is arriving. There’s a lot going on with Angular. Some people can lose track of things, or even become scared of getting overwhelmed. This article examines if this concern is justified or if the Angular team’s plan to usher in an Angular renaissance can succeed. First of all: Anyone who has been putting off Angular upgrades or is only planning to update at the end of an LTS cycle should closely watch current developments and evaluate if incremental updates in small steps instead of a large leaps makes more sense in terms of effort and risk. Of course, we’ll take a look at the Angular Core changes as well as TypeScript and Angular Material. TypeScript The new Angular version also supports a new version of TypeScript. In Angular 17, TypeScript version 5.2 or higher must be used. Since Angular 16 still required TypeScript 5.0, let’s take a look at some interesting new features from both TypeScript 5.1 and TypeScript 5.2. Implicit “return“ when “undefined“ is returned If a JavaScript function doesn’t contain a 'return' statement, it still always implicitly has 'undefined' as its return value. This fact wasn’t reflected in TypeScript yet. If 'undefined' was specified as the return type for a function, a 'return' statement always had to be used explicitly too. Additionally, a function that explicitly returned 'undefined' wasn’t compatible with a 'void' function. See Listing 1. declare function onEvent(f: () => undefined): undefined; onEvent(function f() { }) // Argument of type '() => void' is not assignable to parameter of type '() => undefined'. Listing 1: “undefined” and “void” were previously incompatible in TypeScript This is now improved in TypeScript 5.1, so the above example no longer throws compiler errors. A function with 'undefined' as the return type also no longer requires an explicit 'return', similar to the 'demo1()' function in Listing 2. Alternatively, an explicit but 'empty' return can also be used, as in the 'demo2()' function. function demo1(): undefined { // no returns } function demo2(): undefined { return; } Listing 2: No more return needed for the “undefined” return type Independent getter and setter types Previously, TypeScript get and set functions that belonged together (for example, if they had the same name) had to have compatible types. For a\n'slidetext': ''\n'from': 'index'\n'score': 124.87600708007812\n'normalizedScore': 1.2487600708007813\n'beforeDatePenaltyScore': 1.2487600708007813\n\n'documentId': '04721391f3f7580f0631b9d3'\n'chunk_id': '687a2103a98d5a30b3a3413d'\n'access': 'granted'\n'part_number': 17\n'total_parts': 21\n'contentType': 'READ'\n'title': Angular 17: Neues Release des Web-Frameworks - Renaissance? Angular 17! - Alle Features im Überblick\n'parentName': iJS Magazin 2.2024\n'language': 'DE'\n'date': '2024-04-03T22:00:00.000Z'\n'abstract': Das beliebte JavaScript-Framework Angular veröffentlicht Version 17. Da bei Angular viel in Bewegung ist, kann manch einer da den Überblick verlieren. Wir stellen alle Features von Angular 17 vor.\n'parentId': 'c04db0163e3cb47407e78b63'\n'parentDescription': Kaum ein Softwareprojekt, das nicht in wesentlichen Teilen auf der JavaScript-Technologie basiert. Eine breite Unterstützung sowie, leistungsfähige Programmiersprachen, die Vielzahl moderner Tools, sowie ausgereifte Frameworks wie Angular, React, Vue.js oder Node.js machen den JavaScript-Werkzeugkasten zu einem Alleskönner. Das iJS Magazin informiert aktuell und umfassend über die wichtige und innovative Entwicklungen im JavaScript-Universum und bietet handfeste Praxisinformationen für Softwareentwickler und -architekten.\n'indexBrandName': ''\n'indexSeriesName': ''\n'author': 'Karsten Sitterberg'\n'chunkSource': 'text'\n'text': 16 items.mutate(itemsArray => itemsArray.push(newItem)); // Ab Angular 17: items.update(itemsArray => [itemsArray, ...newItem]); Neben den Signals gibt es Breaking Changes im Router. Dieser hat bisher die Properties - “canceledNavigationResolution“ - “paramsInheritanceStrategy“ - “titleStrategy“ - “urlUpdateStrategy“ - “malformedUriErrorHandler“ - “urlHandlingStrategy“ zur Verfügung gestellt. Mit Angular 17 wurden diese Properties aus der Public API des Router entfernt. Statt über den Router, sollten diese Properties jetzt durch die entsprechenden Konfigurationsparameter in der “provideRouter()”-Funktion oder dem “RouterModule.forRoot()”-Hook konfiguriert werden. Angular 17 in der Praxis Mit den Änderungen sind neuartige Architekturen möglich und Optimierungen, die früher gar nicht oder nur schwer umsetzbar waren. Zur Illustration soll ein Beispiel aus der Praxis dienen: Um effektive, sichere und vollständig DSGVO konforme Remote-Schulungen durchzuführen, wurde eine integrierte Plattform entwickelt, an der der Autor dieses Beitrags federführend beteiligt war. Schaut man sich einen Live-Screenshot an (Abbildung 3), so ist direkt zu erkennen, dass die Steuerung von Audio und Video direkt in der primären Ansicht verfügbar ist (Schalter unten links). Das bedeutet, dass die zugehörigen Komponenten und Services nicht durch Lazy-Loading später nachgeladen werden können, da es keine geschachtelte Route gibt, mit der ein entsprechendes Code-Splitting möglich gewesen wäre. Das ist dank der neuen Möglichkeit, Code-Splitting und Lazy-Loading auch auf Komponenten-Ebene durchzuführen, nunmehr möglich: Damit lädt die initiale Anwendung erheblich schneller, da gerade die Audio/Video-Funktionalität sehr aufwändig ist und große Teile des Codes ausmacht. Abbildung 3: Komplexe Angular-Echtzeitanwendung Ebenfalls vorteilhaft ist die Möglichkeit, auf zone.js zu verzichten und durch Signals besser gesteuerte und feingranulare Change-Detection umzusetzen, was zu einer insgesamt verbesserten Performance und reduzierter Last auf dem Clientsystem führt. Auf der anderen Seite sind dafür entsprechende Umbauten durchzuführen, die nicht durch eine automatische Code-Transformation umgesetzt werden können. Und, nicht zuletzt, müssen alle beteiligten Entwickler:innen die neuen Konzepte kennenlernen und auch in der Tiefe beherrschen, um effektiv und sinnvoll mit diesen neuen Möglichkeiten zu agieren. Apropos, was ist mit dem Angular Modulsystem? Es\n'slidetext': ''\n'from': 'index'\n'score': 124.54964447021484\n'normalizedScore': 1.2454964447021484\n'beforeDatePenaltyScore': 1.2454964447021484\n\n'documentId': 'eba6f5d083b14f4d8d53d87a'\n'chunk_id': '687ad1b9eb1b160a4cabaea5'\n'access': 'granted'\n'part_number': 1\n'total_parts': 9\n'contentType': 'READ'\n'title': Was ist neu in Angular 16? Signals, Hydration, esbuild und mehr - Kolumne: Enterprise Angular\n'parentName': Windows Developer 7.2023\n'language': 'DE'\n'date': '2023-06-13T00:00:00.000Z'\n'abstract': Mit Angular 16 kommen gleich zwei große Neuerungen: Signals und Non-destructive Hydration. Außerdem gibt es zahlreiche Abrundungen, die das Arbeiten mit dem Framework vereinfachen. In diesem Artikel gehe ich anhand von Beispielen auf die wichtigsten Neuerungen ein. Den Quellcode findet man im Branch ng16-features auf GitHub [1].\n'parentId': '8d98b5cda2e54cc436ac50d8'\n'parentDescription': Windows Developer informiert umfassend und herstellerneutral über die neuen Trends und Möglichkeiten der Software- und Systementwicklung rund um Microsoft- und Web-Technologien. Von der klassischen .NET-Entwicklung über .NET Core bis hin zu neuen Technologien wie Windows 10, Microsoft Azure und der ganzen Bandbreite der aktuellen Web-, Phone- und Tabletentwicklung für Android und iOS mit Xamarin und unterschiedlichen JavaScript-Frameworks. Professionelle Entwickler und IT-Entscheider erhalten genau die Informationen, die sie für den erfolgreichen Einsatz von unternehmensorientierten Lösungen benötigen.\n'indexBrandName': ''\n'indexSeriesName': ''\n'author': 'Manfred Steyer'\n'chunkSource': 'text'\n'text': Was ist neu in Angular 16? Signals, Hydration, esbuild und mehr Kolumne: Enterprise Angular Mit Angular 16 kommen gleich zwei große Neuerungen: Signals und Non-destructive Hydration. Außerdem gibt es zahlreiche Abrundungen, die das Arbeiten mit dem Framework vereinfachen. In diesem Artikel gehe ich anhand von Beispielen auf die wichtigsten Neuerungen ein. Den Quellcode findet man im Branch ng16-features auf GitHub [1]. Mit Angular 16 kommen gleich zwei große Neuerungen: Signals und Non-destructive Hydration. Außerdem gibt es zahlreiche Abrundungen, die das Arbeiten mit dem Framework vereinfachen. In diesem Artikel gehe ich anhand von Beispielen auf die wichtigsten Neuerungen ein. Den Quellcode findet man im Branch ng16-features auf GitHub [1]. Signals Die wohl größte Neuerung in Angular 16 sind Signals. Dabei handelt es sich um einen simplen reaktiven Building Block, der künftig eine feingranulare Change Detection ohne Zone.js ermöglichen soll. Ein Signal ist ein Objekt, das einen Wert aufnimmt. Konsumenten können diesen Wert lesen und aktualisieren. Außerdem können sie sich informieren lassen, wenn sich der Wert ändert (Abb. 1). Abb. 1: Signals Bindet sich das Template einer Komponente an ein Signal, stößt Angular die Change Detection an, sobald sich das Signal ändert. Ein Beispiel dafür findet sich in Listing 1, in dem alle zu bindenden Eigenschaften from, to und flights als Signals vorliegen. Listing 1 import { computed, effect, signal } from '@angular/core'; [...] @Component([…]) export class FlightSearchComponent implements OnInit { from = signal('Hamburg'); // in Germany to = signal('Graz'); // in Austria flights = signal([]); flightRoute = computed(() => this.from() + ' to ' + this.to()); constructor() { effect(() => { this.search(); }); } async search() { if (!this.from() || !this.to()) return; const flights = await this.flightService.findPromise( this.from(), this.to() ); this.flights.set(flights); } } Um das Erzeugen der Signals kümmert sich die Funktion signal, die das Angular-Team im Paket @angular/core platziert hat. Diese Funktion liefert ein sogenanntes WritableSignal, also ein Signal, das der Programmcode nicht nur lesen, sondern auch aktualisieren kann. T steht für den Typ des verwalteten Werts. In den meisten Fällen kann signal diesen Typ aus dem übergebenen Standardwert herleiten. Falls nicht, ist ein Typparameter wie bei der Eigenschaft flight an signal zu übergeben.\n'slidetext': ''\n'from': 'index'\n'score': 124.51710510253906\n'normalizedScore': 1.2451710510253906\n'beforeDatePenaltyScore': 1.2451710510253906\n\n'documentId': 'de0df53930e2e1e582caf57f'\n'chunk_id': '687814d4bed6dcd41a99b07f'\n'access': 'granted'\n'part_number': 9\n'total_parts': 15\n'contentType': 'READ'\n'title': Angular 17: The Web Framework's Newest Release - Renaissance? Angular 17! - All features at a glance\n'parentName': JavaScript Magazine Volume 12\n'language': 'EN'\n'date': '2024-03-22T02:00:00.000Z'\n'abstract': The popular JavaScript framework Angular has released version 17. It can be difficult to keep up with all the changes in angular, but this article covers an overview of Angular 17 features.\n'parentId': '7e9c82426451f3a6ca3ddfbf'\n'parentDescription': Broaden your knowledge and expand your JavaScript techniques and practices. From Angular, React, and WebAssembly, to the best JavaScript IDEs, open source tools and more, you’ll learn insights on everything JS from seasoned experts in their field. Keep up with JavaScript news, tips, and advice with interviews, tutorials, and in-depth articles.\n'indexBrandName': ''\n'indexSeriesName': ''\n'author': 'Karsten Sitterberg'\n'chunkSource': 'text'\n'text': “@switch” syntax in Angular 17 The last element of the new control flow syntax offers new syntax and completely new functionality. 'Deferred Views' (with '@defer') enable lazy loading at the component level without needing the router or complex renderer constructs. An example of a deferred view can be seen in Listing 13. Here, the component '' is the component that will be reloaded. The 'when' expression is optional. If it’s omitted, lazy loading begins once the outer component is rendered. Otherwise, the 'when' expression can be used to load the '@defer' block’s content only after a certain condition occurs. In the simplest case, a Boolean expression ('isLoaded') can be queried, as seen in Listing 13. In addition to the '@defer' block, Listing 13 shows more optional blocks. A template can be specified in '@loading' to represent the 'loading status', like a loading spinner. The loading status is displayed the moment the Boolean condition (here 'isLoading') changes to 'true'. When the '' component is loaded and rendered, the loading status is automatically removed. Developers should be especially careful with the loading state and avoid UX pitfalls. One large spinner for the entire page is easier for a user to “digest” than 20 simultaneously active spinners spread across the entire page and all individual components. When using load states, take care to make sure the page doesn’t permanently 'flicker' due to piecemeal reloading the smallest page elements or that the content doesn’t constantly shift back and forth. Here, '@placeholder' content is displayed until the 'isLoaded' condition first has the value 'false'. One important note here: '@defer' doesn’t work like '@if' in the sense that you can switch back and forth between the values. Once 'isLoaded' has the value 'true', the lazy loaded component is displayed. Even if 'isLoaded' is manually reset to 'false', the '@defer' content continues to be displayed and doesn’t switch back to the '@placeholder' content. If an error occurs when reloading the '@defer' content, (due to a network interruption, for example), content from the '@error' block is displayed. @defer (when isLoaded) {  } @loading { \n\nLoading... } @placeholder { pending } @error { Failed to load } Listing 13: Example of the new “@defer” expression in Angular 17 Besides the 'when' specification with a Boolean expression, you can also specify an 'on' condition. Listing 14 shows an example of the 'on immediate' and the 'on idle' condition. Here, 'on immediate' behaves as if the expression were omitted. Once the outer component is rendered, components in\n'slidetext': ''\n'from': 'index'\n'score': 124.42501831054688\n'normalizedScore': 1.2442501831054686\n'beforeDatePenaltyScore': 1.2442501831054686\n\n'documentId': '04721391f3f7580f0631b9d3'\n'chunk_id': '687a2101a98d5a30b3a34128'\n'access': 'granted'\n'part_number': 7\n'total_parts': 21\n'contentType': 'READ'\n'title': Angular 17: Neues Release des Web-Frameworks - Renaissance? Angular 17! - Alle Features im Überblick\n'parentName': iJS Magazin 2.2024\n'language': 'DE'\n'date': '2024-04-03T22:00:00.000Z'\n'abstract': Das beliebte JavaScript-Framework Angular veröffentlicht Version 17. Da bei Angular viel in Bewegung ist, kann manch einer da den Überblick verlieren. Wir stellen alle Features von Angular 17 vor.\n'parentId': 'c04db0163e3cb47407e78b63'\n'parentDescription': Kaum ein Softwareprojekt, das nicht in wesentlichen Teilen auf der JavaScript-Technologie basiert. Eine breite Unterstützung sowie, leistungsfähige Programmiersprachen, die Vielzahl moderner Tools, sowie ausgereifte Frameworks wie Angular, React, Vue.js oder Node.js machen den JavaScript-Werkzeugkasten zu einem Alleskönner. Das iJS Magazin informiert aktuell und umfassend über die wichtige und innovative Entwicklungen im JavaScript-Universum und bietet handfeste Praxisinformationen für Softwareentwickler und -architekten.\n'indexBrandName': ''\n'indexSeriesName': ''\n'author': 'Karsten Sitterberg'\n'chunkSource': 'text'\n'text': Abhängigkeiten aktuell. Daher muss für Angular und Angular-CLI nun mindestens TypeScript in Version 5.2, zone.js in Version 0.14.0 verwendet werden. Auch die minimal notwendige node.js-Version wird nun auf 18.13.0 hochgesetzt. Bei Angular-CLI sind außerdem einige Defaults ausgetauscht worden: Wenn etwa eine neue Anwendung generiert wird, wird bei dieser nun standardmäßig der Angular Router initialisiert. Dies war bisher nicht der Fall. Falls kein Routing gewünscht ist, muss die Kommandozeilenoption “--no-routing” angegeben werden. Weiterhin werden ab Angular-CLI 17 alle Anwendungen standardmäßig als “standalone”-Applications erzeugt, also als Anwendung ohne eigene “@NgModule()”s. Ein anderer geänderter Standardwert betrifft die Angular-Interceptoren: Mit dem Befehl “ng g interceptor” können Angular HTTP-Interceptoren generiert werden. Bisher wurden mit diesem Befehl Klassen-basierte Interceptoren erzeugt. Mit Angular-CLI 17 werden stattdessen funktionale Interceptoren generiert. Soll weiterhin ein klassenbasierter Interceptor generiert werden, so muss dem Befehl die Option “--no-functional” mitgegeben werden. Abbildung 1: Altes Angular-Logo links, Neues Angular-Logo rechts. Neue Features in Angular 17 Mit Angular 17 kommen eine Menge neuer Features. Das Angular-Team selbst spricht von einem der “größten” Releases in der Geschichte von Angular. Dementsprechend bietet es - neben den bereits oben erwähnten Version-Updates von zone.js und TypeScript - auch viele kleinere und größere Neuerungen. Zwei Neuerungen, die speziell mit den neuen APIs rund um Signals zu tun haben, sind bereits mit Angular 16.2.0 hinzugekommen. Nämlich zwei neue, spezielle Komponenten-Lifecycle-Hooks. Speziell deshalb, weil sie nicht wie herkömmliche Lifecycle-Hooks per Interface implementiert werden müssen, sondern als Callback-Funktion aufgerufen werden können. Das ist somit ähnlich wie die “computed()”-Funktion der Signals. Ein Beispiel mit den neuen Hooks ist in Listing 6 aufgeführt, die beiden Hooks heißen “afterRender()” und “afterNextRender()” und werden, entsprechend ihres Namens, ausgeführt, nachdem Angular die jeweilige Komponente gerendert hat. Der Unterschied zwischen beiden Hooks besteht darin, dass “afterNextRender()” nur einmal, nach dem nächsten Rendering-Vorgang, aufgerufen wird, während “afterRender()” aktiv bleibt, solange die Komponente aktiv ist. Diese beiden Hooks sind allerdings noch als\n'slidetext': ''\n'from': 'index'\n'score': 124.26818084716797\n'normalizedScore': 1.2426818084716797\n'beforeDatePenaltyScore': 1.2426818084716797\n\n'documentId': 'de0df53930e2e1e582caf57f'\n'chunk_id': '687814d4bed6dcd41a99b077'\n'access': 'granted'\n'part_number': 3\n'total_parts': 15\n'contentType': 'READ'\n'title': Angular 17: The Web Framework's Newest Release - Renaissance? Angular 17! - All features at a glance\n'parentName': JavaScript Magazine Volume 12\n'language': 'EN'\n'date': '2024-03-22T02:00:00.000Z'\n'abstract': The popular JavaScript framework Angular has released version 17. It can be difficult to keep up with all the changes in angular, but this article covers an overview of Angular 17 features.\n'parentId': '7e9c82426451f3a6ca3ddfbf'\n'parentDescription': Broaden your knowledge and expand your JavaScript techniques and practices. From Angular, React, and WebAssembly, to the best JavaScript IDEs, open source tools and more, you’ll learn insights on everything JS from seasoned experts in their field. Keep up with JavaScript news, tips, and advice with interviews, tutorials, and in-depth articles.\n'indexBrandName': ''\n'indexSeriesName': ''\n'author': 'Karsten Sitterberg'\n'chunkSource': 'text'\n'text': is shown in Listing 5 using the 'DemoMeta' decorator factory, which receives the metadata key to be set and the associated metadata value as parameters and returns the configured decorator. The 'DemoMeta' factory is used in Listing 5 to add the metadata entry ''entity'' with the value ''3270'' to the 'DemoClass' class. The metadata entry ''demo'' with the value ''42'' is added to the 'demoMethod()' method. Then, the class metadata is accessed again with 'Symbol.metadata'. function DemoMeta(key: string, value: string) { return (_: any, context: Context) => { context.metadata[key] = value; }; } @DemoMeta('entity', '3270') class DemoClass { @DemoMeta('demo', '42') demoMethod() {} } DemoClass[Symbol.metadata].entity; // '3270' DemoClass[Symbol.metadata].demo; // '42' Listing 5: Example Decorator Factory in TypeScript After our look at TypeScript, next we will turn to the Angular CLI. This is typically used to build Angular applications. Angular CLI The Angular team provides the Angular CLI for developers to manage Angular projects. An important step in Angular CLI 17 is the Angular build system update. In Angular CLI 17, newly created projects are now built with the new build system based on 'esbuild' as the standard for the first time. This is primarily meant to speed up the build and optimize the build result or make it smaller. The new name 'Vite' (pronounced like the French. 'vite' = 'fast') based live development server promises a better, faster development cycle. For example, Vite lets you apply changes to the global CSS without needing a live reload. For apps to be built entirely with the esbuild-based build system in the future, the esbuild builder needed some enhancements. For example, basic support for checking Angular CLI bundle budgets was added to help developers keep track of the size of JavaScript and CSS files generated in the build. Basic support for building WebWorkers has also been added. These are a browser-native feature, but still must be considered in the Angular build, since worker scripts are typically written with TypeScript. The old builder was already able to do this, and now the new esbuild builder follows suit. Since they’re built in Angular, SPAs have one disadvantage. Once the initial web page has loaded, some scripts must first be loaded, which start the application. Depending on the internet connection and the page size, this takes a moment. Along with the fact that scripts have to be executed in order to display the content of the page, this is bad for the page’s SEO ranking. Previously, the '@nguniversal' package could be used to make an Angular application SEO-fit. '@nguniversal' can (pre-)render an Angular application\n'slidetext': ''\n'from': 'index'\n'score': 124.0683822631836\n'normalizedScore': 1.240683822631836\n'beforeDatePenaltyScore': 1.240683822631836\n\n'documentId': '04721391f3f7580f0631b9d3'\n'chunk_id': '687a2102a98d5a30b3a3412d'\n'access': 'granted'\n'part_number': 9\n'total_parts': 21\n'contentType': 'READ'\n'title': Angular 17: Neues Release des Web-Frameworks - Renaissance? Angular 17! - Alle Features im Überblick\n'parentName': iJS Magazin 2.2024\n'language': 'DE'\n'date': '2024-04-03T22:00:00.000Z'\n'abstract': Das beliebte JavaScript-Framework Angular veröffentlicht Version 17. Da bei Angular viel in Bewegung ist, kann manch einer da den Überblick verlieren. Wir stellen alle Features von Angular 17 vor.\n'parentId': 'c04db0163e3cb47407e78b63'\n'parentDescription': Kaum ein Softwareprojekt, das nicht in wesentlichen Teilen auf der JavaScript-Technologie basiert. Eine breite Unterstützung sowie, leistungsfähige Programmiersprachen, die Vielzahl moderner Tools, sowie ausgereifte Frameworks wie Angular, React, Vue.js oder Node.js machen den JavaScript-Werkzeugkasten zu einem Alleskönner. Das iJS Magazin informiert aktuell und umfassend über die wichtige und innovative Entwicklungen im JavaScript-Universum und bietet handfeste Praxisinformationen für Softwareentwickler und -architekten.\n'indexBrandName': ''\n'indexSeriesName': ''\n'author': 'Karsten Sitterberg'\n'chunkSource': 'text'\n'text': Regelfall nur beim Start der Anwendung ein HTML-Dokument geladen wird. Beim Wechsel auf eine andere Route werden lediglich Bestandteile im Browser-DOM ausgetauscht. Damit können Animationen nicht wie bei serverseitigen Anwendungen einfach beim Page-Load ausgeführt werden, sondern Animationen müssen besser auf SPA-Logik, wie beispielsweise Routenwechsel, abgestimmt werden. Genau dafür ist die neue View Transitions DOM-API gedacht. Diese API stellt den Callback “document.startViewTransition()” zur Verfügung, der dem Browser zum einen mitteilt, dass eine View-Transition gestartet werden soll. Zum anderen kann der Funktion Logik übergeben werden, die definiert, wie der Browser-DOM am Ende der Transition aussehen soll. Die Transitionsanimation kann dann anhand spezieller CSS-Pseudo-Selektoren erfolgen. Angular nutzt diese neue API im Angular-17-Router, sodass für jede Navigation eine View Transition gestartet wird. Da das “View Transition” Feature allerdings bisher noch experimentell ist und nur im Chrome und Edge umgesetzt ist, findet die Router-Navigation in Browsern wie Firefox oder Safari weiterhin synchron wie bisher statt. Um die ViewTransitions zu aktivieren, kann dem Router beim Start die Funktion “withViewTransitions()” mitgegeben werden. In Listing 7 wird der “withViewTransitions()” außerdem noch ein Konfigurationsobjekt mitgegeben, in dem beispielsweise ein “onViewTransitionCreated()”-Callback definiert werden kann, falls zusätzliche (Animations-)Logik benötigt wird. Listing 7: Aktivierung der ViewTransitions im AppModule oder app.config provideRouter( routes, withViewTransitions({ onViewTransitionCreated: transitionInfo => { } }) ), Neue Control-Flow Syntax Die größte und tiefgreifendste Neuerung für Entwickler:innen in diesem Release und, bezogen auf die Template-Syntax, die größte Neuerung in Angular überhaupt, ist die neue Control-Flow-Syntax von Angular. In Angular 17 ist diese Syntax noch als Developer Preview markiert, allerdings sollen damit in Zukunft unter anderem die bisherigen Direktiven “*ngIf”, “*ngFor” und “ngSwitch” komplett ersetzt werden. Damit wird die Logik dieser Direktiven ein Teil des Frameworks an sich, statt “normaler” Direktiven wie bisher, wodurch das Angular-Team die jeweilige Logik besser optimieren kann. Ein wesentlicher Grund für diese Neuerungen waren auch die Signals und das Ziel, zone.js mit Hilfe der Signals optional zu machen, denn die alten Control-Flow-Direktiven basierten und benötigen “zone.js”.\n'slidetext': ''\n'from': 'index'\n'score': 123.86287689208984\n'normalizedScore': 1.2386287689208983\n'beforeDatePenaltyScore': 1.2386287689208983\n\n'documentId': '04721391f3f7580f0631b9d3'\n'chunk_id': '687a2102a98d5a30b3a3412f'\n'access': 'granted'\n'part_number': 10\n'total_parts': 21\n'contentType': 'READ'\n'title': Angular 17: Neues Release des Web-Frameworks - Renaissance? Angular 17! - Alle Features im Überblick\n'parentName': iJS Magazin 2.2024\n'language': 'DE'\n'date': '2024-04-03T22:00:00.000Z'\n'abstract': Das beliebte JavaScript-Framework Angular veröffentlicht Version 17. Da bei Angular viel in Bewegung ist, kann manch einer da den Überblick verlieren. Wir stellen alle Features von Angular 17 vor.\n'parentId': 'c04db0163e3cb47407e78b63'\n'parentDescription': Kaum ein Softwareprojekt, das nicht in wesentlichen Teilen auf der JavaScript-Technologie basiert. Eine breite Unterstützung sowie, leistungsfähige Programmiersprachen, die Vielzahl moderner Tools, sowie ausgereifte Frameworks wie Angular, React, Vue.js oder Node.js machen den JavaScript-Werkzeugkasten zu einem Alleskönner. Das iJS Magazin informiert aktuell und umfassend über die wichtige und innovative Entwicklungen im JavaScript-Universum und bietet handfeste Praxisinformationen für Softwareentwickler und -architekten.\n'indexBrandName': ''\n'indexSeriesName': ''\n'author': 'Karsten Sitterberg'\n'chunkSource': 'text'\n'text': optimieren kann. Ein wesentlicher Grund für diese Neuerungen waren auch die Signals und das Ziel, zone.js mit Hilfe der Signals optional zu machen, denn die alten Control-Flow-Direktiven basierten und benötigen “zone.js”. Neben den oben genannten Control-Flow-Logiken ist ein weiteres Feature, dass dank der neuen Syntax umgesetzt werden konnte, eine neue Form des Lazy Loading auf Komponentenebene. Das auch “deferrable Views” genannte Feature wird im weiteren Verlauf detaillierter betrachtet. Zunächst wollen wir uns mit der grundsätzlichen Syntax vertraut machen. Bisher wird der “Control Flow” in Angular-Templates durch sogenannte strukturelle Direktiven erledigt, wie beispielsweise “*ngIf” und “*ngFor”, siehe auch Listing 8. Strukturelle Direktiven können zwar auch in Zukunft verwendet und gebaut werden, speziell “*ngIf”, “*ngFor” und “ngSwitch” werden aber mit der neuen Syntax umgesetzt. Das Beispiel aus Listing 8 kann recht einfach in die neue Syntax umgeschrieben werden, siehe Listing 9. Auffällig ist, dass das “if” nun kein HTML-Attribut mehr ist, sondern ein eigenständiges Syntax-Konstrukt, das mit einem “@” gekennzeichnet ist. Die Bedingung wird dann nachfolgend in runden Klammern angegeben, wie bereits in TypeScript. Danach folgt dann das anzuzeigende Template innerhalb einfacher geschweifter Klammern. Listing 8: Bisheriger “Control Flow” mit Angular Directiven Content here Listing 9: “@if” mit der neuen Control-Flow-Syntax in Angular 17 @if (show) { Content here } Die neue Syntax hat sich übrigens seit dem ersten RFC nochmal leicht verändert, mit dem Ursprünglichen Vorschlag würde das Beispiel aus Listing 9 etwas komplexer aussehen (“{#if show} ... {/if}” statt “@if (show) { ... }”). Speziell für “if-elseif-else”-Bedignungen hat die neue Syntax einen deutlichen Vorteil gegenüber den alten strukturellen Direktiven. Während für den “else”-Fall bisher eigene Templates innerhalb eines “”-Element angelegt werden mussten, waren “if-elseif-else”-Konstrukte so gar nicht möglich, stattdessen mussten “if-else”-Konstrukte verschachtelt werden. In Listing 10 ist nun die neue Syntax gezeigt, mit der beides sehr einfach möglich ist, die Syntax erinnert an JavaScript. Wichtig ist hier, dass die Keywords\n'slidetext': ''\n'from': 'index'\n'score': 123.80867004394531\n'normalizedScore': 1.2380867004394531\n'beforeDatePenaltyScore': 1.2380867004394531\n\n'documentId': 'de0df53930e2e1e582caf57f'\n'chunk_id': '687814d5bed6dcd41a99b084'\n'access': 'granted'\n'part_number': 14\n'total_parts': 15\n'contentType': 'READ'\n'title': Angular 17: The Web Framework's Newest Release - Renaissance? Angular 17! - All features at a glance\n'parentName': JavaScript Magazine Volume 12\n'language': 'EN'\n'date': '2024-03-22T02:00:00.000Z'\n'abstract': The popular JavaScript framework Angular has released version 17. It can be difficult to keep up with all the changes in angular, but this article covers an overview of Angular 17 features.\n'parentId': '7e9c82426451f3a6ca3ddfbf'\n'parentDescription': Broaden your knowledge and expand your JavaScript techniques and practices. From Angular, React, and WebAssembly, to the best JavaScript IDEs, open source tools and more, you’ll learn insights on everything JS from seasoned experts in their field. Keep up with JavaScript news, tips, and advice with interviews, tutorials, and in-depth articles.\n'indexBrandName': ''\n'indexSeriesName': ''\n'author': 'Karsten Sitterberg'\n'chunkSource': 'text'\n'text': now strictly validated. For example, if the 'mat.button-typography' mixin is used with a theme in which 'typography: null' is set, there will now be an error during the SCSS build. In addition to importing the global Material styles, it’s also possible to load only the styles for individual components in the build. To do this, you can use the SCSS mixin 'mat.-theme', where '' corresponds to the component name, for example 'card', 'checkbox', 'radio', or 'list'. Additionally, you can also load only individual parts of the component styles, such as the button typography (via the mixin 'mat.-typography'), the colors (via the mixin 'mat.-color'), or the density styles (you could also say 'spacing styles', the mixin is 'mat.-density'). With Angular Material 17, even more styles have been added that are available in the component '-theme' mixins, but not in the sub-mixins. To use these styles, you must then use the 'mat.-base' mixin. To add the basic styles for all components, there is now also the mixin 'mat.all-component-bases'. Conclusion Is Angular still known as the framework with long-term investment security? Is Angular’s popularity waning or is the framework able to conquer new target groups without alienating existing teams and developers? Or is there even a plan to consciously abandon existing teams and developers in order to modernize Angular? Angular is being renewed so quickly that it feels almost like a new framework altogether. It will be interesting to see how long the old concepts will continue to be supported. After all, an ng-upgrade transformation of the source code is not enough;users also need to learn new concepts and replace old ones, which can temporarily reduce productivity. To what extent do third-party libraries support old and new Angular concepts? This is an important question, as the Angular team's communication with existing users could be improved. Additionally, users are concerned about Google's history of discontinuing products, which raises doubts about Angular's long-term viability. The new Angular features are well-designed and enable new architectures and even more high-performance front-end applications. They also significantly improve the developer experience, especially by providing options for expressing if-elseif-else statements. The rapid development pace of recent Angular versions could be challenging especially for enterprise customers and large projects with long-term maintenance requirements. Existing users may find it difficult to keep up, which could lead to frustration and concerns about investments made, and could ultimately limit Angular's adoption and traction with new users. The Angular team could certainly work on improving its relationship with users by communicating more sensitively and carefully\n'slidetext': ''\n'from': 'index'\n'score': 123.71265411376953\n'normalizedScore': 1.2371265411376953\n'beforeDatePenaltyScore': 1.2371265411376953\n\n'documentId': 'eba6f5d083b14f4d8d53d87a'\n'chunk_id': '687ad1baeb1b160a4cabaea8'\n'access': 'granted'\n'part_number': 3\n'total_parts': 9\n'contentType': 'READ'\n'title': Was ist neu in Angular 16? Signals, Hydration, esbuild und mehr - Kolumne: Enterprise Angular\n'parentName': Windows Developer 7.2023\n'language': 'DE'\n'date': '2023-06-13T00:00:00.000Z'\n'abstract': Mit Angular 16 kommen gleich zwei große Neuerungen: Signals und Non-destructive Hydration. Außerdem gibt es zahlreiche Abrundungen, die das Arbeiten mit dem Framework vereinfachen. In diesem Artikel gehe ich anhand von Beispielen auf die wichtigsten Neuerungen ein. Den Quellcode findet man im Branch ng16-features auf GitHub [1].\n'parentId': '8d98b5cda2e54cc436ac50d8'\n'parentDescription': Windows Developer informiert umfassend und herstellerneutral über die neuen Trends und Möglichkeiten der Software- und Systementwicklung rund um Microsoft- und Web-Technologien. Von der klassischen .NET-Entwicklung über .NET Core bis hin zu neuen Technologien wie Windows 10, Microsoft Azure und der ganzen Bandbreite der aktuellen Web-, Phone- und Tabletentwicklung für Android und iOS mit Xamarin und unterschiedlichen JavaScript-Frameworks. Professionelle Entwickler und IT-Entscheider erhalten genau die Informationen, die sie für den erfolgreichen Einsatz von unternehmensorientierten Lösungen benötigen.\n'indexBrandName': ''\n'indexSeriesName': ''\n'author': 'Manfred Steyer'\n'chunkSource': 'text'\n'text': Hektik: Bestandscode muss nicht zwingend migriert werden. RxJS Interop Signals und RxJS weisen einige Gemeinsamkeiten auf, zumal beide reaktive Anwendungen ermöglichen. Im Gegensatz zu RxJS wurden Signals jedoch bewusst sehr einfach gehalten. Das primäre Ziel ist die Unterstützung der Change Detection. Der ab Version 16 mit Angular ausgelieferte RxJS-Interop-Layer erlaubt es, die Einfachheit von Signals mit den vielen und teils komplexen Möglichkeiten von RxJS zu kombinieren. Der Interop-Layer befindet sich im Namensraum @angular/core/rxjs-interop und bietet Funktionen zum Umwandeln von Signals in Observables und vice versa (Listing 3). Listing 3 import { toObservable, toSignal } from '@angular/core/rxjs-interop'; [...] from = signal('Hamburg'); to = signal('Graz'); from$ = toObservable(this.from); to$ = toObservable(this.to); flights$ = combineLatest({ from: this.from$, to: this.to$ }).pipe( debounceTime(300), tap(() => this.loading.set(true)), switchMap((combi) => this.flightService.find(combi.from, combi.to)), tap(() => this.loading.set(false)) ); flights = toSignal(this.flights$, { initialValue: [] }); Die Funktion toObservable überführt die Signals from und to in entsprechende Observables. Das ermöglicht die Nutzung von RxJS-basierten Operatoren, wie combineLatest, debounceTime und switchMap. Das Ergebnis ist ein Observable, das Arrays mit Flight-Objekten liefert. Die Funktion toSignal erzeugt ein darauf basierendes Signal. Da ein Signal im Gegensatz zu einem Observable immer einen Wert aufweist, legt das Beispiel einen Initialwert fest. Stattdessen könnte der Aufrufer der Funktion toSignal auch versichern, dass das Observable synchron einen Initialwert veröffentlicht. Dazu ist die Eigenschaft requireSync auf true zu setzen: flights = toSignal(this.flights$, { requireSync: true }); In beiden Fällen leitet toSignal die Typisierung des Signal vom Observable ab. Im gezeigten Fall ergibt sich ein Signal. Kommen weder initialValue noch requireSync zum Einsatz, nimmt toSignal den Typ undefined in die Typisierung auf. Somit würde sich hier ein Signal ergeben, das undefined als Initialwert aufweist. Auch Signals, die auf Observables basieren, sind an die Lebenszeitspanne des nutzenden Building Block – zum Beispiel der jeweiligen Komponente oder des jeweiligen Service – gebunden. Bei Observables, die auf Signals basieren, ist das jedoch nicht so. Das Angular-Team wollte das von RxJS gewohnte Verhalten nicht ändern. Wer\n'slidetext': ''\n'from': 'index'\n'score': 123.6031265258789\n'normalizedScore': 1.236031265258789\n'beforeDatePenaltyScore': 1.236031265258789\n\n'documentId': 'eba6f5d083b14f4d8d53d87a'\n'chunk_id': '687ad1b9eb1b160a4cabaea6'\n'access': 'granted'\n'part_number': 2\n'total_parts': 9\n'contentType': 'READ'\n'title': Was ist neu in Angular 16? Signals, Hydration, esbuild und mehr - Kolumne: Enterprise Angular\n'parentName': Windows Developer 7.2023\n'language': 'DE'\n'date': '2023-06-13T00:00:00.000Z'\n'abstract': Mit Angular 16 kommen gleich zwei große Neuerungen: Signals und Non-destructive Hydration. Außerdem gibt es zahlreiche Abrundungen, die das Arbeiten mit dem Framework vereinfachen. In diesem Artikel gehe ich anhand von Beispielen auf die wichtigsten Neuerungen ein. Den Quellcode findet man im Branch ng16-features auf GitHub [1].\n'parentId': '8d98b5cda2e54cc436ac50d8'\n'parentDescription': Windows Developer informiert umfassend und herstellerneutral über die neuen Trends und Möglichkeiten der Software- und Systementwicklung rund um Microsoft- und Web-Technologien. Von der klassischen .NET-Entwicklung über .NET Core bis hin zu neuen Technologien wie Windows 10, Microsoft Azure und der ganzen Bandbreite der aktuellen Web-, Phone- und Tabletentwicklung für Android und iOS mit Xamarin und unterschiedlichen JavaScript-Frameworks. Professionelle Entwickler und IT-Entscheider erhalten genau die Informationen, die sie für den erfolgreichen Einsatz von unternehmensorientierten Lösungen benötigen.\n'indexBrandName': ''\n'indexSeriesName': ''\n'author': 'Manfred Steyer'\n'chunkSource': 'text'\n'text': übergeben. Die Methode search liest und aktualisiert diese Signals. Dazu kommen Getter und Setter zum Einsatz. Um den Getter aufzurufen, wird das Signal wie eine Funktion behandelt. Den Setter bietet das Signal in Form einer Methode set an. Listing 1 erzeugt auch ein berechnetes Signal mit der Funktion computed. Das Signal aktualisiert die als Lambdaausdruck übergebene Berechnung, wenn sich eines der verwendeten Signals ändert. Der Rückgabewert von computed ist vom Typ Signal. Im Gegensatz zum zuvor erwähnten WritableSignal ist dieses read-only. Der Konstruktor in Listing 1 definiert mit der Funktion effect einen Seiteneffekt. Immer, wenn sich eines der darin verwendeten Signals ändert, kommt der übergebene Lambdaausdruck erneut zur Ausführung. Signals, die in aufgerufenen Methoden wie search zum Einsatz kommen, berücksichtigen effect auf dieselbe Weise. Das Template der Komponente bindet sich an die Signals (Listing 2). Listing 2   {{ flightRoute() }}      Änderungen an Signals führen dazu, dass Angular die Change Detection anstößt und die Ansicht im Browser aktualisiert. Dieses Verhalten gleicht dem von Observables, die mit der Async Pipe ans Template gebunden werden. Deswegen lässt sich auch beim Einsatz von Signals die Change Detection-Strategie OnPush zur Verbesserung der Performance aktivieren. Künftige Angular-Versionen werden jedoch noch einen Schritt weitergehen und eine feingranulare Change Detection anbieten. Die soll es erlauben, Teile von Templates anstatt ganzer Templates zu aktualisieren. Anders als bei Observables müssen sich Konsumenten nicht bei Signals abmelden (unsubscribe). Konsumiert der Code einer Komponente oder ein Template ein Signal, findet die Abmeldung automatisch beim Zerstören der Komponente statt. Dasselbe gilt für die Nutzung innerhalb anderer Angular-basierter Building Blocks wie Services oder Direktiven – der Konsument ist an die Lebensdauer des jeweiligen Building-Blocks gebunden. In Version 16 liegen Signals erst einmal als Developer-Preview vor. Das bedeutet, dass sie sich in künftigen Versionen noch ändern können. Wie schon bei Standalone Components werden auch Signals mit bestehendem Code zusammenspielen. Es gibt also keinen Grund zur Hektik:\n'slidetext': ''\n'from': 'index'\n'score': 123.41246795654297\n'normalizedScore': 1.2341246795654297\n'beforeDatePenaltyScore': 1.2341246795654297\n\n'documentId': 'de0df53930e2e1e582caf57f'\n'chunk_id': '687814d5bed6dcd41a99b080'\n'access': 'granted'\n'part_number': 10\n'total_parts': 15\n'contentType': 'READ'\n'title': Angular 17: The Web Framework's Newest Release - Renaissance? Angular 17! - All features at a glance\n'parentName': JavaScript Magazine Volume 12\n'language': 'EN'\n'date': '2024-03-22T02:00:00.000Z'\n'abstract': The popular JavaScript framework Angular has released version 17. It can be difficult to keep up with all the changes in angular, but this article covers an overview of Angular 17 features.\n'parentId': '7e9c82426451f3a6ca3ddfbf'\n'parentDescription': Broaden your knowledge and expand your JavaScript techniques and practices. From Angular, React, and WebAssembly, to the best JavaScript IDEs, open source tools and more, you’ll learn insights on everything JS from seasoned experts in their field. Keep up with JavaScript news, tips, and advice with interviews, tutorials, and in-depth articles.\n'indexBrandName': ''\n'indexSeriesName': ''\n'author': 'Karsten Sitterberg'\n'chunkSource': 'text'\n'text': you can also specify an 'on' condition. Listing 14 shows an example of the 'on immediate' and the 'on idle' condition. Here, 'on immediate' behaves as if the expression were omitted. Once the outer component is rendered, components in the defer block are reloaded. With 'on idle', the components are loaded as soon as the browser is in the 'idle' state (technically, this corresponds to the browser’s 'requestIdleCallback()' function). @defer (on immediate) { //... @defer (on idle) { //... Listing 14: Examples of 'on' expressions that load directly or only in the idle state In addition to these fairly static specifications, you can also react to dynamic user interactions with the 'on interaction' conditions. To react to an interaction, an element that the user should interact with must be specified. The example in Listing 15 shows that either an external element like a button, can be transferred to the 'interaction' condition using a template reference variable. Alternatively, this explicit assignment can be omitted. But then a '@placeholder' must be specified, since the placeholder content serves as the interaction element. This is shown in the middle of Listing 15. This could be used to reload a detailed view at the push of a button, which contains complex parsing logic (or parsing and displaying XML) in the form of components and services that should only reload 'on demand'. The 'on hover' condition works similarly to the 'on interaction' specification. See Listing 15. The only difference is that instead of an interaction, you only need to hover over the trigger element. @defer (on interaction(trigger)) {  } Trigger @defer (on interaction) {  } @placeholder { Trigger } @defer (on hover(trigger)) {  } Trigger Listing 15: Options for loading defer content based on an interaction trigger Instead of direct user interaction, you can also load a defer block when another (trigger) element comes into the visible viewport. for instance, when the user scrolls to the trigger element. See Listing 16. Instead of the external trigger element, the placeholder can also be used as an implicit trigger element. @defer (on viewport(trigger)) {  } Content Listing 16: Viewport triggers are used to load content when the trigger element is visible (in the viewport) Last but not least, a defer block can also be reloaded using a time trigger. You must give a trigger a duration to load the component after. For example, Listing 17 specifies that the defer block should start loading the '' component after 1.5 seconds. Regardless of the 'on' condition\n'slidetext': ''\n'from': 'index'\n'score': 123.30654907226562\n'normalizedScore': 1.2330654907226561\n'beforeDatePenaltyScore': 1.2330654907226561\n\n'documentId': '64ace3828d8056484c3534ab'\n'chunk_id': '687814c5bed6dcd41a99b029'\n'access': 'granted'\n'part_number': 17\n'total_parts': 21\n'contentType': 'READ'\n'title': Angular 16 released - Alles zu neuen Features und Breaking Changes\n'parentName': iJS Magazin Band 27\n'language': 'DE'\n'date': '2023-04-06T00:00:00.000Z'\n'abstract': Wir geben einen Überblick zu allen wichtigen Infos zum Release von Angular 16. Alles zu Signals, der Angular-CLI und TypeScript in Angular 16 erfahren Sie hier.\n'parentId': '5093fc7a779ccfe852d8fe7b'\n'parentDescription': Kaum ein Softwareprojekt, das nicht in wesentlichen Teilen auf der JavaScript-Technologie basiert. Eine breite Unterstützung sowie, leistungsfähige Programmiersprachen, die Vielzahl moderner Tools, sowie ausgereifte Frameworks wie Angular, React, Vue.js oder Node.js machen den JavaScript-Werkzeugkasten zu einem Alleskönner. Das iJS Magazin informiert aktuell und umfassend über die wichtige und innovative Entwicklungen im JavaScript-Universum und bietet handfeste Praxisinformationen für Softwareentwickler und -architekten.\n'indexBrandName': ''\n'indexSeriesName': ''\n'author': 'Karsten Sitterberg'\n'chunkSource': 'text'\n'text': in Listing 20 verwendet, um den Gesamtpreis total aus der Invoice zu “berechnen”. Das Besondere an den Computed Signals ist, dass die Compute-Funktion jedesmal dann aufgerufen wird, wenn ein Signal, das in der Funktion verwendet wird, seinen Wert ändert. In Listing 19 wird im total-Signal nur auf das invoice zugegriffen. Das bedeutet, dass jedesmal, wenn sich an der invoice etwas ändert, auch das total-Signal neu berechnet wird. Theoretisch gesehen kann ein Computed Signal von beliebig vielen anderen Signals abhängen. Das Computed Signal wird dann jedesmal neu berechnet, sobald eines der anderen Signals den Wert ändert. Listing 19: Beispiel zur Verwendung der Signal API @Component({ selector: 'app-signal-demo', standalone: true, template: ` \n\n Counter: {{counter()}} Increase ` }) export class SignalDemoComponent { protected counter = signal(0); increase(): void { this.counter.set(this.counter() + 1); //this.counter.update(counter => counter + 1); } } Listing 20: Verwendung der Signals-API mit Objekten @Component({ selector: 'app-signal-object-demo', standalone: true, template: ` \n\n Total Invoice Sum: {{total()}} GetNewInvoice ` }) export class SignalObjectDemoComponent { protected invoice = signal({price: 1}); protected total = computed(() => this.invoice().price); getNewInvoice(): void { this.invoice.mutate(inv => inv.price = 42); } } Neben den Signals gibt es noch die Effects. Die haben zunächst einmal nicht direkt etwas mit den NgRx-Effects zu tun, haben aber eine ähnliche Idee wie diese: Effects sollen auch hier Seiteneffekte ausführen. Da hören die Gemeinsamkeiten aber auch schon auf. Effects im Kontext von Signals sind - ähnlich wie Computed Signals - Funktionen, die immer dann ausgeführt werden, wenn sich eines oder mehrere der in dem Effect genutzten Signals geändert hat. Effects nutzen intern die inject()-Funktion, daher müssen auch Effects immer im Konstruktor- bzw. Injector-Kontext aufgerufen werden. Listing 21 zeigt beispielhaft, wie der Konstruktor der Komponente aus Listing 20 aussehen könnte. In diesem Fall loggt der effect() einfach nur jede Wertänderung des invoice-Signal auf die Konsole aus. Innerhalb von Effects sollten zur Vermeidung von Endlosschleifen Signals immer nur gelesen, nie geschrieben werden. Dies wird auch durch die Signal-API überprüft und dann ggf. ein Fehler geworfen. Listing 21: Beispiel für Logging als Signal-Effect constructor() {\n'slidetext': ''\n'from': 'index'\n'score': 123.1484146118164\n'normalizedScore': 1.231484146118164\n'beforeDatePenaltyScore': 1.231484146118164\n\n'documentId': 'de0df53930e2e1e582caf57f'\n'chunk_id': '687814d5bed6dcd41a99b085'\n'access': 'granted'\n'part_number': 15\n'total_parts': 15\n'contentType': 'READ'\n'title': Angular 17: The Web Framework's Newest Release - Renaissance? Angular 17! - All features at a glance\n'parentName': JavaScript Magazine Volume 12\n'language': 'EN'\n'date': '2024-03-22T02:00:00.000Z'\n'abstract': The popular JavaScript framework Angular has released version 17. It can be difficult to keep up with all the changes in angular, but this article covers an overview of Angular 17 features.\n'parentId': '7e9c82426451f3a6ca3ddfbf'\n'parentDescription': Broaden your knowledge and expand your JavaScript techniques and practices. From Angular, React, and WebAssembly, to the best JavaScript IDEs, open source tools and more, you’ll learn insights on everything JS from seasoned experts in their field. Keep up with JavaScript news, tips, and advice with interviews, tutorials, and in-depth articles.\n'indexBrandName': ''\n'indexSeriesName': ''\n'author': 'Karsten Sitterberg'\n'chunkSource': 'text'\n'text': which could lead to frustration and concerns about investments made, and could ultimately limit Angular's adoption and traction with new users. The Angular team could certainly work on improving its relationship with users by communicating more sensitively and carefully considering the risks and benefits of new features. Java is a good example of this: it consistently innovates, but with enough lead time and maximum compatibility even with very old codebases. Which is why Java is the preferred language in the enterprise environment. The Angular Ivy migration and Java Loom project would be a good comparison, massive benefits were created through high-quality engineering, without requiring developers to make massive efforts themselves. It’s clear that this can’t always be achieved, but it’s perhaps worth keeping this in mind as a goal. For Angular beginners, it's best to orient yourself with the latest concepts and avoid outdated literature, blog posts, and training courses.\n'slidetext': ''\n'from': 'index'\n'score': 123.09623718261719\n'normalizedScore': 1.230962371826172\n'beforeDatePenaltyScore': 1.230962371826172\n\n'documentId': '04721391f3f7580f0631b9d3'\n'chunk_id': '687a2102a98d5a30b3a34133'\n'access': 'granted'\n'part_number': 12\n'total_parts': 21\n'contentType': 'READ'\n'title': Angular 17: Neues Release des Web-Frameworks - Renaissance? Angular 17! - Alle Features im Überblick\n'parentName': iJS Magazin 2.2024\n'language': 'DE'\n'date': '2024-04-03T22:00:00.000Z'\n'abstract': Das beliebte JavaScript-Framework Angular veröffentlicht Version 17. Da bei Angular viel in Bewegung ist, kann manch einer da den Überblick verlieren. Wir stellen alle Features von Angular 17 vor.\n'parentId': 'c04db0163e3cb47407e78b63'\n'parentDescription': Kaum ein Softwareprojekt, das nicht in wesentlichen Teilen auf der JavaScript-Technologie basiert. Eine breite Unterstützung sowie, leistungsfähige Programmiersprachen, die Vielzahl moderner Tools, sowie ausgereifte Frameworks wie Angular, React, Vue.js oder Node.js machen den JavaScript-Werkzeugkasten zu einem Alleskönner. Das iJS Magazin informiert aktuell und umfassend über die wichtige und innovative Entwicklungen im JavaScript-Universum und bietet handfeste Praxisinformationen für Softwareentwickler und -architekten.\n'indexBrandName': ''\n'indexSeriesName': ''\n'author': 'Karsten Sitterberg'\n'chunkSource': 'text'\n'text': Template-Code innerhalb des “@empty”-Ausdruck wird immer dann angezeigt, wenn die übergebene Liste (hier “items”) keine Einträge hat, oder “null” bzw. “undefined” ist. Innerhalb des “@for”-Ausdrucks können auch verschiedene implizite Variablen genutzt werden, etwa um sich wie in Listing 11 den momentanen Schleifeniterationsindex ausgeben zu lassen (per “$index”). Es ist auch möglich, auf die Länge der Schleife zuzugreifen (“$count”), zu überprüfen, ob der momentane Schleifenindex gerade (“$even”) oder ungerade (“$odd”) ist, oder ob es sich dabei um das erste (“$first”) oder letzte (“$last”) Schleifenelement handelt. Listing 11: Beispiel für Schleife mit neuer “@for” Syntax in Angular 17 @for (item of items; track item.id) { \n\nElement Nummer {{$index}}: {{item.name}} } @empty { \n\nNo items } Um ein Switch-Case-Statement umzusetzen, wurden bisher drei Direktiven verwendet: Zum einen “ngSwitch”, zum anderen die Strukturellen Direktiven “*ngSwitchCase” und “*ngSwitchDefault”. Mit der neuen Syntax kann nun “@switch”, “@case” und “@default” verwendet werden, wie in Listing 12 dargestellt. Es kann natürlich weiterhin über primitive Werte oder z.B. Enum-Werte geswitched werden. Als Inhalt der Cases kann, wie auch bei den anderen Control-Flow Statements, normaler Angular-Template-Code verwendet werden. Es ist natürlich auch möglich, die Control-Flow-Angaben zu verschachteln. Listing 12: Beispiel für Switch-Case mit neuer “@switch” Syntax in Angular 17 @switch (value) { @case (1) { Fall Eins } @case (2) { \n\nFall Zwei } @default { Default-Fall } } Nicht nur neue Syntax, sondern eine komplett neue Funktionalität bietet das letzte Element der neuen Control-Flow-Syntax: Die “Deferred Views” (mit “@defer”) ermöglichen Lazy Loading auf Komponentenebene, ohne dass dafür der Router oder komplexe Renderer-Konstrukte benötigt werden. Ein Beispiel für eine Deferred View ist in Listing 13 zu sehen. Die Komponente “” ist in diesem Fall die Komponente, die nachgeladen werden soll. Der “when”-Ausdruck ist optional: Wenn er weggelassen wird, beginnt das Lazy Loading, sobald die äußere Komponente gerendert ist. Ansonsten kann der “when”-Ausdruck verwendet werden, um den Inhalt des “@defer”-Block erst zu laden, wenn eine\n'slidetext': ''\n'from': 'index'\n'score': 122.84436798095703\n'normalizedScore': 1.2284436798095704\n'beforeDatePenaltyScore': 1.2284436798095704\n\n'documentId': '04721391f3f7580f0631b9d3'\n'chunk_id': '687a2103a98d5a30b3a34141'\n'access': 'granted'\n'part_number': 19\n'total_parts': 21\n'contentType': 'READ'\n'title': Angular 17: Neues Release des Web-Frameworks - Renaissance? Angular 17! - Alle Features im Überblick\n'parentName': iJS Magazin 2.2024\n'language': 'DE'\n'date': '2024-04-03T22:00:00.000Z'\n'abstract': Das beliebte JavaScript-Framework Angular veröffentlicht Version 17. Da bei Angular viel in Bewegung ist, kann manch einer da den Überblick verlieren. Wir stellen alle Features von Angular 17 vor.\n'parentId': 'c04db0163e3cb47407e78b63'\n'parentDescription': Kaum ein Softwareprojekt, das nicht in wesentlichen Teilen auf der JavaScript-Technologie basiert. Eine breite Unterstützung sowie, leistungsfähige Programmiersprachen, die Vielzahl moderner Tools, sowie ausgereifte Frameworks wie Angular, React, Vue.js oder Node.js machen den JavaScript-Werkzeugkasten zu einem Alleskönner. Das iJS Magazin informiert aktuell und umfassend über die wichtige und innovative Entwicklungen im JavaScript-Universum und bietet handfeste Praxisinformationen für Softwareentwickler und -architekten.\n'indexBrandName': ''\n'indexSeriesName': ''\n'author': 'Karsten Sitterberg'\n'chunkSource': 'text'\n'text': “inject()”-Funktion. Dieser Breaking Change hat vor allem dann eine Auswirkung, wenn man - etwa in Unit-Tests - den NativeDateAdapter selbst per Konstruktor erzeugt hat. Das ist nun nicht mehr möglich, stattdessen muss in einem solchen Fall der NativeDateAdapter mittels Angulars Depenency-Injection erzeugt werden. Breaking Changes im CSS Um Angular-Material Styles per SCSS einzubinden, konnte bisher der “@import”-Mechanismus von SCSS verwendet werden. Da dieser Mechanismus aber schon länger SCSS-Seitig deprecated ist, wurde die “@import”-Möglichkeit nun auch auf der Seite von Angular-Material entfernt. Ab Angular Material 17 muss zum Einbinden der Material-Styles die neue SCSS “@use”-Syntax verwendet werden. Soll Angular Material mit einem Custom-Styling verwendet werden, so ist dies über die Material-Theming API möglich. Bisher wurde dabei Material-seitig allerdings nicht überprüft, ob die Custom-Themes formal korrekt sind. Mit Angular Material 17 werden diese nun strikt validiert. Wenn beispielsweise das “mat.button-typography”-Mixin mit einem Theme verwendet wird, bei dem “typography: null” gesetzt ist, gibt es beim SCSS-Build von nun an einen Fehler. Neben dem Import der globalen Material-Styles ist es auch möglich, nur die Styles für einzelne Komponenten im Build zu laden. Dazu kann das SCSS-Mixin “mat.-theme” verwendet werden, wobei “” dem Komponentennamen entspricht, z.B. “card”, “checkbox”, “radio” oder “list”. Zusätzlich können aber auch nur einzelne Teile der Komponenten-Styles geladen werden, etwa wie im letzten Absatz die Button-Typographie (per Mixin “mat.-typography”), die Farben (per Mixin “mat.-color”) oder die Density-Styles (man könnte auch “Spacing-Styles” sagen, das Mixin ist “mat.-density”). Mit Angular Material 17 sind nun noch weitere Styles hinzugekommen, die zwar in den Komponenten “-theme”-Mixins vorhanden sind, aber nicht in den Sub-Mixins. Um diese Styles nutzen zu können, muss dann das “mat.-base” Mixin verwendet werden. Um die Basic-Styles für alle Komponenten hinzuzufügen, gibt es nun auch das Mixin “mat.all-component-bases”. Fazit Ist Angular weiterhin das Framework mit langfristiger Investitionssicherung? Schwinded Angular oder schafft es das Framework neue Zielgruppen zu erobern, ohne bestehenden Teams und Entwickler:innen vor den Kopf zu stoßen? Oder plant man gar, diese bewusst zu\n'slidetext': ''\n'from': 'index'\n'score': 122.63552856445312\n'normalizedScore': 1.2263552856445312\n'beforeDatePenaltyScore': 1.2263552856445312\n\n'documentId': '04721391f3f7580f0631b9d3'\n'chunk_id': '687a2103a98d5a30b3a3413f'\n'access': 'granted'\n'part_number': 18\n'total_parts': 21\n'contentType': 'READ'\n'title': Angular 17: Neues Release des Web-Frameworks - Renaissance? Angular 17! - Alle Features im Überblick\n'parentName': iJS Magazin 2.2024\n'language': 'DE'\n'date': '2024-04-03T22:00:00.000Z'\n'abstract': Das beliebte JavaScript-Framework Angular veröffentlicht Version 17. Da bei Angular viel in Bewegung ist, kann manch einer da den Überblick verlieren. Wir stellen alle Features von Angular 17 vor.\n'parentId': 'c04db0163e3cb47407e78b63'\n'parentDescription': Kaum ein Softwareprojekt, das nicht in wesentlichen Teilen auf der JavaScript-Technologie basiert. Eine breite Unterstützung sowie, leistungsfähige Programmiersprachen, die Vielzahl moderner Tools, sowie ausgereifte Frameworks wie Angular, React, Vue.js oder Node.js machen den JavaScript-Werkzeugkasten zu einem Alleskönner. Das iJS Magazin informiert aktuell und umfassend über die wichtige und innovative Entwicklungen im JavaScript-Universum und bietet handfeste Praxisinformationen für Softwareentwickler und -architekten.\n'indexBrandName': ''\n'indexSeriesName': ''\n'author': 'Karsten Sitterberg'\n'chunkSource': 'text'\n'text': beteiligten Entwickler:innen die neuen Konzepte kennenlernen und auch in der Tiefe beherrschen, um effektiv und sinnvoll mit diesen neuen Möglichkeiten zu agieren. Apropos, was ist mit dem Angular Modulsystem? Es existiert aktuell weiterhin, der Plan ist jedoch, die Module zukünftig optional zu machen. Auch damit soll neuen Entwicklern der Einstieg in Angular erleichtert werden. Angular Material 17 Angular Material 17 bringt eine wichtige Änderung und gleichzeitig auch einen großen Breaking Change für alle, die noch mit den alten, seit Angular 15 als „Legacy-„ bezeichneten Material-Komponenten arbeiten. Legacy deshalb, da sich das Angular-Material-Team mit Version 15 dazu entschieden hat, das bisher genutzte CSS gegen die offiziellen Google-Material-Design-Components (MDC) Styles auszutauschen. Da in diesem Rahmen einige Komponenten deutlich überarbeitet werden mussten, wurden die alten Versionen der Komponenten mit „Legacy“ prefixed und deprecated, sodass sie noch verwendet werden konnten. Mit Angular Material 17 werden nun alle Legacy-Komponenten, die ein modernes MDC-Gegenstück haben, entfernt. Das heißt, dass Anwendungen spätestens mit Angular 17 auf die neuen, MDC basierten, Material-Komponenten migriert werden müssen. Wenn im JavaScript-Universum mit Datumsangaben gearbeitet werden soll, gibt es mehrere Möglichkeiten beziehungsweise Bibliotheken, dies zu tun. Um auch in Angular-Material mit diesen unterschiedlichen Date-Time-Bibliotheken arbeiten zu können, bietet Angular Material einen sogenannten “DateAdapter” an. Der DateAdapter wird dann z.B. vom Datepicker zur Datums-Verwaltung genutzt. Der “DateAdapter” ist allerdings eine abstrakte Klasse, die implementiert werden muss, um eine bestimmte Date-Time-Bibliothek zu nutzen. In Angular Material direkt eingebaut gibt es zum Beispiel den “NativeDateAdapter”, der einfach nur das nativ im Browser verfügbare “Date”-Objekt zur Datenverwaltung nutzt. Dieser “NativeDateAdapter” bekam bisher per Konstruktor-Injection den “Platform”-Service übergeben. Mit Angular Material 17 ist dies nicht länger der Fall, außerdem nutzt der “NativeDateAdapter” nun auch generell keine Konstruktor-Injection mehr, sondern die “inject()”-Funktion. Dieser Breaking Change hat vor allem dann eine Auswirkung, wenn man - etwa in Unit-Tests - den NativeDateAdapter selbst per Konstruktor erzeugt hat. Das ist nun nicht mehr möglich, stattdessen muss in\n'slidetext': ''\n'from': 'index'\n'score': 122.41951751708984\n'normalizedScore': 1.2241951751708984\n'beforeDatePenaltyScore': 1.2241951751708984\n\n'documentId': 'de0df53930e2e1e582caf57f'\n'chunk_id': '687814d4bed6dcd41a99b076'\n'access': 'granted'\n'part_number': 2\n'total_parts': 15\n'contentType': 'READ'\n'title': Angular 17: The Web Framework's Newest Release - Renaissance? Angular 17! - All features at a glance\n'parentName': JavaScript Magazine Volume 12\n'language': 'EN'\n'date': '2024-03-22T02:00:00.000Z'\n'abstract': The popular JavaScript framework Angular has released version 17. It can be difficult to keep up with all the changes in angular, but this article covers an overview of Angular 17 features.\n'parentId': '7e9c82426451f3a6ca3ddfbf'\n'parentDescription': Broaden your knowledge and expand your JavaScript techniques and practices. From Angular, React, and WebAssembly, to the best JavaScript IDEs, open source tools and more, you’ll learn insights on everything JS from seasoned experts in their field. Keep up with JavaScript news, tips, and advice with interviews, tutorials, and in-depth articles.\n'indexBrandName': ''\n'indexSeriesName': ''\n'author': 'Karsten Sitterberg'\n'chunkSource': 'text'\n'text': return; } Listing 2: No more return needed for the “undefined” return type Independent getter and setter types Previously, TypeScript get and set functions that belonged together (for example, if they had the same name) had to have compatible types. For a setter that can be given the type 'string|number|boolean', previously you could only specify a subtype like 'string' as the corresponding getter. In TypeScript 5.1, these types can be assigned completely independently, but they must be assigned explicitly. See Listing 3. interface MyElementStyling { set style(newValue: string); get style(): CSSStyleDeclaration; } Listing 3: Independent getter and setter types. Decorator Metadata In TypeScript, a decorator is a function that is given a class, property, or method in order to extend the passed entity’s behavior. TypeScript 5.2 adds an exciting feature specifically for the Angular framework: the ability to add metadata to a decorator. This feature was already in the 'Experimental Decorators' originally used by Angular, but now it’s also in the stable TypeScript specification. For example, in Listing 4, the decorator 'setMetadata' is defined. A decorator is a function that’s given the decorated entity as a 'target' and the associated 'context'. The 'metadata' property was added to this context object in TypeScript 5.2. The metadata can be understood as a key-value store. Its corresponding TypeScript type is called 'record'. The metadata key is the name of the decorated entity; in Listing 4, for example, the property 'demoAmount' is decorated. Therefore, it becomes a metadata key. Listing 4 shows how metadata can be written by accessing 'context.metadata'. The decorated entity’s name is in 'context.name'. In Listing 4, the string 'Demo data' is stored in the metadata for each property decorated with '@setMetadata'. Stored metadata can be read from the class with the TypeScript metadata symbol ('Symbol.metadata'). interface Context { name: string; metadata: Record\n\n; } function setMetadata(_target: any, context: Context) { context.metadata[context.name] = 'Demo-Data'; } class MyClass { @setMetadata demoAmount = 123; @setMetadata demoAction() { } } const ourMetadata = MyClass[Symbol.metadata]; console.log(JSON.stringify(ourMetadata)); // { 'demoAmount': 'Demo-Data', 'demoAction': 'Demo-Data' } Listing 4: Set and read metadata in TypeScript To better configure a decorator, you can implement a decorator factory. It will then return the actual decorator. This is shown in Listing 5 using the 'DemoMeta' decorator factory, which receives the metadata key to be set and the associated metadata value as parameters and returns the configured decorator. The 'DemoMeta' factory is used in Listing 5 to add the metadata entry\n'slidetext': ''\n'from': 'index'\n'score': 122.36517333984375\n'normalizedScore': 1.2236517333984376\n'beforeDatePenaltyScore': 1.2236517333984376\n\n'documentId': '04721391f3f7580f0631b9d3'\n'chunk_id': '687a2101a98d5a30b3a34126'\n'access': 'granted'\n'part_number': 6\n'total_parts': 21\n'contentType': 'READ'\n'title': Angular 17: Neues Release des Web-Frameworks - Renaissance? Angular 17! - Alle Features im Überblick\n'parentName': iJS Magazin 2.2024\n'language': 'DE'\n'date': '2024-04-03T22:00:00.000Z'\n'abstract': Das beliebte JavaScript-Framework Angular veröffentlicht Version 17. Da bei Angular viel in Bewegung ist, kann manch einer da den Überblick verlieren. Wir stellen alle Features von Angular 17 vor.\n'parentId': 'c04db0163e3cb47407e78b63'\n'parentDescription': Kaum ein Softwareprojekt, das nicht in wesentlichen Teilen auf der JavaScript-Technologie basiert. Eine breite Unterstützung sowie, leistungsfähige Programmiersprachen, die Vielzahl moderner Tools, sowie ausgereifte Frameworks wie Angular, React, Vue.js oder Node.js machen den JavaScript-Werkzeugkasten zu einem Alleskönner. Das iJS Magazin informiert aktuell und umfassend über die wichtige und innovative Entwicklungen im JavaScript-Universum und bietet handfeste Praxisinformationen für Softwareentwickler und -architekten.\n'indexBrandName': ''\n'indexSeriesName': ''\n'author': 'Karsten Sitterberg'\n'chunkSource': 'text'\n'text': zieht hier auch der neue esbuild-Builder nach. Server Side Rendering und SEO SPAs, wie sie mit Angular gebaut werden, haben einen Nachteil: Wenn die initiale Webseite geladen wurde, müssen zunächst einige Scripte geladen werden, die dann Ihrerseits erst die Anwendung starten. Das dauert natürlich je nach Internetanbindung und Größe der Seite einen Moment. Dies zusammen mit der Tatsache, dass überhaupt Scripte ausgeführt werden müssen, um die Inhalte der Seite angezeigt zu bekommen, ist schlecht für das SEO-Ranking der Seite. Um eine Angular-Anwendung SEO-fit zu machen, konnte bisher das Paket “@nguniversal” verwendet werden. “@nguniversal” kann eine Angular-Anwendung serverseitig (pre-)rendern. Dadurch sind die Inhalte der Seite direkt sichtbar, nachdem das HTML geladen wurde, da diese nicht mehr dynamisch im Client erzeugt werden müssen. Das führt zu einem schnellen Page Load, besserer Usability und u.a. dadurch auch zu einem besseren SEO-Ranking. Bisher waren die Pre-Rendering-Pakete in einem eigenen Namespace “@nguniversal”, obwohl auch diese Pakete vom Angular-Team mit betreut wurden. Mit Angular 17 wurde der Code von “@nguniversal” größtenteils verschoben in das Paket “@angular/ssr” im “@angular” Namespace. Die Funktionalität ist dabei allerdings bis auf Umbenennungen im Wesentlichen dieselbe wie vorher. Dem Angular-Team ist das Thema SSR (Server Side (pre-) Rendering) wichtiger geworden, das sieht man neben obiger Änderung auch daran, dass es einfacher geworden ist, die Pakete hierfür einzubinden. So wird beim Anlegen eines neuen Angular-17-Projektes gefragt, ob Server-Side-Rendering aktiviert werden soll. Alternativ kann auch die neue Option “ng new --ssr” verwendet werden, um ein Projekt mit vorkonfiguriertem SSR zu generieren. In diesem Projekt ist dann auch direkt die mit Angular 16 hinzugekommene Hydration aktiviert, die einen nahtlosen Übergang von der serverseitig generierten Seite zur voll funktionsfähigen Angular-App ohne Flackern sicherstellen soll. Breaking Changes in Angular-CLI 17 Angular 17 hält natürlich seine eigenen Abhängigkeiten aktuell. Daher muss für Angular und Angular-CLI nun mindestens TypeScript in Version 5.2, zone.js in Version 0.14.0 verwendet werden. Auch die minimal notwendige node.js-Version wird nun auf 18.13.0\n'slidetext': ''\n'from': 'index'\n'score': 122.22234344482422\n'normalizedScore': 1.222223434448242\n'beforeDatePenaltyScore': 1.222223434448242\n\n'documentId': '8b35e3d0070110b78d6c9434'\n'chunk_id': '687a2210d92aed38f5a4a5af'\n'access': 'granted'\n'part_number': 1\n'total_parts': 9\n'contentType': 'READ'\n'title': Angular: Signals, Standalone, SSR - So bauen Sie Angular-Apps der Zukunft\n'parentName': Windows Developer 7.2024\n'language': 'DE'\n'date': '2024-06-10T22:00:00.000Z'\n'abstract': Mit der Veröffentlichung der 16. Hauptversion von Angular läutete das Angular-Team die „Angular Renaissance“ ein. Wörtlich übersetzt bedeutet das nichts Geringeres als die Wiedergeburt von Googles SPA-Framework - eine treffende Bezeichnung, denn Angular-Codebasen werden sich nachhaltig verändern. Der Unterschied zwischen Angular-2- und Angular-17-Code ist mit bloßem Auge erkennbar.\n'parentId': 'b662818c73a937b86282ae99'\n'parentDescription': Windows Developer informiert umfassend und herstellerneutral über die neuen Trends und Möglichkeiten der Software- und Systementwicklung rund um Microsoft- und Web-Technologien. Von der klassischen .NET-Entwicklung über .NET Core bis hin zu neuen Technologien wie Windows 10, Microsoft Azure und der ganzen Bandbreite der aktuellen Web-, Phone- und Tabletentwicklung für Android und iOS mit Xamarin und unterschiedlichen JavaScript-Frameworks. Professionelle Entwickler und IT-Entscheider erhalten genau die Informationen, die sie für den erfolgreichen Einsatz von unternehmensorientierten Lösungen benötigen.\n'indexBrandName': ''\n'indexSeriesName': ''\n'author': 'Christian Liebel'\n'chunkSource': 'text'\n'text': Angular: Signals, Standalone, SSR So bauen Sie Angular-Apps der Zukunft Mit der Veröffentlichung der 16. Hauptversion von Angular läutete das Angular-Team die „Angular Renaissance“ ein. Wörtlich übersetzt bedeutet das nichts Geringeres als die Wiedergeburt von Googles SPA-Framework - eine treffende Bezeichnung, denn Angular-Codebasen werden sich nachhaltig verändern. Der Unterschied zwischen Angular-2- und Angular-17-Code ist mit bloßem Auge erkennbar. Mit der Veröffentlichung der 16. Hauptversion von Angular läutete das Angular-Team die „Angular Renaissance“ ein. Wörtlich übersetzt bedeutet das nichts Geringeres als die Wiedergeburt von Googles SPA-Framework – eine treffende Bezeichnung, denn Angular-Codebasen werden sich nachhaltig verändern. Der Unterschied zwischen Angular-2- und Angular-17-Code ist mit bloßem Auge erkennbar. Derzeit führt das Angular-Team zahlreiche neue Features und Konzepte in das Framework ein. Ziel dieser Änderungen ist, Angular zu vereinfachen und damit Anfänger:innen den Einstieg zu erleichtern, Schnittstellen zu modernisieren und die Performance von Angular-Anwendungen zu verbessern, damit das Framework auch im kommenden Jahrzehnt seines Bestehens konkurrenzfähig bleibt. Alle neuen Funktionen sind abwärtskompatibel und interoperabel. In diesem Artikel soll es um drei dieser Features gehen: 1. den neuen reaktiven Basisdatentyp Signals, 2. die Standalone-Schnittstellen als NgModule-Killer und 3. den neuen Ansatz zum Server-side Rendering, der es in die 17. Hauptversion von Angular geschafft hat. Angular-Entwickler:innen, die neue Anwendungen erstellen, sollten diese Features in jedem Fall berücksichtigen. Bestandsanwendungen sollten schnellstmöglich migriert werden. In diesem Artikel wird zu jedem Feature angegeben, ob, wann und wie eine Migration vorgenommen werden sollte. Signals – Die neue Art des State Management Mit der 16. Hauptversion von Angular wurden Signals in das Framework eingeführt. Es handelt sich um den neuen reaktiven Basisdatentyp [1]. Ein Signal ist ein Wrapper um einen bestimmten Wert. Wenn sich dieser ändert, informiert das Signal interessierte Konsumenten, sodass diese auf die Änderung reagieren können. const count = signal(0); count.set(3); Ein neues schreibbares Signal lässt sich über die Methode signal() erzeugen. Signals müssen zwingend mit einem Initialwert vorbelegt sein, der als Argument angegeben wird. Es ist\n'slidetext': ''\n'from': 'index'\n'score': 122.15689849853516\n'normalizedScore': 1.2215689849853515\n'beforeDatePenaltyScore': 1.2215689849853515\n\n'documentId': '64ace3828d8056484c3534ab'\n'chunk_id': '687814c6bed6dcd41a99b02d'\n'access': 'granted'\n'part_number': 21\n'total_parts': 21\n'contentType': 'READ'\n'title': Angular 16 released - Alles zu neuen Features und Breaking Changes\n'parentName': iJS Magazin Band 27\n'language': 'DE'\n'date': '2023-04-06T00:00:00.000Z'\n'abstract': Wir geben einen Überblick zu allen wichtigen Infos zum Release von Angular 16. Alles zu Signals, der Angular-CLI und TypeScript in Angular 16 erfahren Sie hier.\n'parentId': '5093fc7a779ccfe852d8fe7b'\n'parentDescription': Kaum ein Softwareprojekt, das nicht in wesentlichen Teilen auf der JavaScript-Technologie basiert. Eine breite Unterstützung sowie, leistungsfähige Programmiersprachen, die Vielzahl moderner Tools, sowie ausgereifte Frameworks wie Angular, React, Vue.js oder Node.js machen den JavaScript-Werkzeugkasten zu einem Alleskönner. Das iJS Magazin informiert aktuell und umfassend über die wichtige und innovative Entwicklungen im JavaScript-Universum und bietet handfeste Praxisinformationen für Softwareentwickler und -architekten.\n'indexBrandName': ''\n'indexSeriesName': ''\n'author': 'Karsten Sitterberg'\n'chunkSource': 'text'\n'text': Davon abgesehen wirken die großen Schritte in Richtung Signal-API und Zone.js als optionale Implementierung der Change Detection zukunftsweisend, fast schon wie die heimliche Vision einer neuen Generation Angular. Dasselbe gilt auch für das Modulsystem, das als optionales Mittel eingesetzt werden kann, große Anwendungen gut zu strukturieren und damit wartbar zu halten, ohne für Einsteiger oder bei kleinen Anwendungen ungerechtfertigte Komplexität zu erzwingen. Entwickler:innen sollten hier unbedingt am Ball bleiben - und auch die Zukunft Angulars aktiv mitgestalten. Angular-Tutorial und mehr Für Angular-Entwickler:innen und alle die es werden wollen, empfehlen wir unsere sechsteilige Tutorialserie Angular für Einsteiger:innen. Weitere Artikel, Serien und Kolumnen zu Angular finden Sie in unserer Übersicht zu Angular.\n'slidetext': ''\n'from': 'index'\n'score': 122.13517761230469\n'normalizedScore': 1.2213517761230468\n'beforeDatePenaltyScore': 1.2213517761230468\n\n'documentId': '04721391f3f7580f0631b9d3'\n'chunk_id': '687a2102a98d5a30b3a34136'\n'access': 'granted'\n'part_number': 14\n'total_parts': 21\n'contentType': 'READ'\n'title': Angular 17: Neues Release des Web-Frameworks - Renaissance? Angular 17! - Alle Features im Überblick\n'parentName': iJS Magazin 2.2024\n'language': 'DE'\n'date': '2024-04-03T22:00:00.000Z'\n'abstract': Das beliebte JavaScript-Framework Angular veröffentlicht Version 17. Da bei Angular viel in Bewegung ist, kann manch einer da den Überblick verlieren. Wir stellen alle Features von Angular 17 vor.\n'parentId': 'c04db0163e3cb47407e78b63'\n'parentDescription': Kaum ein Softwareprojekt, das nicht in wesentlichen Teilen auf der JavaScript-Technologie basiert. Eine breite Unterstützung sowie, leistungsfähige Programmiersprachen, die Vielzahl moderner Tools, sowie ausgereifte Frameworks wie Angular, React, Vue.js oder Node.js machen den JavaScript-Werkzeugkasten zu einem Alleskönner. Das iJS Magazin informiert aktuell und umfassend über die wichtige und innovative Entwicklungen im JavaScript-Universum und bietet handfeste Praxisinformationen für Softwareentwickler und -architekten.\n'indexBrandName': ''\n'indexSeriesName': ''\n'author': 'Karsten Sitterberg'\n'chunkSource': 'text'\n'text': eines Netzwerkabbruchs, wird der Inhalt des “@error”-Blocks dargestellt. Listing 13: Beispiel für den neuen “@defer”-Ausdruck in Angular 17 @defer (when isLoaded) {  } @loading { \n\nLoading... } @placeholder { pending } @error { Failed to load } Neben der “when”-Angabe mit einem booleschen Ausdruck ist es auch möglich, eine “on”-Bedingung zu spezifizieren. In Listing 14 werden beispielhaft die “on immediate” und die “on idle”-Bedingung gezeigt. Dabei verhält sich “on immediate” genau so, wie wenn der Ausdruck weggelassen würde: Sobald die äußere Komponente gerendert ist, werden die Komponenten im Defer-Block nachgeladen. Mit “on idle” werden die Komponenten geladen, sobald der Browser im “idle”-Zustand ist (Technisch entspricht das der “requestIdleCallback()”-Funktion des Browsers). Listing 14: Beispeile für “on”-Ausdrücke, die direkt oder erst im Idle-Zustand laden @defer (on immediate) { //... @defer (on idle) { //... Neben diesen eher statischen Angaben kann auch auf dynamische Nutzer-Interaktionen reagiert werden, dazu gibt es die “on interaction”-Bedingungen. Um auf eine Interaktion reagieren zu können, muss natürlich ein Element angegeben werden, mit dem der Nutzer interagieren soll. Im oberen Beispiel von Listing 15 ist zu sehen, dass dafür entweder ein externes Element, z.B. ein Button, per Template-Referenz-Variable an die “interaction”-Bedingung übergeben werden kann. Alternativ kann diese explizite Zuweisung weggelassen werden, dann muss aber ein “@placeholder” spezifiziert werden, denn der Placeholder-Inhalt dient dann als Interaktionselement. Das ist in Listing 15 in der Mitte zu sehen. Damit könnte beispielsweise eine Detailansicht auf Knopfdruck nachgeladen werden, in der aufwändige Parsing-Logik (z.B. zum Parsen und Darstellen von XML) in Form von Komponenten und Services enthalten ist, die nur “On-Demand” nachgeladen werden sollen. Ähnlich wie die “on interaction”-Angabe funktioniert die “on hover”-Bedingung, siehe Listing 15 unten. Einziger Unterschied: Statt einer Interaktion ist es lediglich notwendig, über das Trigger-Element zu hovern. Listing 15: Möglichkeiten, Defer-Inhalte basierend auf einem Interaktions-Trigger zu laden @defer (on interaction(trigger)) {  } Trigger @defer (on interaction) {\n'slidetext': ''\n'from': 'index'\n'score': 121.99089813232422\n'normalizedScore': 1.2199089813232422\n'beforeDatePenaltyScore': 1.2199089813232422\n\n'documentId': '04721391f3f7580f0631b9d3'\n'chunk_id': '687a2102a98d5a30b3a34131'\n'access': 'granted'\n'part_number': 11\n'total_parts': 21\n'contentType': 'READ'\n'title': Angular 17: Neues Release des Web-Frameworks - Renaissance? Angular 17! - Alle Features im Überblick\n'parentName': iJS Magazin 2.2024\n'language': 'DE'\n'date': '2024-04-03T22:00:00.000Z'\n'abstract': Das beliebte JavaScript-Framework Angular veröffentlicht Version 17. Da bei Angular viel in Bewegung ist, kann manch einer da den Überblick verlieren. Wir stellen alle Features von Angular 17 vor.\n'parentId': 'c04db0163e3cb47407e78b63'\n'parentDescription': Kaum ein Softwareprojekt, das nicht in wesentlichen Teilen auf der JavaScript-Technologie basiert. Eine breite Unterstützung sowie, leistungsfähige Programmiersprachen, die Vielzahl moderner Tools, sowie ausgereifte Frameworks wie Angular, React, Vue.js oder Node.js machen den JavaScript-Werkzeugkasten zu einem Alleskönner. Das iJS Magazin informiert aktuell und umfassend über die wichtige und innovative Entwicklungen im JavaScript-Universum und bietet handfeste Praxisinformationen für Softwareentwickler und -architekten.\n'indexBrandName': ''\n'indexSeriesName': ''\n'author': 'Karsten Sitterberg'\n'chunkSource': 'text'\n'text': stattdessen mussten “if-else”-Konstrukte verschachtelt werden. In Listing 10 ist nun die neue Syntax gezeigt, mit der beides sehr einfach möglich ist, die Syntax erinnert an JavaScript. Wichtig ist hier, dass die Keywords “@if” und “@else” immer mit einem vorangestellten “@” ausgezeichnet werden. Listing 10: “@if-@else” mit Angular 17 Control-Flow-Syntax im Template @if (show) { Inhalt Fall 1 } @else if (otherCond) { Inhalt Fall 2 } @else { sonstiger Inhalt } Auch die “*ngFor”-Direktive soll durch die neue Control-Flow-Syntax “@for” abgelöst werden, die entsprechende Syntax ist in Listing 11 gezeigt. Was direkt auffällt: Innerhalb des “for”-Statement wird nun “item of items” geschrieben, nicht mehr “let item of items” wie es mit “*ngFor” nötig war. Weiterhin ist es nun notwendig, eine “track”-Option anzugeben, die die Rolle der “trackBy”-Option aus “*ngFor” übernimmt. Wichtiger Unterschied hierbei: Die neue “@for-track”-Option ist nicht optional, sondern muss immer mit spezifiziert werden. Sie wird intern von Angular genutzt, um das Rendering der Liste zu optimieren, sodass die Liste nicht andauernd komplett neu gerendert werden muss, speziell wenn sich ggf. nur einzelne Listeneinträge innerhalb der Liste ändern. Dabei hilft auch ein komplett neuer Algorithmus zum List-Rendering, der durch die neue “@for”-Syntax ermöglicht wurde, und in Benchmarks eine deutliche Verbesserung der Performance gegenüber dem alten Algorithmus gezeigt hat. Der Wert, der beim “track”-Ausdruck angegeben wird, muss identifizierend für den jeweiligen Collection-Eintrag sein. Falls z.B. über ein Array mit Objekten iteriert wird, sollte eine ID des jeweiligen Objektes genutzt werden, wie auch in Listing 11 dargestellt. Falls über ein Array von primitiven Werten iteriert wird, so kann auch einfach direkt der Wert selbst genutzt werden (“track item”). Eine Neuerung, die wir von “*ngFor” bisher nicht kannten, ist, dass “@for” durch ein “@empty{}” erweitert werden kann. Der Template-Code innerhalb des “@empty”-Ausdruck wird immer dann angezeigt, wenn die übergebene Liste (hier “items”) keine Einträge hat, oder “null” bzw. “undefined” ist. Innerhalb des “@for”-Ausdrucks können auch\n'slidetext': ''\n'from': 'index'\n'score': 121.91799926757812\n'normalizedScore': 1.2191799926757811\n'beforeDatePenaltyScore': 1.2191799926757811\n\n'documentId': '04721391f3f7580f0631b9d3'\n'chunk_id': '687a2100a98d5a30b3a34117'\n'access': 'granted'\n'part_number': 1\n'total_parts': 21\n'contentType': 'READ'\n'title': Angular 17: Neues Release des Web-Frameworks - Renaissance? Angular 17! - Alle Features im Überblick\n'parentName': iJS Magazin 2.2024\n'language': 'DE'\n'date': '2024-04-03T22:00:00.000Z'\n'abstract': Das beliebte JavaScript-Framework Angular veröffentlicht Version 17. Da bei Angular viel in Bewegung ist, kann manch einer da den Überblick verlieren. Wir stellen alle Features von Angular 17 vor.\n'parentId': 'c04db0163e3cb47407e78b63'\n'parentDescription': Kaum ein Softwareprojekt, das nicht in wesentlichen Teilen auf der JavaScript-Technologie basiert. Eine breite Unterstützung sowie, leistungsfähige Programmiersprachen, die Vielzahl moderner Tools, sowie ausgereifte Frameworks wie Angular, React, Vue.js oder Node.js machen den JavaScript-Werkzeugkasten zu einem Alleskönner. Das iJS Magazin informiert aktuell und umfassend über die wichtige und innovative Entwicklungen im JavaScript-Universum und bietet handfeste Praxisinformationen für Softwareentwickler und -architekten.\n'indexBrandName': ''\n'indexSeriesName': ''\n'author': 'Karsten Sitterberg'\n'chunkSource': 'text'\n'text': Angular 17: Neues Release des Web-Frameworks Renaissance? Angular 17! - Alle Features im Überblick Das beliebte JavaScript-Framework Angular veröffentlicht Version 17. Da bei Angular viel in Bewegung ist, kann manch einer da den Überblick verlieren. Wir stellen alle Features von Angular 17 vor. Bei Angular ist viel in Bewegung. Manch einer kann da den Überblick verlieren, oder gar Angst vor Überforderung bekommen. Ob diese Sorge begründet ist oder der Plan des Angular-Teams, für Angular eine Renaissance einzuläuten, gelingen kann, soll in diesem Beitrag beleuchtet werden. Vorneweg: Wer bisher Angular Upgrades vor sich her geschoben hat, oder plant lediglich zum Ende eines LTS Zyklus zu aktualisieren, der sollte die aktuellen Entwicklungen sehr genau beobachten und bewerten, ob inkrementelle Updates mit kleinen Schritten, statt großer Sprünge aus Aufwand- und Risikosicht nicht sinnvoller sind. Wir werfen natürlich nicht nur einen Blick auf die Angular-Core Änderungen, sondern werden auch TypeScript und Angular-Material betrachten. Das Angular 17 Release in Stichpunkten Hier findet ihr knapp zusammengefasst einige der wichtigsten Neuerungen und Breaking Changes in Angular 17. TypeScript - Angular 17 erfordert mindestens TypeScript 5.2. - Implizites 'return' bei 'undefined' wird nun unterstützt; Funktionen mit Rückgabetyp 'undefined' sind mit 'void'-Funktionen kompatibel. - Unabhängige Typangaben für Getter und Setter werden mit TypeScript 5.1 ermöglicht. - Neue Metadaten für Decorators mit TypeScript 5.2, um Verhalten zu definieren und auszulesen. Angular CLI - Angular CLI nutzt 'esbuild' für schnellere Builds und kleinere Ergebnisse, einschließlich eines Vite-basierten Development-Servers. - Server-Side Rendering Funktionalitäten unter dem Paket '@angular/ssr' wurden eingeführt, mit vereinfachten SSR-Optionen im CLI. - Es gibt mehrere Breaking Changes in Angular CLI, einschließlich der Anforderung von TypeScript 5.2 und zone.js 0.14.0, sowie der Anhebung der minimalen Node.js-Version auf 18.13.0. Angular 17 - Neue Anwendungen initialisieren den Angular Router standardmäßig und erzeugen Anwendungen als 'standalone' ohne '@NgModule()'s. - Funktionale HTTP-Interceptoren werden in Angular CLI 17 bevorzugt, klassenbasierte sind optional. - Einführung der neuen Syntax @switch, @case, und @default für Conditional Rendering und neue Direktiven wie @defer für Lazy\n'slidetext': ''\n'from': 'index'\n'score': 121.89221954345703\n'normalizedScore': 1.2189221954345704\n'beforeDatePenaltyScore': 1.2189221954345704\n\n'documentId': '64ace3828d8056484c3534ab'\n'chunk_id': '687814c4bed6dcd41a99b019'\n'access': 'granted'\n'part_number': 1\n'total_parts': 21\n'contentType': 'READ'\n'title': Angular 16 released - Alles zu neuen Features und Breaking Changes\n'parentName': iJS Magazin Band 27\n'language': 'DE'\n'date': '2023-04-06T00:00:00.000Z'\n'abstract': Wir geben einen Überblick zu allen wichtigen Infos zum Release von Angular 16. Alles zu Signals, der Angular-CLI und TypeScript in Angular 16 erfahren Sie hier.\n'parentId': '5093fc7a779ccfe852d8fe7b'\n'parentDescription': Kaum ein Softwareprojekt, das nicht in wesentlichen Teilen auf der JavaScript-Technologie basiert. Eine breite Unterstützung sowie, leistungsfähige Programmiersprachen, die Vielzahl moderner Tools, sowie ausgereifte Frameworks wie Angular, React, Vue.js oder Node.js machen den JavaScript-Werkzeugkasten zu einem Alleskönner. Das iJS Magazin informiert aktuell und umfassend über die wichtige und innovative Entwicklungen im JavaScript-Universum und bietet handfeste Praxisinformationen für Softwareentwickler und -architekten.\n'indexBrandName': ''\n'indexSeriesName': ''\n'author': 'Karsten Sitterberg'\n'chunkSource': 'text'\n'text': Angular 16 released Alles zu neuen Features und Breaking Changes Wir geben einen Überblick zu allen wichtigen Infos zum Release von Angular 16. Alles zu Signals, der Angular-CLI und TypeScript in Angular 16 erfahren Sie hier. Angular 16 setzt in vielerlei Hinsicht neue Akzente. Das wird nicht jedem gefallen. Ob das Angular-Team - und dahinter Google - hier kluge Entscheidungen trifft, wird vermutlich erst die Zeit zeigen. Um sich selbst ein Bild zu machen, betrachten wir alle wichtigen Änderungen zu TypeScript in Angular, die Angular-CLI und besonders Signals von Angular 16 im folgenden Beitrag. Angular hat besonders da einen guten Ruf, wo es um langlebige Anwendungen geht, bei denen Investitutionsschutz ein sehr wichtiges Kriterium ist. Selbst bei sehr kritischen Umbaumaßnahmen, wie der Umstellung der Renderingengine auf Ivy hat das Angular-Team stets extrem gutes Fingerspitzengefühl bewiesen. Durch kontinuierliche Verbesserungen von ng-upgrade und gutes Engineering bedeuteten notwendige Migrationen für Entwickler immer weniger Aufwand. Zumal viele der Änderungen im Laufe mehrerer Versionen schrittweise umgesetzt wurden und oft sogar die API-Oberfläche für typische Anwendungen stabil gehalten werden konnte. TypeScript und Angular 16 Angular legt auch mit diesem Release ein Augenmerk darauf, seine eigenen Abhängigkeiten aktuell zu halten. So muss mit Angular 16 TypeScript in Version 4.9 oder 5.0 vorliegen. Daher schauen wir uns die wichtigsten Neuerungen in TypeScript 4.9 hier zunächst an. Die weiteren Neuerungen von TypeScript 5 können in folgenden Artikel nachgelesen werden: TypeScript 5: Neuerungen und Breaking Changes. Auch mit TypeScript 4.9 kamen einige Neuerungen: So gibt es etwa Verbesserungen bei der Build-Performance oder beim File-Watching durch den Dev-Server. Außerdem wurde ein “Auto-Accessor”-Keyword eingeführt (Verwendungsbeispiel: public accessor name: string;), das automatisch sowohl einen set- als auch einen get-Accessor für das Property name erzeugt. Es wurde auch ein Compiler-Hinweis eingefügt, der einen Fehler ausgibt, sobald ein Vergleich mit NaN ausgeführt wird, da diese Vergleiche eigentlich immer ein Fehler sind (NaN !== x ist immer true, selbst wenn x=NaN, während NaN === x immer false zurück liefert). Stattdessen sollte die Funktion Number.isNaN(someValue) verwendet werden. Es wurde auch ein\n'slidetext': ''\n'from': 'index'\n'score': 121.88720703125\n'normalizedScore': 1.2188720703125\n'beforeDatePenaltyScore': 1.2188720703125\n\n'documentId': '64ace3828d8056484c3534ab'\n'chunk_id': '687814c4bed6dcd41a99b01c'\n'access': 'granted'\n'part_number': 4\n'total_parts': 21\n'contentType': 'READ'\n'title': Angular 16 released - Alles zu neuen Features und Breaking Changes\n'parentName': iJS Magazin Band 27\n'language': 'DE'\n'date': '2023-04-06T00:00:00.000Z'\n'abstract': Wir geben einen Überblick zu allen wichtigen Infos zum Release von Angular 16. Alles zu Signals, der Angular-CLI und TypeScript in Angular 16 erfahren Sie hier.\n'parentId': '5093fc7a779ccfe852d8fe7b'\n'parentDescription': Kaum ein Softwareprojekt, das nicht in wesentlichen Teilen auf der JavaScript-Technologie basiert. Eine breite Unterstützung sowie, leistungsfähige Programmiersprachen, die Vielzahl moderner Tools, sowie ausgereifte Frameworks wie Angular, React, Vue.js oder Node.js machen den JavaScript-Werkzeugkasten zu einem Alleskönner. Das iJS Magazin informiert aktuell und umfassend über die wichtige und innovative Entwicklungen im JavaScript-Universum und bietet handfeste Praxisinformationen für Softwareentwickler und -architekten.\n'indexBrandName': ''\n'indexSeriesName': ''\n'author': 'Karsten Sitterberg'\n'chunkSource': 'text'\n'text': erkennt TypeScript, dass ein solcher Zugriff abgesichert und damit erlaubt ist. Listing 4: Type-Narrowing durch Type-Guard interface Cow { giveMilk(): void; } interface Bird { layEggs(): void; } function doItWithObjects(value: Cow | Bird) { if ('layEggs' in value) { value.layEggs(); // value is vom Typ 'Bird' } } Listing 5: Type-Narrowing bei unbekannten Typen function tryGetDataContent(data: unknown): string | undefined { if (data && typeof data === 'object') { if ('content' in data && typeof data.content === 'string') { // ^ Bisher: TypeError return data.content; } } return undefined; } Mehr zum Thema Angular © gdainti/Shutterstock.com Change Detection performanter und leichtgewichtiger mit Signals Sarah Drasner, die als Director of Engineering bei Googleu. a. auch dem Angular-Team vorsteht, hat auf Twitter von einer Angular-Renaissance gesprochen. Das trifft es ziemlich gut, denn in den letzten Releases gab es tatsächlich einige Neuerungen, die Angular äußert attraktiv machen. Die wohl wichtigsten sind Standalone Components und Standalone APIs. Angulars neues Standalone API Die neuen Standalone Components ermöglichen Angular-Entwicklung ohne Ng-Modules. Wir zeigen, was das für eine bestehende Architektur heißt. Die neuesten Innovationen im Angular-Umfeld In den letzten Monaten hat Angular einige neue Features erhalten, die es ermöglichen, das Framework auf eine frische und leichtgewichtige Weise zu verwenden. Dieser Artikel zeigt, wie diese Neuerungen dazu beitragen, unsere Lösungen wartbarer zu gestalten. Angular-CLI Fast alle Angular-Projekte werden mit Angular-CLI aufgesetzt und gebaut. Angular-CLI bietet dabei eine Abstraktion über das zugrundeliegende Buildsystem. So konnte in der Vergangenheit zum Beispiel die Umstellung von SystemJS auf Webpack als Implementierungsdetail verborgen werden. Aktuell werden als Nachfolger von Webpack sowohl Vite aus dem Vue-Umfeld als auch esbuild untersucht. Bis zur tatsächlichen Umstellung ist es aber sicherlich noch mindestens ein Release hin. Doch auch in Angular-CLI 16 gibt es einige Neuerungen, einige davon betreffen auch die bereits angesprochenen Experimente. So wird der bestehende Support für das esbuild-basierte Build-Setup um Progress-Ausgaben erweitert. Außerdem kann der esbuild-DevServer nun z.B. SSL nutzen. Die Einbindung erfolgt, wie mit dem bestehenden Setup, per ng serve --ssl. Weiterhin können auch zusätzliche Scripte in den Build einbezogen werden. Das\n'slidetext': ''\n'from': 'index'\n'score': 121.77204132080078\n'normalizedScore': 1.2177204132080077\n'beforeDatePenaltyScore': 1.2177204132080077\n\n'documentId': '04721391f3f7580f0631b9d3'\n'chunk_id': '687a2101a98d5a30b3a34123'\n'access': 'granted'\n'part_number': 5\n'total_parts': 21\n'contentType': 'READ'\n'title': Angular 17: Neues Release des Web-Frameworks - Renaissance? Angular 17! - Alle Features im Überblick\n'parentName': iJS Magazin 2.2024\n'language': 'DE'\n'date': '2024-04-03T22:00:00.000Z'\n'abstract': Das beliebte JavaScript-Framework Angular veröffentlicht Version 17. Da bei Angular viel in Bewegung ist, kann manch einer da den Überblick verlieren. Wir stellen alle Features von Angular 17 vor.\n'parentId': 'c04db0163e3cb47407e78b63'\n'parentDescription': Kaum ein Softwareprojekt, das nicht in wesentlichen Teilen auf der JavaScript-Technologie basiert. Eine breite Unterstützung sowie, leistungsfähige Programmiersprachen, die Vielzahl moderner Tools, sowie ausgereifte Frameworks wie Angular, React, Vue.js oder Node.js machen den JavaScript-Werkzeugkasten zu einem Alleskönner. Das iJS Magazin informiert aktuell und umfassend über die wichtige und innovative Entwicklungen im JavaScript-Universum und bietet handfeste Praxisinformationen für Softwareentwickler und -architekten.\n'indexBrandName': ''\n'indexSeriesName': ''\n'author': 'Karsten Sitterberg'\n'chunkSource': 'text'\n'text': hinzuzufügen; der Methode “demoMethod()” wird der Metadaten-Eintrag “'demo'” mit dem Wert “'42'” hinzugefügt. Der Zugriff auf die Metadaten der Klasse erfolgt dann wieder mit Hilfe von “Symbol.metadata”. Listing 5: Beispiel Decorator-Factory in TypeScript function DemoMeta(key: string, value: string) { return (_: any, context: Context) => { context.metadata[key] = value; }; } @DemoMeta('entity', '3270') class DemoClass { @DemoMeta('demo', '42') demoMethod() {} } DemoClass[Symbol.metadata].entity; // '3270' DemoClass[Symbol.metadata].demo; // '42' Nach dem Blick auf TypeScript schauen wir als nächstes einmal auf das Angular CLI, mit dem typischerweise unter anderem der Build von Angular Anwendungen umgesetzt ist. Angular CLI in Angular 17 Zur Verwaltung von Angular-Projekten stellt das Angular-Team Entwickler:innen das Angular-CLI zur Verfügung. Ein wichtiger Schritt mit Angular-CLI 17 ist das Update des Angular-Build-Systems: Mit Angular-CLI 17 werden neu angelegte Projekte nun erstmals standardmäßig mit dem neuen, auf “esbuild” basierenden Buildsystem gebaut. Dies soll vor allem den Build beschleunigen und auch das Build-Resultat optimieren, bzw. kleiner machen. Außerdem verspricht der neue, auf “Vite” (gesprochen wie franz. “vite” = ”schnell”) basierende Live-Development-Server einen besseren, schnelleren Entwicklungszyklus zu ermöglichen. Beispielsweise ist es mit Vite möglich, Änderungen am globalen CSS anzuwenden, ohne dass dafür ein Live-Reload durchgeführt werden muss. Damit Apps in Zukunft komplett mit dem auf esbuild basierenden Build-System gebaut werden können, mussten noch einige Erweiterungen am esbuild-Builder vorgenommen werden: So wurde zum Beispiel grundlegende Unterstützung für die Überprüfung von Angular-CLI Bundle-Budgets hinzugefügt, die dem Entwickler helfen, die Größe der im Build generierten JavaScript- und CSS-Dateien im Auge zu behalten. Außerdem wurde grundlegender Support für den Build von WebWorkern hinzugefügt. Diese sind natürlich ein Browser-natives Feature, müssen aber trotzdem im Angular-Build berücksichtigt werden, da die Worker-Scripte typischerweise mit TypeScript geschrieben sind. Der alte Builder konnte dies bereits, nun zieht hier auch der neue esbuild-Builder nach. Server Side Rendering und SEO SPAs, wie sie mit Angular gebaut werden, haben einen Nachteil: Wenn die initiale Webseite geladen wurde, müssen zunächst einige Scripte geladen\n'slidetext': ''\n'from': 'index'\n'score': 121.5547866821289\n'normalizedScore': 1.2155478668212891\n'beforeDatePenaltyScore': 1.2155478668212891\n\n'documentId': '64ace3828d8056484c3534ab'\n'chunk_id': '687814c4bed6dcd41a99b01d'\n'access': 'granted'\n'part_number': 5\n'total_parts': 21\n'contentType': 'READ'\n'title': Angular 16 released - Alles zu neuen Features und Breaking Changes\n'parentName': iJS Magazin Band 27\n'language': 'DE'\n'date': '2023-04-06T00:00:00.000Z'\n'abstract': Wir geben einen Überblick zu allen wichtigen Infos zum Release von Angular 16. Alles zu Signals, der Angular-CLI und TypeScript in Angular 16 erfahren Sie hier.\n'parentId': '5093fc7a779ccfe852d8fe7b'\n'parentDescription': Kaum ein Softwareprojekt, das nicht in wesentlichen Teilen auf der JavaScript-Technologie basiert. Eine breite Unterstützung sowie, leistungsfähige Programmiersprachen, die Vielzahl moderner Tools, sowie ausgereifte Frameworks wie Angular, React, Vue.js oder Node.js machen den JavaScript-Werkzeugkasten zu einem Alleskönner. Das iJS Magazin informiert aktuell und umfassend über die wichtige und innovative Entwicklungen im JavaScript-Universum und bietet handfeste Praxisinformationen für Softwareentwickler und -architekten.\n'indexBrandName': ''\n'indexSeriesName': ''\n'author': 'Karsten Sitterberg'\n'chunkSource': 'text'\n'text': erweitert. Außerdem kann der esbuild-DevServer nun z.B. SSL nutzen. Die Einbindung erfolgt, wie mit dem bestehenden Setup, per ng serve --ssl. Weiterhin können auch zusätzliche Scripte in den Build einbezogen werden. Das ist zum Beispiel bei der Einbindung von globalen Scripten wie dem Google Tag Manager praktisch. Auch für das bestehende Buildsystem wurden einige Erweiterungen vorgenommen: So können neue Anwendungen als Standalone-Anwendungen (also ohne @NgModules) generiert werden. Dazu wird bei der Generierung der Anwendung das Flag --standalone mitgegeben. Um die Funktionalität von Standalone-Anwendungen an die Funktionalität von bisherigen Angular-Anwendungen anzugleichen, ist es nun auch möglich, Service-Worker und App-Shells für Standalone-Anwendungen per Schematics zu generieren. Breaking Changes in Angular-CLI 16 Mit der neuen Major-Version des Angular-CLI gibt es natürlich auch einige Breaking Changes: So wurde der Support für TypeScript 4.8 und Node.js 14 entfernt. Stattdessen wird als Standard TypeScript 5 verwendet, Node.js sollte in Version 16, 18 oder neuer vorliegen. Auch in Angular-CLI 16 werden einige veraltete oder überhole Zöpfe abgeschnitten: So wird der Angular-Compatibility-Compiler NGCC mit Angular-CLI 16 entfernt. NGCC war dafür zuständig, alte, noch auf der View-Engine beruhende Libraries so zu transformieren, dass diese kompatibel mit dem neuen Ivy-Compiler werden. Da die View-Engine schon seit Angular 12 deprecated ist, geht das Angular-Team davon aus, dass alle wesentlichen Libraries bereits entsprechend so angepasst sind, dass sie Ivy-kompatibel zur Verfügung gestellt werden. Das bedeutet, dass Projekte, die noch Libraries verwenden, die lediglich für die View-Engine gebaut sind, nicht auf Angular 16 umstellen können, solange die Libraries nicht angepasst wurden. Handelt es sich dabei um transitive Abhängigkeiten, ist einem dieses potentielle Problem unter Umständen gar nicht bewusst. Um eine Library für Ivy kompatibel zu machen, sollte die jeweilige Library auf eine aktuellere Angular-Version umgestellt werden (mindestens 12) und in der tsconfig.lib.prod.json der Compiler-Modus auf partial gestellt werden, siehe Listing 6. Da dadurch in der Regel keine negativen Auswirkungen entstehen, sollte dieser Modus definitiv aktiviert werden. Mit dieser Änderung ist die Transition von der alten View-Engine endgültig abgeschlossen. Durch den so wegfallenden Code\n'slidetext': ''\n'from': 'index'\n'score': 121.51598358154297\n'normalizedScore': 1.2151598358154296\n'beforeDatePenaltyScore': 1.2151598358154296\n\n'documentId': '64ace3828d8056484c3534ab'\n'chunk_id': '687814c6bed6dcd41a99b02c'\n'access': 'granted'\n'part_number': 20\n'total_parts': 21\n'contentType': 'READ'\n'title': Angular 16 released - Alles zu neuen Features und Breaking Changes\n'parentName': iJS Magazin Band 27\n'language': 'DE'\n'date': '2023-04-06T00:00:00.000Z'\n'abstract': Wir geben einen Überblick zu allen wichtigen Infos zum Release von Angular 16. Alles zu Signals, der Angular-CLI und TypeScript in Angular 16 erfahren Sie hier.\n'parentId': '5093fc7a779ccfe852d8fe7b'\n'parentDescription': Kaum ein Softwareprojekt, das nicht in wesentlichen Teilen auf der JavaScript-Technologie basiert. Eine breite Unterstützung sowie, leistungsfähige Programmiersprachen, die Vielzahl moderner Tools, sowie ausgereifte Frameworks wie Angular, React, Vue.js oder Node.js machen den JavaScript-Werkzeugkasten zu einem Alleskönner. Das iJS Magazin informiert aktuell und umfassend über die wichtige und innovative Entwicklungen im JavaScript-Universum und bietet handfeste Praxisinformationen für Softwareentwickler und -architekten.\n'indexBrandName': ''\n'indexSeriesName': ''\n'author': 'Karsten Sitterberg'\n'chunkSource': 'text'\n'text': das Ökosystem auch bei den anderen Frameworks immens umfangreich ist. Auf der anderen Seite stehen neue Entwicklungen, wie Qwik, das von Ex-Angular Entwicklern mitgegründet wurde. Was die wirklichen Gründe hinter allen Entscheidungen sind, kann man nur spekulieren. Da die Bi-Weekly-Notes September 2022 eingestellt wurden, scheint die Motivation für Transparenz auch nicht mehr auf dem höchsten Stand zu sein. Ehrlicherweise muss man jedoch auch sagen, dass der Informationsgehalt zunehmend verschwindend gering wurde. Doch auch die RFC-Diskussionen wirken ein wenig wie diplomatisches Taktieren: Weniger als drei Wochen vor dem ersten Release Candidate von Angular 16 wurden die RFC-Diskussionen zur Signal-API erst gestartet, Kritik wurde “aufmerksam beobachtet”. (https://github.com/angular/angular/discussions/49989) Vorher gab es entsprechende interne Diskussionen um Design, allerdings stellt sich dann die Frage, wieso dies nicht transparent umgesetzt wurde. Es erscheint insgesamt so, dass Angular sich dem politischen Druck von aufstrebenden Frameworks ausgesetzt sieht. Aus ähnlichem Grund ist auch eine Investition in Server-side Rendering erkennbar. Sicherlich auch, um bei den Google-Lighthouse-Metriken gut dazustehen. Auf der anderen Seite möchte man neue Nutzer gewinnen und den Einstieg leichter machen. Angular glänzte bisher als Fullstack-Framework für absehbar komplexe und große Anwendungen mit hervorragender Wartbarkeit. Es bleibt zu hoffen, dass nicht gerade diese Kerngruppe von Enterprise-Entwickler:innen durch massiven Aufwand bei Migrationen auf neuere Angular Versionen so vor den Kopf gestoßen wird, dass auch diese sich überlegen, neue Projekte nicht mehr mit Angular umzusetzen. Was Migrationen auf neue Versionen angeht, müssen Aufwand und Nutzen im richtigen Verhältnis stehen. Ein Blick auf Dinge wie IPv6, Python 3 und die vielen Firmen, die noch Java 11, oder sogar darunter einsetzen, zeigt noch einmal, wie hervorragend Angular in der Vergangenheit da stand. Es bleibt zu hoffen, dass Angular den Blick auch auf diese Zielgruppe gerichtet hält und den Fokus nicht verliert. Davon abgesehen wirken die großen Schritte in Richtung Signal-API und Zone.js als optionale Implementierung der Change Detection zukunftsweisend, fast schon wie die heimliche Vision einer neuen Generation Angular. Dasselbe gilt auch für das\n'slidetext': ''\n'from': 'index'\n'score': 121.51428985595703\n'normalizedScore': 1.2151428985595703\n'beforeDatePenaltyScore': 1.2151428985595703\n\n'documentId': '04721391f3f7580f0631b9d3'\n'chunk_id': '687a2102a98d5a30b3a34138'\n'access': 'granted'\n'part_number': 15\n'total_parts': 21\n'contentType': 'READ'\n'title': Angular 17: Neues Release des Web-Frameworks - Renaissance? Angular 17! - Alle Features im Überblick\n'parentName': iJS Magazin 2.2024\n'language': 'DE'\n'date': '2024-04-03T22:00:00.000Z'\n'abstract': Das beliebte JavaScript-Framework Angular veröffentlicht Version 17. Da bei Angular viel in Bewegung ist, kann manch einer da den Überblick verlieren. Wir stellen alle Features von Angular 17 vor.\n'parentId': 'c04db0163e3cb47407e78b63'\n'parentDescription': Kaum ein Softwareprojekt, das nicht in wesentlichen Teilen auf der JavaScript-Technologie basiert. Eine breite Unterstützung sowie, leistungsfähige Programmiersprachen, die Vielzahl moderner Tools, sowie ausgereifte Frameworks wie Angular, React, Vue.js oder Node.js machen den JavaScript-Werkzeugkasten zu einem Alleskönner. Das iJS Magazin informiert aktuell und umfassend über die wichtige und innovative Entwicklungen im JavaScript-Universum und bietet handfeste Praxisinformationen für Softwareentwickler und -architekten.\n'indexBrandName': ''\n'indexSeriesName': ''\n'author': 'Karsten Sitterberg'\n'chunkSource': 'text'\n'text': lediglich notwendig, über das Trigger-Element zu hovern. Listing 15: Möglichkeiten, Defer-Inhalte basierend auf einem Interaktions-Trigger zu laden @defer (on interaction(trigger)) {  } Trigger @defer (on interaction) {  } @placeholder { Trigger } @defer (on hover(trigger)) {  } Trigger Statt direkter Nutzer-Interaktion ist es auch möglich, einen Defer-Block zu laden, sobald ein anderes (Trigger-)Element in den sichtbaren Viewport kommt, z.B. indem der Nutzer zum Trigger-Element scrollt. Dies ist in Listing 16 dargestellt. Statt des externen Triggerelements kann auch wieder der Placeholder als implizites Triggerelement verwendet werden. Listing 16: Viewport-Trigger dienen dazu, Inhalte zu laden, wenn das Trigger-Element sichtbar (im Viewport) ist @defer (on viewport(trigger)) {  } Content Zu guter Letzt kann ein Defer-Block auch durch einen zeitlichen Trigger nachgeladen werden. Diesem Trigger muss die gewünschte Dauer mitgegeben werden, nach der die Komponente geladen werden soll. In Listing 17 wird beispielsweise angegeben, dass der Defer-Block nach 1,5 Sekunden anfangen soll, die Komponente ““ zu laden. Unabhängig von der verwendeten “on”-Bedingung kann dem “@loading”-Block eine “after”- und/oder eine “minimum”-Dauer mitgegeben werden. Die “after”-Angabe sorgt in Listing 17 dafür, dass der Loading-State frühestens nach 100 Millisekunden dargestellt wird. Die “minimum”-Angabe sorgt dafür, dass der Loading-State mindestens 150 Millisekunden angezeigt wird. Analog dazu sorgt die “minimum”-Angabe beim “@placeholder” dafür, dass der Placeholder mindestens 150 Millisekunden angezeigt wird, bevor der Loading-State angezeigt wird. Listing 17: Timer-Bedingung und Minimalangaben @defer (on timer(1500ms)) {  } @loading (after 100ms; minimum 150ms) { \n\n...Loading... } @placeholder (minimum 100ms) { Placeholder } Die neue Defer-Syntax ermöglicht direkt auch eine Optimierung, denn optional kann in der Defer-Bedingung auch ein “prefetch”-Statement angegeben werden. Die Logik, die nach dem Prefetch-Statement angegeben wird, entspricht der oben beschriebenen Defer-Logik. In Listing 18 oben soll zum Beispiel eine Komponente erst dann angezeigt werden, wenn der Zustand der Variablen “isVisible” auf “true” wechselt. Damit\n'slidetext': ''\n'from': 'index'\n'score': 120.97447967529297\n'normalizedScore': 1.2097447967529298\n'beforeDatePenaltyScore': 1.2097447967529298\n\n'documentId': 'eba6f5d083b14f4d8d53d87a'\n'chunk_id': '687ad1bdeb1b160a4cabaecf'\n'access': 'granted'\n'part_number': 9\n'total_parts': 9\n'contentType': 'READ'\n'title': Was ist neu in Angular 16? Signals, Hydration, esbuild und mehr - Kolumne: Enterprise Angular\n'parentName': Windows Developer 7.2023\n'language': 'DE'\n'date': '2023-06-13T00:00:00.000Z'\n'abstract': Mit Angular 16 kommen gleich zwei große Neuerungen: Signals und Non-destructive Hydration. Außerdem gibt es zahlreiche Abrundungen, die das Arbeiten mit dem Framework vereinfachen. In diesem Artikel gehe ich anhand von Beispielen auf die wichtigsten Neuerungen ein. Den Quellcode findet man im Branch ng16-features auf GitHub [1].\n'parentId': '8d98b5cda2e54cc436ac50d8'\n'parentDescription': Windows Developer informiert umfassend und herstellerneutral über die neuen Trends und Möglichkeiten der Software- und Systementwicklung rund um Microsoft- und Web-Technologien. Von der klassischen .NET-Entwicklung über .NET Core bis hin zu neuen Technologien wie Windows 10, Microsoft Azure und der ganzen Bandbreite der aktuellen Web-, Phone- und Tabletentwicklung für Android und iOS mit Xamarin und unterschiedlichen JavaScript-Frameworks. Professionelle Entwickler und IT-Entscheider erhalten genau die Informationen, die sie für den erfolgreichen Einsatz von unternehmensorientierten Lösungen benötigen.\n'indexBrandName': ''\n'indexSeriesName': ''\n'author': 'Manfred Steyer'\n'chunkSource': 'text'\n'text': unterstützen wird. Zusammenfassung Mit Version 16 setzt das Angular-Team seine Bestrebungen fort, das Framework moderner und gleichzeitig leichtgewichtiger zu machen. Signals läuten eine neue Ära der zielgerichteten Change Detection ein und mit Non-destructive Hydration macht Angular den ersten Schritt hin zu modernen Hydration-Szenarien, die gerade für öffentliche Weblösungen wichtig sind. Die Unterstützung für verpflichtende Inputs, das Binden von Routingparametern sowie die neue DestroyRef bringen außerdem Komfort für die Entwicklung. Daneben erlaubt das CLI nun das Erzeugen von Anwendungen, die auf Standalone Components basieren, und der noch experimentelle esbuild-basierte Builder beschleunigt das Bauen von Angular-Anwendungen erheblich. Links & Literatur [1] https://github.com/manfredsteyer/standalone-example-cli Mehr zum Thema Angular 16 © gdainti/Shutterstock.com Angular 16 released Angular 16 setzt in vielerlei Hinsicht neue Akzente. Das wird nicht jedem gefallen. Ob das Angular-Team - und dahinter Google - hier kluge Entscheidungen trifft, wird vermutlich erst die Zeit zeigen. Um sich selbst ein Bild zu machen, betrachten wir alle wichtigen Änderungen zu TypeScript in Angular, die Angular-CLI und besonders Signals von Angular 16 im folgenden Beitrag.\n'slidetext': ''\n'from': 'index'\n'score': 120.9456787109375\n'normalizedScore': 1.209456787109375\n'beforeDatePenaltyScore': 1.209456787109375\n\n'documentId': '04721391f3f7580f0631b9d3'\n'chunk_id': '687a2102a98d5a30b3a34135'\n'access': 'granted'\n'part_number': 13\n'total_parts': 21\n'contentType': 'READ'\n'title': Angular 17: Neues Release des Web-Frameworks - Renaissance? Angular 17! - Alle Features im Überblick\n'parentName': iJS Magazin 2.2024\n'language': 'DE'\n'date': '2024-04-03T22:00:00.000Z'\n'abstract': Das beliebte JavaScript-Framework Angular veröffentlicht Version 17. Da bei Angular viel in Bewegung ist, kann manch einer da den Überblick verlieren. Wir stellen alle Features von Angular 17 vor.\n'parentId': 'c04db0163e3cb47407e78b63'\n'parentDescription': Kaum ein Softwareprojekt, das nicht in wesentlichen Teilen auf der JavaScript-Technologie basiert. Eine breite Unterstützung sowie, leistungsfähige Programmiersprachen, die Vielzahl moderner Tools, sowie ausgereifte Frameworks wie Angular, React, Vue.js oder Node.js machen den JavaScript-Werkzeugkasten zu einem Alleskönner. Das iJS Magazin informiert aktuell und umfassend über die wichtige und innovative Entwicklungen im JavaScript-Universum und bietet handfeste Praxisinformationen für Softwareentwickler und -architekten.\n'indexBrandName': ''\n'indexSeriesName': ''\n'author': 'Karsten Sitterberg'\n'chunkSource': 'text'\n'text': er weggelassen wird, beginnt das Lazy Loading, sobald die äußere Komponente gerendert ist. Ansonsten kann der “when”-Ausdruck verwendet werden, um den Inhalt des “@defer”-Block erst zu laden, wenn eine bestimmte Bedingung eintritt. Im einfachsten Fall, wie in Listing 13, kann ein boolescher Ausdruck (“isLoaded”) abgefragt werden. Neben dem “@defer”-Block sind in Listing 13 noch weitere, optionale Blöcke gezeigt. Innerhalb “@loading” kann ein Template angegeben werden, das den “Ladezustand” darstellt, etwa eine Lade-Spinner. Der Ladezustand wird ab dem Moment angezeigt, ab dem die boolesche Bedingung (hier “isLoading”) auf “true” wechselt. Wenn die Komponente “” geladen und gerendert ist, wird der Ladezustand automatisch entfernt. Speziell beim Ladezustand sollten Entwickler:innen natürlich vorsicht walten lassen, um nicht in ein oder mehrere UX-Fettnäpfchen zu treten: Für Nutzer:innen ist ein großer Spinner für die komplette Seite vermutlich einfacher zu “verdauen” als 20 gleichzeitig aktive Spinner, die sich über die ganze Seite und über alle Einzelkomponenten verteilen. Weiterhin sollte beim Einsatz von Ladezuständen darauf geachtet werden, dass die Seite durch stückchenweises Nachladen kleinster Seitenelemente nicht dauerhaft “flackert” bzw. der eigentliche Inhalt nicht andauernd hin- und her verschoben wird. Der Inhalt von “@placeholder” wird in diesem Fall solange angezeigt, bis die Bedingung “isLoaded” das erste Mal den Wert “false” hat. Ein wichtiger Hinweis in diesem Kontext: “@defer” funktioniert nicht wie “@if” in dem Sinne, dass man zwischen den Werten vor- und zurückschalten kann. Das bedeutet: Sobald “isLoaded” den Wert “true” hat, wird die lazy geladene Komponente angezeigt. Selbst wenn “isLoaded” manuell auf “false” zurückgesetzt wird, wird weiterhin der Inhalt von “@defer” angezeigt und nicht etwa auf den Inhalt von “@placeholder” zurückgewechselt. Falls es beim Nachladen des Inhaltes von “@defer” zu einem Fehler kommt, z.B. wegen eines Netzwerkabbruchs, wird der Inhalt des “@error”-Blocks dargestellt. Listing 13: Beispiel für den neuen “@defer”-Ausdruck in Angular 17 @defer (when isLoaded) {  } @loading { \n\nLoading... }\n'slidetext': ''\n'from': 'index'\n'score': 120.72901916503906\n'normalizedScore': 1.2072901916503906\n'beforeDatePenaltyScore': 1.2072901916503906\n\n'documentId': '04721391f3f7580f0631b9d3'\n'chunk_id': '687a2103a98d5a30b3a34144'\n'access': 'granted'\n'part_number': 20\n'total_parts': 21\n'contentType': 'READ'\n'title': Angular 17: Neues Release des Web-Frameworks - Renaissance? Angular 17! - Alle Features im Überblick\n'parentName': iJS Magazin 2.2024\n'language': 'DE'\n'date': '2024-04-03T22:00:00.000Z'\n'abstract': Das beliebte JavaScript-Framework Angular veröffentlicht Version 17. Da bei Angular viel in Bewegung ist, kann manch einer da den Überblick verlieren. Wir stellen alle Features von Angular 17 vor.\n'parentId': 'c04db0163e3cb47407e78b63'\n'parentDescription': Kaum ein Softwareprojekt, das nicht in wesentlichen Teilen auf der JavaScript-Technologie basiert. Eine breite Unterstützung sowie, leistungsfähige Programmiersprachen, die Vielzahl moderner Tools, sowie ausgereifte Frameworks wie Angular, React, Vue.js oder Node.js machen den JavaScript-Werkzeugkasten zu einem Alleskönner. Das iJS Magazin informiert aktuell und umfassend über die wichtige und innovative Entwicklungen im JavaScript-Universum und bietet handfeste Praxisinformationen für Softwareentwickler und -architekten.\n'indexBrandName': ''\n'indexSeriesName': ''\n'author': 'Karsten Sitterberg'\n'chunkSource': 'text'\n'text': mit langfristiger Investitionssicherung? Schwinded Angular oder schafft es das Framework neue Zielgruppen zu erobern, ohne bestehenden Teams und Entwickler:innen vor den Kopf zu stoßen? Oder plant man gar, diese bewusst zu opfern, um sich moderner aufzustellen? Im Moment erneuert sich Angular so schnell, dass es fast den Anschein eines neuen Frameworks macht. Spannend wird dabei, wie lange die alten Konzepte weiter unterstützt werden. Denn mit einer ng-upgrade-Transformation des Quellcodes ist es ja nicht getan, sondern es geht auch um den kognitiven Aufwand bei den Nutzer:innen: Es gilt neue Konzepte zu lernen, mit alten abzuschließen. Das reduziert zumindest temporär die Produktivität. Es stellt sich auch die Frage, inwieweit alte und neue Konzepte durch 3rd-Party-Bibliotheken unterstützt werden. Leider tut sich das Angular Team auch mit der, sagen wir mal optimierbaren, Kommunikation, nicht unbedingt einen Gefallen bei den bestehenden Nutzer:innen. Als Sorge schwingt bei den Nutzer:innen natürlich auch mit, dass Google als Hauptsponsor von Angular in den letzten Jahren nicht gerade zimperlich war, wenn es darum ging, Produkte abzukündigen. Dabei machen die neuen Features durchaus Sinn und ermöglichen neuartige Architekturen und noch performantere Anwendungen im Frontend. Auch ist die Developer-Experience erheblich besser, fehlten bisher Möglichkeiten if-elseif-else auszudrücken. Schaut man sich jedoch das Entwicklungstempo von Angular in den letzten Versionen an, ist das gerade für Enterprise-Kund:innen und große Projekte, die langfristig gewartet werden sollen, ein extrem hohes Tempo. Es wäre nicht verwunderlich, wenn sich hier einige Nutzer:innen zumindest schwer tun, mitzuhalten. Hier besteht das Risiko, dass Angular trotz der Renaissance nicht genug Traktion bei neuen Nutzer:innen aufbaut und gleichzeitig Frustration und Sorge um getätigte Investitionen bei bestehenden Nutzer:innen erzeugt. Hier könnte sicherlich durch etwas feinfühligere Kommunikation und sorgfältige Abwägung von Risiko und Nutzen durch das Angular-Team ein besseres Vertrauensverhältnis geschaffen werden. Ein hervorragendes Beispiel ist hier Java: Innovation findet statt, jedoch mit entsprechend viel Vorlauf und maximal möglicher Kompatibilität selbst zu sehr alten Codebasen. Nicht umsonst ist\n'slidetext': ''\n'from': 'index'\n'score': 120.5577163696289\n'normalizedScore': 1.205577163696289\n'beforeDatePenaltyScore': 1.205577163696289\n\n'documentId': '64ace3828d8056484c3534ab'\n'chunk_id': '687814c5bed6dcd41a99b025'\n'access': 'granted'\n'part_number': 13\n'total_parts': 21\n'contentType': 'READ'\n'title': Angular 16 released - Alles zu neuen Features und Breaking Changes\n'parentName': iJS Magazin Band 27\n'language': 'DE'\n'date': '2023-04-06T00:00:00.000Z'\n'abstract': Wir geben einen Überblick zu allen wichtigen Infos zum Release von Angular 16. Alles zu Signals, der Angular-CLI und TypeScript in Angular 16 erfahren Sie hier.\n'parentId': '5093fc7a779ccfe852d8fe7b'\n'parentDescription': Kaum ein Softwareprojekt, das nicht in wesentlichen Teilen auf der JavaScript-Technologie basiert. Eine breite Unterstützung sowie, leistungsfähige Programmiersprachen, die Vielzahl moderner Tools, sowie ausgereifte Frameworks wie Angular, React, Vue.js oder Node.js machen den JavaScript-Werkzeugkasten zu einem Alleskönner. Das iJS Magazin informiert aktuell und umfassend über die wichtige und innovative Entwicklungen im JavaScript-Universum und bietet handfeste Praxisinformationen für Softwareentwickler und -architekten.\n'indexBrandName': ''\n'indexSeriesName': ''\n'author': 'Karsten Sitterberg'\n'chunkSource': 'text'\n'text': Falls für die Styles eine CSP-Policy style-src 'self' oder gar 'strict-dynamic' verwendet wird, hat dies die Konsequenz, dass die Komponenten-Styles in Angular-Anwendungen nicht funktioniert haben. Das liegt daran, dass der Browser bei einer solchen Einstellung keine Inline-Styles erlaubt hat, die Angular für die Komponenten-Styles nutzt. In einem solchen Fall musste dann die CSP-Direktive unsafe-inline aktiviert werden, die jedoch als potentiell unsicher gilt. Mit Angular 16 ist es nun möglich, das Injection-Token CSP_NONCE zu nutzen, um einen sogenannten CSP-Nonce zu setzen, der dann von Angular an die Inline-Styles angefügt wird. Falls die index.html zur Produktionszeit durch den ausliefernden Server noch modifiziert werden kann, so kann statt des Injection-Tokens einfach das Attribut ngCspNonce auf dem App-Element gesetzt werden, siehe Listing 17. Es ist dabei explizit wichtig, dass der Wert von XYZ nicht irgendein fixer Wert ist, sondern jedesmal, wenn die index.html ausgeliefert wird, neu berechnet werden muss. Ein fixer Nonce hätte ähnliche Security-Eigenschaften wie die CSP-Direktive unsafe-inline. Zusammen mit dem Nonce-Property in der index.html muss der Nonce auch in die CSP-Direktive aufgenommen werden, z.B. auf diese Art: style-src 'nonce-XYZ' 'self' oder etwas strikter style-src 'nonce-XYZ' 'strict-dynamic'. Dieses Feature wurde in Zusammenarbeit zwischen dem Angular-Core-, dem Angular-Material- und dem Angular-CLI-Team entwickelt, sodass auch diese Pakete den neuen Mechanismus entsprechend unterstützen. Listing 17: Dynamische Konfiguration des CSP-Nonce-Wertes in der index.html  Als weiteres kleines Feature ist die DestroyRef hinzugekommen. Diese kann wie ein Service injected werden und erlaubt es, Logik per Callback zu registrieren, die beim OnDestroy der Komponente ausgeführt wird. Beispielsweise können auf diese Art und Weise Ressourcen freigegeben werden, ohne den ngOnDestroy()-Lifecycle-Hook implementieren zu müssen, siehe auch Listing 18. Um die Destroy-Logik wieder zu entfernen, z.B. weil eine Ressource bereits aus anderem Grund wieder freigegeben wurde, kann die unregisterFn() aufgerufen werden. Dann würde in diesem Beispiel doSomethingOnDestroy() nicht mehr aufgerufen. Neben der DestroyRef wurde noch ein neues Paket @angular/rxjs-interop eingeführt, das vor allem mit\n'slidetext': ''\n'from': 'index'\n'score': 120.47567749023438\n'normalizedScore': 1.2047567749023438\n'beforeDatePenaltyScore': 1.2047567749023438\n\n'documentId': '64ace3828d8056484c3534ab'\n'chunk_id': '687814c5bed6dcd41a99b021'\n'access': 'granted'\n'part_number': 9\n'total_parts': 21\n'contentType': 'READ'\n'title': Angular 16 released - Alles zu neuen Features und Breaking Changes\n'parentName': iJS Magazin Band 27\n'language': 'DE'\n'date': '2023-04-06T00:00:00.000Z'\n'abstract': Wir geben einen Überblick zu allen wichtigen Infos zum Release von Angular 16. Alles zu Signals, der Angular-CLI und TypeScript in Angular 16 erfahren Sie hier.\n'parentId': '5093fc7a779ccfe852d8fe7b'\n'parentDescription': Kaum ein Softwareprojekt, das nicht in wesentlichen Teilen auf der JavaScript-Technologie basiert. Eine breite Unterstützung sowie, leistungsfähige Programmiersprachen, die Vielzahl moderner Tools, sowie ausgereifte Frameworks wie Angular, React, Vue.js oder Node.js machen den JavaScript-Werkzeugkasten zu einem Alleskönner. Das iJS Magazin informiert aktuell und umfassend über die wichtige und innovative Entwicklungen im JavaScript-Universum und bietet handfeste Praxisinformationen für Softwareentwickler und -architekten.\n'indexBrandName': ''\n'indexSeriesName': ''\n'author': 'Karsten Sitterberg'\n'chunkSource': 'text'\n'text': ablösen sollen. Angular nutzt die TypeScript Decorators, um damit Metainformationen, unter anderem für das Dependency-Injection-System, bereitzustellen. Die Informationen können für Klassen, aber auch Methodenparameter oder den Konstruktor hinterlegt werden. Die finalen Decorators werden jedoch nur an Typen unterstützt, damit können @Component, @Directive, @Pipe, @Injectable und @NgModule mit dem neuen Standard umgesetzt werden. Konstruktor-Parameter-Decorators, wie z.B. @Inject(), @Host(), @Optional() und dergleichen, die zur Konfiguration der Dependency-Injection genutzt werden können, sind mit der neuen Spezifikation noch nicht möglich. Da es noch nicht sicher ist, ob Parameter-Decorators in die ECMAScript- und TypeScript-Spezifikation aufgenommen werden, nutzt Angular im Standard weiterhin die experimentalDecorators. Wenn sowohl die TypeScript 5-Decorators als auch die DI-Konfigurationen genutzt werden sollen, so muss die mit Angular 14 eingeführte inject()-Funktion genutzt werden, beispielhaft in Listing 9 dargestellt. Listing 9: inject()-Funktion mit Flags @Component({}) class DemoComponent { readonly demoService = inject(DemoService, { optional: true, host: true }); } Wie bereits oben erwähnt, sind die Router-Guard- und -Resolver-Interfaces deprecated. Daher werden alle Referenzen auf diese Interfaces beim Upgrade auf Angular 16 durch eine automatische Migration gelöscht. Der Guard als solches kann aber zunächst weiter wie gewohnt verwendet werden, da TypeScript nun die Signatur der Guard-Funktion selbst prüft. Beispielhaft wird in Listing 10 ein CanActivate-Guard gezeigt. Dessen canActivate()-Methode muss mit dem Typen CanActivateFn übereinstimmen, damit der Guard als ein CanActivate-Guard verwendet werden kann. In Listing 10 ist außerdem auch gezeigt, wie ein funktionaler CanActivate-Guard im Prinzip aussieht. Hier ist zu beachten, dass es auch in funktionalen Guards möglich ist, Services zu injecten. Dazu wird aber die inject()-Funktion verwendet werden müssen, siehe ebenfalls Listing 10. In Zukunft sollen Guards nur noch funktional geschrieben werden, allerdings bleibt es auch möglich, Guards und Resolver klassenbasiert zu schreiben. Dann muss allerdings in zukünftigen Versionen von Angular dieser Guard umgewandelt werden. Diese Umwandlung kann in der Routen-Definition selbst geschehen, die Umwandlungsfunktionen stellt Angular zur Verfügung. In Listing 11 ist beispielhaft die Umwandlungsfunktion mapToCanActivate() dargestellt, mit der ein Array von klassenbasierten CanActivate-Guards in funktionale\n'slidetext': ''\n'from': 'index'\n'score': 120.46727752685547\n'normalizedScore': 1.2046727752685547\n'beforeDatePenaltyScore': 1.2046727752685547\n\n'documentId': '8b35e3d0070110b78d6c9434'\n'chunk_id': '687a2210d92aed38f5a4a5b5'\n'access': 'granted'\n'part_number': 4\n'total_parts': 9\n'contentType': 'READ'\n'title': Angular: Signals, Standalone, SSR - So bauen Sie Angular-Apps der Zukunft\n'parentName': Windows Developer 7.2024\n'language': 'DE'\n'date': '2024-06-10T22:00:00.000Z'\n'abstract': Mit der Veröffentlichung der 16. Hauptversion von Angular läutete das Angular-Team die „Angular Renaissance“ ein. Wörtlich übersetzt bedeutet das nichts Geringeres als die Wiedergeburt von Googles SPA-Framework - eine treffende Bezeichnung, denn Angular-Codebasen werden sich nachhaltig verändern. Der Unterschied zwischen Angular-2- und Angular-17-Code ist mit bloßem Auge erkennbar.\n'parentId': 'b662818c73a937b86282ae99'\n'parentDescription': Windows Developer informiert umfassend und herstellerneutral über die neuen Trends und Möglichkeiten der Software- und Systementwicklung rund um Microsoft- und Web-Technologien. Von der klassischen .NET-Entwicklung über .NET Core bis hin zu neuen Technologien wie Windows 10, Microsoft Azure und der ganzen Bandbreite der aktuellen Web-, Phone- und Tabletentwicklung für Android und iOS mit Xamarin und unterschiedlichen JavaScript-Frameworks. Professionelle Entwickler und IT-Entscheider erhalten genau die Informationen, die sie für den erfolgreichen Einsatz von unternehmensorientierten Lösungen benötigen.\n'indexBrandName': ''\n'indexSeriesName': ''\n'author': 'Christian Liebel'\n'chunkSource': 'text'\n'text': dieser auch erst nachträglich (asynchron) emittiert werden. Komplexe Konstrukte, die sich bei RxJS hinter einem einfachen Operator verbergen wie debounceTime, also zum Ignorieren von Änderungen während eines bestimmten Zeitraums etwa für Type-ahead-Komponenten, lassen sich mit Signals nicht so einfach abdecken. Signals sind interoperabel. Ein Observable lässt sich über die Funktion toSignal() in ein Signal verwandeln. Dabei wird undefined als Initialwert gewählt, wobei auch ein anderer Wert angegeben werden kann. Ein Signal lässt sich über die Methode toObservable() in ein Observable konvertieren: counter$ = interval(1000); counter = toSignal(this.counter$, {initialValue: 0}); counter = signal(0); counter$ = toObservable(this.counter); Signal-basierte Komponenten Mit den Nebenversionen von Angular 17 wurde schrittweise die Unterstützung für Signal-basierte Komponenten hinzugefügt. Bei diesem Unterfangen werden die traditionellen Input- und Output-Felder, die bislang durch einen gleichnamigen TypeScript-Dekorator ausgezeichnet waren, durch Signals ersetzt [2]: - So wurde mit Angular 17.1 die Methode input() hinzugefügt. Über diese Methode werden künftig Input-Felder deklariert, im Gegensatz zum @Input()-Dekorator. Das Feld enthält danach ein lesbares Signal. - Mit Angular 17.2 wurde die Methode model() hinzugefügt, mit der sich Two-way Bindings definieren lassen. Das Feld enthält danach ein schreibbares Signal. Hierfür war in Angular bisher ein Input-Feld mit um Change ergänzten Output-Feld erforderlich, für das Input ngModel also das Output ngModelChange. - Mit Angular 17.3 kam schließlich die Methode output() hinzu, die die klassischen auf dem EventEmitter basierenden Outputs ersetzt. Wie gehabt werden Ereignisse nach außen durch den Aufruf der Methode emit() ausgelöst. Für input() und model(), bei denen ein Initialwert angegeben werden muss, gibt es jeweils noch eine required()-Methode auf den jeweiligen Funktionen. Bei dieser entfällt die Angabe des Initialwerts und Angular stellt mit Hilfe des Template-Compilers sicher, dass Entwickler:innen im Template einen Initialwert angeben. Vergleichbar zur signal()-Methode kann bei allen hier vorgestellten Methoden per generischem Typparameter angegeben werden, mit welchen Typen zur Laufzeit gearbeitet wird. Eine Übersicht der Verwendung der verschiedenen Methoden zeigt Listing 1. Listing 1 @Component({ selector: 'my-component', template: '...' }) export class\n'slidetext': ''\n'from': 'index'\n'score': 120.45947265625\n'normalizedScore': 1.2045947265625\n'beforeDatePenaltyScore': 1.2045947265625\n\n'documentId': '8b35e3d0070110b78d6c9434'\n'chunk_id': '687a2211d92aed38f5a4a5b6'\n'access': 'granted'\n'part_number': 5\n'total_parts': 9\n'contentType': 'READ'\n'title': Angular: Signals, Standalone, SSR - So bauen Sie Angular-Apps der Zukunft\n'parentName': Windows Developer 7.2024\n'language': 'DE'\n'date': '2024-06-10T22:00:00.000Z'\n'abstract': Mit der Veröffentlichung der 16. Hauptversion von Angular läutete das Angular-Team die „Angular Renaissance“ ein. Wörtlich übersetzt bedeutet das nichts Geringeres als die Wiedergeburt von Googles SPA-Framework - eine treffende Bezeichnung, denn Angular-Codebasen werden sich nachhaltig verändern. Der Unterschied zwischen Angular-2- und Angular-17-Code ist mit bloßem Auge erkennbar.\n'parentId': 'b662818c73a937b86282ae99'\n'parentDescription': Windows Developer informiert umfassend und herstellerneutral über die neuen Trends und Möglichkeiten der Software- und Systementwicklung rund um Microsoft- und Web-Technologien. Von der klassischen .NET-Entwicklung über .NET Core bis hin zu neuen Technologien wie Windows 10, Microsoft Azure und der ganzen Bandbreite der aktuellen Web-, Phone- und Tabletentwicklung für Android und iOS mit Xamarin und unterschiedlichen JavaScript-Frameworks. Professionelle Entwickler und IT-Entscheider erhalten genau die Informationen, die sie für den erfolgreichen Einsatz von unternehmensorientierten Lösungen benötigen.\n'indexBrandName': ''\n'indexSeriesName': ''\n'author': 'Christian Liebel'\n'chunkSource': 'text'\n'text': Methoden per generischem Typparameter angegeben werden, mit welchen Typen zur Laufzeit gearbeitet wird. Eine Übersicht der Verwendung der verschiedenen Methoden zeigt Listing 1. Listing 1 @Component({ selector: 'my-component', template: '...' }) export class MyComponent { protected readonly name = input.required(); protected readonly address = model('My address'); protected readonly delete = output(); } Im Template ergibt sich durch die Verwendung der Signal-basierten Methoden kein sichtbarer Unterschied:  Mit Angular 17.2 kamen außerdem noch die neuen Signal-Querys dazu, welche die Dekoratoren @ViewChild(), @ViewChildren(), @ContentChild() und @ContentChildren() ersetzen [3]. Die Methoden sind analog benannt, geben aber Signals zurück (z. B. viewChild()). Der Vorteil der Signal-Querys ist das klarere Timing, wenn sich Inhalte der View bzw. des Contents ändern. Wichtig anzumerken ist dabei, dass sich alle diese Methoden noch in der Developer Preview befinden. NgRx Signals: State Management auf Signal-Basis Auch das Angular-Ökosystem hat in der Zwischenzeit nachgezogen: Das State-Management-Framework NgRx gibt es nun auch in einer auf Signals basierenden Variante, die sich im Paket @ngrx/signals befindet. Das Paket kann den globalen Store, lokalen Component Store sowie den Entity Adapter ersetzen. Ebenso werden Interop-Funktionen zur Integration von Signal-Stores mit RxJS zur Verfügung gestellt. An Signals führt kein Weg vorbei Zusammenfassend lässt sich sagen, dass ab sofort für sämtliche Bindings an die Oberfläche nur noch Signals verwendet werden sollten. Sie sind nicht nur einfacher zu verwenden, sondern können die Performance von Angular-Anwendungen in Zukunft steigern. Wo Signals ausreichen, sollten nur diese verwendet werden – wo die Power von RxJS benötigt wird, können beide Ansätze gemischt werden. Das geht auch schrittweise nur für neue Komponenten, da Signals interoperabel verwendet werden können. Wenn es die Zeit im Projekt zulässt, sollten auch ältere Komponenten migriert werden. Dabei ist zumindest derzeit keine Eile geboten: RxJS und die übrigen traditionellen Wege in Angular werden in absehbarer Zeit nicht verschwinden, zumal manche Signal-APIs noch in der Entwicklervorschau sind. Die Migration auf Signals dürfte in den allermeisten Fällen ein manueller Aufwand sein. Es gibt im Angular-Repository zumindest ein Ticket zur\n'slidetext': ''\n'from': 'index'\n'score': 120.35673522949219\n'normalizedScore': 1.203567352294922\n'beforeDatePenaltyScore': 1.203567352294922\n\n'documentId': '04721391f3f7580f0631b9d3'\n'chunk_id': '687a2103a98d5a30b3a34145'\n'access': 'granted'\n'part_number': 21\n'total_parts': 21\n'contentType': 'READ'\n'title': Angular 17: Neues Release des Web-Frameworks - Renaissance? Angular 17! - Alle Features im Überblick\n'parentName': iJS Magazin 2.2024\n'language': 'DE'\n'date': '2024-04-03T22:00:00.000Z'\n'abstract': Das beliebte JavaScript-Framework Angular veröffentlicht Version 17. Da bei Angular viel in Bewegung ist, kann manch einer da den Überblick verlieren. Wir stellen alle Features von Angular 17 vor.\n'parentId': 'c04db0163e3cb47407e78b63'\n'parentDescription': Kaum ein Softwareprojekt, das nicht in wesentlichen Teilen auf der JavaScript-Technologie basiert. Eine breite Unterstützung sowie, leistungsfähige Programmiersprachen, die Vielzahl moderner Tools, sowie ausgereifte Frameworks wie Angular, React, Vue.js oder Node.js machen den JavaScript-Werkzeugkasten zu einem Alleskönner. Das iJS Magazin informiert aktuell und umfassend über die wichtige und innovative Entwicklungen im JavaScript-Universum und bietet handfeste Praxisinformationen für Softwareentwickler und -architekten.\n'indexBrandName': ''\n'indexSeriesName': ''\n'author': 'Karsten Sitterberg'\n'chunkSource': 'text'\n'text': Vertrauensverhältnis geschaffen werden. Ein hervorragendes Beispiel ist hier Java: Innovation findet statt, jedoch mit entsprechend viel Vorlauf und maximal möglicher Kompatibilität selbst zu sehr alten Codebasen. Nicht umsonst ist Java damit die Sprache im Enterprise-Umfeld. Und das ist definitiv positiv und wertschätzend gemeint. Ein passender Vergleich wäre hier die Angular-Ivy Umstellung und das Java Projekt Loom: Massiver Nutzen wurde durch hochkarätiges Engineering geschaffen, ohne dass dazu Entwickler:innen zu massivem Eigenaufwand genötigt werden. Es ist klar, dass dies nicht immer gelingen kann, aber es ist vielleicht erstrebenswert, dies als Ziel vor Augen zu haben. Und wer ganz neu mit Angular einsteigt, tut gut daran, sich direkt an den aktuellen Konzepten zu orientieren und nicht auf ältere Literatur, Blogeinträge oder Trainings zurückzugreifen.\n'slidetext': ''\n'from': 'index'\n'score': 120.26181030273438\n'normalizedScore': 1.2026181030273437\n'beforeDatePenaltyScore': 1.2026181030273437\n\n'documentId': '8b35e3d0070110b78d6c9434'\n'chunk_id': '687a2210d92aed38f5a4a5b4'\n'access': 'granted'\n'part_number': 3\n'total_parts': 9\n'contentType': 'READ'\n'title': Angular: Signals, Standalone, SSR - So bauen Sie Angular-Apps der Zukunft\n'parentName': Windows Developer 7.2024\n'language': 'DE'\n'date': '2024-06-10T22:00:00.000Z'\n'abstract': Mit der Veröffentlichung der 16. Hauptversion von Angular läutete das Angular-Team die „Angular Renaissance“ ein. Wörtlich übersetzt bedeutet das nichts Geringeres als die Wiedergeburt von Googles SPA-Framework - eine treffende Bezeichnung, denn Angular-Codebasen werden sich nachhaltig verändern. Der Unterschied zwischen Angular-2- und Angular-17-Code ist mit bloßem Auge erkennbar.\n'parentId': 'b662818c73a937b86282ae99'\n'parentDescription': Windows Developer informiert umfassend und herstellerneutral über die neuen Trends und Möglichkeiten der Software- und Systementwicklung rund um Microsoft- und Web-Technologien. Von der klassischen .NET-Entwicklung über .NET Core bis hin zu neuen Technologien wie Windows 10, Microsoft Azure und der ganzen Bandbreite der aktuellen Web-, Phone- und Tabletentwicklung für Android und iOS mit Xamarin und unterschiedlichen JavaScript-Frameworks. Professionelle Entwickler und IT-Entscheider erhalten genau die Informationen, die sie für den erfolgreichen Einsatz von unternehmensorientierten Lösungen benötigen.\n'indexBrandName': ''\n'indexSeriesName': ''\n'author': 'Christian Liebel'\n'chunkSource': 'text'\n'text': diese nimmt einen Callback entgegen, der aufgerufen wird, sobald sich die darin enthaltenen Signals ändern. Das letzte Codebeispiel zeigt die Verwendung dieser Methode: Wann immer sich das Signal doubleCount ändert, wird eine Logausgabe auf der Konsole ausgeführt. Voraussetzung dafür ist, dass die effect()-Methode innerhalb eines Injection Context aufgerufen wird, also überall dort, wo auch die inject()-Methode genutzt werden kann, etwa im Konstruktor. Abb. 1: Dank Signals sind Änderungsquellen genau bekannt und könnten in Zukunft eine deutlich effizientere Änderungsnachverfolgung in Angular erlauben Signals könnten in Zukunft die Performance von Angular-Anwendungen erheblich verbessern. Derzeit basiert die Änderungsnachverfolgung von Angular noch auf der Bibliothek zone.js. Diese versucht auf sämtliche asynchrone Ereignisse innerhalb des Browsers zu reagieren und prüft danach standardmäßig alle Komponenten innerhalb der Anwendung auf Änderungen. Da mit Signals die genaue Änderungsquelle bekannt ist, kann in Zukunft eine deutlich effizientere Change Detection implementiert werden. Dann muss nicht mehr die gesamte Anwendung geprüft werden, sondern nur noch die Komponenten, bei denen sich tatsächlich eine Änderung ergibt (Abb. 1). zone.js optional zu machen, ist ein festes Ziel des Angular-Teams. Während signal() und computed() als stabil markiert sind, befindet sich die effect()-Methode noch in der Entwicklervorschau (Developer Preview). Das Angular-Team behält sich also vor, diese Schnittstelle noch einmal anzupassen, bevor sie als stabil markiert wird. Signals und RxJS Signals verhalten sich also ähnlich wie BehaviorSubjects und allgemein Observables aus RxJS – dennoch ist die Signals-Schnittstelle deutlich vereinfacht, denn unter anderem gibt es keine Operatoren. Das soll den Einstieg in Angular vereinfachen: Neue Entwickler:innen sollen neben den Frameworkkonzepten nicht auch gleich noch die Spezifika einer so umfangreichen Bibliothek wie RxJS lernen müssen. Umgekehrt können Signals aber nicht den kompletten Funktionsumfang abdecken, den RxJS bietet: So muss jedes Signal immer zwingend mit einem Wert vorbelegt sein. Bei Observables könnte dieser auch erst nachträglich (asynchron) emittiert werden. Komplexe Konstrukte, die sich bei RxJS hinter einem einfachen Operator verbergen wie debounceTime, also zum Ignorieren von Änderungen während eines bestimmten\n'slidetext': ''\n'from': 'index'\n'score': 120.14299011230469\n'normalizedScore': 1.201429901123047\n'beforeDatePenaltyScore': 1.201429901123047\n\n'documentId': '64ace3828d8056484c3534ab'\n'chunk_id': '687814c5bed6dcd41a99b022'\n'access': 'granted'\n'part_number': 10\n'total_parts': 21\n'contentType': 'READ'\n'title': Angular 16 released - Alles zu neuen Features und Breaking Changes\n'parentName': iJS Magazin Band 27\n'language': 'DE'\n'date': '2023-04-06T00:00:00.000Z'\n'abstract': Wir geben einen Überblick zu allen wichtigen Infos zum Release von Angular 16. Alles zu Signals, der Angular-CLI und TypeScript in Angular 16 erfahren Sie hier.\n'parentId': '5093fc7a779ccfe852d8fe7b'\n'parentDescription': Kaum ein Softwareprojekt, das nicht in wesentlichen Teilen auf der JavaScript-Technologie basiert. Eine breite Unterstützung sowie, leistungsfähige Programmiersprachen, die Vielzahl moderner Tools, sowie ausgereifte Frameworks wie Angular, React, Vue.js oder Node.js machen den JavaScript-Werkzeugkasten zu einem Alleskönner. Das iJS Magazin informiert aktuell und umfassend über die wichtige und innovative Entwicklungen im JavaScript-Universum und bietet handfeste Praxisinformationen für Softwareentwickler und -architekten.\n'indexBrandName': ''\n'indexSeriesName': ''\n'author': 'Karsten Sitterberg'\n'chunkSource': 'text'\n'text': Routen-Definition selbst geschehen, die Umwandlungsfunktionen stellt Angular zur Verfügung. In Listing 11 ist beispielhaft die Umwandlungsfunktion mapToCanActivate() dargestellt, mit der ein Array von klassenbasierten CanActivate-Guards in funktionale Guards transformiert werden kann. In Listing 11 ist auch dargestellt, dass klassenbasierte und funktionale Guards auch an der gleichen Route verwendet werden können, indem beide miteinander konkateniert werden. Listing 10: Klassenbasierter Guard und funktionaler Guard @Injectable({providedIn: 'root'}) export class DemoClassGuard { constructor(private authService: DemoAuthService) {} canActivate(route: ActivatedRouteSnapshot, state: RouterStateSnapshot): boolean | UrlTree { return this.auth.isLoggedIn(); } } export const demoFuncGuard: CanActivateFn = (route, state) => { const authService = inject(DemoAuthService) return authService.isLoggedIn(); }; Listing 11: Zukünftige Einbindung von Guards const routes: Routes = [ { path: 'demo', canActivate: mapToCanActivate([DemoClassGuard]) .concat(demoFuncGuard), component: DemoComponent } ]; Dem Router wurde in Version 16 noch ein weiteres und sehr angenehmes Feature hinzugefügt, das viel Boilerplate auf einfache Art und Weise überflüssig machen kann. Denn es ist nun möglich, Daten aus dem Routing-Vorgang direkt an Komponenten-Inputs zu binden. Dabei können Daten sowohl dynamisch per Resolver geladene Daten, als auch Daten aus den Query-Parameter an die Komponente gebunden werden. Um dies zu veranschaulichen, ist in Listing 12 eine Komponente gezeigt, die mit der Routen-Konfiguration aus Listing 13 eingebunden ist. In dieser Routen-Konfiguration ist für die Route demo zum einen ein statisches Datenobjekt mit dem Property demoData hinterlegt, zum anderen ein Resolver-Objekt mit Property demoResolved hinterlegt. Der Resolver ist hier zwar synchron, könnte aber genauso ein asynchrones Observable oder Promise zurückliefern, da dies vom Router aufgelöst würde. Dabei ist es hier explizit kein Zufall, dass die Properties in der Routen-Definition genau gleich heißen, wie die @Input-Properties in der Komponente. Das ist tatsächlich eine Voraussetzung dafür, dass die entsprechenden Eigenschaften aufeinander abgebildet werden können. Das Feature kann aktiviert werden, indem beim Aufruf von provideRouter() die Funktion _withComponentInputBinding()- mitgegeben wird, siehe unten in Listing 13. Falls noch nicht die neue Syntax zum Erzeugen des Routers verwendet wird, sondern das RouterModule, kann im RouterModule.forRoot() das Flag\n'slidetext': ''\n'from': 'index'\n'score': 120.00129699707031\n'normalizedScore': 1.2000129699707032\n'beforeDatePenaltyScore': 1.2000129699707032\n\n'documentId': '64ace3828d8056484c3534ab'\n'chunk_id': '687814c6bed6dcd41a99b02b'\n'access': 'granted'\n'part_number': 19\n'total_parts': 21\n'contentType': 'READ'\n'title': Angular 16 released - Alles zu neuen Features und Breaking Changes\n'parentName': iJS Magazin Band 27\n'language': 'DE'\n'date': '2023-04-06T00:00:00.000Z'\n'abstract': Wir geben einen Überblick zu allen wichtigen Infos zum Release von Angular 16. Alles zu Signals, der Angular-CLI und TypeScript in Angular 16 erfahren Sie hier.\n'parentId': '5093fc7a779ccfe852d8fe7b'\n'parentDescription': Kaum ein Softwareprojekt, das nicht in wesentlichen Teilen auf der JavaScript-Technologie basiert. Eine breite Unterstützung sowie, leistungsfähige Programmiersprachen, die Vielzahl moderner Tools, sowie ausgereifte Frameworks wie Angular, React, Vue.js oder Node.js machen den JavaScript-Werkzeugkasten zu einem Alleskönner. Das iJS Magazin informiert aktuell und umfassend über die wichtige und innovative Entwicklungen im JavaScript-Universum und bietet handfeste Praxisinformationen für Softwareentwickler und -architekten.\n'indexBrandName': ''\n'indexSeriesName': ''\n'author': 'Karsten Sitterberg'\n'chunkSource': 'text'\n'text': sich die Auswirkungen für den Großteil der Nutzer sicherlich im Rahmen. So haben sich die Versionsanforderungen der verwendeten Werkzeuge und Frameworks geändert. Zunächst wird als TypeScript-Version mindestens 4.9 verlangt. Node.js muss mindestens in Version 16 vorliegen, denn Node.js 14 hat als End-of-Life Datum den 30.3.2023. Zone.js in Versionen unter 0.12 wird nicht mehr unterstützt. Der ReflectiveInjector als altes und bereits als deprecated markiertes Konstrukt ist entfallen. Bei Bedarf kann als Ersatz Injector.create verwendet werden. Bereits mit Angular 14 war das BrowserTransferStateModule leer, es entfällt in diesem Release. Die TransferState-Klasse kann ohne das Modul direkt injiziert werden. Im BrowserModule ist die Methode withServerTransition als deprecated markiert worden. Diese wurde im Falle von SSR genutzt, um der App eine App-ID zu setzen. Um nun eine App-ID zu vergeben, kann das Injection-Token APP_ID verwendet werden. Wenn mehrere Angular-Anwendungen auf derselben Seite platziert werden, ist es nötig, die APP-ID pro Anwendung auf einen individuellen Wert zu setzen. Falls nur eine App verwendet wird, kann auf die Konfiguration der APP-ID verzichtet werden. Im Router wurden alle Referenzen auf den ComponentFactoryResolver entfernt, der früher u.a. für das Lazy-Loading zuständig war. Seit Angular 13 wird der ComponentFactoryResolver dafür jedoch nicht mehr benötigt und ist generell als 'Deprecated' markiert. Neben dem Einsatz im Router konnte man mit dem ComponentFactoryResolver auch manuell Komponenten erzeugen. Um Komponenten heute manuell zu erzeugen, reicht jedoch einfach eine Referenz auf die Komponenten-Klasse. Diese kann dann zusammen mit einer ViewContainerRef genutzt werden, um eine Komponente per viewContainerRef.createComponent() zu erzeugen. Vor allem in Kombination mit Standalone-Komponenten ist es so auch einfach möglich, Komponenten unabhängig vom Router lazy nachzuladen. Fazit Dem Angular-Framework ist anzusehen, dass es einem enormen Wettbewerb ausgesetzt ist. React und zunehmend Vue sind bei Einsteigern beliebt. Sicherlich nicht zuletzt, weil die gefühlte Lernkurve flacher ist und inzwischen das Ökosystem auch bei den anderen Frameworks immens umfangreich ist. Auf der anderen Seite stehen neue Entwicklungen, wie Qwik, das von Ex-Angular Entwicklern mitgegründet wurde. Was die wirklichen Gründe hinter allen\n'slidetext': ''\n'from': 'index'\n'score': 119.82176208496094\n'normalizedScore': 1.1982176208496094\n'beforeDatePenaltyScore': 1.1982176208496094\n\n'documentId': '04721391f3f7580f0631b9d3'\n'chunk_id': '687a2101a98d5a30b3a34120'\n'access': 'granted'\n'part_number': 4\n'total_parts': 21\n'contentType': 'READ'\n'title': Angular 17: Neues Release des Web-Frameworks - Renaissance? Angular 17! - Alle Features im Überblick\n'parentName': iJS Magazin 2.2024\n'language': 'DE'\n'date': '2024-04-03T22:00:00.000Z'\n'abstract': Das beliebte JavaScript-Framework Angular veröffentlicht Version 17. Da bei Angular viel in Bewegung ist, kann manch einer da den Überblick verlieren. Wir stellen alle Features von Angular 17 vor.\n'parentId': 'c04db0163e3cb47407e78b63'\n'parentDescription': Kaum ein Softwareprojekt, das nicht in wesentlichen Teilen auf der JavaScript-Technologie basiert. Eine breite Unterstützung sowie, leistungsfähige Programmiersprachen, die Vielzahl moderner Tools, sowie ausgereifte Frameworks wie Angular, React, Vue.js oder Node.js machen den JavaScript-Werkzeugkasten zu einem Alleskönner. Das iJS Magazin informiert aktuell und umfassend über die wichtige und innovative Entwicklungen im JavaScript-Universum und bietet handfeste Praxisinformationen für Softwareentwickler und -architekten.\n'indexBrandName': ''\n'indexSeriesName': ''\n'author': 'Karsten Sitterberg'\n'chunkSource': 'text'\n'text': das Angular-Framework spannendes Feature hinzu: Die Möglichkeit, Metadaten zu einem Decorator hinzuzufügen. Mit den ursprünglich von Angular verwendeten “Experimental Decorators” gab es dieses Feature bereits, nun ist es auch in der stabilen TypeScript-Spezifikation angekommen. In Listing 4 wird beispielsweise der Decorator “setMetadata” definiert. Ein Decorator ist eine Funktion, der zum einen die dekorierte Entität als “target” übergeben wird, zum einen in dazugehöriger “context”. Diesem Kontext-Objekt wurde mit TypeScript 5.2 das “metadata”-Property hinzugefügt. Die Metadaten können als Key-Value-Store verstanden werden, der entsprechende TypeScript-Typ wird “Record” genannt. Der Metadaten-Key ist der Name der dekorierten Entität, in Listing 4 ist zum Beispiel das Property “demoAmount” dekoriert, und wird so zu einem Metadaten-Key. In Listing 4 wird gezeigt, wie Metadaten per Zugriff auf “context.metadata” geschrieben werden können. Der Name der dekorierten Entität ist in “context.name” enthalten. In Listing 4 wird einfach für jedes mit “@setMetadata” dekorierte Property der String “Demo-Daten” in den Metadaten hinterlegt. Die hinterlegten Metadaten können durch das spezielle TypeScript-Metadaten-Symbol (“Symbol.metadata”) aus der Klasse ausgelesen werden. Listing 4: Metadaten setzen und auslesen in TypeScript interface Context { name: string; metadata: Record\n\n; } function setMetadata(_target: any, context: Context) { context.metadata[context.name] = 'Demo-Daten'; } class MyClass { @setMetadata demoAmount = 123; @setMetadata demoAction() { } } const ourMetadata = MyClass[Symbol.metadata]; console.log(JSON.stringify(ourMetadata)); // { 'demoAmount': 'Demo-Daten', 'demoAction': 'Demo-Daten' } Um einen Decorator besser konfigurieren zu können, kann eine Decorator-Factory implementiert werden, die dann den eigentlichen Decorator zurückgibt. In Listing 5 ist dies anhand der Decorator-Factory “DemoMeta” gezeigt, die den zu setzenden Metadaten-Key und den damit verbunden Metadaten-Value als Parameter übergeben bekommt und dann den fertig konfigurierten Decorator zurückgibt. Die “DemoMeta”-Factory wird in Listing 5 genutzt, um der Klasse “DemoClass” den Metadaten-Eintrag “'entity'” mit dem Wert “'3270'” hinzuzufügen; der Methode “demoMethod()” wird der Metadaten-Eintrag “'demo'” mit dem Wert “'42'” hinzugefügt. Der Zugriff auf die Metadaten der Klasse erfolgt dann wieder mit Hilfe von “Symbol.metadata”.\n'slidetext': ''\n'from': 'index'\n'score': 119.79788208007812\n'normalizedScore': 1.1979788208007813\n'beforeDatePenaltyScore': 1.1979788208007813\n\n'documentId': '04721391f3f7580f0631b9d3'\n'chunk_id': '687a2101a98d5a30b3a3411b'\n'access': 'granted'\n'part_number': 3\n'total_parts': 21\n'contentType': 'READ'\n'title': Angular 17: Neues Release des Web-Frameworks - Renaissance? Angular 17! - Alle Features im Überblick\n'parentName': iJS Magazin 2.2024\n'language': 'DE'\n'date': '2024-04-03T22:00:00.000Z'\n'abstract': Das beliebte JavaScript-Framework Angular veröffentlicht Version 17. Da bei Angular viel in Bewegung ist, kann manch einer da den Überblick verlieren. Wir stellen alle Features von Angular 17 vor.\n'parentId': 'c04db0163e3cb47407e78b63'\n'parentDescription': Kaum ein Softwareprojekt, das nicht in wesentlichen Teilen auf der JavaScript-Technologie basiert. Eine breite Unterstützung sowie, leistungsfähige Programmiersprachen, die Vielzahl moderner Tools, sowie ausgereifte Frameworks wie Angular, React, Vue.js oder Node.js machen den JavaScript-Werkzeugkasten zu einem Alleskönner. Das iJS Magazin informiert aktuell und umfassend über die wichtige und innovative Entwicklungen im JavaScript-Universum und bietet handfeste Praxisinformationen für Softwareentwickler und -architekten.\n'indexBrandName': ''\n'indexSeriesName': ''\n'author': 'Karsten Sitterberg'\n'chunkSource': 'text'\n'text': “return“ bei Rückgabe von “undefined“ Wenn in JavaScript eine Funktion keine “return”-Angabe enthält, hat diese Funktion dennoch immer implizit “undefined” als Rückgabewert. In TypeScript hat sich diese Tatsache bisher nicht widergespiegelt: Wenn bei einer Funktion als Rückgabetyp “undefined” spezifiziert war, musste auch immer explizit ein “return”-Statement verwendet werden. Außerdem war eine Funktion, die explizit “undefined” zurückgibt, nicht kompatibel mit einer “void”-Funktion, siehe Listing 1. Listing 1: “undefined” und “void” waren bisher in TypeScript inkompatibel declare function onEvent(f: () => undefined): undefined; onEvent(function f() { }) // Argument of type '() => void' is not assignable to parameter of type '() => undefined'. Mit TypeScript 5.1 wurde dies nun verbessert, sodass obiges Beispiel nun keine Kompilerfehler mehr wirft. Außerdem benötigt eine Funktion mit “undefined” als Rückgabetyp nun kein explizites “return” mehr, analog Funktion “demo1()” aus Listing 2. Alternativ kann auch ein explizites, aber “leeres” return verwendet werden, wie in der Funktion “demo2()”. Listing 2: Keine Rückgabe bei Rückgabetyp “undefined” mehr nötig function demo1(): undefined { // no returns } function demo2(): undefined { return; } Unabhängige Getter- und Setter-Typen Bisher mussten zusammengehörige - also gleich benannte - TypeScript get- und set-Funktionen kompatible Typen haben. Bei einem Setter, dem beispielsweise der Typ “string|number|boolean” übergeben werden kann, konnte bisher für den entsprechenden Getter nur ein Subtyp, etwa “string” spezifiziert werden. Mit TypeScript 5.1 können diese Typen nun komplett unabhängig vergeben werden, müssen dafür aber explizit vergeben werden, siehe Listing 3. Listing 3: Unabhängige Getter- und Setter-Typen. interface MyElementStyling { set style(newValue: string); get style(): CSSStyleDeclaration; } Decorator Metadaten Ein Decorator ist in TypeScript eine Funktion, die eine Klasse, ein Property oder auch eine Methode übergeben bekommt, um das Verhalten der jeweils übergebenen Entität zu erweitern. Mit TypeScript 5.2 kommt ein speziell für das Angular-Framework spannendes Feature hinzu: Die Möglichkeit, Metadaten zu einem Decorator hinzuzufügen. Mit den ursprünglich von Angular verwendeten “Experimental Decorators” gab es dieses Feature bereits, nun ist es auch in der\n'slidetext': ''\n'from': 'index'\n'score': 119.79788208007812\n'normalizedScore': 1.1979788208007813\n'beforeDatePenaltyScore': 1.1979788208007813\n\n'documentId': '64ace3828d8056484c3534ab'\n'chunk_id': '687814c5bed6dcd41a99b023'\n'access': 'granted'\n'part_number': 11\n'total_parts': 21\n'contentType': 'READ'\n'title': Angular 16 released - Alles zu neuen Features und Breaking Changes\n'parentName': iJS Magazin Band 27\n'language': 'DE'\n'date': '2023-04-06T00:00:00.000Z'\n'abstract': Wir geben einen Überblick zu allen wichtigen Infos zum Release von Angular 16. Alles zu Signals, der Angular-CLI und TypeScript in Angular 16 erfahren Sie hier.\n'parentId': '5093fc7a779ccfe852d8fe7b'\n'parentDescription': Kaum ein Softwareprojekt, das nicht in wesentlichen Teilen auf der JavaScript-Technologie basiert. Eine breite Unterstützung sowie, leistungsfähige Programmiersprachen, die Vielzahl moderner Tools, sowie ausgereifte Frameworks wie Angular, React, Vue.js oder Node.js machen den JavaScript-Werkzeugkasten zu einem Alleskönner. Das iJS Magazin informiert aktuell und umfassend über die wichtige und innovative Entwicklungen im JavaScript-Universum und bietet handfeste Praxisinformationen für Softwareentwickler und -architekten.\n'indexBrandName': ''\n'indexSeriesName': ''\n'author': 'Karsten Sitterberg'\n'chunkSource': 'text'\n'text': von provideRouter() die Funktion _withComponentInputBinding()- mitgegeben wird, siehe unten in Listing 13. Falls noch nicht die neue Syntax zum Erzeugen des Routers verwendet wird, sondern das RouterModule, kann im RouterModule.forRoot() das Flag bindToComponentInputs: true gesetzt werden. In Listing 14 ist beispielhaft gezeigt, welche Werte die Komponenten-Inputs annehmen, wenn in der Anwendung die Route /demo?language=french aufgerufen wird. Wichtig ist hierbei anzumerken, dass sogar die Query-Parameter (und die der Route zugeordneten Matrix-Parameter) über diesen Mechanismus gebunden werden können, was das Leben der Entwickler:innen an diesen Stellen erheblich vereinfachen dürfte. Die zu bindenden Query-Parameter müssen dann wieder genauso heißen, wie die zu bindende Input-Variable. Falls es zu Namenskollisionen zwischen den einzelnen Datenquellen kommt, so haben die Daten aus dem Resolver die höchste Priorität. Danach werden die statischen Daten aus der Routenkonfiguration herangezogen, dann folgen die Matrixparameter. Nur wenn das Property in keiner dieser Quellen gefunden wird, werden die Daten aus den Query-Params extrahiert. Listing 12: Komponente mit Input @Component({ template: '' }) export class DemoComponent { @Input() language?: string; @Input() demoResolved?: string; @Input() demoData?: string; } Listing 13: Routen-Konfiguration const routes = [{ path: 'demo', component: DemoComponent, data: {'demoData': 'My static data'}, resolve: {'demoResolved': () => 'My resolved data'}, }]; // inside AppModule/app-config provideRouter(routes, withComponentInputBinding()) Listing 14: Komponenten-Properties zur Laufzeit router.navigateByUrl('/demo?language=french') // component.language === 'french'; // component.demoData === 'My static data'; // component.demoResolved === 'My resolved data' Ein sehr wichtiges Thema in diesem Release ist die Fähigkeit von Angular, die Browseranwendung auf der Serverseite dynamisch zu rendern (Server-side Rendering, SSR) und das Ergebnis an den Browser zu senden. Dadurch können die Seiteninhalte nach Übertragung an den Client direkt dargestellt werden, ohne den App-Start abwarten zu müssen. Dies ist vor allem interessant, wenn die initiale Ladezeit der Anwendung hohe Priorität hat oder die Anwendung im freien Internet verfügbar ist und SEO (Search Engine Optimization) für die App relevant ist. Bisher kam es allerdings immer, wenn nach dem initialen Page-Load die Angular-App geladen war, zu einem kurzen Flackern, da die gerade gestartete App einmal den kompletten DOM neu gezeichnet hat. Nun gibt\n'slidetext': ''\n'from': 'index'\n'score': 119.35953521728516\n'normalizedScore': 1.1935953521728515\n'beforeDatePenaltyScore': 1.1935953521728515\n\n'documentId': '8b35e3d0070110b78d6c9434'\n'chunk_id': '687a2212d92aed38f5a4a5c3'\n'access': 'granted'\n'part_number': 9\n'total_parts': 9\n'contentType': 'READ'\n'title': Angular: Signals, Standalone, SSR - So bauen Sie Angular-Apps der Zukunft\n'parentName': Windows Developer 7.2024\n'language': 'DE'\n'date': '2024-06-10T22:00:00.000Z'\n'abstract': Mit der Veröffentlichung der 16. Hauptversion von Angular läutete das Angular-Team die „Angular Renaissance“ ein. Wörtlich übersetzt bedeutet das nichts Geringeres als die Wiedergeburt von Googles SPA-Framework - eine treffende Bezeichnung, denn Angular-Codebasen werden sich nachhaltig verändern. Der Unterschied zwischen Angular-2- und Angular-17-Code ist mit bloßem Auge erkennbar.\n'parentId': 'b662818c73a937b86282ae99'\n'parentDescription': Windows Developer informiert umfassend und herstellerneutral über die neuen Trends und Möglichkeiten der Software- und Systementwicklung rund um Microsoft- und Web-Technologien. Von der klassischen .NET-Entwicklung über .NET Core bis hin zu neuen Technologien wie Windows 10, Microsoft Azure und der ganzen Bandbreite der aktuellen Web-, Phone- und Tabletentwicklung für Android und iOS mit Xamarin und unterschiedlichen JavaScript-Frameworks. Professionelle Entwickler und IT-Entscheider erhalten genau die Informationen, die sie für den erfolgreichen Einsatz von unternehmensorientierten Lösungen benötigen.\n'indexBrandName': ''\n'indexSeriesName': ''\n'author': 'Christian Liebel'\n'chunkSource': 'text'\n'text': Zeitpunkt überhaupt nicht möglich ist. Ferner ist zu beachten, dass sich die Outputpfade des Build verändern und eventuell bestehende Build Pipelines angepasst werden müssen. Nicht jeder braucht SSR Im Gegensatz zu Signals und Standalone APIs ist SSR kein zwingend gebotenes Update. Ob die Verwendung von SSR im Projekt sinnvoll ist, muss im Einzelfall betrachtet werden, denn die Voraussetzungen sind recht hoch: SSR mit Authentifizierung bereitzustellen führt zu einem hohen Aufwand. Angular i18n wird mit Hydration derzeit nicht unterstützt. Ferner müssen für Hydration sämtliche Komponenten dafür gebaut worden sein und sämtliche DOM-Zugriffe über Angular geschehen. Das ist bei Bibliotheken wie D3.js oder Grid-Komponenten von Drittherstellern nicht der Fall. Die Deaktivierung von Hydration ist für diese Komponenten zwar möglich, damit gehen aber auch die Vorteile dieses Ansatzes verloren. Kurzum erscheint SSR für Projekte sinnvoll, die eher kleineren Umfangs und öffentlich zugänglich sind. Für neue Projekte fragt das Angular CLI schon bei der Erstellung nach, ob SSR aktiviert werden soll, standardmäßig ist es deaktiviert. Für Bestandsprojekte kann SSR durch die Ausführung des Kommandos ng add @angular/ssr nachträglich aktiviert werden. Die Angular-Renaissance ist eine gute Nachricht für Entwickler:innen Angular macht derzeit bedeutende Fortschritte, ohne dabei die Abwärtskompatibilität zu vernachlässigen. Besonders hervorzuheben sind die Verbesserungen der Developer Experience sowie die möglichen Leistungssteigerungen bei Build- und Laufzeitperformance. Durch diese Verbesserungen bleiben Ihre Anwender:innen und Entwickler:innen zufrieden und Ihre Angular-Apps laufen flüssiger denn je. Um technische Schulden zu vermeiden, ist es ratsam, schnellstmöglich auf neue Angular-Versionen und die neuen Features zu migrieren. Links & Literatur [1] https://angular.dev/guide/signals [2] https://angular.io/guide/signal-inputs [3] https://angular.io/guide/signal-queries [4] https://github.com/angular/angular/issues/54808 [5] https://angular.io/guide/standalone-components [6] https://angular.dev/reference/migrations/standalone [7] https://angular.io/guide/ssr [8] https://angular.io/guide/esbuild\n'slidetext': ''\n'from': 'index'\n'score': 118.82921600341797\n'normalizedScore': 1.1882921600341796\n'beforeDatePenaltyScore': 1.1882921600341796\n\n\nTop Vectors:\n'documentId': 'df387f02fdf1c3c67daf2189'\n'chunk_id': '68f25130d754e200146e6f66'\n'access': 'restricted'\n'part_number': 3\n'total_parts': 16\n'contentType': 'RHEINGOLD'\n'title': Bringing Intelligence to the Edge: A Lightweight JavaScript ELM Library for Front-End Machine Learning\n'parentName': International JavaScript New York 2025\n'language': 'EN'\n'date': '2025-10-01T14:00:00.000Z'\n'abstract': In this talk, we introduce an open-source JavaScript library that brings real-time machine learning to the browser using Extreme Learning Machines (ELMs)—a fast, single-pass neural network architecture ideal for edge inference. Designed for simplicity, speed, and versatility, our library allows developers to train and run predictive models entirely in the browser, without external APIs or heavy back-end dependencies.We'll walk through the architecture of the library and demonstrate how it supports a variety of interactive use cases, including: - Autocomplete prediction for text fields - Intent detection in command-based interfaces - Language and sentiment classification - Hashtag and tag suggestion engines - Text-based game input recognitionBy combining efficient encoding, fast matrix operations, and intuitive APIs for binding to DOM elements, the library empowers developers to embed intelligence directly into their front-end workflows. We’ll also showcase how the library can be extended to support new domains, how it can be bundled as an NPM package, and how it integrates with modern JS/TS development ecosystems.If you're curious about doing machine learning without TensorFlow or PyTorch—or want to explore how neural networks can enhance your web interfaces with zero dependencies—this session is for you.\n'parentId': '9f97d5cdc68d72a05f834df4'\n'parentDescription': The JavaScript Fullstack Conference - Angular, Node.js, React and more\n'indexBrandName': 'InternationalJavaScriptCon'\n'indexSeriesName': 'NewYork'\n'author': 'Julian Duran'\n'chunkSource': 'text'\n'text': that component is un push, then angular just gonna assume, oh, the inputs haven't changed, so I'm not gonna refresh that component. And now we have signals where with the signal, angular knows exactly what changes and where, what are the consequences of that change, which is true for components, but also true for other signals, right? Um, the idea is when you use a signal, angular knows about what anything, any code that depends on it, right? It, it builds a dependency graph on, on those signals and knows exactly what depends on, um, on these signals. So when you change the value, everything that needs to change as a result is just known. And so it can happen quickly. And so along with signal scheme, a whole bunch of new functions, features like components, inputs, outputs, can all be signal based. Now, models, um, content queries, all of that is now, uh, signal based, which leads us with what do we do with RXGS, right? Because RXGS is still a big part of angular. You can find it in the router, you'll find it in forms, you'll find it in the HTP client. And that's a paradox, right? How do we use signals everywhere? If you know, the entry point for our data, which is the A GTP client is using RXGS. So the, the first, uh, quick and dirty, even though not so dirty, but the, the first option was to just use two signal. So that's a function that takes an observable, turns it into a signal. There's the opposite function to observable that we don't use somehow who would turn a signal into an observable, I don't know. Um, so yeah, these two utility functions can be used. But the thing is, even though the work, um, it still feels like not, not the, you know, the perfect solution, not right to just do conversions and conversion and conversions of, um, of observables to signals. And so then with, uh, angular 18, as we saw resources were introduced, uh, back in Angular, that disappeared in Angular one and came back in angular 18 with a, a different shape. And so resource. Uh, so, so the idea was to kind of find a way to wrap asynchronous code into a signal based approach, right? So when you use resources, you don't see any RXJS anymore. You don't see any, uh, well, anything async, I would say, everything is just a signal. Everything becomes a signal. And so the, the initial release of resource was, uh, and still is available as is. It's a resource\n'slidetext': ''\n'from': 'vector'\n'score': 0.9313324689865112\n'normalizedScore': 0.9291384736820972\n'beforeDatePenaltyScore': 0.9313324689865112\n\n'documentId': '1da46606f89dc3ccaa9c0f9d'\n'chunk_id': '690d456dd334ac0013d8cf18'\n'access': 'restricted'\n'part_number': 40\n'total_parts': 51\n'contentType': 'FLEX_CAMP'\n'title': Woche 2: Angular Pipes, NgModules & Subkomponenten: Meistern Sie die fortgeschrittenen Angular-Konzepte (Lektionen 4, 5 & 6) | verfügbar bis 27.03.2026\n'parentName': Angular Camp - Flexible Basic Camp März 2026 | online\n'language': 'DE'\n'date': '2026-03-09T00:00:00.000Z'\n'abstract': Weiter geht es in die zweite Woche! Hier behandeln wir 3 Lektionen. In diesem Kursteil erlangen Sie tiefere Einblicke in die fortgeschrittenen Konzepte von Angular und lernen, wie Sie Pipes, NgModules und Subkomponenten effektiv einsetzen, um Ihre Anwendungen zu optimieren. 4. Lektion: Pipes: Datenformatierung mit eigener Hand: - Lernen Sie, wie Sie eigene Pipes entwickeln, um Daten im Zuge der Datenbindung zu transformieren. - Pure Pipes im Fokus: Verstehen Sie das Konzept der reinen Pipes und ihre Bedeutung für die Anwendungsperformance. - In diesem kurzen Kapitel erfahren Sie alles zur Entwicklung eigener Pipes für das Transformieren von Daten im Zuge der Datenbindung, zum Konzept der reinen Pipes (engl. pure pipes) und warum es für die Anwendungsperformance wichtig ist. 5. Lektion: NgModules & Standalone Components in Angular: Alt und neu im Einklang Auch wenn NgModules seit der Einführung von Standalone Components weniger wichtig sind, existieren noch zahlreiche Codestrecken und Bibliotheken, die darauf aufbauen. Deswegen beschäftigen wir uns hier mit dem Zusammenspiel dieser beiden Konzepte. - NgModules verstehen: Obwohl Standalone Components an Bedeutung gewinnen, bleiben NgModules relevant. Erfahren Sie, wie diese beiden Konzepte zusammenspielen. - Codestrecken und Bibliotheken meistern: Navigieren Sie souverän durch Codestrecken und Bibliotheken, die auf NgModules basieren. 6. Lektion: Angular Subkomponenten & Datenbindung Erweitern Sie Ihre Angular-Fähigkeiten und lernen Sie, wie Sie Subkomponenten und Datenbindung effektiv einsetzen, um komplexe und skalierbare Anwendungen zu erstellen. Hier erfahren Sie Wissenswertes über die Entwicklung weiterer Komponenten, die über Datenbindung miteinander kommunizieren. Dazu werfen wir auch einen genaueren Blick unter die Motorhaube von Angular, um die Datenbindung besser zu verstehen. - Data Binding im Detail - Components and Data Bindung - Event Bindings - Smart vs. Dumb Components - Life Cycle Hooks - Bonus: Signals Auch hier haben Sie die Möglichkeit Ihr Wissen praktisch anzuwenden: Zu den Übungen Wir empfehlen in der zweiten Woche diese Lektionen zu bearbeiten.\n'parentId': 'a35ba82dd72cb1cbd49bc4b5'\n'parentDescription': Das Angular Training für Einsteiger:innen mit Manfred Steyer im zeitlich flexiblen Online-Format\n'indexBrandName': 'AngularCamp'\n'indexSeriesName': 'FlexibleBasicCamp'\n'author': 'Manfred Steyer'\n'chunkSource': 'text'\n'text': weiß man ganz genau, wo sich was geändert hat. Angular kann herausfinden, ah, die Komponente hat sich rechts unten geändert, also muss sich rechts unten aktualisieren und sonst nirgendwo. Das Ganze ist nicht ganz neu, oder? Wir haben ähnliche Mechanismen mit Observables, mit RxJS, mit Subjects. Ja, also sowas hat es schon zuvor gegeben. Allerdings sind Signals ganz bewusst sehr, sehr schlank implementiert. Sehr, sehr simpel. Die können wirklich nicht viel mehr als das hier. Andere Ansätze wie RxJS haben ganz, ganz viele Features und sind schon alleine deswegen nicht obsolet, aber das Ziel ist es halt, mit etwas Simplen zu starten. Und das Angular-Team glaubt, dass in den meisten Fällen diese simple Lösung ausreichend ist. Ja, und wenn ich halt mehr brauche, dann werde ich mir eine Library wie RxJS dazu installieren und habe dann mehr Komplexität, aber auch viel, viel mehr Features. Man möchte also die Standard-Fälle leicht, gewichtiger, einfacher gestalten. Wie schaut jetzt so eine Anwendung mit und ohne Signals aus? Na ja, starten wir vielleicht einmal mit der Variante ohne Signals. Sowas haben wir eh schon die ganze Zeit gemacht, da hat man Properties, die bekommen Werte. Die Werte werden vielleicht aktualisiert, weil ich aus dem Backend Daten abrufe und die Werte werden gebunden. Nach jedem Event-Handler prüft Angular, ob da jetzt da was zu aktualisieren ist. Ob die Schleife oder das If oder sonst irgendwas neu gerendert werden müssen. So schaut es klassischerweise aus. Wenn ich genau dasselbe mit Signals mache, dann muss ich halt alle Werte, die ich Daten binden möchte, in ein Signal einwickeln. Dazu gibt es die Hilfsfunktion Signal, die befindet sich seit Angular 16 im Namespace Angular Core. Da sieht man also schon, das Konzept ist ein integraler Bestandteil des Kerns von Angular. Die Funktion Signal kriegt einen Standardwert übergeben, Klammerauf, Klammerzu in dem Fall, also ein leeres Array. Und da Klammerauf, Klammerzu keine Typ-Informationen beinhaltet, gebe ich hier als Typparameter an, ich meine damit ein leeres Flugarray. Diesen Typparameter in den Spitzenklammern, den kann man sehr häufig weglassen, weil TypeScript sehr häufig aus dem Standardwert\n'slidetext': ''\n'from': 'vector'\n'score': 0.9222575426101685\n'normalizedScore': 0.9287439126025581\n'beforeDatePenaltyScore': 0.9222575426101685\n\n'documentId': 'e8463276c25a9a889f842e96'\n'chunk_id': '69118b500f4b7700138ebda4'\n'access': 'granted'\n'part_number': 1\n'total_parts': 4\n'contentType': 'READ'\n'title': What’s New in Angular 21? - Discover the key features, improvements, and changes coming with Angular 21\n'parentName': iJS Magazine Volume 22\n'language': 'EN'\n'date': '2025-12-16T23:00:00.000Z'\n'abstract': Angular 21 introduces a new era of efficiency and developer-friendly design. With experimental Signal Forms and default zoneless change detection, this release focuses on performance and reactivity. Explore how these updates shape the framework’s future and simplify everyday development.\n'parentId': 'b6ef74991ae60010a55b93d4'\n'parentDescription': Broaden your knowledge and expand your JavaScript techniques and practices. From Angular, React, and WebAssembly, to the best JavaScript IDEs, open source tools and more, you’ll learn insights on everything JS from seasoned experts in their field. Keep up with JavaScript news, tips, and advice with interviews, tutorials, and in-depth articles.\n'indexBrandName': ''\n'indexSeriesName': ''\n'author': 'Brygida Fiejdasz'\n'chunkSource': 'text'\n'text': What’s New in Angular 21? Discover the key features, improvements, and changes coming with Angular 21 Angular 21 introduces a new era of efficiency and developer-friendly design. With experimental Signal Forms and default zoneless change detection, this release focuses on performance and reactivity. Explore how these updates shape the framework’s future and simplify everyday development. Angular 21 introduces a new era of efficiency and developer-friendly design. With experimental Signal Forms and default zoneless change detection, this release focuses on performance and reactivity. Let's explore how these updates shape the framework’s future and simplify everyday development. If you’ve been following Angular’s journey, version 21 brings some fresh air with features that many developers have been waiting for. The long-awaited Signal Forms are finally arriving. Although they’re experimental, this feature gives a glimpse into a smoother, more reactive approach to handling forms in Angular. Meanwhile, zoneless change detection is now enabled by default, boosting the framework’s performance and making your life easier. Let’s go over some of the cool updates coming in Angular 21. Signal Forms Angular 21 introduces Signal Forms, an experimental but promising feature that offers a fresh, declarative, and reactive way to manage form state using signals. To better understand how Signal Forms work in practice, let’s walk through the basic steps of creating one, starting with defining your form’s state as a signal. crewMember = signal( { name: '', imageUrl: '', position: '' } ); crewForm = form(this.crewMember); This setup defines a signal holding the crew member’s model. You can then pass this model to Angular’s form() function to create the reactive form tree reflecting this structure. The next step is to bind individual signal form fields to your HTML elements using the Field directive. This directive creates a two-way binding between the input element and the form’s signal model. Any changes in the input automatically update the form state, and any updates to the model immediately reflect in the input. Using it is really straightforward: just add [field] to your input elements and assign the corresponding form field. Remember to import the Field directive in your component’s imports array; otherwise, Angular won’t recognize it.    …   \n\nName: {{ crewForm.name().value() }} \n\nPosition: {{ crewForm.position().value() }}   In this example, you can see inputs bound to the crewForm fields for name, image URL, and position. Just below, there’s a live preview\n'slidetext': ''\n'from': 'vector'\n'score': 0.9257361888885498\n'normalizedScore': 0.9277271250909851\n'beforeDatePenaltyScore': 0.9257361888885498\n\n'documentId': '651822c08be4e71b1d4a39ae'\n'chunk_id': '690d38f563a89a0013451893'\n'access': 'restricted'\n'part_number': 40\n'total_parts': 51\n'contentType': 'FLEX_CAMP'\n'title': Woche 2: Angular Pipes, NgModules & Subkomponenten: Meistern Sie die fortgeschrittenen Angular-Konzepte (Lektionen 4, 5 & 6) | verfügbar bis 27.02.2026\n'parentName': Angular Camp - Flexible Basic Camp Februar 2026 | online\n'language': 'DE'\n'date': '2026-02-09T00:00:00.000Z'\n'abstract': Weiter geht es in die zweite Woche! Hier behandeln wir 3 Lektionen. In diesem Kursteil erlangen Sie tiefere Einblicke in die fortgeschrittenen Konzepte von Angular und lernen, wie Sie Pipes, NgModules und Subkomponenten effektiv einsetzen, um Ihre Anwendungen zu optimieren. 4. Lektion: Pipes: Datenformatierung mit eigener Hand: - Lernen Sie, wie Sie eigene Pipes entwickeln, um Daten im Zuge der Datenbindung zu transformieren. - Pure Pipes im Fokus: Verstehen Sie das Konzept der reinen Pipes und ihre Bedeutung für die Anwendungsperformance. - In diesem kurzen Kapitel erfahren Sie alles zur Entwicklung eigener Pipes für das Transformieren von Daten im Zuge der Datenbindung, zum Konzept der reinen Pipes (engl. pure pipes) und warum es für die Anwendungsperformance wichtig ist. 5. Lektion: NgModules & Standalone Components in Angular: Alt und neu im Einklang Auch wenn NgModules seit der Einführung von Standalone Components weniger wichtig sind, existieren noch zahlreiche Codestrecken und Bibliotheken, die darauf aufbauen. Deswegen beschäftigen wir uns hier mit dem Zusammenspiel dieser beiden Konzepte. - NgModules verstehen: Obwohl Standalone Components an Bedeutung gewinnen, bleiben NgModules relevant. Erfahren Sie, wie diese beiden Konzepte zusammenspielen. - Codestrecken und Bibliotheken meistern: Navigieren Sie souverän durch Codestrecken und Bibliotheken, die auf NgModules basieren. 6. Lektion: Angular Subkomponenten & Datenbindung Erweitern Sie Ihre Angular-Fähigkeiten und lernen Sie, wie Sie Subkomponenten und Datenbindung effektiv einsetzen, um komplexe und skalierbare Anwendungen zu erstellen. Hier erfahren Sie Wissenswertes über die Entwicklung weiterer Komponenten, die über Datenbindung miteinander kommunizieren. Dazu werfen wir auch einen genaueren Blick unter die Motorhaube von Angular, um die Datenbindung besser zu verstehen. - Data Binding im Detail - Components and Data Bindung - Event Bindings - Smart vs. Dumb Components - Life Cycle Hooks - Bonus: Signals Auch hier haben Sie die Möglichkeit Ihr Wissen praktisch anzuwenden: Zu den Übungen Wir empfehlen in der zweiten Woche diese Lektionen zu bearbeiten.\n'parentId': '07bd3b1440c66d2e1f03033f'\n'parentDescription': Das Angular Training für Einsteiger:innen mit Manfred Steyer im zeitlich flexiblen Online-Format\n'indexBrandName': 'AngularCamp'\n'indexSeriesName': 'FlexibleBasicCamp'\n'author': 'Manfred Steyer'\n'chunkSource': 'text'\n'text': weiß man ganz genau, wo sich was geändert hat. Angular kann herausfinden, ah, die Komponente hat sich rechts unten geändert, also muss sich rechts unten aktualisieren und sonst nirgendwo. Das Ganze ist nicht ganz neu, oder? Wir haben ähnliche Mechanismen mit Observables, mit RxJS, mit Subjects. Ja, also sowas hat es schon zuvor gegeben. Allerdings sind Signals ganz bewusst sehr, sehr schlank implementiert. Sehr, sehr simpel. Die können wirklich nicht viel mehr als das hier. Andere Ansätze wie RxJS haben ganz, ganz viele Features und sind schon alleine deswegen nicht obsolet, aber das Ziel ist es halt, mit etwas Simplen zu starten. Und das Angular-Team glaubt, dass in den meisten Fällen diese simple Lösung ausreichend ist. Ja, und wenn ich halt mehr brauche, dann werde ich mir eine Library wie RxJS dazu installieren und habe dann mehr Komplexität, aber auch viel, viel mehr Features. Man möchte also die Standard-Fälle leicht, gewichtiger, einfacher gestalten. Wie schaut jetzt so eine Anwendung mit und ohne Signals aus? Na ja, starten wir vielleicht einmal mit der Variante ohne Signals. Sowas haben wir eh schon die ganze Zeit gemacht, da hat man Properties, die bekommen Werte. Die Werte werden vielleicht aktualisiert, weil ich aus dem Backend Daten abrufe und die Werte werden gebunden. Nach jedem Event-Handler prüft Angular, ob da jetzt da was zu aktualisieren ist. Ob die Schleife oder das If oder sonst irgendwas neu gerendert werden müssen. So schaut es klassischerweise aus. Wenn ich genau dasselbe mit Signals mache, dann muss ich halt alle Werte, die ich Daten binden möchte, in ein Signal einwickeln. Dazu gibt es die Hilfsfunktion Signal, die befindet sich seit Angular 16 im Namespace Angular Core. Da sieht man also schon, das Konzept ist ein integraler Bestandteil des Kerns von Angular. Die Funktion Signal kriegt einen Standardwert übergeben, Klammerauf, Klammerzu in dem Fall, also ein leeres Array. Und da Klammerauf, Klammerzu keine Typ-Informationen beinhaltet, gebe ich hier als Typparameter an, ich meine damit ein leeres Flugarray. Diesen Typparameter in den Spitzenklammern, den kann man sehr häufig weglassen, weil TypeScript sehr häufig aus dem Standardwert\n'slidetext': ''\n'from': 'vector'\n'score': 0.9222575426101685\n'normalizedScore': 0.9272096660272157\n'beforeDatePenaltyScore': 0.9222575426101685\n\n'documentId': '1fed2c6361980d606789e315'\n'chunk_id': '68c26fcc0a53cd001394ab92'\n'access': 'granted'\n'part_number': 2\n'total_parts': 8\n'contentType': 'READ'\n'title': Manfred Steyer on Angular 20: Signals, Dynamic Components, AI, and What’s Next - Exploring selectorless components, signal-based forms, and other features in Angular\n'parentName': iJS Magazine Volume 19\n'language': 'EN'\n'date': '2025-06-24T22:00:00.000Z'\n'abstract': In this interview, GDE Manfred Steyer highlights Angular’s journey towards a more reactive future. We discuss the framework’s strengths, challenges, and what’s ahead with the release of Angular 20.\n'parentId': 'a1269c65e87d5b8ebcde4b28'\n'parentDescription': Broaden your knowledge and expand your JavaScript techniques and practices. From Angular, React, and WebAssembly, to the best JavaScript IDEs, open source tools and more, you’ll learn insights on everything JS from seasoned experts in their field. Keep up with JavaScript news, tips, and advice with interviews, tutorials, and in-depth articles.\n'indexBrandName': ''\n'indexSeriesName': ''\n'author': 'Manfred Steyer'\n'chunkSource': 'text'\n'text': for new code, which simplifies the codebase. Additionally, the new lightweight reactivity system trims down unnecessary complexity. With these changes, Angular feels as lightweight as the other frameworks. Ines Chargui: Signals has received so much momentum lately, can you explain what it is and why it is getting so much attention? Manfred Steyer: The idea of Signals is to provide a very simple, reactive building block that holds a value. The value can be changed and tracked, meaning that someone can find out when the value is changing and then they can react accordingly. This someone is first and foremost Angular itself because Angular needs to know when something is changed in order to trigger a rendering, updating your view and your components. But another consumer of this reactivity can be the application itself. The application can recalculate something every time something else changes. Both have advantages. Angular’s ability to detect exactly when and where data changes occur makes it more efficient, as it avoids the need for broad dirty checking across the entire application. It allows us to optimize the whole change detection. For instance, we can easily switch to the change detection strategy.OnPush. Think of it like an Excel sheet: when one value changes, all dependent values update automatically. You no longer need to manually manage updates like “if this changes, then update that.” It just stays in sync. Those are the big two advantages. Some people may argue that this isn’t entirely new, since RxJS and observables have long provided similar capabilities. And that’s true, everything you can currently do with Signals can also be achieved with RxJS. However, the main idea behind Signals is simplicity. They make common use cases easier to implement. They’re not as powerful as observables, but they’re more well-suited for new developers. Of course, if you’re implementing something more difficult and complex, you can still use RxJS. Ines Chargui: What initially drew you to Angular? How did your Angular journey begin? Manfred Steyer: I think it was sometime between 2010 and 2012 when I realized how valuable it is to get a lot of stuff out-of-the-box. Working in the JavaScript ecosystem at the time often meant combining several tools and technologies. Back then, I used Knockout.js for data binding, some jQuery libraries for UI, and had to rely on a completely separate tool set for testing—none of which felt particularly well. Eventually, I switched to AngularJS. Although AngularJS was a different framework from the modern Angular we know today, I soon started exploring Angular 2 while it was still in its early alpha and beta\n'slidetext': ''\n'from': 'vector'\n'score': 0.9335132241249084\n'normalizedScore': 0.9259128361264305\n'beforeDatePenaltyScore': 0.9335132241249084\n\n'documentId': 'af64d26c0f5fa509f9042a4b'\n'chunk_id': '690d25f4f6e2cc0012fef926'\n'access': 'restricted'\n'part_number': 40\n'total_parts': 51\n'contentType': 'FLEX_CAMP'\n'title': Woche 2: Angular Pipes, NgModules & Subkomponenten: Meistern Sie die fortgeschrittenen Angular-Konzepte (Lektionen 4, 5 & 6) | verfügbar bis 30.01.2026\n'parentName': Angular Camp - Flexible Basic Camp Januar 2026 | online\n'language': 'DE'\n'date': '2026-01-12T00:00:00.000Z'\n'abstract': Weiter geht es in die zweite Woche! Hier behandeln wir 3 Lektionen. In diesem Kursteil erlangen Sie tiefere Einblicke in die fortgeschrittenen Konzepte von Angular und lernen, wie Sie Pipes, NgModules und Subkomponenten effektiv einsetzen, um Ihre Anwendungen zu optimieren. 4. Lektion: Pipes: Datenformatierung mit eigener Hand: - Lernen Sie, wie Sie eigene Pipes entwickeln, um Daten im Zuge der Datenbindung zu transformieren. - Pure Pipes im Fokus: Verstehen Sie das Konzept der reinen Pipes und ihre Bedeutung für die Anwendungsperformance. - In diesem kurzen Kapitel erfahren Sie alles zur Entwicklung eigener Pipes für das Transformieren von Daten im Zuge der Datenbindung, zum Konzept der reinen Pipes (engl. pure pipes) und warum es für die Anwendungsperformance wichtig ist. 5. Lektion: NgModules & Standalone Components in Angular: Alt und neu im Einklang Auch wenn NgModules seit der Einführung von Standalone Components weniger wichtig sind, existieren noch zahlreiche Codestrecken und Bibliotheken, die darauf aufbauen. Deswegen beschäftigen wir uns hier mit dem Zusammenspiel dieser beiden Konzepte. - NgModules verstehen: Obwohl Standalone Components an Bedeutung gewinnen, bleiben NgModules relevant. Erfahren Sie, wie diese beiden Konzepte zusammenspielen. - Codestrecken und Bibliotheken meistern: Navigieren Sie souverän durch Codestrecken und Bibliotheken, die auf NgModules basieren. 6. Lektion: Angular Subkomponenten & Datenbindung Erweitern Sie Ihre Angular-Fähigkeiten und lernen Sie, wie Sie Subkomponenten und Datenbindung effektiv einsetzen, um komplexe und skalierbare Anwendungen zu erstellen. Hier erfahren Sie Wissenswertes über die Entwicklung weiterer Komponenten, die über Datenbindung miteinander kommunizieren. Dazu werfen wir auch einen genaueren Blick unter die Motorhaube von Angular, um die Datenbindung besser zu verstehen. - Data Binding im Detail - Components and Data Bindung - Event Bindings - Smart vs. Dumb Components - Life Cycle Hooks - Bonus: Signals Auch hier haben Sie die Möglichkeit Ihr Wissen praktisch anzuwenden: Zu den Übungen Wir empfehlen in der zweiten Woche diese Lektionen zu bearbeiten.\n'parentId': 'b1eb76f978c59032388f94ed'\n'parentDescription': Das Angular Training für Einsteiger:innen mit Manfred Steyer im zeitlich flexiblen Online-Format\n'indexBrandName': 'AngularCamp'\n'indexSeriesName': 'FlexibleBasicCamp'\n'author': 'Manfred Steyer'\n'chunkSource': 'text'\n'text': weiß man ganz genau, wo sich was geändert hat. Angular kann herausfinden, ah, die Komponente hat sich rechts unten geändert, also muss sich rechts unten aktualisieren und sonst nirgendwo. Das Ganze ist nicht ganz neu, oder? Wir haben ähnliche Mechanismen mit Observables, mit RxJS, mit Subjects. Ja, also sowas hat es schon zuvor gegeben. Allerdings sind Signals ganz bewusst sehr, sehr schlank implementiert. Sehr, sehr simpel. Die können wirklich nicht viel mehr als das hier. Andere Ansätze wie RxJS haben ganz, ganz viele Features und sind schon alleine deswegen nicht obsolet, aber das Ziel ist es halt, mit etwas Simplen zu starten. Und das Angular-Team glaubt, dass in den meisten Fällen diese simple Lösung ausreichend ist. Ja, und wenn ich halt mehr brauche, dann werde ich mir eine Library wie RxJS dazu installieren und habe dann mehr Komplexität, aber auch viel, viel mehr Features. Man möchte also die Standard-Fälle leicht, gewichtiger, einfacher gestalten. Wie schaut jetzt so eine Anwendung mit und ohne Signals aus? Na ja, starten wir vielleicht einmal mit der Variante ohne Signals. Sowas haben wir eh schon die ganze Zeit gemacht, da hat man Properties, die bekommen Werte. Die Werte werden vielleicht aktualisiert, weil ich aus dem Backend Daten abrufe und die Werte werden gebunden. Nach jedem Event-Handler prüft Angular, ob da jetzt da was zu aktualisieren ist. Ob die Schleife oder das If oder sonst irgendwas neu gerendert werden müssen. So schaut es klassischerweise aus. Wenn ich genau dasselbe mit Signals mache, dann muss ich halt alle Werte, die ich Daten binden möchte, in ein Signal einwickeln. Dazu gibt es die Hilfsfunktion Signal, die befindet sich seit Angular 16 im Namespace Angular Core. Da sieht man also schon, das Konzept ist ein integraler Bestandteil des Kerns von Angular. Die Funktion Signal kriegt einen Standardwert übergeben, Klammerauf, Klammerzu in dem Fall, also ein leeres Array. Und da Klammerauf, Klammerzu keine Typ-Informationen beinhaltet, gebe ich hier als Typparameter an, ich meine damit ein leeres Flugarray. Diesen Typparameter in den Spitzenklammern, den kann man sehr häufig weglassen, weil TypeScript sehr häufig aus dem Standardwert\n'slidetext': ''\n'from': 'vector'\n'score': 0.9222575426101685\n'normalizedScore': 0.9256754194518731\n'beforeDatePenaltyScore': 0.9222575426101685\n\n'documentId': '59c6dfa238c69ebd748cc7dc'\n'chunk_id': '69038857a7bbb00013e754e7'\n'access': 'restricted'\n'part_number': 1\n'total_parts': 1\n'contentType': 'RHEINGOLD'\n'title': Angular Signals: Neue Features für die reaktive Entwicklung\n'parentName': JavaScript Days Berlin und online 2025\n'language': 'DE'\n'date': '2025-10-22T11:30:00.000Z'\n'abstract': Angular Signals sind seit einiger Zeit ein spannender Bestandteil der reaktiven Entwicklung in Angular. Mit neuen Features wie linkedSignal() und resource() in Angular 20 rücken sie weiter in den Fokus. Doch wie funktionieren Signals und was macht sie so besonders – insbesondere in Bezug auf die Performance? Welche Vorteile bieten sie gegenüber klassischen RxJS-Patterns? Felix Schütz von Thinktecture gibt eine praxisnahe Einführung in Angular Signals und die damit verbundenen neuen Features und zeigt, wie sie die Entwicklung von modernen, reaktiven Anwendungen nachhaltig verändern. Zusätzlich gibt er einen Ausblick auf die geplante Unterstützung von Signal-basierten Formularen.\n'parentId': 'a233287a238c6e0ce3f91546'\n'parentDescription': 40 Workshops zu JavaScript, Angular, React, Typescript und KI\n'indexBrandName': 'JavaScriptDays'\n'indexSeriesName': 'Berlin'\n'author': 'Felix Wunderlich'\n'chunkSource': 'text'\n'text': Angular Signals: Neue Features für die reaktive Entwicklung Angular Signals sind seit einiger Zeit ein spannender Bestandteil der reaktiven Entwicklung in Angular. Mit neuen Features wie linkedSignal() und resource() in Angular 20 rücken sie weiter in den Fokus. Doch wie funktionieren Signals und was macht sie so besonders – insbesondere in Bezug auf die Performance? Welche Vorteile bieten sie gegenüber klassischen RxJS-Patterns? Felix Schütz von Thinktecture gibt eine praxisnahe Einführung in Angular Signals und die damit verbundenen neuen Features und zeigt, wie sie die Entwicklung von modernen, reaktiven Anwendungen nachhaltig verändern. Zusätzlich gibt er einen Ausblick auf die geplante Unterstützung von Signal-basierten Formularen.\n'slidetext': ''\n'from': 'vector'\n'score': 0.9251232147216797\n'normalizedScore': 0.9240741965862155\n'beforeDatePenaltyScore': 0.9251232147216797\n\n'documentId': 'e45840c0b8a784e3b3cf3be3'\n'chunk_id': '690211f50902850012f245ce'\n'access': 'granted'\n'part_number': 1\n'total_parts': 22\n'contentType': 'RHEINGOLD'\n'title': RxJS, Signals and Native Observables: What Now?\n'parentName': International JavaScript Conference Munich 2025\n'language': 'EN'\n'date': '2025-10-28T11:00:00.000Z'\n'abstract': Angular’s approach to reactivity is evolving. For years, RxJS was the standard. Then Signals introduced a simpler, framework-integrated model. Now, with Native Observables becoming part of the web platform, new questions arise: how do these pieces fit together? In this talk, we will explore the differences and common ground between RxJS and Native Observables, and examine what this means for the future of Angular and Signals. Beyond simple patterns like “events vs. state,” you will learn a practical model to decide when to use Signals, when Observables are more suitable, and where Signals are likely to replace them.\n'parentId': 'd9a5c0715a7cff50bbb51e14'\n'parentDescription': \n'indexBrandName': 'InternationalJavaScriptCon'\n'indexSeriesName': 'Munich'\n'author': 'Rainer Hahnekamp'\n'chunkSource': 'text'\n'text': RxJS, Signals and Native Observables: What Now? Angular’s approach to reactivity is evolving. For years, RxJS was the standard. Then Signals introduced a simpler, framework-integrated model. Now, with Native Observables becoming part of the web platform, new questions arise: how do these pieces fit together? In this talk, we will explore the differences and common ground between RxJS and Native Observables, and examine what this means for the future of Angular and Signals. Beyond simple patterns like “events vs. state,” you will learn a practical model to decide when to use Signals, when Observables are more suitable, and where Signals are likely to replace them. Then it's just the introduction, I just keep the introduction of myself. I just go directly to the first slide. So again. When signals came out, uh, we've been told signals are necessary to reach songless change detection. Nowadays we hope we have songless change detection and we know we don't have to use signals. That became clear quite soon, so after a few months of Ingula 16, uh, the Engler team switched their plan, and it was around Christmas where they said, There is now a roadmap, there is now a version to strategy for signals. We don't need it for soundless anymore. And then the question is, OK, why do we need to use them then? Uh, and then the answer was signals should make it much easier. So the the the simplification and developer experience, this is also one of the main points. But there is something else. Everyone was kind of asking, OK, and what is going to happen with RXGS. Um, if signals should become easier than RX chairs, then I don't need to use RX chairs anymore. And the other query answer was, no, uh, you still can use RX chairs. There are still some places where you are going to be, where you are going to use RX chairs, and in a way, Um, certain people or some people then said, well, maybe it is an option to to reach a situation one day where we don't need RX chairs, and this was something where in the beginning I always thought maybe it is possible to write an Engle application one day, but the way how things are currently evolving, I don't see it like this. There are a few reasons for that. First of all, we have an existing code base, so I can't just rewrite everything to signals and get rid of RXGS. Even now, we can't get rid of RXJS because it's it's just still in the API. But, but given we have\n'slidetext': ''\n'from': 'vector'\n'score': 0.9240995645523071\n'normalizedScore': 0.9233781719876192\n'beforeDatePenaltyScore': 0.9240995645523071\n\n'documentId': '69ab8ba6bfa5d1a198f998c3'\n'chunk_id': '690b0f2aeb0efe0012394f2b'\n'access': 'restricted'\n'part_number': 40\n'total_parts': 51\n'contentType': 'FLEX_CAMP'\n'title': Woche 2: Angular Pipes, NgModules & Subkomponenten: Meistern Sie die fortgeschrittenen Angular-Konzepte (Lektionen 4, 5 & 6) | verfügbar bis 30.11.2025\n'parentName': Angular Camp - Flexible Basic Camp November 2025 | online\n'language': 'DE'\n'date': '2025-11-10T00:00:00.000Z'\n'abstract': Weiter geht es in die zweite Woche! Hier behandeln wir 3 Lektionen. In diesem Kursteil erlangen Sie tiefere Einblicke in die fortgeschrittenen Konzepte von Angular und lernen, wie Sie Pipes, NgModules und Subkomponenten effektiv einsetzen, um Ihre Anwendungen zu optimieren. 4. Lektion: Pipes: Datenformatierung mit eigener Hand: - Lernen Sie, wie Sie eigene Pipes entwickeln, um Daten im Zuge der Datenbindung zu transformieren. - Pure Pipes im Fokus: Verstehen Sie das Konzept der reinen Pipes und ihre Bedeutung für die Anwendungsperformance. - In diesem kurzen Kapitel erfahren Sie alles zur Entwicklung eigener Pipes für das Transformieren von Daten im Zuge der Datenbindung, zum Konzept der reinen Pipes (engl. pure pipes) und warum es für die Anwendungsperformance wichtig ist. 5. Lektion: NgModules & Standalone Components in Angular: Alt und neu im Einklang Auch wenn NgModules seit der Einführung von Standalone Components weniger wichtig sind, existieren noch zahlreiche Codestrecken und Bibliotheken, die darauf aufbauen. Deswegen beschäftigen wir uns hier mit dem Zusammenspiel dieser beiden Konzepte. - NgModules verstehen: Obwohl Standalone Components an Bedeutung gewinnen, bleiben NgModules relevant. Erfahren Sie, wie diese beiden Konzepte zusammenspielen. - Codestrecken und Bibliotheken meistern: Navigieren Sie souverän durch Codestrecken und Bibliotheken, die auf NgModules basieren. 6. Lektion: Angular Subkomponenten & Datenbindung Erweitern Sie Ihre Angular-Fähigkeiten und lernen Sie, wie Sie Subkomponenten und Datenbindung effektiv einsetzen, um komplexe und skalierbare Anwendungen zu erstellen. Hier erfahren Sie Wissenswertes über die Entwicklung weiterer Komponenten, die über Datenbindung miteinander kommunizieren. Dazu werfen wir auch einen genaueren Blick unter die Motorhaube von Angular, um die Datenbindung besser zu verstehen. - Data Binding im Detail - Components and Data Bindung - Event Bindings - Smart vs. Dumb Components - Life Cycle Hooks - Bonus: Signals Auch hier haben Sie die Möglichkeit Ihr Wissen praktisch anzuwenden: Zu den Übungen Wir empfehlen in der zweiten Woche diese Lektionen zu bearbeiten.\n'parentId': '7a76c5fc628bffdcec626f4e'\n'parentDescription': Das Angular Training für Einsteiger:innen mit Manfred Steyer im zeitlich flexiblen Online-Format\n'indexBrandName': 'AngularCamp'\n'indexSeriesName': 'FlexibleBasicCamp'\n'author': 'Manfred Steyer'\n'chunkSource': 'text'\n'text': weiß man ganz genau, wo sich was geändert hat. Angular kann herausfinden, ah, die Komponente hat sich rechts unten geändert, also muss sich rechts unten aktualisieren und sonst nirgendwo. Das Ganze ist nicht ganz neu, oder? Wir haben ähnliche Mechanismen mit Observables, mit RxJS, mit Subjects. Ja, also sowas hat es schon zuvor gegeben. Allerdings sind Signals ganz bewusst sehr, sehr schlank implementiert. Sehr, sehr simpel. Die können wirklich nicht viel mehr als das hier. Andere Ansätze wie RxJS haben ganz, ganz viele Features und sind schon alleine deswegen nicht obsolet, aber das Ziel ist es halt, mit etwas Simplen zu starten. Und das Angular-Team glaubt, dass in den meisten Fällen diese simple Lösung ausreichend ist. Ja, und wenn ich halt mehr brauche, dann werde ich mir eine Library wie RxJS dazu installieren und habe dann mehr Komplexität, aber auch viel, viel mehr Features. Man möchte also die Standard-Fälle leicht, gewichtiger, einfacher gestalten. Wie schaut jetzt so eine Anwendung mit und ohne Signals aus? Na ja, starten wir vielleicht einmal mit der Variante ohne Signals. Sowas haben wir eh schon die ganze Zeit gemacht, da hat man Properties, die bekommen Werte. Die Werte werden vielleicht aktualisiert, weil ich aus dem Backend Daten abrufe und die Werte werden gebunden. Nach jedem Event-Handler prüft Angular, ob da jetzt da was zu aktualisieren ist. Ob die Schleife oder das If oder sonst irgendwas neu gerendert werden müssen. So schaut es klassischerweise aus. Wenn ich genau dasselbe mit Signals mache, dann muss ich halt alle Werte, die ich Daten binden möchte, in ein Signal einwickeln. Dazu gibt es die Hilfsfunktion Signal, die befindet sich seit Angular 16 im Namespace Angular Core. Da sieht man also schon, das Konzept ist ein integraler Bestandteil des Kerns von Angular. Die Funktion Signal kriegt einen Standardwert übergeben, Klammerauf, Klammerzu in dem Fall, also ein leeres Array. Und da Klammerauf, Klammerzu keine Typ-Informationen beinhaltet, gebe ich hier als Typparameter an, ich meine damit ein leeres Flugarray. Diesen Typparameter in den Spitzenklammern, den kann man sehr häufig weglassen, weil TypeScript sehr häufig aus dem Standardwert\n'slidetext': ''\n'from': 'vector'\n'score': 0.9222575426101685\n'normalizedScore': 0.9222233646573527\n'beforeDatePenaltyScore': 0.9222575426101685\n\n'documentId': '86a43d1e179681ee6a344c28'\n'chunk_id': '690210a20902850012f24510'\n'access': 'granted'\n'part_number': 1\n'total_parts': 1\n'contentType': 'RHEINGOLD'\n'title': Workshop: Modern Angular Architectures with Signals, Resource API, and the New NgRx Signal Store\n'parentName': International JavaScript Conference Munich 2025\n'language': 'EN'\n'date': '2025-10-31T08:00:00.000Z'\n'abstract': In this interactive workshop, we use Angular's latest features to build a modern and maintainable architecture for large applications. We start with a sustainable project setup using Nx with Module Boundaries and Sheriff. We continue with integrating Signals that will shape the future of the framework and leverage the new Resource API including the httpResource for establishing a reactive design. Then, we use the brand-new NGRX Signal Store to establish modern and lightweight state management. In the end, you will know how you can use the individual tools to design modern and, above all, long-term maintainable Angular architectures.\n'parentId': 'd9a5c0715a7cff50bbb51e14'\n'parentDescription': \n'indexBrandName': 'InternationalJavaScriptCon'\n'indexSeriesName': 'Munich'\n'author': 'Manfred Steyer,Michael Egger-Zikes'\n'chunkSource': 'text'\n'text': Workshop: Modern Angular Architectures with Signals, Resource API, and the New NgRx Signal Store In this interactive workshop, we use Angular's latest features to build a modern and maintainable architecture for large applications. We start with a sustainable project setup using Nx with Module Boundaries and Sheriff. We continue with integrating Signals that will shape the future of the framework and leverage the new Resource API including the httpResource for establishing a reactive design. Then, we use the brand-new NGRX Signal Store to establish modern and lightweight state management. In the end, you will know how you can use the individual tools to design modern and, above all, long-term maintainable Angular architectures.\n'slidetext': ''\n'from': 'vector'\n'score': 0.9218511581420898\n'normalizedScore': 0.9212872998239772\n'beforeDatePenaltyScore': 0.9218511581420898\n\n'documentId': '0747f0655ef3790a97eba95b'\n'chunk_id': '68f24b683134c10012c3d12d'\n'access': 'restricted'\n'part_number': 2\n'total_parts': 16\n'contentType': 'RHEINGOLD'\n'title': How to architect Angular apps in 2025\n'parentName': International JavaScript New York 2025\n'language': 'EN'\n'date': '2025-10-01T08:15:00.000Z'\n'abstract': In this talk, Alain showcases several architecture concepts he uses to optimize apps for performance, readability, and scalability in 2025 and beyond. We’ll touch on using Signals as state in our services, how to control access to such Signals, using the new resource API, and more!\n'parentId': '9f97d5cdc68d72a05f834df4'\n'parentDescription': The JavaScript Fullstack Conference - Angular, Node.js, React and more\n'indexBrandName': 'InternationalJavaScriptCon'\n'indexSeriesName': 'NewYork'\n'author': 'Alain Chautard'\n'chunkSource': 'text'\n'text': done all continents except Antarctica because that's, that's tricky to, to find an audience there, but that's okay. So as I told you earlier, angular, and as you probably know, there's been a lot of things changing lately in the past two, three years, even more. It really started with signals version 16, and then everything kind of became crazy and faster in terms of pace of change. So I listed some of the main things that changed here. Uh, starting at V 14. We got standalone components 16, angular signals 17, the new control flow blocks, uh, 19 HTP resource V 20 is on as is stable. And V 21 coming soon, we we're gonna have signal forms. So that's a lot. And you can write Angular code today that looks nothing like what it would look like five years ago. Well, you, you'll still recognize things, but you can do things in a way that's completely different. So we'll see why these changes are happening, what's the motivation behind this and what the impact on our code and on, you know, what we, what we're supposed to do with this. So the main idea of the Angular team was really to make Angular easier to learn, easier to understand, easier to maintain. 'cause the thing is, this is an Angular talk. If you go to a React talk, there's gonna be more people. And the fact of the matter is, is that React has always advertised itself as the easier option, right? Easier to learn. It's fast. It's like jQuery, just add something, you can use it, blah, blah, blah. So Angular lasts a lot of audience to react because of that, mostly on kind of reputation I would say. But, um, and so that perceived difficulty is something that the Angular team is trying to fight against and say, no, angular is not that difficult. And so all of the things that's changed since V 14 are really going into that idea of, well, angular is actually easy to learn. We don't need to know that much about RXJS. You don't need to know about all of these extra things. You can start with the basics. So one of the things that started in the 14 was NG modules, right? Angular modules. It's one of the things that if you come into the Angular world, you're like, why do we have that? React doesn't have that view, doesn't have that. Why do we have NG modules in Angular? So standalone fixes that we remove NG modules pretty much, and you can just do your thing like you would do with other\n'slidetext': ''\n'from': 'vector'\n'score': 0.923045814037323\n'normalizedScore': 0.9208386908790277\n'beforeDatePenaltyScore': 0.923045814037323\n\n'documentId': '18e1984b93f7b81b65afb3ad'\n'chunk_id': '69020ea2a5de460012a1ae9a'\n'access': 'granted'\n'part_number': 1\n'total_parts': 19\n'contentType': 'RHEINGOLD'\n'title': Rethinking Angular: The Future with Signals and the New Resource API\n'parentName': International JavaScript Conference Munich 2025\n'language': 'EN'\n'date': '2025-10-28T11:00:00.000Z'\n'abstract': Angular is on the brink of a fundamental paradigm shift: with Signals and the new Resource API, declarative programming moves to the forefront. This transformation not only requires a new mindset for state management, but also for how modern applications are structured. In this talk, we’ll explore how Angular’s new reactivity foundation changes the way Angular solutions are built. We’ll look at common architectural patterns using Signals and the Resource API, explain how the new NgRx Signal Store can be used for state management, and show what an architecture looks like that embraces reactivity and data flow over imperative code blocks. The goal is to foster a deeper understanding of these new concepts — and to equip you with concrete tools and structures to make your Angular architectures not only modern, but also maintainable and scalable in the long term.\n'parentId': 'd9a5c0715a7cff50bbb51e14'\n'parentDescription': \n'indexBrandName': 'InternationalJavaScriptCon'\n'indexSeriesName': 'Munich'\n'author': 'Manfred Steyer'\n'chunkSource': 'text'\n'text': Rethinking Angular: The Future with Signals and the New Resource API Angular is on the brink of a fundamental paradigm shift: with Signals and the new Resource API, declarative programming moves to the forefront. This transformation not only requires a new mindset for state management, but also for how modern applications are structured. In this talk, we’ll explore how Angular’s new reactivity foundation changes the way Angular solutions are built. We’ll look at common architectural patterns using Signals and the Resource API, explain how the new NgRx Signal Store can be used for state management, and show what an architecture looks like that embraces reactivity and data flow over imperative code blocks. The goal is to foster a deeper understanding of these new concepts — and to equip you with concrete tools and structures to make your Angular architectures not only modern, but also maintainable and scalable in the long term. Come When we usually think about our source code, we think about it in terms of a script, a script like when playing theater, a script that tells us what to do when, or to put it in another way, this is more of a control flow centric perspective. This is completely fine, however, if you really want to succeed with signals in Angular, then you need to succeed with reactive programming. And if you want to succeed with reactive programming, you need to switch your thinking. In this case you need to think more about the application of as a marble run, a marble run where several marbles are going through. Those marbles represent the data in your system, the state, and the state in turn is represented by signals. And now sometimes a marble can be split to several marbles, and sometimes several marbles can be combined to one marble. This is what we usually do with computed or with the resource API. If you manage to switch over to this perspective, to this more data flow centric perspective, then you are more likely to succeed with this new way of programming. Because here is the story. When I started with signals in one of the early preview versions, I had the impression, oh, a signal is so cute. It is just an object with gathers and setters. And yeah, this is true technology wise. However, if you don't switch your thinking towards a marble run, towards a more data flow centric perspective, then you will have to swim across the stream. That means you need to work against the design of this entire API and this causes a lot of pain. So the big question is how to switch over to a more data flow centric design\n'slidetext': ''\n'from': 'vector'\n'score': 0.9207788109779358\n'normalizedScore': 0.9200574184132478\n'beforeDatePenaltyScore': 0.9207788109779358\n\n'documentId': 'bc0bef25841c96486c56f58f'\n'chunk_id': '6876da63225e92fc1ac7c2dc'\n'access': 'restricted'\n'part_number': 44\n'total_parts': 56\n'contentType': 'FLEX_CAMP'\n'title': Woche 2: Angular Pipes, NgModules & Subkomponenten: Meistern Sie die fortgeschrittenen Angular-Konzepte (Lektionen 4, 5 & 6) | verfügbar bis 28.09.2025\n'parentName': Angular Camp - Flexible Basic Camp September 2025 | online\n'language': 'DE'\n'date': '2025-09-07T23:00:00.000Z'\n'abstract': Weiter geht es in die zweite Woche! Hier behandeln wir 3 Lektionen. In diesem Kursteil erlangen Sie tiefere Einblicke in die fortgeschrittenen Konzepte von Angular und lernen, wie Sie Pipes, NgModules und Subkomponenten effektiv einsetzen, um Ihre Anwendungen zu optimieren. 4. Lektion: Pipes: Datenformatierung mit eigener Hand: - Lernen Sie, wie Sie eigene Pipes entwickeln, um Daten im Zuge der Datenbindung zu transformieren. - Pure Pipes im Fokus: Verstehen Sie das Konzept der reinen Pipes und ihre Bedeutung für die Anwendungsperformance. - In diesem kurzen Kapitel erfahren Sie alles zur Entwicklung eigener Pipes für das Transformieren von Daten im Zuge der Datenbindung, zum Konzept der reinen Pipes (engl. pure pipes) und warum es für die Anwendungsperformance wichtig ist. 5. Lektion: NgModules & Standalone Components in Angular: Alt und neu im Einklang Auch wenn NgModules seit der Einführung von Standalone Components weniger wichtig sind, existieren noch zahlreiche Codestrecken und Bibliotheken, die darauf aufbauen. Deswegen beschäftigen wir uns hier mit dem Zusammenspiel dieser beiden Konzepte. - NgModules verstehen: Obwohl Standalone Components an Bedeutung gewinnen, bleiben NgModules relevant. Erfahren Sie, wie diese beiden Konzepte zusammenspielen. - Codestrecken und Bibliotheken meistern: Navigieren Sie souverän durch Codestrecken und Bibliotheken, die auf NgModules basieren. 6. Lektion: Angular Subkomponenten & Datenbindung Erweitern Sie Ihre Angular-Fähigkeiten und lernen Sie, wie Sie Subkomponenten und Datenbindung effektiv einsetzen, um komplexe und skalierbare Anwendungen zu erstellen. Hier erfahren Sie Wissenswertes über die Entwicklung weiterer Komponenten, die über Datenbindung miteinander kommunizieren. Dazu werfen wir auch einen genaueren Blick unter die Motorhaube von Angular, um die Datenbindung besser zu verstehen. - Data Binding im Detail - Components and Data Bindung - Event Bindings - Smart vs. Dumb Components - Life Cycle Hooks - Bonus: Signals Auch hier haben Sie die Möglichkeit Ihr Wissen praktisch anzuwenden: Zu den Übungen Wir empfehlen in der zweiten Woche diese Lektionen zu bearbeiten.\n'parentId': 'a22478b5a24a40c79edc21dd'\n'parentDescription': Das Angular Training für Einsteiger:innen mit Manfred Steyer im zeitlich flexiblen Online-Format\n'indexBrandName': 'AngularCamp'\n'indexSeriesName': 'FlexibleBasicCamp'\n'author': 'Manfred Steyer'\n'chunkSource': 'text'\n'text': geändert hat. Angular kann herausfinden, ah, die Komponente hat sich rechts unten geändert, also muss sich rechts unten aktualisieren und sonst nirgendwo. Das Ganze ist nicht ganz neu, oder? Wir haben ähnliche Mechanismen mit Observables, mit RxJS, mit Subjects. Ja, also sowas hat es schon zuvor gegeben. Allerdings sind Signals ganz bewusst sehr, sehr schlank implementiert. Sehr, sehr simpel. Die können wirklich nicht viel mehr als das hier. Andere Ansätze wie RxJS haben ganz, ganz viele Features und sind schon alleine deswegen nicht obsolet, aber das Ziel ist es halt, mit etwas Simplen zu starten. Und das Angular-Team glaubt, dass in den meisten Fällen diese simple Lösung ausreichend ist. Ja, und wenn ich halt mehr brauche, dann werde ich mir eine Library wie RxJS dazu installieren und habe dann mehr Komplexität, aber auch viel, viel mehr Features. Man möchte also die Standard-Fälle leicht, gewichtiger, einfacher gestalten. Wie schaut jetzt so eine Anwendung mit und ohne Signals aus? Na ja, starten wir vielleicht einmal mit der Variante ohne Signals. Sowas haben wir eh schon die ganze Zeit gemacht, da hat man Properties, die bekommen Werte. Die Werte werden vielleicht aktualisiert, weil ich aus dem Backend Daten abrufe und die Werte werden gebunden. Nach jedem Event-Handler prüft Angular, ob da jetzt da was zu aktualisieren ist. Ob die Schleife oder das If oder sonst irgendwas neu gerendert werden müssen. So schaut es klassischerweise aus. Wenn ich genau dasselbe mit Signals mache, dann muss ich halt alle Werte, die ich Daten binden möchte, in ein Signal einwickeln. Dazu gibt es die Hilfsfunktion Signal, die befindet sich seit Angular 16 im Namespace Angular Core. Da sieht man also schon, das Konzept ist ein integraler Bestandteil des Kerns von Angular. Die Funktion Signal kriegt einen Standardwert übergeben, Klammerauf, Klammerzu in dem Fall, also ein leeres Array. Und da Klammerauf, Klammerzu keine Typ-Informationen beinhaltet, gebe ich hier als Typparameter an, ich meine damit ein leeres Flugarray. Diesen Typparameter in den Spitzenklammern, den kann man sehr häufig weglassen, weil TypeScript sehr häufig aus dem Standardwert den Datentyp ableiten kann. Beim Array\n'slidetext': ''\n'from': 'vector'\n'score': 0.921909749507904\n'normalizedScore': 0.9184212336555448\n'beforeDatePenaltyScore': 0.921909749507904\n\n'documentId': 'a46f583e86ab963aed1784a1'\n'chunk_id': '68a457709f706f00135a4801'\n'access': 'granted'\n'part_number': 1\n'total_parts': 20\n'contentType': 'RHEINGOLD'\n'title': Master Angular Signals in your existing Codebase\n'parentName': iJS San Diego 2025\n'language': 'EN'\n'date': '2025-05-20T12:30:00.000Z'\n'abstract': Angular Signals bring a fresh perspective to our codebases and introduce a fundamentally simple API. However, implementing a Signal-based application requires a slightly different approach compared to traditional methods. Reactive Design principles and immutable data structures necessitate adjusted strategies but offer numerous benefits in terms of managing state and enhancing Performance. Component implementations are undergoing a transformation that makes the use of lifecycle hook methods increasingly obsolete. In this talk, we will explore how to successfully implement a scalable frontend architecture using Signals. Attendees will leave the session equipped with a comprehensive toolbox to transform their enterprise codebase into the new Angular paradigm.\n'parentId': 'dd29929140400f153a277e50'\n'parentDescription': The Fullstack Conference for JS Development\n'indexBrandName': 'InternationalJavaScriptCon'\n'indexSeriesName': 'SanDiego'\n'author': 'Michael Egger-Zikes'\n'chunkSource': 'text'\n'text': Master Angular Signals in your existing Codebase Angular Signals bring a fresh perspective to our codebases and introduce a fundamentally simple API. However, implementing a Signal-based application requires a slightly different approach compared to traditional methods. Reactive Design principles and immutable data structures necessitate adjusted strategies but offer numerous benefits in terms of managing state and enhancing Performance. Component implementations are undergoing a transformation that makes the use of lifecycle hook methods increasingly obsolete. In this talk, we will explore how to successfully implement a scalable frontend architecture using Signals. Attendees will leave the session equipped with a comprehensive toolbox to transform their enterprise codebase into the new Angular paradigm. Uh, so, uh, thanks for joining my talk today. Um, I hope you are excited, um, to get some updates about the angular signals. It's quite an interesting, thanks for closing the door. Um, it's quite an interesting API, um, and it's an API, to be honest, that was not invented by Angular team, right? So, uh, it's from the Angular, not the angular ecosystem, but the JavaScript ecosystem, uh, from a guy, a brilliant guy called Ryan Canto. So let's dive into that. Uh, we want to take a look, uh, at an existing angular code base and how, uh, we can turn that code base into signal usage because it's not, uh, a one-to-one translation that you can do with s schematics directly. So, for example, the new template syn with the ad symbol. That's a quite nice transition because you can just activate the schematics and you're good to go. It can convert your code base almost a hundred percent. Just the track information is necessary to be updated. Typically, um, the rest can be done automatically. It's not that way with angular signals because we are talking about and reactive a reactive API. And if we turn an application that is maybe at the moment not that reactive into the reactive design world, things, uh, need to change. Maybe you're thinking on how to, uh, implement that component might shift a little bit. Let's take a look, um, into what we will talk about, uh, the reactive primitive, uh, on how to use this, uh, signal reactive primitive, uh, so built in implementation inside the angle of framework, the core package, how we can use that in the templates, how we can use it in side effects. Um, we'll take a look at other signal APIs like, uh, input and model that's quite nice for, uh, binding support property bindings, uh, two-way bindings. All of that can\n'slidetext': ''\n'from': 'vector'\n'score': 0.9276810884475708\n'normalizedScore': 0.9181412027321979\n'beforeDatePenaltyScore': 0.9276810884475708\n\n'documentId': '0747f0655ef3790a97eba95b'\n'chunk_id': '68f24b683134c10012c3d131'\n'access': 'restricted'\n'part_number': 6\n'total_parts': 16\n'contentType': 'RHEINGOLD'\n'title': How to architect Angular apps in 2025\n'parentName': International JavaScript New York 2025\n'language': 'EN'\n'date': '2025-10-01T08:15:00.000Z'\n'abstract': In this talk, Alain showcases several architecture concepts he uses to optimize apps for performance, readability, and scalability in 2025 and beyond. We’ll touch on using Signals as state in our services, how to control access to such Signals, using the new resource API, and more!\n'parentId': '9f97d5cdc68d72a05f834df4'\n'parentDescription': The JavaScript Fullstack Conference - Angular, Node.js, React and more\n'indexBrandName': 'InternationalJavaScriptCon'\n'indexSeriesName': 'NewYork'\n'author': 'Alain Chautard'\n'chunkSource': 'text'\n'text': want to synchronize the state of our data with the state of our components, what's displayed on the screen, because that's really what it is. Data changed, let's synchronize our components done. So that looks better, right? Than what we started from. But the thing is, if we want this, we have to use signals and we have to use them pretty much everywhere, right? But the good news is Angular is helping with that. And there's a lot of things that have been happening lately to go, well, you know, go, go already all the way in that direction. So, um, signal based components, you probably notice that, uh, inputs, outputs, model, all of the content queries like future child content, child, all of these things. Now you have functions like input and model and all of these that replace the, the old decorators. And that's because all of these are signal based so that you can start using signals all over the place. And the good news about that is you don't have to do the migration manually. There's actually migration command to help. So if I go to angular dev, uh, I think it's here in the reference migrations can make this a little bit bigger, but, uh, migrating to standalone versus comments of that migrating the new control flow, you can do that, uh, migrating to the new inputs or outputs APIs or queries or signals versus migration for that, which are, you know, the, the angular CLI comments that we're familiar with. So if you want to migrate to the new single inputs NG generate angular core signal input, migration, and it's gonna go through all of your decorators, replay them with input signals, and then, you know, do all the right things to make it happen. So nice and easy takes one minute, maximum less if you copy paste from here. So yeah, that helps really getting, you know, into that signal based approach as much as possible. And, um, and yeah, starting migrating step by step. Now, the thing is, if you start doing that, at some point you still need RXJS. You, you still have an HDB client, you still have some router APIs or forms where you have to subscribe to our observables, right? The, the current way to remove that part is to use to signal. So this two signal function, it's actually came about at the same time as a signal, API in Anglo 16 in developer preview, and now it's stable. And so you can use it to convert any observable into a signal. So all of the places where you think, oh, here, I\n'slidetext': ''\n'from': 'vector'\n'score': 0.9202964305877686\n'normalizedScore': 0.9180893074294733\n'beforeDatePenaltyScore': 0.9202964305877686\n\n'documentId': '0747f0655ef3790a97eba95b'\n'chunk_id': '68f24b693134c10012c3d13d'\n'access': 'restricted'\n'part_number': 2\n'total_parts': 2\n'contentType': 'RHEINGOLD'\n'title': How to architect Angular apps in 2025\n'parentName': International JavaScript New York 2025\n'language': 'EN'\n'date': '2025-10-01T08:15:00.000Z'\n'abstract': In this talk, Alain showcases several architecture concepts he uses to optimize apps for performance, readability, and scalability in 2025 and beyond. We’ll touch on using Signals as state in our services, how to control access to such Signals, using the new resource API, and more!\n'parentId': '9f97d5cdc68d72a05f834df4'\n'parentDescription': The JavaScript Fullstack Conference - Angular, Node.js, React and more\n'indexBrandName': 'InternationalJavaScriptCon'\n'indexSeriesName': 'NewYork'\n'author': 'Alain Chautard'\n'chunkSource': 'slidetext'\n'text': \n'slidetext': 'toSignal and toObservable ●One key difference between Observables and Signals is that Signals are synchronous and always return a value immediately (like a BehaviorSubject) ●As a result, if you don’t want to get undefined values, you can set an initialValue when creating a Signal: ● 21 Resources ●httpResource is also experimental, but it’s the way to think about how to replace the HttpClient in the future: ●No more visible RxJs, no subscription, no operator ● 22 DEMO - Signal-based code Impact on architecture 2) Lazy-loading How an Angular application gets loaded index.html (2-3 kb) main.js (20 MB) What happens when we use lazy-loading index.html (2-3 kb) main.js (10 MB) cart.js (5 MB) loaded later when needed checkout.js (5 MB) loaded later when needed Multiple different chunks Lazy-loading comes with lots of options Typically router-based •NgModules or components get loaded when a given route gets activated (loading on demand) Can use preloading •Angular can download extra chunks in the background once main chunk is loaded Can be done within a single component •Lazy-load portions of the page that will be displayed later (scrolling) Defer Block ●Allows deferred loading of components, directives, and pipes, including CSS: DEMO - Lazy-loading architecture Conclusion - Key takeaways ●Use Signals - everywhere! ●Replace HttpClient with httpResource ●Use and share Signals from services ●Replace old directives with new blocks (automated migration) ●Use lazy-loading with standalone components and/or @defer What you’ll get: ●More performant, easier to read code ●Less boilerplate syntax 30 Want to showcase your Angular skills? https://certificates.dev/angular Thanks for your attention Email: al@interstate21.com https://blog.angulartraining.com Check out our certification exam at: https://certificates.dev/angular Coupon code: IJCNY25 for $25 off'\n'from': 'vector'\n'score': 0.9199877977371216\n'normalizedScore': 0.9177806745788263\n'beforeDatePenaltyScore': 0.9199877977371216\n\n'documentId': 'a527c16f5bc7b4da1bc88ab0'\n'chunk_id': '68f251653134c10012c3d1fb'\n'access': 'restricted'\n'part_number': 2\n'total_parts': 15\n'contentType': 'RHEINGOLD'\n'title': Angular Resources: Everything you need to know\n'parentName': International JavaScript New York 2025\n'language': 'EN'\n'date': '2025-10-01T12:45:00.000Z'\n'abstract': Discover how game changing Angular Resources will be for your Angular applications. We'll dive into what Angular Resources are, why they matter, and how they can replace most RxJs code in your Angular applications. We’ll see how to use resources for cleaner, more concise code. A perfect talk for those looking to level up their Angular skills and stay ahead with the latest features.\n'parentId': '9f97d5cdc68d72a05f834df4'\n'parentDescription': The JavaScript Fullstack Conference - Angular, Node.js, React and more\n'indexBrandName': 'InternationalJavaScriptCon'\n'indexSeriesName': 'NewYork'\n'author': 'Alain Chautard'\n'chunkSource': 'text'\n'text': so just a little bit later, and it's still experimental right now. So these are the, the three main features, functions, resource, RX resource, and HDDP resource. Um, so everything is still experimental, but very likely to become stable very soon. And interestingly enough, because I'm an old Angular GS guy, I can go back to the Angular GS documentation. Back in the day, there was a dollar resource, which was a little bit different from the resource we have in Angular right now, but the idea was very much the same. It was to give us an API around how to interact with a server, right? And back then there was no observer. It was all about promises. So it was basically this dollar resource function that you would pass a URL and some parameters, and then you would be able to do things and, and interact with the backend through simple functions. So the idea of what's, uh, what angular resources do now in Angular 20 is a little bit similar and also a little bit different. So we'll, we'll see that. So the first way that it's different is that it's all about signals. Um, so Angular is evolving from its default change detection, where basically anything would get angular to detect changes and, and try to render its components. So any click, any timeout, any HDP request that happens would just say, Hey, check, check your stuff, right? Um, we had a small optimization, we still have it, yes, on push to make things, uh, smarter about change detection and, and the fact that Angular would now have a little bit more insight that, oh, you change an input here, so I'm gonna check that component. But if a component inputs doesn't change and that component is un push, then angular just gonna assume, oh, the inputs haven't changed, so I'm not gonna refresh that component. And now we have signals where with the signal, angular knows exactly what changes and where, what are the consequences of that change, which is true for components, but also true for other signals, right? Um, the idea is when you use a signal, angular knows about what anything, any code that depends on it, right? It, it builds a dependency graph on, on those signals and knows exactly what depends on, um, on these signals. So when you change the value, everything that needs to change as a result is just known. And so it can happen quickly. And so along with signal scheme, a whole bunch of new functions, features like components, inputs, outputs, can all be signal based. Now, models, um, content\n'slidetext': ''\n'from': 'vector'\n'score': 0.9191646575927734\n'normalizedScore': 0.9169678084070809\n'beforeDatePenaltyScore': 0.9191646575927734\n\n'documentId': '01a63ca630515849aaa314b1'\n'chunk_id': '6876e25c51ca701363239b74'\n'access': 'restricted'\n'part_number': 1\n'total_parts': 1\n'contentType': 'RHEINGOLD'\n'title': Angular Signals: Neue Features für die reaktive Entwicklung\n'parentName': JavaScript Days München und online 2025\n'language': 'DE'\n'date': '2025-03-19T12:30:00.000Z'\n'abstract': Angular Signals sind seit einiger Zeit ein spannender Bestandteil der reaktiven Entwicklung in Angular. Mit neuen Features wie linkedSignal() und resource() in Angular 19 rücken sie weiter in den Fokus. Doch wie funktionieren Signals und was macht sie so besonders – insbesondere in Bezug auf die Performance? Welche Vorteile bieten sie gegenüber klassischen RxJS-Patterns?Felix Schütz von Thinktecture gibt eine praxisnahe Einführung in Angular Signals und die damit verbundenen neuen Features und zeigt, wie sie die Entwicklung von modernen, reaktiven Anwendungen nachhaltig verändern. Zusätzlich gibt er einen Ausblick auf die geplante Unterstützung von Signal-basierten Formularen.\n'parentId': 'efd4ff41c4b9e889b50854b8'\n'parentDescription': 40 Workshops zu JavaScript, Angular, React, HTML & CSS und KI\n'indexBrandName': 'JavaScriptDays'\n'indexSeriesName': 'Munich'\n'author': 'Felix Schütz'\n'chunkSource': 'text'\n'text': Angular Signals: Neue Features für die reaktive Entwicklung Angular Signals sind seit einiger Zeit ein spannender Bestandteil der reaktiven Entwicklung in Angular. Mit neuen Features wie linkedSignal() und resource() in Angular 19 rücken sie weiter in den Fokus. Doch wie funktionieren Signals und was macht sie so besonders – insbesondere in Bezug auf die Performance? Welche Vorteile bieten sie gegenüber klassischen RxJS-Patterns?Felix Schütz von Thinktecture gibt eine praxisnahe Einführung in Angular Signals und die damit verbundenen neuen Features und zeigt, wie sie die Entwicklung von modernen, reaktiven Anwendungen nachhaltig verändern. Zusätzlich gibt er einen Ausblick auf die geplante Unterstützung von Signal-basierten Formularen.\n'slidetext': ''\n'from': 'vector'\n'score': 0.9263350367546082\n'normalizedScore': 0.9133978907652627\n'beforeDatePenaltyScore': 0.9263350367546082\n\n'documentId': 'a46f583e86ab963aed1784a1'\n'chunk_id': '68a457709f706f00135a4802'\n'access': 'granted'\n'part_number': 2\n'total_parts': 20\n'contentType': 'RHEINGOLD'\n'title': Master Angular Signals in your existing Codebase\n'parentName': iJS San Diego 2025\n'language': 'EN'\n'date': '2025-05-20T12:30:00.000Z'\n'abstract': Angular Signals bring a fresh perspective to our codebases and introduce a fundamentally simple API. However, implementing a Signal-based application requires a slightly different approach compared to traditional methods. Reactive Design principles and immutable data structures necessitate adjusted strategies but offer numerous benefits in terms of managing state and enhancing Performance. Component implementations are undergoing a transformation that makes the use of lifecycle hook methods increasingly obsolete. In this talk, we will explore how to successfully implement a scalable frontend architecture using Signals. Attendees will leave the session equipped with a comprehensive toolbox to transform their enterprise codebase into the new Angular paradigm.\n'parentId': 'dd29929140400f153a277e50'\n'parentDescription': The Fullstack Conference for JS Development\n'indexBrandName': 'InternationalJavaScriptCon'\n'indexSeriesName': 'SanDiego'\n'author': 'Michael Egger-Zikes'\n'chunkSource': 'text'\n'text': can be done with signal APIs as well. Uh, also the so-called, uh, view queries. So view queries is maybe a term that was not, uh, has not been that present, uh, until the signal APIs were introduced. Uh, we are basically talking about few child, uh, few children, content child, content children that's reactive right now as well. So quite nice because you know, the Anglo community, maybe you as well. Um, we always strived for having reactive APIs, uh, for inputs, uh, for quite a while. I would say since Anglo two, uh, quite a lot of people dreamed about having a reactive API to get notified when an input changes. Um, so at the beginning everyone thought this is likely, uh, if ever provided it will be provided naturally with Rx js. But, uh, now we have a different reactive API that is directly built into the framework. Uh, we'll also talk about the linked signal. Um, that was an API that was introduced later with Anglo 19, and it helps us to have a kind of derived state with the right able state in combination so we can connect one signal to another signal without an uh, effect. Um, they are also quite nice APIs, uh, that we already received, and some of them will even turn, uh, into the stable, uh, status with, uh, angular 20. Now, uh, we're talking about APIs on how, uh, we can inter have the interoperability between RX js and angular signals because we have the traditional API already, uh, RX JS is a mandatory dependency since, since Angola two. Uh, so why not, uh, taking the strand of both APIs, the power of operators, and the power of custom behavior of RX JS together with the signal API. Um, moreover, we received those with Angola 19 and the feature releases of Anglo 19, uh, an nice a p called resource, uh, different resource APIs where you even can connect directly to your, uh, h TT P backend. And finally, brand new the NJX signal store with the NTPI. So meanwhile, uh, the signal store that was, uh, introduced last year, um, can also act, uh, as a red flag to be fully precise, uh, flux lag API. So if you love to have an event based state management, uh, the new event based API of the signal store is, uh, the correct API for you. Fine. Uh, my name is Michael, uh, funda, ma Complicated last la last name, so you can forget about that. I'm, uh, part of the Angular architect, um, consulting\n'slidetext': ''\n'from': 'vector'\n'score': 0.9225736260414124\n'normalizedScore': 0.9130337403260395\n'beforeDatePenaltyScore': 0.9225736260414124\n\n'documentId': '68fe3d9fc389515d1d6bea43'\n'chunk_id': '6876d50f225e92fc1ac7a4ec'\n'access': 'granted'\n'part_number': 1\n'total_parts': 6\n'contentType': 'COURSE'\n'title': Professional Tips for Using Signals in Angular\n'parentName': Advanced Angular: Signals, NgRx & AI Forms\n'language': 'DE'\n'date': '2025-05-02T10:49:04.000Z'\n'abstract': The new Signals in Angular are a simple reactive building block. However, as is so often the case, the devil is in the detail. In this article, I will give three tips to help you use Signals in a more straightforward way.\n'parentId': '5e78d57fd77e42835f9996dc'\n'parentDescription': Level up your Angular skills with this advanced course, highlighting the framework’s evolving features. We will cover cutting-edge topics, from mastering state management with the NgRx Signal store and unlocking AI-enhanced forms’ potential, to revisiting the performance benefits of server-side rendering. You will learn how to effectively use Signals through professional tips and real-world insights, and explore emerging features like httpResource in Angular 19.2. Whether you are scaling enterprise apps or upgrading legacy codebases, this course equips you with the practices to build smarter, faster Angular applications and stay ahead in today’s Angular ecosystem.\n'indexBrandName': 'InternationalJavaScriptCon'\n'indexSeriesName': ''\n'author': 'Manfred Steyer'\n'chunkSource': 'text'\n'text': Professional Tips for Using Signals in Angular The new Signals in Angular are a simple reactive building block. However, as is so often the case, the devil is in the detail. In this article, I will give three tips to help you use Signals in a more straightforward way. The new Signals in Angular are a simple reactive building block. However, as is so often the case, the devil is in the detail. In this article, I will give three tips to help you use Signals in a more straightforward way. The examples used for this can be found here. Guiding theory: Unidirectional data flow with signals The approach for establishing a unidirectional data flow (Fig. 1) serves as the guiding theory for my three tips. Fig. 1: Unidirectional data flow with a store Handlers for UI events delegate to the store. I use the abstract term “intention”, since this process is different for different stores. With the Redux-based NgRx store, actions are dispatched; whereas with the lightweight NgRx Signal store, the component calls a method offered by the store. The store executes synchronous or asynchronous tasks. These usually lead to a status change, which the application transports to the views of the individual components with signals. As part of this data flow, the state can be projected onto view models using computed, i.e. onto data structures that represent the view of individual use cases on the state. This approach is based on the fact that signals are primarily suitable for informing the view synchronously about data and data changes. They are less suitable for asynchronous tasks and for representing events. For one, they don’t offer a simple way of dealing with overlapping asynchronous requests and the resulting race conditions. Furthermore, they cannot directly represent error states. Second, signals ignore the resulting intermediate states in the case of directly consecutive value changes. This desired property is called “glitch free”. For example, if a signal changes from 1 to 2 and immediately afterwards from 2 to 3, the consumer only receives a notification about the 3. This is also conducive to data binding performance, especially as updating with intermediate results would result in an unnecessary performance overhead. Tip 1: Signals harmonize with RxJS Signals are deliberately kept simple. That's why it offers fewer options than RxJS, which has been established in the Angular world for years. Thanks to the RxJS interop that Angular provides, the best of both worlds can be combined. Listing 1 demonstrates this. It converts the signals from and to into observables and implements a typeahead based on them. To do this, it uses the operators filter, debounceTime and switchMap provided\n'slidetext': ''\n'from': 'vector'\n'score': 0.9199122786521912\n'normalizedScore': 0.9093822508769501\n'beforeDatePenaltyScore': 0.9199122786521912\n\n\n Dieser Content von  ist in deiner Sprache nicht verfügbar. Zurück zur Antwort"
}