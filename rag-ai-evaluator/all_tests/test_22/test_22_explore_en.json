{
  "test_id": "test_022_explore_en",
  "query": "I'm a backend developer. Show me relevant tutorials.",
  "endpoint": "reader_explore_text",
  "user": {
    "tier": "elevate",
    "language": "en"
  },
  "prompt": "main",
  "actual_response": "arrow_forward_iosDeine Suchergebnisse:  React-Grundlagen Nils HartmannModern React: von Null auf Full-Stack Die Welt der Web Components Peter KrönerWeb Components von 0 auf 100 Das ist .NET MAUI André KrämerMit .NET MAUI zur erfolgreichen Cross-Platform-App Micro Frontends Manfred Steyer, Michael Egger-Zikes und weitereModerne Angular-Architekturen Typsicheres Routing mit TanStack Router Nils HartmannModern React: von Null auf Full-Stack Datenabfrage mit TanStack Query Nils HartmannModern React: von Null auf Full-Stack Zugriff auf lokale Datenbanken André KrämerMit .NET MAUI zur erfolgreichen Cross-Platform-App Shadow DOM (Teil 3): Server-Side Rendering Peter KrönerWeb Components von 0 auf 100 GitHub Copilot in der Praxis – Code Complet... Rainer StropekC# Coding mit AI – Führende Tools im Vergleich RAG im Praxiseinsatz: Intelligente Code-Erk... Rainer StropekC# Coding mit AI – Führende Tools im Vergleich Agentisches Arbeiten mit GitHub Copilot: Ei... Rainer StropekC# Coding mit AI – Führende Tools im Vergleich Listen und Navigation André KrämerMit .NET MAUI zur erfolgreichen Cross-Platform-App Testen und Frontendarchitektur David TanzerWebentwicklung mit React API-Authentifizierung und - Autorisierung Martina KrausAPI Security meistern: Ein umfassender Leitfaden zum Schutz deiner APIs Programmieren mit GitHub Copilot an einem P... Rainer StropekSoftwareentwicklung mit ChatGPT und GitHub CopilotI'm a backend developer. Show me relevant tutorials.gpt-4.1-mini keyword: {\n  'phrase_out': 'tutorials',\n  'primary_version_array': [],\n  'secondary_version_array': [],\n  'year_array': ['2025','2026'],\n  'issue_array': []\n} \nAs a backend developer with a focus on serverless architecture, relevant tutorials can help you enhance your skills in API security, cloud-native development, and efficient coding practices with AI assistance. Here are some curated tutorials that align well with backend and serverless development themes:\n\nThe tutorial on API Authentication and Authorization covers essential techniques such as API keys, Basic Auth, OAuth 2.0, and JWT. It also addresses common pitfalls in API authorization and best practices to secure your APIs effectively [1.].\n\nFor improving productivity with AI tools, the C# Coding with AI – Leading Tools Comparison tutorial series explores GitHub Copilot and other AI assistants. It includes practical examples of using Copilot in CLI and code completion, as well as advanced agentic workflows for .NET developers [2.].\n\nIf you are interested in modern cross-platform app development that can complement backend services, the .NET MAUI for Successful Cross-Platform Apps tutorial offers step-by-step guidance on building native apps with C# and .NET, including data access, dependency injection, and UI navigation patterns [3.].\n\nFor frontend-backend integration and modern SPA development, the Modern React: From Zero to Full-Stack tutorial series covers React fundamentals, type-safe routing with TanStack Router, and efficient data fetching with TanStack Query. These skills are valuable for building serverless frontends that interact with backend APIs [4.].\n\nTo explore scalable frontend architectures that can work with serverless backends, the Micro Frontends tutorial explains modular and native federation principles, enabling independent development and deployment of frontend modules [5.].\n\n\nThese tutorials provide a solid foundation for backend developers aiming to leverage serverless architectures, secure APIs, and modern development tools effectively.\nIn conclusion, focusing on API security, AI-assisted coding, cross-platform app development, and modern frontend-backend integration will enhance your backend and serverless expertise. These tutorials are accessible with your current access rights and offer practical, up-to-date knowledge for your development needs.\n\nSources\n\nAPI-Authentifizierung und - Autorisierung This tutorial lesson examines secure API authentication and authorization, focusing on common vulnerabilities and practical defense strategies. ✅ This content is included with your elevate membership.\n\nProgrammieren mit GitHub Copilot an einem Praxisbeispiel mit .NET This tutorial lesson demonstrates programming with GitHub Copilot in .NET by building a TicTacToe game and sharing practical Copilot usage tips. ✅ This content is included with your elevate membership.\n\nDas ist .NET MAUI This tutorial lesson introduces .NET MAUI, guiding you through its architecture, setup, and building your first cross-platform app. ✅ This content is included with your elevate membership.\n\nTypsicheres Routing mit TanStack Router This tutorial lesson introduces type-safe routing in React applications using TanStack Router, focusing on modern navigation, dynamic routes, and performance optimization. ✅ This content is included with your elevate membership.\n\nMicro Frontends This tutorial lesson focuses on building scalable frontend architectures using Micro Frontends within modern Angular applications. ✅ This content is included with your elevate membership.\n\n\n\nMore on this Topic\n\nListen und Navigation This tutorial lesson guides you through building dynamic lists and implementing navigation in .NET MAUI mobile apps using BindableLayout and CollectionView. ✅ This content is included with your elevate membership.\n\nZugriff auf lokale Datenbanken This tutorial lesson guides you through integrating a local SQLite database into a .NET MAUI cross-platform app using dependency injection. ✅ This content is included with your elevate membership.\n\n\nReference:\n{\n  'translated_headers': {\n    'sources': 'Sources',\n    'more_on_this_topic': 'More on this Topic'\n  },\n  'sources': [],\n  'more_on_this_topic': [\n    {\n      'doc_id': 'bc32faafecf246529545044f'\n    },\n    {\n      'doc_id': 'xv6mWjJ7P65853SYR'\n    },\n    {\n      'doc_id': '535b45361ad6c9e12a423cbc'\n    },\n    {\n      'doc_id': 'bfcf46ef07492f36a37f0212'\n    },\n    {\n      'doc_id': 'e041b16a103e515fb3ff7fa7'\n    }\n  ]\n}\n\nChunks:\n'documentId': 'xv6mWjJ7P65853SYR'\n'chunk_id': '687a3121ca798166d3ba4322'\n'access': 'granted'\n'part_number': 3\n'total_parts': 31\n'contentType': 'TUTORIAL'\n'title': Programmieren mit GitHub Copilot an einem Praxisbeispiel mit .NET\n'parentName': Softwareentwicklung mit ChatGPT und GitHub Copilot\n'language': 'DE'\n'date': '2024-01-08T09:13:18.000Z'\n'abstract': In der 1.Lesson entwickeln wir ein einfaches Programmierbeispiel (TicTacToe) in C# mit Hilfe von GitHub Copilot. Sie erhalten Tipps, welche Vorgehensweisen am besten funktionieren und welche zu weniger guten Ergebnissen führen. Auch sehen wir uns die von GitHub Copilot gebotenen Funktionen im Überblick an, vergleichen die Preis- und Lizenzmodelle und probieren die Copilot CLI aus.\n'parentId': 'ddHC42kMkrLCuKs65'\n'parentDescription': Dieses Tutorial bietet eine umfassende Einführung in die KI-gestützte Softwareentwicklung, speziell unter Verwendung von ChatGPT und GitHub Copilot. Das Tutorial ist in fünf Lektionen gegliedert und zielt darauf ab, Teilnehmer:innen die Grundlagen, fortgeschrittenen Techniken und Grenzen der generativen Künstlichen Intelligenz (KI) im Kontext der Softwareentwicklung zu vermitteln.\n'indexBrandName': 'MLCon'\n'indexSeriesName': ''\n'author': 'Rainer Stropek'\n'chunkSource': 'text'\n'text': Beispiele in Ihrer Umgebung nachvollziehen, werden Sie mit großer Wahrscheinlichkeit da oder dort andere Tipps bekommen, als ich Sie hier bekomme. Aber das ist einfach so, damit müssen wir leben. Ich werde Schritt für Schritt den Prozess hier zeigen. Und sie bekommen wahrscheinlich am meisten Wert aus diesem Tutorial heraus, wenn sie, wie gesagt, nebenbei in ihrer eigenen Umgebung mit programmieren und die entsprechenden Schritte in ihrem in ihrer Umgebung mit ihrer Sprache nachvollziehen, versuchen sie auf ähnliche Ergebnisse zu kommen. Dort wo sie der meinung sind, sie möchten in einen anderen ansatz gehen wie ich, tun Sie das ruhig und probieren Sie aus, wie die entsprechenden ki Werkzeuge Sie bei Ihrem Ansatz unterstützen. In meinem Fall werde ich jetzt mal mit einer leeren dort nett Applikation starten und als Thema als einstiegs thema für unser heutiges Video tutorial werden wir das Thema tick tack to verwenden tick tao kennen wir wahrscheinlich alle. Jeder jede entwicklerin hat die dieses tutorial ansieht hat wahrscheinlich tick tao in der ausbildung in schulungen oder ähnliches schon als eine oder andere mal programmiert. Es ist wenn man so will, eine art von hello world applikation für einen nicht vollkommen trivialen algorithmus. Der algorithmus ist sehr einfach, aber er eignet sich sehr gut, dass ich ihnen die grundprinzipien insbesondere von gitter cop heilert. Das wird nämlich in unserer ersten lektion hier im mittelpunkt stehen, dass ich ihnen diese grundlagen einmal demonstriere ich werde bei mir hier eine neue nett Konsolen applikation erstellen, das geht relativ schnell, ich nutze hier die neueste Version von do ne und ich möchte noch einmal betonen wenn Sie keine done entwicklerin sind, wenn Sie die short nicht verwenden, sondern lieber javascript oder tike script oder Piton einsetzen, dann bitte tun sie das ruhig zu dem zweck haben wir ja ki damit uns damit uns dieses System hilft in der jeweiligen programmiersprache in der wir programmieren wollen oder müssen, dass wir dort produktiver werden, dass wir dort schneller werden ich werde in meinem Fall hier meine done applikation in Visual studio Code öffnen und hier sehen wir schon wir haben hier\n'slidetext': ''\n'from': 'vector'\n'score': 0.8999722599983215\n'normalizedScore': 0.8631351315907873\n'beforeDatePenaltyScore': 0.8999722599983215\n\n'documentId': 'bc32faafecf246529545044f'\n'chunk_id': '687a2ec29bbcb45d2a11f9a8'\n'access': 'granted'\n'part_number': 5\n'total_parts': 7\n'contentType': 'TUTORIAL'\n'title': API-Authentifizierung und - Autorisierung\n'parentName': API Security meistern: Ein umfassender Leitfaden zum Schutz deiner APIs\n'language': 'DE'\n'date': '2024-11-01T15:39:03.000Z'\n'abstract': In der zweiten Lesson dieses Tutorials geht Martina Kraus auf zentrale Themen der API-Authentifizierung und -Autorisierung ein: \n\n• Grundlegende Techniken der API-Authentifizierung: Einführung in einfache Authentifizierungsmethoden wie API-Schlüssel und Basic Auth. \n• Fortgeschrittene Mechanismen: Martina erklärt fortgeschrittene Verfahren wie OAuth 2.0 und JWT für eine sichere Benutzer- und Client-Authentifizierung. \n• Praktische Szenarien: Sie zeigt typische Anwendungsfälle der API-Authentifizierung und wie man sie in verschiedenen Szenarien implementiert. \n• Häufige Fehler bei der API-Autorisierung: Martina identifiziert häufige Sicherheitslücken und Fehler bei der Autorisierung und wie man diese vermeidet. \n• Best Practices: Empfehlungen zur effektiven Durchsetzung der API-Autorisierung, um unbefugten Zugriff zu verhindern.\n\n Diese Lesson ist ideal für Entwickler:innen, die ihre Kenntnisse in der sicheren Authentifizierung und Autorisierung von APIs vertiefen möchten.\n'parentId': '5629542fca82563a78ace644'\n'parentDescription': Martina Kraus bietet in ihrem Tutorial eine umfassende Einführung in die API-Sicherheit, gerade in Bezug auf essenzielle HTTP Security Header und Maßnahmen wie HSTS, X-Frame-Options und CORS-Policy. Behandelt werden die OWASP Top 10 API-Sicherheitsrisiken einschließlich gebrochener Authentifizierung, Autorisierung und Schwachstellen bei JSON Web Tokens. Fortgeschrittene Angriffe wie etwa Denial of Service, SSRF und SQL Injection werden analysiert, um effektive Schutzstrategien vorzustellen, die APIs gegen gängige Bedrohungen abzusichern.\n'indexBrandName': 'APICon'\n'indexSeriesName': ''\n'author': 'Martina Kraus'\n'chunkSource': 'text'\n'text': gängigsten Maßnahmen ist, zu liefern. Datenbank wie MongoDB eben ablegen können, um nur die Daten natürlich dem Frontend zu einfach vielleicht noch in ein anderes JSON-Objekt zu Viel besser sind hier sogenannte Datentransfer-Objekte. dann wird uns das tatsächlich schon automatisch mitgegeben, Mapping stattfinden. Und das gilt natürlich als Hauptpräventionsmaßnahme hier. die Nutzerin hat. rausfiltern müssen. aber der Aufwand lohnt sich, Auf der anderen Seite und etwas, biete ich auch eine Möglichkeit, alle Properties des Objektes tatsächlich auch möglich sein, sondern dass der Nutzer, dass vielleicht auch keine sensiblen Daten verändert werden. den Nutzer, der Nutzerin, Verfügung steht. was in diesen Daten drin steckt, sollte Natürlich muss da beim API Design auch sehr sehr nah mit dem Man sollte sowieso zusammenarbeiten und sich auf einen eine ziemlich fiese Attacke. dem Angreifer der Angreiferin zur Verfügung stelle, Wir haben gesehen, dass man mit der Vehicle Natürlich kann ich doch eine direkte Attacke ausführen, das dann in dem Postrequest mitgesendet wird, Mit sendet. dann eben versuchen diese Properties ebenfalls zu setzen, Und das kann natürlich Gefahren bergen, die eigentlich nicht verändert werden sollten. Denn wir können natürlich das Objekt verändern, irgendetwas abzudaten oder vielleicht etwas zu lesen, ich vielleicht wiederum dieselbe URL mit einem Delete sein und dies eigentlich nicht zulassen. Application an. Sprich, wir wollen jetzt eine Ressource finden, um dann gegebenenfalls in Postman dann darauf doch ein können dürfte. Dort finden wir einen Bereich, dass ich tatsächlich nur drei Funktionalitäten habe, auszutauschen oder dann dieses Video mit der kompletten je nachdem wie es implementiert ist, ein Patch-Request. weil ich natürlich auch das Video lesen muss. ob ich diesen Request auch mit Postman absetzen kann und kann. Das ist die ID des Videos das ich bereits hochgeladen habe einfach nur einen zufälligen String letztendlich mit senden dann sehen wir hier unten das Video mit der ID das ist erhalte noch ein paar weitere Parameter hinzu. welche HTTP-Methoden diese URL mir eigentlich das Backend sogenannte Options-Request. denn, wenn ich auf diese Ressource zugreifen möchte? dass\n'slidetext': ''\n'from': 'vector'\n'score': 0.8845714330673218\n'normalizedScore': 0.8640777502451503\n'beforeDatePenaltyScore': 0.8845714330673218\n\n'documentId': '554842349c829ccc79d45375'\n'chunk_id': '687a2b1a495b49563aa8787e'\n'access': 'granted'\n'part_number': 1\n'total_parts': 1\n'contentType': 'TUTORIAL'\n'title': Testen und Frontendarchitektur\n'parentName': Webentwicklung mit React\n'language': 'DE'\n'date': '2024-06-19T09:51:24.000Z'\n'abstract': In der 2.Lesson geht es um: -Testen und Debuggen -In React Denken\n'parentId': '4045cf6162f22726e5913d6c'\n'parentDescription': React ist eine Library zum Erstellen von komponentenbasierten Benutzerschnittstellen. Damit können wir Single-Page Anwendungen oder native Anwendungen entwickeln oder auch nur einen kleinen Bereich einer statischen Webseite mit etwas mehr Interaktivität ausstatten. In diesem Tutorial lernen Sie die Grundlagen, die Sie für jeden dieser Anwendungsfälle gebrauchen können: Von der Erstellung der ersten Komponenten über Komponentenzustand, Auslagerung der Geschäftslogik, Testen und Debuggen zu Hooks, Web Components und weiteren Themen. Die einzelnen Themen werden anhand von einem durchgängigen Codebeispiel erklärt und es gibt viele Gelegenheiten, das gelernte selbst zu üben.\n'indexBrandName': 'InternationalJavaScriptCon'\n'indexSeriesName': ''\n'author': 'David Tanzer'\n'chunkSource': 'text'\n'text': Testen und Frontendarchitektur In der 2.Lesson geht es um: -Testen und Debuggen -In React Denken\n'slidetext': ''\n'from': 'vector'\n'score': 0.8942122459411621\n'normalizedScore': 0.8663080741546324\n'beforeDatePenaltyScore': 0.8942122459411621\n\n'documentId': 'bfcf46ef07492f36a37f0212'\n'chunk_id': '6876daaf225e92fc1ac7c46f'\n'access': 'granted'\n'part_number': 25\n'total_parts': 37\n'contentType': 'TUTORIAL'\n'title': Listen und Navigation\n'parentName': Mit .NET MAUI zur erfolgreichen Cross-Platform-App\n'language': 'DE'\n'date': '2025-02-07T10:45:08.000Z'\n'abstract': In der vierten Lesson dreht sich alles um Listen. Du lernst, wie du das Bindable Layout und die CollectionView verwendest, um dynamische Listen in deiner App zu erstellen und sie benutzerfreundlich darzustellen.\n'parentId': 'dd0d8f751be8d368f2f60eb9'\n'parentDescription': Zusammen mit Microsoft MVP André Krämer lernst du Schritt für Schritt, wie du mit .NET MAUI in C# und .NET native Apps für Android, iOS, macOS und Windows aus einer einzigen Codebasis erstellst. Du gestaltest ansprechende Benutzeroberflächen mit XAML und dem MVVM-Design-Pattern, stellst Daten in Listen übersichtlich dar und navigierst dabei nahtlos zwischen verschiedenen Ansichten. Zudem erfährst du, wie du Dependency Injection effizient einsetzt und native Gerätefunktionen wie die Kamera nutzt. Das praxisorientierte Tutorial ermöglicht dir, moderne Cross-Platform-Apps eigenständig zu entwickeln.\n'indexBrandName': 'BASTA!'\n'indexSeriesName': ''\n'author': 'André Krämer'\n'chunkSource': 'text'\n'text': vier Tagen, in sechs Tagen, nächste Woche, wunderbar, unser Converter scheint zu funktionieren und damit haben wir gesehen, mit wie wenig Aufwand wir tatsächlich hingehen können und eine deutlich bessere Darstellung für den Benutzer erzielen können. Kleiner Tipp, es gibt das Community Toolkit Maui, das ist ein Open Source Projekt, dort sind schon einige Converter vordefiniert, die ihr in euren Anwendungen direkt nutzen könnt, da müsst ihr nicht für alles einen eigenen Converter schreiben. In unserer Anwendung haben wir bisher drei Seiten, wir haben die Startseite und wenn wir hier das Menü öffnen, dann haben wir noch eine Seite, mit der wir neue Einträge hinzufügen können oder uns auch bestehende ansehen können und wir haben eine Seite, die eine Liste aller Einträge darstellt. Dass wir jetzt bisher über das Menü navigieren können, ist zwar ganz okay, aber wenn wir uns die Startseite anschauen, dann würde es sich eigentlich anbieten, wenn wir hier über diesen Button hier auf die Seite für den Eintrag navigieren oder hier über diese Kacheln auf die Liste der Einträge und zwar auch immer so, dass das ganze gefiltert ist. So hier würde ich alle Gegenstände sehen, hier die, bald zurückgegeben werden müssen, hier die die heute zurückgegeben werden müssen, hier die die schon hätten zurückgegeben werden müssen und wir können sogar noch weiter bringen und sagen, wenn wir auf einen Kontakt klicken, dann kriegen wir auch wieder die Liste der verliehenden Gegenstände, dieses Mal aber gefiltert nach der Person. Und genau das das werden wir jetzt hier zusammen Schritt für Schritt bauen. Wir fangen an mit der Schaltfläche hier unten und nähern uns dann über die Kacheln hier oben, bis wir hier zu den Kontakten kommen. Also legen wir los., das erste, was wir machen müssen ist, wir gehen einmal hin und starten mit der Item-Seite und die werden wir jetzt hier aus der Navigation rausschmeißen. So damit wir navigieren können, müssen wir aber eine Route definieren und eine Route, die können wir über zwei Wege definieren. Das eine wäre hier in der App Shell, innerhalb des Konstruktors. Hier\n'slidetext': ''\n'from': 'vector'\n'score': 0.8832212686538696\n'normalizedScore': 0.8680862648017641\n'beforeDatePenaltyScore': 0.8832212686538696\n\n'documentId': 'e041b16a103e515fb3ff7fa7'\n'chunk_id': '6876df627899910dd58c1008'\n'access': 'granted'\n'part_number': 17\n'total_parts': 35\n'contentType': 'TUTORIAL'\n'title': Zugriff auf lokale Datenbanken\n'parentName': Mit .NET MAUI zur erfolgreichen Cross-Platform-App\n'language': 'DE'\n'date': '2025-02-07T10:45:08.000Z'\n'abstract': In dieser Lesson geht es um: -Zugriff auf lokale Datenbanken -Feinschliff -Abschluss\n'parentId': 'dd0d8f751be8d368f2f60eb9'\n'parentDescription': Zusammen mit Microsoft MVP André Krämer lernst du Schritt für Schritt, wie du mit .NET MAUI in C# und .NET native Apps für Android, iOS, macOS und Windows aus einer einzigen Codebasis erstellst. Du gestaltest ansprechende Benutzeroberflächen mit XAML und dem MVVM-Design-Pattern, stellst Daten in Listen übersichtlich dar und navigierst dabei nahtlos zwischen verschiedenen Ansichten. Zudem erfährst du, wie du Dependency Injection effizient einsetzt und native Gerätefunktionen wie die Kamera nutzt. Das praxisorientierte Tutorial ermöglicht dir, moderne Cross-Platform-Apps eigenständig zu entwickeln.\n'indexBrandName': 'BASTA!'\n'indexSeriesName': ''\n'author': 'André Krämer'\n'chunkSource': 'text'\n'text': kannst. Also, komm, los geht's. Jetzt haben wir hier drei Optionen. Ich kann mit vorgeschlagenen Orten starten. Wenn ich das mache, dann würden in dem Fall hier Orte angelegt. In unserem Fall sind das die Borderer oder mit vorgeschlagenen Orten und Lebensmitteln. Und ich erkläre auch hier immer wirklich, was passiert, damit der Anwender direkt ganz klar sieht, was passiert eigentlich. Ich klicke mal hier drauf, zack und dann passiert im Endeffekt das ganz Ähnliches wie bei uns. Es wird einfach eine Liste gefüllt., und der Trick ist einfach die Methode, die dorthin steht im Viewmodel. Das ist ganz ähnlich wie das, was wir eben auch gemacht haben mit unserem DummyData. Der Trick ist einfach, ich gehe hier über so ein Empty View Template. Okay, damit sind wir durch mit dem Speichern unserer Daten. Tja, das Einzige was jetzt eigentlich noch fehlt, Folgendes. Wir haben Daten aus der Eskoleit Datenbank gelesen. Haben Daten reingeschrieben, aber natürlich nur über Initialisierungscode. Tatsächlich müssen wir noch eine Kleinigkeit machen, damit die App wirklich rund ist und sich rund anfühlt. Nämlich, wir müssen dafür Sorge tragen, dass wenn hier jemand auf Gegenstand hinzufügen drückt und wir hier was auswählen, dass wir das hier tatsächlich auch speichern. Das passiert ja noch gar nicht. Das gucken wir uns jetzt gleich an und dann möchte ich mit euch auch noch Folgendes machen. Ich möchte dafür Sorge tragen, dass wenn ich hier auf irgendwas draufklicke, dass wir dann auch zu dem entsprechenden Eintrag navigieren. das legen wir jetzt gleich zusammen los. Rein technisch gesehen sind wir eigentlich so ziemlich durch mit dem Tutorial. Ich habe euch alles das gezeigt, was ich euch zeigen wollte. Ihr habt also die Grundlagen von Aber so richtig rund ist die App ja noch nicht. Was meine ich damit? wenn ich mal hier auf meinen Bildschirm wechsle, dann sehen wir ja hier, wenn wir in der App sind, dass wir hier diesen Detailbildschirm haben. Und in diesem Detailbildschirm, da kann ich zwar gerade irgendwelche Sachen eingeben und kann auch hier auswählen,\n'slidetext': ''\n'from': 'vector'\n'score': 0.883411169052124\n'normalizedScore': 0.8682761652000185\n'beforeDatePenaltyScore': 0.883411169052124\n\n'documentId': '535b45361ad6c9e12a423cbc'\n'chunk_id': '6876d395225e92fc1ac79d31'\n'access': 'granted'\n'part_number': 35\n'total_parts': 35\n'contentType': 'TUTORIAL'\n'title': Das ist .NET MAUI\n'parentName': Mit .NET MAUI zur erfolgreichen Cross-Platform-App\n'language': 'DE'\n'date': '2025-02-07T10:45:08.000Z'\n'abstract': In der ersten Lesson des Tutorials zeigt dir André Krämer die Grundlagen von .NET MAUI, Microsofts Framework für plattformübergreifende Apps. Du erfährst, wie du deine erste App erstellst und auf Windows, macOS, Android und iOS testest. Zum Abschluss baust du eine einfache To-do-App, die dir als Ausgangspunkt für weitere Projekte dient.\n'parentId': 'dd0d8f751be8d368f2f60eb9'\n'parentDescription': Zusammen mit Microsoft MVP André Krämer lernst du Schritt für Schritt, wie du mit .NET MAUI in C# und .NET native Apps für Android, iOS, macOS und Windows aus einer einzigen Codebasis erstellst. Du gestaltest ansprechende Benutzeroberflächen mit XAML und dem MVVM-Design-Pattern, stellst Daten in Listen übersichtlich dar und navigierst dabei nahtlos zwischen verschiedenen Ansichten. Zudem erfährst du, wie du Dependency Injection effizient einsetzt und native Gerätefunktionen wie die Kamera nutzt. Das praxisorientierte Tutorial ermöglicht dir, moderne Cross-Platform-Apps eigenständig zu entwickeln.\n'indexBrandName': 'BASTA!'\n'indexSeriesName': ''\n'author': 'André Krämer'\n'chunkSource': 'text'\n'text': können auch für iOS entwickeln. Ich kann das sogar unter Windows starten aber ich brauche später zu paketieren davon auf jeden Fall immer einen Mac. Im einfachsten Fall, wenn ich jetzt selber mit dem Mac noch nicht ganz so warm geworden bin, dann kann ich einfach hingehen und kann ja meinen Mac remote verbinden, indem ich die entfernte Anmeldung aktiviere und dann kann ich aus Visual Studio heraus meine Anwendung auf dem Mac starten, debuggen, paketieren und so weiter. Natürlich kann ich aber auch direkt auf dem Mac arbeiten und dort habe ich zwei Optionen. Ich kann Visual Studio Code benutzen oder eben JetBrains Rider. Was nicht mehr geht, ist Visual Studio for Mac zu nutzen. Das Ganze wurde ja entsprechend abgekündigt. Zum Abschluss haben wir dann folgendes gemacht. haben mal diese neue Option gewählt, nämlich, dass ich beim Anlegen eines Projektes Beispieldaten hereinholen möchte und dann bekomme ich tatsächlich eigentlich keine leere App mehr. Noch einmal. Und dann bekomme ich tatsächlich gar keine leere App mehr, sondern was ich dann bekomme, ist eine vollständige To-Do App, in der ich mir angucken kann, wie funktioniert eigentlich das Model View View Model Muster? Wie mache ich Datenzugriff in eine SQLite Datenbank? Wie kann ich schicke Controls mit schicken Charts und so weiter einbinden? All das findet ihr in dieser App, so bisschen als Sammlung von Best Practices. Ja und damit sind wir, wie gesagt, am Ende der ersten Lektion angekommen. Ich hoffe, es hat euch soweit Spaß gemacht. Ich freue mich auf die nächste Lektion, denn jetzt sind wir eigentlich gewappnet, um unsere richtige App, die wir Laufe dieses Tutorials entwickeln möchten, zu programmieren. Schonmal als kleine Vorschau, worum es geht. Wir werden zusammen eine App entwickeln, mit der wir verwalten können, welche Gegenstände wir an jemanden ausgeliehen haben und sehen können, ob wir die eigentlich pünktlich zurückbekommen haben. Wie das Ganze funktioniert, das folgt dann in den nächsten Lektionen. Ich wünsche euch dabei schon mal viel Spaß und bis dahin.\n'slidetext': ''\n'from': 'vector'\n'score': 0.8853634595870972\n'normalizedScore': 0.8702284557356258\n'beforeDatePenaltyScore': 0.8853634595870972\n\n'documentId': 'e041b16a103e515fb3ff7fa7'\n'chunk_id': '6876df647899910dd58c101a'\n'access': 'granted'\n'part_number': 35\n'total_parts': 35\n'contentType': 'TUTORIAL'\n'title': Zugriff auf lokale Datenbanken\n'parentName': Mit .NET MAUI zur erfolgreichen Cross-Platform-App\n'language': 'DE'\n'date': '2025-02-07T10:45:08.000Z'\n'abstract': In dieser Lesson geht es um: -Zugriff auf lokale Datenbanken -Feinschliff -Abschluss\n'parentId': 'dd0d8f751be8d368f2f60eb9'\n'parentDescription': Zusammen mit Microsoft MVP André Krämer lernst du Schritt für Schritt, wie du mit .NET MAUI in C# und .NET native Apps für Android, iOS, macOS und Windows aus einer einzigen Codebasis erstellst. Du gestaltest ansprechende Benutzeroberflächen mit XAML und dem MVVM-Design-Pattern, stellst Daten in Listen übersichtlich dar und navigierst dabei nahtlos zwischen verschiedenen Ansichten. Zudem erfährst du, wie du Dependency Injection effizient einsetzt und native Gerätefunktionen wie die Kamera nutzt. Das praxisorientierte Tutorial ermöglicht dir, moderne Cross-Platform-Apps eigenständig zu entwickeln.\n'indexBrandName': 'BASTA!'\n'indexSeriesName': ''\n'author': 'André Krämer'\n'chunkSource': 'text'\n'text': eigentlich, ab Kapitel 8 glaube ich ist es, in jedem Kapitel siehst du hier die Beispielanwendung plus ein technisches Beispiel. Also schau dort rein, dort lernst du noch eine ganze ganze Menge mehr über .NET Maui. Ansonsten freue ich mich über dein Feedback, wie kannst du mir das geben, entweder indem du hier direkt auf den Link zu meiner Website klickst und hier gibt es dann ein Kontaktformular, schreib mir gerne mal wie du das Tutorial gefunden hast, bewerte es auch natürlich auch hier auf Entwickler.de. Ansonsten freue ich mich auch, wenn du hier unten Kontakt auf LinkedIn mit mir aufnimmst, vernetze dich dort mit mir und schreib mir auch da gerne mal, wie es dir gefallen hat. Ja ansonsten wie gesagt, ich wünsche dir ganz viel Spaß mit dem erworbenen Wissen, ich bin gespannt auf die Apps, die du schreiben wirst und auch da, wenn du eine fertige App hast, mach einfach mal einen Screenshot, schick es mir durch, ich bin total gespannt, was du mit dem Wissen was du hier erworben hast, dann im Endeffekt auch gemacht hast. Insofern viel Spaß dabei und bis zum nächsten Mal.\n'slidetext': ''\n'from': 'vector'\n'score': 0.886168897151947\n'normalizedScore': 0.8710338933004756\n'beforeDatePenaltyScore': 0.886168897151947\n\n'documentId': '2ed8aad14972c165c82e16e1'\n'chunk_id': '6876ce4a225e92fc1ac79115'\n'access': 'granted'\n'part_number': 16\n'total_parts': 20\n'contentType': 'TUTORIAL'\n'title': Agentisches Arbeiten mit GitHub Copilot: Einblicke, Grenzen und Tipps für .NET-Entwickler:innen\n'parentName': C# Coding mit AI – Führende Tools im Vergleich\n'language': 'DE'\n'date': '2025-04-03T09:46:57.000Z'\n'abstract': In der vierten Session liegt der Fokus auf GitHub Copilot und dessen Einsatzmöglichkeiten für agentisches Arbeiten in Visual Studio Code. Anhand eines Beispiels zur Berechnung von ECEF-Koordinaten wird gezeigt, wie Unit Tests mit Copilot erstellt werden, einschließlich der Nutzung von Prompts und Tags wie #File und #Folder. Außerdem zeigt Rainer dir die Copilot Instruction Files, mit denen Coding-Guidelines automatisch in Prompts integriert werden können, auch wenn sie nicht immer berücksichtigt werden. Der Vergleich mit Cursor und Windsurf zeigt, dass diese Tools in Bezug auf Projektverständnis und Kontextverarbeitung weiter entwickelt sind, während Copilot durch Stabilität und Integration in das Visual-Studio-Ökosystem besticht. Die Bedeutung von differenziertem Prompting und kritischer Reflexion beim Einsatz von AI-Tools steht in dieser Session im Fokus.\n'parentId': 'e58728ab5cc5f14f75910106'\n'parentDescription': Künstliche Intelligenz revolutioniert die Softwareentwicklung – doch welches AI-Coding-Tool bietet den größten Mehrwert für C#-Entwickler:innen? In diesem Tutorial vergleichen wir führende AI-gestützte Coding-Assistenten wie GitHub Copilot, Cursor, Windsurf und die Open-Source-Alternative continue.dev. Anhand praxisnaher C#-Beispiele untersuchen wir ihre Stärken, Schwächen und Einsatzmöglichkeiten im .NET-Umfeld. Die Teilnehmer:innen erhalten hilfreiche Einblicke in die Effizienzsteigerung durch AI, bewährte Best Practices und konkrete Empfehlungen für den Einsatz in ihren Entwicklungsprozessen. Das Tutorial richtet sich an Entwickler:innen, die ihre C#-Skills mit AI-gestütztem Coding optimieren und die besten Tools für ihre Workflows identifizieren möchten.\n'indexBrandName': 'BASTA!'\n'indexSeriesName': ''\n'author': 'Rainer Stropek'\n'chunkSource': 'text'\n'text': falsch was ich damit zeigen will ist wenn wir uns das leben sehr stark vereinfachen als entwicklerin oder als entwickler und einfach solche shortcuts verwenden wie slash tests oder sowas dann bekommen wir natürlich auch nur sehr generell Ich bin ein großer Freund davon, dass ich wirklich mit intensiven Prompts arbeite und mir Gedanken dazu mache, was ich wirklich will und das auch in Worte fasse. Ich gebe zu, ich schreibe manchmal etwas ausladend mit Bitte und Danke und Erklärend. Das ist einfach weil ich mir leichter tue in dieser Form zu schreiben, denn das ist auch das wie ich reden würde. Man könnte viele Füllwörter hier weglassen und es würde immer noch ganz gut funktionieren. Das hier das werdet vielleicht bei Demos von GitHub oder anderen Marketingleuten sehen solche Slash Tests und es funktioniert auch recht gut bei einem Tic Tac Toe oder ähnlichem. Aber wenn man eine etwas komplexere Logik hat, wo man sich vorher Gedanken gemacht hat über Akzeptanzkriterien, über Eingabeparameter, erwartete Ausgabeparameter in einem Projekt, professionelles Requirements Engineering dahinter steckt, da ist das schon wertvoll, wenn man auf diese kleinen Geschichten Slash Tests verzichtet und einfach ausformuliert, was man haben will. Am Ende des Tages kommt eh das Gleiche raus, weil auch dieses Slash Tests was ihr hier seht führt zu einem Prompt, nur der Prompt wurde dann eben von Microsoft geschrieben. Man kann da auch hinten noch was dran schreiben, dann kann man das Beste aus beiden Welten kombinieren, aber ich bin eher auf dieser Seite. Bildet euch selbst eine Meinung, probiert es aus. In meinem Fall ist es dann aber oft so, dass mir die Prompts fast schon zu lange werden und es gibt Fälle, wo ich möglicherweise Prompts habe, die seitenlang sind, wo ich mir wirklich viele Gedanken über die Daten mache, die übergeben werden, wo Requirements aufeinander aufbauen, wie gehe ich dann damit um, was tue ich dann, das möchte ich euch an einem kleinen Beispiel Zeigen, wird zwar Jetzt nicht mehr auskodieren, aber ich denke, es sollte euch gleich klar werden, welche Richtung das geht. Ich öffne das Beispiel Mal. Dieses Beispiel verwende ich\n'slidetext': ''\n'from': 'vector'\n'score': 0.8842471837997437\n'normalizedScore': 0.8721236646000988\n'beforeDatePenaltyScore': 0.8842471837997437\n\n'documentId': 'ff0a5cf3f58b38ddfe7d481c'\n'chunk_id': '6876e19a7899910dd58c1bc6'\n'access': 'granted'\n'part_number': 13\n'total_parts': 13\n'contentType': 'TUTORIAL'\n'title': RAG im Praxiseinsatz: Intelligente Code-Erkundung mit GitHub Copilot und Cursor\n'parentName': C# Coding mit AI – Führende Tools im Vergleich\n'language': 'DE'\n'date': '2025-04-03T09:46:57.000Z'\n'abstract': In der fünften Session stellt dir Rainer das Konzept der Retrieval Augmented Generation (RAG) vor und erläutert deren Anwendung in KI-gestützten Entwickler-Tools wie GitHub Copilot und Cursor. Du erfährst, wie RAG dabei hilft, große Codebasen zu durchsuchen und relevante Codeschnipsel für die Antwortgenerierung zu nutzen. GitHub Copilot indiziert Code über GitHub.com und speichert ihn in Vektordatenbanken, während Cursor den Code lokal indiziert und die Vektordatenbank in der Cloud speichert. Zudem werden weitere Einsatzmöglichkeiten von Copilot vorgeführt, darunter die Unterstützung bei Commit-Messages und die Analyse von Programmierfehlern.\n'parentId': 'e58728ab5cc5f14f75910106'\n'parentDescription': Künstliche Intelligenz revolutioniert die Softwareentwicklung – doch welches AI-Coding-Tool bietet den größten Mehrwert für C#-Entwickler:innen? In diesem Tutorial vergleichen wir führende AI-gestützte Coding-Assistenten wie GitHub Copilot, Cursor, Windsurf und die Open-Source-Alternative continue.dev. Anhand praxisnaher C#-Beispiele untersuchen wir ihre Stärken, Schwächen und Einsatzmöglichkeiten im .NET-Umfeld. Die Teilnehmer:innen erhalten hilfreiche Einblicke in die Effizienzsteigerung durch AI, bewährte Best Practices und konkrete Empfehlungen für den Einsatz in ihren Entwicklungsprozessen. Das Tutorial richtet sich an Entwickler:innen, die ihre C#-Skills mit AI-gestütztem Coding optimieren und die besten Tools für ihre Workflows identifizieren möchten.\n'indexBrandName': 'BASTA!'\n'indexSeriesName': ''\n'author': 'Rainer Stropek'\n'chunkSource': 'text'\n'text': seid jetzt inspiriert, ihr habt ein Gefühl dafür, welchen dieser Werkzeuge ihr eine Chance geben wollt, es würde mich sehr freuen wenn ihr mich mal irgendwo seht auf einer Veranstaltung oder ähnliches, wenn ihr mich ansprecht, erzählt mir was ihr von diesem Seminar gehalten habt oder verbindet euch über LinkedIn mit mir, da bin ich immer offen für Feedback oder für Fragen. Herzliche Dank fürs Zuschauen, viel Spaß beim Coding mit AI mit euren .NET Projekten.\n'slidetext': ''\n'from': 'vector'\n'score': 0.8864046931266785\n'normalizedScore': 0.8742811739276678\n'beforeDatePenaltyScore': 0.8864046931266785\n\n'documentId': 'f84097699062ea49829a9ba7'\n'chunk_id': '688744882d7a080012cea4d3'\n'access': 'granted'\n'part_number': 27\n'total_parts': 63\n'contentType': 'TUTORIAL'\n'title': Shadow DOM (Teil 3): Server-Side Rendering\n'parentName': Web Components von 0 auf 100\n'language': 'DE'\n'date': '2025-06-05T13:45:07.000Z'\n'abstract': In dieser Lesson schauen wir uns die Herausforderungen und Möglichkeiten von Server-Side Rendering mit Web Components an. Du erfährst, wie Tools wie Happy DOM funktionieren, warum SSR überhaupt notwendig ist, welche Strategien es für CSS gibt, wie unterschiedliche Architekturansätze aussehen können – und worauf du achten musst, um typische Fallen und fehlende Features zu umgehen.\n'parentId': '54cce7e83417cbefa7c0d3f0'\n'parentDescription': Web Components versprechen universelle Frontend-Komponenten, frei von Framework-Fesseln und Dependency-Depression. Das Problem: Web Components sind komplex, manche APIs wirken eigenartig, und das sie umgebende Ökosystem ist unübersichtlich. Was können Web Components leisten – und was nicht? Brauche ich wirklich Shadow DOM oder kann ich darauf verzichten? Vanilla-Komponenten, Lit – oder etwas dazwischen? In diesem Tutorial lernen wir, wie der Komponenten-Eintopf wirklich gemacht wird. Wir orientieren uns im Ökosystem und erhalten einen Überblick über die Fähigkeiten und Grenzen der Standards rund um Web Components. Von den absoluten API-Grundlagen bis zum Einsatz ausgewachsener Komponenten-Frameworks lassen wir keinen Schritt aus. In jedem Abschnitt unserer Reise erfahren wir nicht nur, wie etwas funktioniert, sondern auch, warum. Dieses Tutorial macht uns nicht nur zu Web-Component-Expert:innen, sondern vertieft auch unser Verständnis der Web-Plattform insgesamt.\n'indexBrandName': 'InternationalJavaScriptCon'\n'indexSeriesName': ''\n'author': 'Peter Kröner'\n'chunkSource': 'text'\n'text': unser Use-Case? Die Gretchenfrage lautet ja, wie hält es mit dem Server-Site-Rendering? Und ganz ehrlich, ich bin damit eigentlich immer sehr sparsam. Dass man Server-Site-Rendering braucht, teilt voraus, dass man eine ganze Kaskade an sehr spezifischen Problemen. Problem eins muss sein, die Applikation ist eine sehr JavaScript-lastige mehr oder minder Single-Page-Application. Problem Nummer zwei ist, diese Single-Page-Application ist öffentlich und muss deswegen besonders schnell laden, um da so im Konkurrenzkampf der ganzen Web-Applikationen zu bestehen und oder sie muss halt der Gestalt sein, dass Suchmaschinen sie indizieren können. Also würde man so was bauen, wie einen Single-Page-Application-Web-Shop zum Beispiel. Dann brauchen wir Server-Site-Rendering, das ist ganz klar. Aber da gibt es eben so mehrere Fragen, ob dieses Szenario auftritt und Fans auftritt, ob das tatsächlich auftreten sollte. Denn ist für eine solche Publikation, für eine solche Webseite tatsächlich Server-Site-Rendering der korrekte Ansatz? Ich würde argumentieren, vielleicht eher nicht. Vielleicht ist es bei solchen Ansätzen prinzipiell besser, wenn man einfach hingehen kann und man kann sagen, wir hauen HTML vom Server raus, so wie das unsere Vorväter gemacht haben. machen einfach im Backend Java, PHP oder was auch immer und hauen halt einfach statisches HTML über die Leitung und dann streuseln wir kleinseitig, so wie man das früher JQuery-Style gemacht hat, so ein bisschen JavaScript-Dekorationen drüber, machen schönes CSS und fertig ist die Kiste. Dann brauchen wir kein Server-Site-Rendering, weil Server-Site-Rendering das einzige Rendering ist das stattfindet. Und das schließt ja nicht aus, dass man trotzdem ein paar kleinseitige JavaScript-Dekorationen mit einbaut und das könnten dann selektiv eingebaute Web-Components sein, so wie halt eben hier unser Hello World-Kollege. Den kann man ja tatsächlich in der Applikation drinnen haben, der muss nicht zwingend server-seitig gerendert werden, wenn es von dem Ding nur so ein paar gibt, wo es halt gar nicht so wichtig ist und wo der ganze Rest der Seite so schnell lädt, dass es gar nicht auffällt, dass dieses Hello World erst später gerendert wird. Das wäre ja\n'slidetext': ''\n'from': 'vector'\n'score': 0.883481502532959\n'normalizedScore': 0.8748191007863837\n'beforeDatePenaltyScore': 0.883481502532959\n\n'documentId': '123e7a2a785d7f6f78671362'\n'chunk_id': '6876cc7f225e92fc1ac78759'\n'access': 'granted'\n'part_number': 17\n'total_parts': 31\n'contentType': 'TUTORIAL'\n'title': GitHub Copilot in der Praxis – Code Completion und CLI\n'parentName': C# Coding mit AI – Führende Tools im Vergleich\n'language': 'DE'\n'date': '2025-04-03T09:46:57.000Z'\n'abstract': In der zweiten Lesson bekommst du einen tieferen Einblick in den praktischen Einsatz von GitHub Copilot, insbesondere in der Kommandozeile und bei der Code Completion in Visual Studio Code. Rainer zeigt dir, wie mit GitHub Copilot in der CLI komplette Projektstrukturen erstellt und Aufgaben wie die Umwandlung von geographischen Koordinaten gelöst werden können. Ein wichtiger Aspekt ist die technische Funktionsweise von Copilot, bei der der Kontext der aktuellen Datei berücksichtigt wird. Zudem werden Unterschiede zu Cursor aufgezeigt, das lokale und leistungsstärkere Vorschläge bietet. Am Ende der Session erhältst du eine Übersicht über wichtige Einstellungen in GitHub Copilot.\n'parentId': 'e58728ab5cc5f14f75910106'\n'parentDescription': Künstliche Intelligenz revolutioniert die Softwareentwicklung – doch welches AI-Coding-Tool bietet den größten Mehrwert für C#-Entwickler:innen? In diesem Tutorial vergleichen wir führende AI-gestützte Coding-Assistenten wie GitHub Copilot, Cursor, Windsurf und die Open-Source-Alternative continue.dev. Anhand praxisnaher C#-Beispiele untersuchen wir ihre Stärken, Schwächen und Einsatzmöglichkeiten im .NET-Umfeld. Die Teilnehmer:innen erhalten hilfreiche Einblicke in die Effizienzsteigerung durch AI, bewährte Best Practices und konkrete Empfehlungen für den Einsatz in ihren Entwicklungsprozessen. Das Tutorial richtet sich an Entwickler:innen, die ihre C#-Skills mit AI-gestütztem Coding optimieren und die besten Tools für ihre Workflows identifizieren möchten.\n'indexBrandName': 'BASTA!'\n'indexSeriesName': ''\n'author': 'Rainer Stropek'\n'chunkSource': 'text'\n'text': flott direkt eingebettet hier als Code Completion eine Antwort wollen, dann machen wir es hier links, oder nehmen wir uns etwas mehr Zeit, formulieren die Frage selbst hier unten in diesem Eingabefeld und geben dem System Sekunden, Minuten, eine Lösung zu finden und da kriegen wir aber dann das beste und intelligenteste, was wir haben können. Und hier müsst ihr als Nutzerinnen und dieser Systeme selbstbewusst entscheiden, was braucht ihr in der jeweiligen Situation? Braucht ihr das Maximum an Intelligenz, weil ihr gerade an einem richtig komplexen Algorithmus oder einem richtig großen Refactoring arbeitet, dann seid ihr hier im Chat- Editbereich sehr gut aufgehoben. Wollt ihr etwas machen auf der linken Seite, wo es um relativ einfache Geschichten geht, wo es einfach um Code geht, der so selbstverständlich ist, dass es eigentlich jeder schreiben könnte ihr habt einfach keine Lust diesen Code selbst zu schreiben, dann seid ihr hier links recht gut aufgehoben. Das müsst ihr euch einfach immer im Kopf behalten, das sind große Unterschiede die ihr seht. Also das haben wir gelernt, indem wir auf diesen Prompt drauf schauen, also auf diesen Response drauf schauen. Aber nehmt das bitte wieder als Konzeptwissen. Wenn ihr euch dieses Video in ein paar Monaten ansieht, dann kann es sein, dass hier bereits ein anderes Modell hinter den Kulissen arbeitet. Das kann ich nicht beurteilen, ich gebe euch Werkzeuge in die Hand, damit ihr nachsehen könnt oder versteht, wie es Stand heute funktioniert und was die Zukunft bringt, wissen wir nicht. Wenn wir da runterscrollen, dann werden wir irgendwo ich lade mal alle Daten, dann werden wir ganz unten sehen, datadone, da sagt der Server, so ich bin fertig, das ist die ganze Wahrheit das habe ich generiert. Den eigentlichen Text übrigens finden wir immer in diesem Delta-Content, bla bla bla, dieses Next, das wäre jetzt zum Beispiel ein Token, das das Large-Language-Model generiert hat. Jetzt bekommt ihr schon ein bisschen ein Gefühl dafür, wie dieses GitHub Copilot hinter den Kulissen arbeitet. Ich mach das wieder rückgängig, denn unsere vorherige Implementierung\n'slidetext': ''\n'from': 'vector'\n'score': 0.887561559677124\n'normalizedScore': 0.8754380404781134\n'beforeDatePenaltyScore': 0.887561559677124\n\n'documentId': 'f84097699062ea49829a9ba7'\n'chunk_id': '688744872d7a080012cea4c7'\n'access': 'granted'\n'part_number': 15\n'total_parts': 63\n'contentType': 'TUTORIAL'\n'title': Shadow DOM (Teil 3): Server-Side Rendering\n'parentName': Web Components von 0 auf 100\n'language': 'DE'\n'date': '2025-06-05T13:45:07.000Z'\n'abstract': In dieser Lesson schauen wir uns die Herausforderungen und Möglichkeiten von Server-Side Rendering mit Web Components an. Du erfährst, wie Tools wie Happy DOM funktionieren, warum SSR überhaupt notwendig ist, welche Strategien es für CSS gibt, wie unterschiedliche Architekturansätze aussehen können – und worauf du achten musst, um typische Fallen und fehlende Features zu umgehen.\n'parentId': '54cce7e83417cbefa7c0d3f0'\n'parentDescription': Web Components versprechen universelle Frontend-Komponenten, frei von Framework-Fesseln und Dependency-Depression. Das Problem: Web Components sind komplex, manche APIs wirken eigenartig, und das sie umgebende Ökosystem ist unübersichtlich. Was können Web Components leisten – und was nicht? Brauche ich wirklich Shadow DOM oder kann ich darauf verzichten? Vanilla-Komponenten, Lit – oder etwas dazwischen? In diesem Tutorial lernen wir, wie der Komponenten-Eintopf wirklich gemacht wird. Wir orientieren uns im Ökosystem und erhalten einen Überblick über die Fähigkeiten und Grenzen der Standards rund um Web Components. Von den absoluten API-Grundlagen bis zum Einsatz ausgewachsener Komponenten-Frameworks lassen wir keinen Schritt aus. In jedem Abschnitt unserer Reise erfahren wir nicht nur, wie etwas funktioniert, sondern auch, warum. Dieses Tutorial macht uns nicht nur zu Web-Component-Expert:innen, sondern vertieft auch unser Verständnis der Web-Plattform insgesamt.\n'indexBrandName': 'InternationalJavaScriptCon'\n'indexSeriesName': ''\n'author': 'Peter Kröner'\n'chunkSource': 'text'\n'text': serverseitiges Skript schreiben, das HTML frisst und ein anderes HTML ausspuckt, wo dann die entsprechenden Änderungen drin sind und das, was dann ausgespuckt wird, das liefer ich halt aus. Das ist so das Szenario statischer Seitengenerator. Wenn ihr irgendwas anderes habt, ihr werkelt halt da irgendwie mit einem Java CMS rum, ihr habt PHP am Start, dann wird das Ganze ein bisschen kniffliger, dann wird das wirklich auch eine Frage vom Deployment und wie wird das integriert in euren sonstigen Text-Stack und das ist ein Thema, das fasse ich nicht an, weil a habe ich keine Ahnung und b weiß ich nicht, wie euer Stack aussieht. Dazu kann ich halt nichts sagen. Ich will nur einmal kurz zu Demonstrationszwecken jetzt zeigen, wie Server-Site-Rendering in Aktion sein kann, aber ihr seht schon, das hat am Ende nicht wirklich was mit den Komponenten zu tun, die ihr schreibt. Ihr werdet die halt auf irgendeine Art und Weise schreiben müssen, dass das auf irgendeine Weise, mit welchem System auch immer ihr am Start habt, so zusammenspielt, dass Server-Site-Rendering passieren kann, wenn ihr das denn haben wollt. Und jetzt gucken wir uns mal einen Weg an das zu tun. Wie gesagt, in dem Modus Static Site Generation in der primitivsten Form. Ich habe einfach HTML und ich baue da das HTML um. Einfach gesagt. Ist tatsächlich mit den entsprechenden Tools auch gar nicht so schwierig, wenn euer Use-Case halt auch ein gar nicht so schwieriger ist. Aber gut, schauen wir uns mal an, wie das tatsächlich funktionieren würde. Auf geht's. Server-Site, rendern wir uns doch mal was. Ich habe mir dafür ein Tool rausgesucht, das heißt Happydom. Hier sehen wir die GitHub-Seite auf der linken Seite. Einfach nach Happydom suchen, dann findet ihr das. Was das ist ist im Prinzip eine JavaScript-Implementierung eines Browsers ohne User-Interface. Davon gibt es viele, aber das ist die die mit Abstand am einfachsten zu benutzen ist. Was es macht, ist tatsächlich ein Browser sein, so mehr oder minder. Es enthält also Dom und JavaScript und HTML und all das und bietet uns nicht eine Oberfläche mit Sachen zum Anklicken, sondern\n'slidetext': ''\n'from': 'vector'\n'score': 0.8853603601455688\n'normalizedScore': 0.8766979583996277\n'beforeDatePenaltyScore': 0.8853603601455688\n\n'documentId': 'a5dcfc84b51456a6b4b27fce'\n'chunk_id': '6878ecf322599b00136894d9'\n'access': 'granted'\n'part_number': 26\n'total_parts': 77\n'contentType': 'TUTORIAL'\n'title': Die Welt der Web Components\n'parentName': Web Components von 0 auf 100\n'language': 'DE'\n'date': '2025-06-05T13:45:07.000Z'\n'abstract': In der ersten Lesson steigen wir in die Welt der Web Components ein. Wir richten unser Setup ein, klären die Ziele des Tutorials – und schreiben unser erstes „Hello World“. Dabei beantworten wir die Grundfrage: Was sind Web Components eigentlich? Wir schauen uns Content-Attribute und DOM-Properties an, ziehen den Vergleich zu Frameworks und klären, wo Web Components glänzen – und wo nicht. Best Practices und erste UI-Beispiele runden den Einstieg ab.\n'parentId': '54cce7e83417cbefa7c0d3f0'\n'parentDescription': Web Components versprechen universelle Frontend-Komponenten, frei von Framework-Fesseln und Dependency-Depression. Das Problem: Web Components sind komplex, manche APIs wirken eigenartig, und das sie umgebende Ökosystem ist unübersichtlich. Was können Web Components leisten – und was nicht? Brauche ich wirklich Shadow DOM oder kann ich darauf verzichten? Vanilla-Komponenten, Lit – oder etwas dazwischen? In diesem Tutorial lernen wir, wie der Komponenten-Eintopf wirklich gemacht wird. Wir orientieren uns im Ökosystem und erhalten einen Überblick über die Fähigkeiten und Grenzen der Standards rund um Web Components. Von den absoluten API-Grundlagen bis zum Einsatz ausgewachsener Komponenten-Frameworks lassen wir keinen Schritt aus. In jedem Abschnitt unserer Reise erfahren wir nicht nur, wie etwas funktioniert, sondern auch, warum. Dieses Tutorial macht uns nicht nur zu Web-Component-Expert:innen, sondern vertieft auch unser Verständnis der Web-Plattform insgesamt.\n'indexBrandName': 'InternationalJavaScriptCon'\n'indexSeriesName': ''\n'author': 'Peter Kröner'\n'chunkSource': 'text'\n'text': arbeite irgendwo wo reakt oder angular oder view oder sonst irgendwas verwendet und aus irgendwelchen gründen bin ich jetzt der meinung web components müssen hier mitspielen das gute ist das ist exakt gar kein problem denn was machen denn die modernen web framework was macht das moderne tooling eigentlich naja das macht nichts weiter als abstraktionen zu schaffen über html und css und javascript über das was wir halt eben als die drei grundpfeiler einer webseite einer web applikation haben es gibt nichts anderes als diese drei pfeiler alles was darauf aufsetzt muss auf irgendeine art und weise mit denen interagieren und das kann man tatsächlich hier an diesem reakt hello world ganz gut sehen da ist dieses komische modul dass wir importieren müssen dann gibt es hier dieses zeug dass wir ignorieren können aber dann kommt hier die zeile 13 da wo halt eben wie es der 13 halt eben auch gut steht alles schief geht da verwendet reakt diese jsx syntax hier das sieht ein bisschen aus als wäre es html ist es aber nicht wirklich es ist im prinzip eine alternative aufruf syntax für funktionen und das macht unter der haube im prinzip ein document create element h1 mit sehr vielen zwischenschritten aber das ist was am ende passiert es wird ein h1 element erstellt und am ende mit hilfe der reakt logik in die webseite gerendert und das können wir auch hier in meinem browser sehen da ist nach h1 mit hello world drin das funktioniert also ganz hervorragend ok was man jetzt aber wirklich wissen muss ist dass reakt eigentlich nur sich auf diese h1 draufgesetzt hat es hat die h1 nicht wirklich neu erfunden es hat nicht wirklich dazu irgendwas beigetragen außer halt alles was reakt ausmacht also den rendermechanismus und das statement und hast du nicht gesehen das ist da alles drin aber am ende wenn es halt wirklich darum geht irgendwas in den browser rein zu beamen dann muss es auch wieder zum nativen html greifen und so sachen wie diffs und h1 elemente und ähnliches benutzen und wissen was noch ein html element ist richtig genau unser hello world hier das kann ganz wunderbar in einer reakt application funktionieren wir können wirklich hingehen können buchstäblich diesen code nehmen können den\n'slidetext': ''\n'from': 'vector'\n'score': 0.8856419324874878\n'normalizedScore': 0.8769795307415467\n'beforeDatePenaltyScore': 0.8856419324874878\n\n'documentId': 'a5dcfc84b51456a6b4b27fce'\n'chunk_id': '6878ecf122599b00136894c4'\n'access': 'granted'\n'part_number': 5\n'total_parts': 77\n'contentType': 'TUTORIAL'\n'title': Die Welt der Web Components\n'parentName': Web Components von 0 auf 100\n'language': 'DE'\n'date': '2025-06-05T13:45:07.000Z'\n'abstract': In der ersten Lesson steigen wir in die Welt der Web Components ein. Wir richten unser Setup ein, klären die Ziele des Tutorials – und schreiben unser erstes „Hello World“. Dabei beantworten wir die Grundfrage: Was sind Web Components eigentlich? Wir schauen uns Content-Attribute und DOM-Properties an, ziehen den Vergleich zu Frameworks und klären, wo Web Components glänzen – und wo nicht. Best Practices und erste UI-Beispiele runden den Einstieg ab.\n'parentId': '54cce7e83417cbefa7c0d3f0'\n'parentDescription': Web Components versprechen universelle Frontend-Komponenten, frei von Framework-Fesseln und Dependency-Depression. Das Problem: Web Components sind komplex, manche APIs wirken eigenartig, und das sie umgebende Ökosystem ist unübersichtlich. Was können Web Components leisten – und was nicht? Brauche ich wirklich Shadow DOM oder kann ich darauf verzichten? Vanilla-Komponenten, Lit – oder etwas dazwischen? In diesem Tutorial lernen wir, wie der Komponenten-Eintopf wirklich gemacht wird. Wir orientieren uns im Ökosystem und erhalten einen Überblick über die Fähigkeiten und Grenzen der Standards rund um Web Components. Von den absoluten API-Grundlagen bis zum Einsatz ausgewachsener Komponenten-Frameworks lassen wir keinen Schritt aus. In jedem Abschnitt unserer Reise erfahren wir nicht nur, wie etwas funktioniert, sondern auch, warum. Dieses Tutorial macht uns nicht nur zu Web-Component-Expert:innen, sondern vertieft auch unser Verständnis der Web-Plattform insgesamt.\n'indexBrandName': 'InternationalJavaScriptCon'\n'indexSeriesName': ''\n'author': 'Peter Kröner'\n'chunkSource': 'text'\n'text': komplett ignorieren, aber dann besprechen werde. Also Bundler und Compiler und Optimizer, wie kann ich irgendwie TypeScript in meinen Web Components benutzen und wie sinnvoll ist das? Das werden wir da alles besprechen, das wird einfach so eine bunte Tool Show werden und das bietet dann so bisschen den Abschluss der Orientierungsphase. Danach seid ihr hoffentlich in der Lage, euch selbst auszusuchen, wie ihr denn operieren möchtet. Wollt ihr Vanilla Web Components schreiben oder wollt ihr ein Framework verwenden oder vielleicht irgendwas dazwischen euch gar, Gott bewahre, was eigenes bauen, das kann man dann nämlich relativ gut machen, das werden wir alles mal durchgekaut haben. Und zum Abschluss bauen wir einmal so eine Web Component wirklich von vorne bis hinten, beginnend bei einer blanken Datei und endend bei einem komplett, ja, alle Features benutzenden Objekte, einem Element. Ich habe mir da so einen Dark Mode Selektor ausgedacht, weil naja, das ist glaube ich, ganz gutes Beispiel. So Dark Mode Selektor ist was, das braucht man ständig, so ziemlich jede Webseite sollte sowas haben, dass man das so troggeln kann auf einer Pro Seitenbasis. Und es ist auch irgendwie was, wo jeder von uns glaube ich, ganz gut umreißen kann, was so die Anforderungen von sowas sind. Dark Mode Selektor kennen wir alle. Aber zum anderen ist es halt eben auch nicht ganz trivial, so ein Ding zu bauen. Da gibt es viele, viele Feinheiten. Es muss irgendwie interaktiv sein, es muss irgendwie einigermaßen zugänglich sein, es muss per Tastatur bedienbar sein, es muss universell sein, anpassbar sein und es muss halt eben auch eine ganze Menge komplizierten Zustand managen. Es muss sich irgendwie initialisieren, entweder irgendwelchen vorherigen State aus dem Storage lesen den wir schon mal eingestellt haben, oder sich initialisieren, abhängig davon, was die Einstellungen sind. Das ist also alles gar nicht mal so trivial, wenn man anfängt, drüber nachzudenken, und wir werden einfach mal das dadurch exerzieren, weil das, glaube ich, eine gute Demonstration ist, wo man dann auch wirklich mal jeden Aspekt von allem, was wir bisher besprochen haben, werden einmal\n'slidetext': ''\n'from': 'vector'\n'score': 0.8860228657722473\n'normalizedScore': 0.8773604640263062\n'beforeDatePenaltyScore': 0.8860228657722473\n\n'documentId': 'f84097699062ea49829a9ba7'\n'chunk_id': '6887448a2d7a080012cea4e3'\n'access': 'granted'\n'part_number': 43\n'total_parts': 63\n'contentType': 'TUTORIAL'\n'title': Shadow DOM (Teil 3): Server-Side Rendering\n'parentName': Web Components von 0 auf 100\n'language': 'DE'\n'date': '2025-06-05T13:45:07.000Z'\n'abstract': In dieser Lesson schauen wir uns die Herausforderungen und Möglichkeiten von Server-Side Rendering mit Web Components an. Du erfährst, wie Tools wie Happy DOM funktionieren, warum SSR überhaupt notwendig ist, welche Strategien es für CSS gibt, wie unterschiedliche Architekturansätze aussehen können – und worauf du achten musst, um typische Fallen und fehlende Features zu umgehen.\n'parentId': '54cce7e83417cbefa7c0d3f0'\n'parentDescription': Web Components versprechen universelle Frontend-Komponenten, frei von Framework-Fesseln und Dependency-Depression. Das Problem: Web Components sind komplex, manche APIs wirken eigenartig, und das sie umgebende Ökosystem ist unübersichtlich. Was können Web Components leisten – und was nicht? Brauche ich wirklich Shadow DOM oder kann ich darauf verzichten? Vanilla-Komponenten, Lit – oder etwas dazwischen? In diesem Tutorial lernen wir, wie der Komponenten-Eintopf wirklich gemacht wird. Wir orientieren uns im Ökosystem und erhalten einen Überblick über die Fähigkeiten und Grenzen der Standards rund um Web Components. Von den absoluten API-Grundlagen bis zum Einsatz ausgewachsener Komponenten-Frameworks lassen wir keinen Schritt aus. In jedem Abschnitt unserer Reise erfahren wir nicht nur, wie etwas funktioniert, sondern auch, warum. Dieses Tutorial macht uns nicht nur zu Web-Component-Expert:innen, sondern vertieft auch unser Verständnis der Web-Plattform insgesamt.\n'indexBrandName': 'InternationalJavaScriptCon'\n'indexSeriesName': ''\n'author': 'Peter Kröner'\n'chunkSource': 'text'\n'text': könnte als so. Außerdem kann man ja vielleicht wirklich was an der Developer Experience tun. Nehmen wir mal das Letztere als erstmal unser Starkbeispiel. Theoretisch ist es ja so, dass die wenigsten Menschen jetzt Web-Entwicklung so betreiben, wie ich das hier betreibe. Das hier ist wirklich eine nackte HTML-Seite und jedes Mal, wenn ich abspeichere, ist da wirklich nichts weiter drin als eine IDE-Extension, die den Browser nebenan macht, hier naht mal neu. Ich habe hier in dem Beispiel hier und bei den meisten anderen, die ich gezeigt habe, außer den React-Beispielen, keinen Bildprozess dabei, keinen Optimierer, keinen CSS-Prozessor, kein gar nichts. Ich verlasse mich wirklich darauf, dass mein Browser, also hier ein ganz normaler Firefox, in der Lage ist, mit modernen JavaScript-Modulen umzugehen. Das ist, was ich hier mache. Was ich mache, ist nicht der Normalfall. Der Normalfall ist tatsächlich, dass ihr irgendwas am Start habt, was in der Lage ist, ein bisschen smarter zu sein. Was spezielle Modul-Lade-Mechanismen zum Beispiel beinhaltet und was man dann da machen könnte. In so einem System, rein theoretisch, wäre sowas zu schreiben wie import styles from foo.css. Wenn ihr jetzt eine foo.css am Start habt, könnte natürlich ein Browser hiermit nichts anfangen, weil Browser standardmäßig CSS nicht importieren können. Ja, können sie demnächst vielleicht schon wir kommen da nachher noch zu. Aber normalerweise würde diese Zeile 7, so wie sie hier steht, nicht funktionieren. Aber wenn ihr irgendeine Art von Compiler habt, ein Webpack oder irgendwas in der Richtung, könnte dieses Ding, sich diese Zeile anschauen, könnte feststellen, hm dot CSS, das sollte ich vielleicht nicht als JavaScript-Modul laden, sondern vielleicht einfach als Text. Dass hier also wirklich CSS-Text rauskommt. Und wenn das der Fall wäre, dann könnte man natürlich hingehen und könnte in seiner Komponente einfach sowas hier machen. Styles kommen hier rein. Und schon ist es nicht mehr ganz so schlimm und man hat eine Trennung geschaffen von der JavaScript-Komponente hier und den CSS-Styles irgendwo anders. Weil das ja vielleicht etwas ist, das ihr Wert legt. Und dann\n'slidetext': ''\n'from': 'vector'\n'score': 0.887181282043457\n'normalizedScore': 0.8785188802975159\n'beforeDatePenaltyScore': 0.887181282043457\n\n'documentId': 'e041b16a103e515fb3ff7fa7'\n'chunk_id': '6876df647899910dd58c1019'\n'access': 'granted'\n'part_number': 34\n'total_parts': 35\n'contentType': 'TUTORIAL'\n'title': Zugriff auf lokale Datenbanken\n'parentName': Mit .NET MAUI zur erfolgreichen Cross-Platform-App\n'language': 'DE'\n'date': '2025-02-07T10:45:08.000Z'\n'abstract': In dieser Lesson geht es um: -Zugriff auf lokale Datenbanken -Feinschliff -Abschluss\n'parentId': 'dd0d8f751be8d368f2f60eb9'\n'parentDescription': Zusammen mit Microsoft MVP André Krämer lernst du Schritt für Schritt, wie du mit .NET MAUI in C# und .NET native Apps für Android, iOS, macOS und Windows aus einer einzigen Codebasis erstellst. Du gestaltest ansprechende Benutzeroberflächen mit XAML und dem MVVM-Design-Pattern, stellst Daten in Listen übersichtlich dar und navigierst dabei nahtlos zwischen verschiedenen Ansichten. Zudem erfährst du, wie du Dependency Injection effizient einsetzt und native Gerätefunktionen wie die Kamera nutzt. Das praxisorientierte Tutorial ermöglicht dir, moderne Cross-Platform-Apps eigenständig zu entwickeln.\n'indexBrandName': 'BASTA!'\n'indexSeriesName': ''\n'author': 'André Krämer'\n'chunkSource': 'text'\n'text': und ich bin hier auf meinem GitHub-Profil, github.com slash André Kremer. Und hier sind für dich zwei relevante Repositories. zwar, klicke mir auf den Repositories-Tab und dann siehst du im Moment ist es ganz oben, falls das später irgendwann, wenn du hier drauf gehst, nicht mehr ganz oben ist, gar kein Problem. Du kannst hier einfach suchen nach Entwickler und dann siehst du hier das Entwickler.de Tutorial für die Anwendung WhoBorrowedIt. Also für das, was wir hier programmiert haben. Und wenn du dort reinklickst, dann siehst du sofort, das Ganze ist unter GitHub.com André Kremer Entwickler.de Tutorial Who Borrowed It. Und hier ist der komplette Quellcode drin von allem, was wir in diesem Tutorial gemeinsam erstellt haben. Heißt also, im Zweifelsfall klonest du dir das Tutorial oder noch einfach, du lädst dir einfach hier die ZIP-Datei herunter, dann entpackst du die und kannst von dort aus loslegen und die fehlenden Masken programmieren. Ich habe gesagt, hier sind mal Minimum zwei spannende Tutorials für dich drin. Nämlich wenn du hier mal reinschaust, dann siehst du hier direkt auf der Startseite den Sourcecode zu meinem Maui Buch. Natürlich, den verstehst du am besten, wenn du auch das zugehörige Buch dazu ich habe es ja mehrfach im Tutorial hier angemerkt, wenn du das auch noch direkt dazu dir bekaufst. Aber auch ansonsten, selbst wenn du das nicht hast, schau mal, das ist so aufgebaut, du hast hier jeweils die einzelnen Buchkapitel und du dort reinklickst, findest du immer ich nehme vielleicht mal ein anderes Kapitel oder 17er hier, dann findest du immer einen Ordner Don't let me expire, das ist die durchgängige Beispiel-App im Buch, die du hier dann auch verfolgen kannst, wie die sich Kapitel für Kapitel weiterentwickelt und du immer ein technisches Beispiel, hier zum Beispiel Kapitel 17, wie arbeite ich mit Bildern oder auch in Kapitel 19, wie findest du hier eigentlich, ab Kapitel 8 glaube ich ist es, in jedem Kapitel siehst du hier die Beispielanwendung plus ein technisches Beispiel. Also schau dort rein, dort lernst du noch eine ganze ganze Menge mehr\n'slidetext': ''\n'from': 'vector'\n'score': 0.8958971500396729\n'normalizedScore': 0.8807621461882015\n'beforeDatePenaltyScore': 0.8958971500396729\n\n'documentId': 'a5dcfc84b51456a6b4b27fce'\n'chunk_id': '6878ecf122599b00136894c5'\n'access': 'granted'\n'part_number': 6\n'total_parts': 77\n'contentType': 'TUTORIAL'\n'title': Die Welt der Web Components\n'parentName': Web Components von 0 auf 100\n'language': 'DE'\n'date': '2025-06-05T13:45:07.000Z'\n'abstract': In der ersten Lesson steigen wir in die Welt der Web Components ein. Wir richten unser Setup ein, klären die Ziele des Tutorials – und schreiben unser erstes „Hello World“. Dabei beantworten wir die Grundfrage: Was sind Web Components eigentlich? Wir schauen uns Content-Attribute und DOM-Properties an, ziehen den Vergleich zu Frameworks und klären, wo Web Components glänzen – und wo nicht. Best Practices und erste UI-Beispiele runden den Einstieg ab.\n'parentId': '54cce7e83417cbefa7c0d3f0'\n'parentDescription': Web Components versprechen universelle Frontend-Komponenten, frei von Framework-Fesseln und Dependency-Depression. Das Problem: Web Components sind komplex, manche APIs wirken eigenartig, und das sie umgebende Ökosystem ist unübersichtlich. Was können Web Components leisten – und was nicht? Brauche ich wirklich Shadow DOM oder kann ich darauf verzichten? Vanilla-Komponenten, Lit – oder etwas dazwischen? In diesem Tutorial lernen wir, wie der Komponenten-Eintopf wirklich gemacht wird. Wir orientieren uns im Ökosystem und erhalten einen Überblick über die Fähigkeiten und Grenzen der Standards rund um Web Components. Von den absoluten API-Grundlagen bis zum Einsatz ausgewachsener Komponenten-Frameworks lassen wir keinen Schritt aus. In jedem Abschnitt unserer Reise erfahren wir nicht nur, wie etwas funktioniert, sondern auch, warum. Dieses Tutorial macht uns nicht nur zu Web-Component-Expert:innen, sondern vertieft auch unser Verständnis der Web-Plattform insgesamt.\n'indexBrandName': 'InternationalJavaScriptCon'\n'indexSeriesName': ''\n'author': 'Peter Kröner'\n'chunkSource': 'text'\n'text': wir werden einfach mal das dadurch exerzieren, weil das, glaube ich, eine gute Demonstration ist, wo man dann auch wirklich mal jeden Aspekt von allem, was wir bisher besprochen haben, werden einmal in Aktion sehen kann. Es ist also überschaubar und verständlich und klar abgegrenzt, aber nicht trivial. Das ist so im Wesentlichen mein Plan und die Ziele sind, wie gesagt, vor allen Dingen für mich Orientierung, dass ihr genau wisst, was es alles gibt und wie die Dinge zusammengehören. Dann auch ein bisschen Verständnis dafür, warum die Technologien so sind, wie sie sind, warum es auch nach diesem Videotutorial für euch viel, einfacher sein wird, ne Angular oder ne React-Komponente zu bauen. Die sind nämlich einfacher zu bauen, aber ein bisschen Verständnis dafür, warum das so ist und ne Einsicht in die Trade-offs, sodass man sich dann eventuell entscheiden kann. Ich wirklich mit meinem klassischen Frontend-Framework arbeite oder brauche ich ein Web-Component-Framework oder möglicherweise auch die Kombination aus beidem das gibt es nämlich auch. Dann möchte ich natürlich euch auch in die Lage versetzen, zur Not die ganzen Sachen manuell selber zu schreiben, also nicht nur die Frameworks zu bedienen. wenn wir das alles dann zusammen haben, dann glaube ich seid ihr ganz brauchbare Nerds Sachen Web-Components. Ihr wisst, wie die Wurst gemacht wird und ihr wisst, wann ihr euch wirklich mit diesen Details befassen wollt und wann nicht. Und das ist im Wesentlichen mein Plan für dieses Videotutorial. Und ich würde sagen, jetzt wo wir die ganzen Basics und die Planung und die Agenda aus dem Weg geräumt haben, bleibt nur eins, wir müssen anfangen. Wir müssen anfangen mit dem, womit wir bei solchen Tutorials immer anfangen müssen, nämlich mit Hallo Welt. Und genau das machen wir jetzt. Das war jetzt wirklich genug Gephasel von Dingen die man mal machen könnte, Zielen, die man haben könnte und Dingen, die vielleicht mal kompliziert sein werden. Was wir jetzt machen, ist ne richtige Web-Component bauen. Wir schauen uns an, wie die einzelnen Dinge zusammenspielen und wie das so grob funktionieren kann. Grundsätzlich\n'slidetext': ''\n'from': 'vector'\n'score': 0.8905597925186157\n'normalizedScore': 0.8818973907726746\n'beforeDatePenaltyScore': 0.8905597925186157\n\n'documentId': 'ed6b19fe4c4328050dad69e5'\n'chunk_id': '68c2ee68787074001356ea83'\n'access': 'granted'\n'part_number': 37\n'total_parts': 40\n'contentType': 'TUTORIAL'\n'title': Typsicheres Routing mit TanStack Router\n'parentName': Modern React: von Null auf Full-Stack\n'language': 'DE'\n'date': '2025-08-27T09:53:51.000Z'\n'abstract': In dieser Lesson lernst du, wie du mit dem TanStack Router eine moderne, typsichere Navigation in deine React-App bringst – inklusive Unterstützung für Links, Back-Button und Bookmarks. Wir zeigen dir die File-System-basierte Routenstruktur, dynamische Routen, Layout-Routen sowie die Verwendung von typsicheren Suchparametern. Außerdem: Integration mit TanStack Query und Performanceoptimierungen.\n'parentId': 'b2c71c7c41dfe8eab4593f02'\n'parentDescription': In diesem Videotutorial lernst du React von Grund auf – bis hin zur Full-Stack-Entwicklung mit Next.js. Du baust Single Page Applications, verwaltest State, entwickelst moderne Formulare, arbeitest mit serverseitigen Daten und setzt Routing effizient um. Zum Abschluss bekommst du eine Einführung in React Server Components und Next.js. Benötigte Vorkenntnisse: JavaScript-Grundlagen, TypeScript ist hilfreich, aber nicht zwingend nötig. Nach dem Tutorial bist du bereit, eigene client- und serverseitige Anwendungen mit React umzusetzen.\n'indexBrandName': 'InternationalJavaScriptCon'\n'indexSeriesName': ''\n'author': 'Nils Hartmann'\n'chunkSource': 'text'\n'text': Weise, wie man Tenstack Query und Tenstack Router miteinander verknüpfen können. So ähnlich, muss man fairer Weise sagen, würde das auch mit dem React Router und Tenstack Query funktionieren. Aber hier ist die Integration natürlich besonders schön auch mit diesen Suchparametern und der Idee, dass ich angebe, wann soll mein Loder eigentlich ausgeführt werden, dann wird er nicht zu häufig und hoffentlich auch nicht zu selten ausgeführt. Damit haben wir das Datenladen jetzt einigermaßen optimiert. Jetzt haben wir unter Umständen noch ein anderes Problem, was auch ein häufiger Kritikpunkt an Single-Page-Anwendung ist. Und zwar, wenn ich meinen Link hier nehme und im Browser aufrufe, dann dauert das natürlich jetzt in dem Fall extrem lange, weil mein Query hier so lange ist. In einer richtigen Anwendung könnte aber auch das Problem bestehen, dass sowieso das erstmal relativ lange dauert, bis der JavaScript-Code für unsere Anwendung in den Browser geladen worden ist. Wir müssen uns ja vergegenwärtigen, wir rufen diese Adresse auf. Der Client macht ein Request zu unserem Server, der unter Umständen ja weit weg von uns steht, uns als Client, lädt den JavaScript-Code runter, muss den JavaScript-Code ausführen und erst dann können die Loader loslaufen, erst dann können die Komponenten gerendert werden. Das heißt da habe ich eine gewisse Latenz zwischen, ich habe die URL hier aufgerufen, die Anwendung ist da und die Anwendung kann loslaufen, um Daten zu laden. Je nachdem, wie groß der JavaScript-Code ist, kann das natürlich ein Momentchen dauern und das ist auf jeden Fall das kann man glaube ich mehr oder weniger pauschal so sagen, langsamer, als wenn ich eine serverseitig gerenderte Anwendung habe. Ob das ein Problem ist sei mal dahingestellt. Üblicherweise sind die Anwendungen ja trotzdem sehr schnell, aber natürlich können wir da eventuell auch noch bisschen Performance rausholen. Eine Kleinigkeit die wir hier machen können, das Thema zumindest ein bisschen besser zu machen, ich breche jetzt mal unseren Bildprozess hier ab, also den Development Server und werde mal einen Bild ausführen. Bild clean. Ich mache jetzt mal ein Produktionsbild von unserer Anwendung in Hoffnung, dass ich hier keine Fehler drin habe.\n'slidetext': ''\n'from': 'vector'\n'score': 0.886326789855957\n'normalizedScore': 0.882203533214024\n'beforeDatePenaltyScore': 0.886326789855957\n\n'documentId': 'ed6b19fe4c4328050dad69e5'\n'chunk_id': '68c2ee64787074001356ea57'\n'access': 'granted'\n'part_number': 1\n'total_parts': 40\n'contentType': 'TUTORIAL'\n'title': Typsicheres Routing mit TanStack Router\n'parentName': Modern React: von Null auf Full-Stack\n'language': 'DE'\n'date': '2025-08-27T09:53:51.000Z'\n'abstract': In dieser Lesson lernst du, wie du mit dem TanStack Router eine moderne, typsichere Navigation in deine React-App bringst – inklusive Unterstützung für Links, Back-Button und Bookmarks. Wir zeigen dir die File-System-basierte Routenstruktur, dynamische Routen, Layout-Routen sowie die Verwendung von typsicheren Suchparametern. Außerdem: Integration mit TanStack Query und Performanceoptimierungen.\n'parentId': 'b2c71c7c41dfe8eab4593f02'\n'parentDescription': In diesem Videotutorial lernst du React von Grund auf – bis hin zur Full-Stack-Entwicklung mit Next.js. Du baust Single Page Applications, verwaltest State, entwickelst moderne Formulare, arbeitest mit serverseitigen Daten und setzt Routing effizient um. Zum Abschluss bekommst du eine Einführung in React Server Components und Next.js. Benötigte Vorkenntnisse: JavaScript-Grundlagen, TypeScript ist hilfreich, aber nicht zwingend nötig. Nach dem Tutorial bist du bereit, eigene client- und serverseitige Anwendungen mit React umzusetzen.\n'indexBrandName': 'InternationalJavaScriptCon'\n'indexSeriesName': ''\n'author': 'Nils Hartmann'\n'chunkSource': 'text'\n'text': Typsicheres Routing mit TanStack Router In dieser Lesson lernst du, wie du mit dem TanStack Router eine moderne, typsichere Navigation in deine React-App bringst – inklusive Unterstützung für Links, Back-Button und Bookmarks. Wir zeigen dir die File-System-basierte Routenstruktur, dynamische Routen, Layout-Routen sowie die Verwendung von typsicheren Suchparametern. Außerdem: Integration mit TanStack Query und Performanceoptimierungen. So, haben uns jetzt schon mit einer ganzen Reihe von Themen auseinandergesetzt. Wir haben gesehen, wie React grundsätzlich überhaupt funktioniert. Wir haben gesehen, wie wir mit Daten lesen, schreiben und so weiter klarkommen in unseren Anwendungen. Und wir haben uns damit auseinandergesetzt, wie wir Formulare bauen können. Und das alles haben wir jeweils gemacht anhand von ich sage mal, einzelnen isolierten Komponenten, die wir natürlich zu größeren Komponenten, Strukturen dann zusammengesteckt haben. Aber wir haben nicht so was gebaut wie eine Anwendung, wo man jetzt sagt, ich komme jetzt hier irgendwie rein, irgendwo an und dann klicke ich irgendwo drauf und dann bin ich im anderen Teil und so weiter und so fort. Und genau dieses Teil wollen wir uns jetzt angucken. Also wir bauen jetzt quasi richtig eine Anwendung, die aus mehreren Seiten sozusagen besteht, auch wenn wir technisch natürlich weiterhin eine Single Page Anwendung bauen. Und wenn wir jetzt mehrere Seiten in unserer Anwendung haben wollen, dann müssen wir üblicherweise so was wie einen Router verwenden. Ein Router ist dazu da, quasi URLs oder Fade in unserem Browser auf Komponenten abzubilden, sodass man quasi weiß, ich slash admin zum Beispiel aufgerufen habe, dann soll das Dashboard zum Beispiel erscheinen. Oder wenn ich nur die slash aufgerufen habe, dann soll vielleicht eine Landing Page erscheinen. Oder wenn ich slash user slash drei aufgerufen habe, dann soll die UI zum Bearbeiten des Users mit der ID 3 aufgerufen werden. Solche Geschichten. Dazu benutzt man einen Router und dieser Router ist eben dazu da, einerseits die Komponenten mit der URL zu verknüpfen, so funktioniert, wie wir das von Server-seitigen Anwendungen auch gewohnt sind. Also sprich, dass wir den Backbutton verwenden können, sprich, dass\n'slidetext': ''\n'from': 'vector'\n'score': 0.8878779411315918\n'normalizedScore': 0.8837546844896588\n'beforeDatePenaltyScore': 0.8878779411315918\n\n'documentId': '50c03dd02cf9b7c2ff4480f2'\n'chunk_id': '68b55eab33a5bf00132cb687'\n'access': 'granted'\n'part_number': 6\n'total_parts': 47\n'contentType': 'TUTORIAL'\n'title': React-Grundlagen\n'parentName': Modern React: von Null auf Full-Stack\n'language': 'DE'\n'date': '2025-08-27T09:53:51.000Z'\n'abstract': In der ersten Lesson lernst du, was React ist und wie es funktioniert. Anhand einer Beispielanwendung schauen wir uns den Projektaufbau und den Workspace an. Du erfährst, wie Komponenten aufgebaut sind, wie man mit Props, Listen und State arbeitet und wie Interaktionen in React abgebildet werden.\n'parentId': 'b2c71c7c41dfe8eab4593f02'\n'parentDescription': In diesem Videotutorial lernst du React von Grund auf – bis hin zur Full-Stack-Entwicklung mit Next.js. Du baust Single Page Applications, verwaltest State, entwickelst moderne Formulare, arbeitest mit serverseitigen Daten und setzt Routing effizient um. Zum Abschluss bekommst du eine Einführung in React Server Components und Next.js. Benötigte Vorkenntnisse: JavaScript-Grundlagen, TypeScript ist hilfreich, aber nicht zwingend nötig. Nach dem Tutorial bist du bereit, eigene client- und serverseitige Anwendungen mit React umzusetzen.\n'indexBrandName': 'InternationalJavaScriptCon'\n'indexSeriesName': ''\n'author': 'Nils Hartmann'\n'chunkSource': 'text'\n'text': so schlau sind, hier in meinen Beispieldaten sei mal dahingestellt. Ehrlich gesagt, die Beispieldaten habe ich mir von Chetjibiti generieren lassen, die nicht so für bare Münze unbedingt nehmen. Dann haben wir hier unten können wir eingeben, welche Zutaten das Rezept braucht, können natürlich auch Zutaten löschen und so weiter. Und wir können dann eingeben, wie man das Rezept eigentlich zubereitet. Und in diesem Formular, wie gesagt, da sind so unterschiedliche Patterns drin, die wir uns angucken werden, wie man die baut, beispielsweise bei diesen Instructions hier. Die kann ich zum Beispiel mit Dreck in Drop umschieben. Wenn ich festgestellt habe, ich habe in der falschen Reihenfolge eingegeben. Ein zweites Pattern ist hier bei diesem Image zum Beispiel, dass ich hier ein neues Bild hochladen kann. Ich habe jetzt nicht so viele Beispielbilder, deswegen nehme ich hier mal eine Nudel und dann nehmen wir die mal hier und dann wird die hochgeladen. Und dann kann ich hier so ein bisschen da noch reinzoomen, wenn ich das möchte. Rauszoomen, wie man das ebenso von modernen Anwendungen kennt, kann hier den Bildausschnitt festlegen. Das Bild ist ein bisschen klein, ich muss wieder bisschen reinzoomen. So hier schön mit den Tomaten und dem Käse. Und dann kann ich das speichern und könnte das jetzt auch diesem Rezept hinzufügen, wenn ich das möchte. Das Rezept könnte ich natürlich jetzt auch noch speichern, das lasse ich mal weil ich jetzt die hier nur so zum Beispiel so ein paar Änderungen gemacht habe, die nicht wirklich sinnvoll sind. Aber wie gesagt, man dieses Formular entwickelt, werde ich euch zeigen. Ich werde euch zeigen, wie man kleinseitig mit verschiedenen Routen arbeitet. Wenn ihr mal hier auf die URL achtet, werdet ihr sehen, dass sich die immer ändert. Wenn ich hier rumklick, relativ lang. Da stehen relativ viele Informationen drin. Aber so verhält sich das ja in modernen Anwendungen. Genau, also das sind sozusagen die Themen, die wir uns angucken wollen. Wir wollen angucken, wie baue ich überhaupt React-Komponenten Was sind die Grundlagen von React? Wie kann ich mit serverseitigen\n'slidetext': ''\n'from': 'vector'\n'score': 0.8885044455528259\n'normalizedScore': 0.8843811889108929\n'beforeDatePenaltyScore': 0.8885044455528259\n\n'documentId': '50c03dd02cf9b7c2ff4480f2'\n'chunk_id': '68b55eab33a5bf00132cb684'\n'access': 'granted'\n'part_number': 3\n'total_parts': 47\n'contentType': 'TUTORIAL'\n'title': React-Grundlagen\n'parentName': Modern React: von Null auf Full-Stack\n'language': 'DE'\n'date': '2025-08-27T09:53:51.000Z'\n'abstract': In der ersten Lesson lernst du, was React ist und wie es funktioniert. Anhand einer Beispielanwendung schauen wir uns den Projektaufbau und den Workspace an. Du erfährst, wie Komponenten aufgebaut sind, wie man mit Props, Listen und State arbeitet und wie Interaktionen in React abgebildet werden.\n'parentId': 'b2c71c7c41dfe8eab4593f02'\n'parentDescription': In diesem Videotutorial lernst du React von Grund auf – bis hin zur Full-Stack-Entwicklung mit Next.js. Du baust Single Page Applications, verwaltest State, entwickelst moderne Formulare, arbeitest mit serverseitigen Daten und setzt Routing effizient um. Zum Abschluss bekommst du eine Einführung in React Server Components und Next.js. Benötigte Vorkenntnisse: JavaScript-Grundlagen, TypeScript ist hilfreich, aber nicht zwingend nötig. Nach dem Tutorial bist du bereit, eigene client- und serverseitige Anwendungen mit React umzusetzen.\n'indexBrandName': 'InternationalJavaScriptCon'\n'indexSeriesName': ''\n'author': 'Nils Hartmann'\n'chunkSource': 'text'\n'text': nicht so gut von existierenden Frameworks abgebildet werden oder wenn man vielleicht sogar sein eigenes Framework bauen will oder wenn du die Grundlagen von React lernen möchtest, dann gibt es auch noch andere Optionen. Dann musst du kein Framework benutzen. Und genau das werden wir im ersten Schritt machen. Wir werden keins dieser Frameworks benutzen und wir werden später auch noch diskutieren, in welchen Fällen aus meiner Sicht ein Framework überhaupt Sinn macht oder nicht. Denn nicht stimmen den Punkten, die hier auf dieser Webseite genannt sind oder die von dem React-Team ins Feld geführt werden, nicht in allen Punkten zu und sehen das ein bisschen differenzierter oder bisschen kritischer vielleicht. Das ist dann wie gesagt, meine Meinung. Aber dazu müssen wir natürlich erst mal wissen, was das eine ist und was überhaupt das andere ist. Und in diesem Kurs möchte ich mit euch eine vollständige React-Anwendung bauen. Am Anfang werden wir da sehr fein granular vorgehen, Schritt für Schritt. Und diese Anwendung besteht im Prinzip aus zwei Teilen, wenn man so möchte. Das eine ist eine Admin-Anwendung. Damit fangen wir gleich an. Damit können wir Daten verwalten. Und das andere habe ich mal Frontend-Anwendung genannt. Das wäre eine Anwendung die quasi öffentlich im Internet steht und die diese Daten anzeigt. Und damit fange ich mal an bzw. Das zeige euch jetzt mal im ersten Schritt hier. Das ist die fertige Anwendung, die nennt sich Recipify. Und die Idee davon ist, dass ich Kochrezepte eingeben kann und diese Kochrezepte anderen Menschen zur Verfügung stellen kann. Das ist jetzt die sogenannte Frontend-Anwendung Die läuft tatsächlich mit Next.js und die gucken wir uns dann später an. Ich möchte jetzt erst mal nur zeigen, wie sie quasi aussieht. Wir haben hier diese Landing-Page. Wir können hier die Seite aufrufen. Dann seht ihr wir haben hier eine Liste von Kochrezepten. Wir können auf ein Kochrezept draufklicken. Wir können dann dieses Kochrezept uns anschauen. Wir haben hier sowas wie Zutaten. Wir haben hier sowas wie Kochinstructions. Also was muss ich eigentlich machen, um dieses Gericht zu kochen? Ich kann hier\n'slidetext': ''\n'from': 'vector'\n'score': 0.889756441116333\n'normalizedScore': 0.8856331844744\n'beforeDatePenaltyScore': 0.889756441116333\n\n'documentId': 'fb34eb7009846674dee32bf6'\n'chunk_id': '68c0399287c67b0014cf549d'\n'access': 'granted'\n'part_number': 1\n'total_parts': 1\n'contentType': 'TUTORIAL'\n'title': Datenabfrage mit TanStack Query\n'parentName': Modern React: von Null auf Full-Stack\n'language': 'EN'\n'date': '2025-08-27T09:53:51.000Z'\n'abstract': In der dritten Lesson lernst du, wie du mit TanStack Query effizient Daten von einem API abrufst und verwaltest – ein zentrales Thema in modernen SPAs. Du erfährst, wie du Daten mit Zod und TypeScript validierst, Typen automatisch aus einer OpenAPI-Beschreibung generierst und den Query-Cache gezielt nutzt. Außerdem klären wir, wie du mit React Suspense die Darstellung priorisieren kannst.\n'parentId': 'b2c71c7c41dfe8eab4593f02'\n'parentDescription': In diesem Videotutorial lernst du React von Grund auf – bis hin zur Full-Stack-Entwicklung mit Next.js. Du baust Single Page Applications, verwaltest State, entwickelst moderne Formulare, arbeitest mit serverseitigen Daten und setzt Routing effizient um. Zum Abschluss bekommst du eine Einführung in React Server Components und Next.js. Benötigte Vorkenntnisse: JavaScript-Grundlagen, TypeScript ist hilfreich, aber nicht zwingend nötig. Nach dem Tutorial bist du bereit, eigene client- und serverseitige Anwendungen mit React umzusetzen.\n'indexBrandName': 'InternationalJavaScriptCon'\n'indexSeriesName': ''\n'author': 'Nils Hartmann'\n'chunkSource': 'text'\n'text': Datenabfrage mit TanStack Query In der dritten Lesson lernst du, wie du mit TanStack Query effizient Daten von einem API abrufst und verwaltest – ein zentrales Thema in modernen SPAs. Du erfährst, wie du Daten mit Zod und TypeScript validierst, Typen automatisch aus einer OpenAPI-Beschreibung generierst und den Query-Cache gezielt nutzt. Außerdem klären wir, wie du mit React Suspense die Darstellung priorisieren kannst.\n'slidetext': ''\n'from': 'vector'\n'score': 0.8910360336303711\n'normalizedScore': 0.8869127769884381\n'beforeDatePenaltyScore': 0.8910360336303711\n\n'documentId': 'ed6b19fe4c4328050dad69e5'\n'chunk_id': '68c2ee68787074001356ea86'\n'access': 'granted'\n'part_number': 40\n'total_parts': 40\n'contentType': 'TUTORIAL'\n'title': Typsicheres Routing mit TanStack Router\n'parentName': Modern React: von Null auf Full-Stack\n'language': 'DE'\n'date': '2025-08-27T09:53:51.000Z'\n'abstract': In dieser Lesson lernst du, wie du mit dem TanStack Router eine moderne, typsichere Navigation in deine React-App bringst – inklusive Unterstützung für Links, Back-Button und Bookmarks. Wir zeigen dir die File-System-basierte Routenstruktur, dynamische Routen, Layout-Routen sowie die Verwendung von typsicheren Suchparametern. Außerdem: Integration mit TanStack Query und Performanceoptimierungen.\n'parentId': 'b2c71c7c41dfe8eab4593f02'\n'parentDescription': In diesem Videotutorial lernst du React von Grund auf – bis hin zur Full-Stack-Entwicklung mit Next.js. Du baust Single Page Applications, verwaltest State, entwickelst moderne Formulare, arbeitest mit serverseitigen Daten und setzt Routing effizient um. Zum Abschluss bekommst du eine Einführung in React Server Components und Next.js. Benötigte Vorkenntnisse: JavaScript-Grundlagen, TypeScript ist hilfreich, aber nicht zwingend nötig. Nach dem Tutorial bist du bereit, eigene client- und serverseitige Anwendungen mit React umzusetzen.\n'indexBrandName': 'InternationalJavaScriptCon'\n'indexSeriesName': ''\n'author': 'Nils Hartmann'\n'chunkSource': 'text'\n'text': zugreife. Dann kann der Browser eine HTML-Seite runterladen anzeigen und das geht natürlich am allerschnellsten. Für diesen Anwendungsfall, ich habe sowas wie eine Admin-Anwendung, ich habe sowas wie eine Inhouse-Anwendung, finde ich, macht das relativ wenig Sinn. Man könnte sich vielleicht sogar vorstellen, dass diese Anwendung hinter einer Login-Schranke, hinter einem Login-Formular liegt, dann würde ich quasi nur die Login-Seite vielleicht vorrendern. Das muss man so bisschen gucken, ob das Sinn macht. Ich finde, an der Stelle ist es fachlich verträgretbar, genau diesem technischen Ansatz so zu arbeiten. Auf der anderen Seite, wenn ich zum Beispiel eine E-Commerce-Seite habe, dann möchte ich vielleicht bessere Performance haben, noch bessere Performance haben, dann wäre eine Möglichkeit hier dieses Tenstack Start zu verwenden und eine andere Möglichkeit wäre, richtig auf die Server-Seite zu setzen, quasi eine Server-First-React-Anwendung zu bauen. Und wie das geht am Beispiel von Next.js, das gucken wir uns dann in der nächsten Lektion an\n'slidetext': ''\n'from': 'vector'\n'score': 0.8931353092193604\n'normalizedScore': 0.8890120525774273\n'beforeDatePenaltyScore': 0.8931353092193604\n\n'documentId': '283cdcdb068c7c636571eee9'\n'chunk_id': '6908c315eec9d90012dc48ee'\n'access': 'granted'\n'part_number': 1\n'total_parts': 1\n'contentType': 'TUTORIAL'\n'title': Micro Frontends\n'parentName': Moderne Angular-Architekturen\n'language': 'DE'\n'date': '2025-11-17T11:00:00.000Z'\n'abstract': In der zweiten Lesson geht es um den Aufbau skalierbarer Frontend-Architekturen durch Micro Frontends. Wir erklären die Prinzipien von Modul- und Native Federation und zeigen anhand einer Demo, wie einzelne Frontend-Module unabhängig entwickelt, bereitgestellt und integriert werden können, um eine flexible und wartbare Anwendung zu schaffen.\n'parentId': 'ac8c34d42ff419c583c5dd09'\n'parentDescription': Unternehmens-Anwendungen müssen langfristig wartbar und erweiterbar sein. Dafür kombinieren wir aktuelle Features wie Signals, den Signal Store und Native Federation mit etablierten Konzepten wie Strategic Design (DDD), vertikalen Architekturen sowie Monorepos, Modulithen und Micro Frontends. Wir nutzen Nx für inkrementelle Builds und zeigen, wie Du die Wartbarkeit Deiner Anwendung analysieren und verbessern kannst.\n'indexBrandName': 'InternationalJavaScriptCon'\n'indexSeriesName': ''\n'author': 'Manfred Steyer,Michael Egger-Zikes,Rainer Hahnekamp'\n'chunkSource': 'text'\n'text': Micro Frontends In der zweiten Lesson geht es um den Aufbau skalierbarer Frontend-Architekturen durch Micro Frontends. Wir erklären die Prinzipien von Modul- und Native Federation und zeigen anhand einer Demo, wie einzelne Frontend-Module unabh��ngig entwickelt, bereitgestellt und integriert werden können, um eine flexible und wartbare Anwendung zu schaffen.\n'slidetext': ''\n'from': 'vector'\n'score': 0.8893067240715027\n'normalizedScore': 0.8896791352377889\n'beforeDatePenaltyScore': 0.8893067240715027\n\n'documentId': 'a5dcfc84b51456a6b4b27fce'\n'chunk_id': '6878ecf122599b00136894cc'\n'access': 'granted'\n'part_number': 13\n'total_parts': 77\n'contentType': 'TUTORIAL'\n'title': Die Welt der Web Components\n'parentName': Web Components von 0 auf 100\n'language': 'DE'\n'date': '2025-06-05T13:45:07.000Z'\n'abstract': In der ersten Lesson steigen wir in die Welt der Web Components ein. Wir richten unser Setup ein, klären die Ziele des Tutorials – und schreiben unser erstes „Hello World“. Dabei beantworten wir die Grundfrage: Was sind Web Components eigentlich? Wir schauen uns Content-Attribute und DOM-Properties an, ziehen den Vergleich zu Frameworks und klären, wo Web Components glänzen – und wo nicht. Best Practices und erste UI-Beispiele runden den Einstieg ab.\n'parentId': '54cce7e83417cbefa7c0d3f0'\n'parentDescription': Web Components versprechen universelle Frontend-Komponenten, frei von Framework-Fesseln und Dependency-Depression. Das Problem: Web Components sind komplex, manche APIs wirken eigenartig, und das sie umgebende Ökosystem ist unübersichtlich. Was können Web Components leisten – und was nicht? Brauche ich wirklich Shadow DOM oder kann ich darauf verzichten? Vanilla-Komponenten, Lit – oder etwas dazwischen? In diesem Tutorial lernen wir, wie der Komponenten-Eintopf wirklich gemacht wird. Wir orientieren uns im Ökosystem und erhalten einen Überblick über die Fähigkeiten und Grenzen der Standards rund um Web Components. Von den absoluten API-Grundlagen bis zum Einsatz ausgewachsener Komponenten-Frameworks lassen wir keinen Schritt aus. In jedem Abschnitt unserer Reise erfahren wir nicht nur, wie etwas funktioniert, sondern auch, warum. Dieses Tutorial macht uns nicht nur zu Web-Component-Expert:innen, sondern vertieft auch unser Verständnis der Web-Plattform insgesamt.\n'indexBrandName': 'InternationalJavaScriptCon'\n'indexSeriesName': ''\n'author': 'Peter Kröner'\n'chunkSource': 'text'\n'text': wirkliche Änderung, denn das hier ist ja nur eine Methode auf Instanzen von Hello World, also auf Objekten, die wir da im DOM finden, und das ist jetzt erstmal für uns vom UI her nicht wirklich erfahrbar, da sehen wir nichts von. Aber wir können das tatsächlich mit den DevTools inspizieren, nehmen wir uns nämlich jetzt mal hier im Inspector unser Hello World Element anklicken, in dem Moment wo wir im Inspector ein Element anklicken, können wir es in der JavaScript-Konsole referenzieren mit der Variable $0, $0 referenziert das, was wir gerade anklickt haben, und wir sehen es jetzt ja hier, wird auch gehighlightet, unser Hello World Element, das ist jetzt also eine Instanz unserer Klasse, und das bedeutet, dass ich auf diesem Ding tatsächlich die Methode foo verwenden und aufrufen kann, und siehe her, mir wird 42 in die Konsole geschrieben, und das undefined, da rauskommt, ist der Rückgabewert von foo da habe ich jetzt keinen Rückgabewert angegeben, deswegen kommt da undefined raus, das passt schon, und naja, das ist im Wesentlichen das, was wir kriegen, wenn wir Web-Components haben, wir kriegen erstmal einen eigenen HTML-Tag, den wir dann einfach erfinden können, den wir dann in unser HTML reinschreiben können, wir müssen dem Browser bloß mitteilen, dass dieser HTML-Tag dann belegt ist durch unsere Komponente, die Implementierung findet statt über eine Klasse, in dieser Klasse können wir einfach ausprogrammieren, was immer wir wollen, das wäre jetzt in dem Fall diese Methode foo, das kann aber auch alles Mögliche sein, wir können hingehen, und wir können da ein UI drin definieren, Event Handling machen, das kommt alles später noch, das ist also, was wir erstmal so haben, wir kriegen im Prinzip die Klasse und können uns da drin austoben, und was wir auch schon gesehen haben, ist, dass gewisse Basics bereits funktionieren, wir haben gesehen, ich kann hier das Style-Attribut verwenden, um zum Beispiel color.red zu machen, und schon kriege ich roten Text, das Featureset haben wir im Prinzip einfach dadurch geerbt, dass unser Custom-Element eine Instanz von HTML-Elementen ist, und alle HTML-Elemente\n'slidetext': ''\n'from': 'index'\n'score': 37.79056167602539\n'normalizedScore': 0.3779056167602539\n'beforeDatePenaltyScore': 0.3779056167602539\n\n'documentId': '535b45361ad6c9e12a423cbc'\n'chunk_id': '6876d392225e92fc1ac79d10'\n'access': 'granted'\n'part_number': 2\n'total_parts': 35\n'contentType': 'TUTORIAL'\n'title': Das ist .NET MAUI\n'parentName': Mit .NET MAUI zur erfolgreichen Cross-Platform-App\n'language': 'DE'\n'date': '2025-02-07T10:45:08.000Z'\n'abstract': In der ersten Lesson des Tutorials zeigt dir André Krämer die Grundlagen von .NET MAUI, Microsofts Framework für plattformübergreifende Apps. Du erfährst, wie du deine erste App erstellst und auf Windows, macOS, Android und iOS testest. Zum Abschluss baust du eine einfache To-do-App, die dir als Ausgangspunkt für weitere Projekte dient.\n'parentId': 'dd0d8f751be8d368f2f60eb9'\n'parentDescription': Zusammen mit Microsoft MVP André Krämer lernst du Schritt für Schritt, wie du mit .NET MAUI in C# und .NET native Apps für Android, iOS, macOS und Windows aus einer einzigen Codebasis erstellst. Du gestaltest ansprechende Benutzeroberflächen mit XAML und dem MVVM-Design-Pattern, stellst Daten in Listen übersichtlich dar und navigierst dabei nahtlos zwischen verschiedenen Ansichten. Zudem erfährst du, wie du Dependency Injection effizient einsetzt und native Gerätefunktionen wie die Kamera nutzt. Das praxisorientierte Tutorial ermöglicht dir, moderne Cross-Platform-Apps eigenständig zu entwickeln.\n'indexBrandName': 'BASTA!'\n'indexSeriesName': ''\n'author': 'André Krämer'\n'chunkSource': 'text'\n'text': Business Apps mit .NET MAUI. Außerdem haben wir uns in den letzten Monaten für unsere Kunden sehr mit dem Thema Migration von Xamarin Forms zu .NET MAUI beschäftigt und auch vieles im Blazer-Umfeld gemacht. Außerdem ist so eines meiner Herzensthemen neben der Mobile-Entwicklung das Thema Dokumenten-Automatisierung mit Take-Stacks-Control. Neben meiner Tätigkeit bei der Quality Bites engagiere mich jetzt auch schon seit vielen Jahren als Sprecher auf Konferenzen rund um das Thema .NET MAUI oder früher eben Xamarin. Ich teile mein Wissen auch gerne schriftlich in der Form von Artikeln oder auch in meinen Büchern, die ich zu Xamarin und .NET MAUI geschrieben habe. Als Anerkennung für mein Community Engagement hat Microsoft mich mittlerweile zum zwölften Mal in Folge mit dem MVP-Titel ausgezeichnet. So, damit genug der Vorrede. Im nächsten Film werden wir uns jetzt gemeinsam anschauen, was ist eigentlich .NET MAUI? Was hat es damit auf sich? Ja wie versprochen sehen wir uns jetzt einmal ein paar Grundlagen zu .NET MAUI an und verschaffen uns somit einen Überblick über die Plattform. Ja, für alle die noch gar nichts damit zu tun hatten, MAUI selbst ist der Nachfolger oder besser gesagt die Weiterentwicklung von Xamarin Forms und tritt damit kein leichtes Erbe an. Denn gerade in letzten Versionen war Xamarin doch ein grundsolides Framework von Mobile Apps mit .NET und C-Sharp zu schreiben. Xamarin hatte allerdings schon immer so einen Fokus auf Mobile und Tablet und eine der großen Änderungen oder eben Weiterentwicklungen bei .NET MAUI ist, dass man als weitere Plattform den Desktop dazu genommen hat. So aber jetzt nicht die einzige Änderung, denn das hätte vielleicht einen Versionssprung bei Xamarin gerechtfertigt, aber nicht direkt einen neuen Namen. Und die nächste große Änderung wirklich war, dass man eine komplett neue Steuerelement Architektur aufgebaut hat, die jetzt weitaus flexibler ist als das noch unter Xamarin Forms der Fall war. Ja, MAUI selbst ist jetzt auch im Gegensatz zu Xamarin fester Bestandteil und zwar in Form eines optionalen Workloads von .NET. Was bedeutet das? Naja, bei Xamarin war es so, das war halt ein Zusatzprodukt, was irgendwie so in diesem Microsoft Universum herumschwörbte. Es\n'slidetext': ''\n'from': 'index'\n'score': 39.998435974121094\n'normalizedScore': 0.39998435974121094\n'beforeDatePenaltyScore': 0.39998435974121094\n\n'documentId': '535b45361ad6c9e12a423cbc'\n'chunk_id': '6876d392225e92fc1ac79d11'\n'access': 'granted'\n'part_number': 3\n'total_parts': 35\n'contentType': 'TUTORIAL'\n'title': Das ist .NET MAUI\n'parentName': Mit .NET MAUI zur erfolgreichen Cross-Platform-App\n'language': 'DE'\n'date': '2025-02-07T10:45:08.000Z'\n'abstract': In der ersten Lesson des Tutorials zeigt dir André Krämer die Grundlagen von .NET MAUI, Microsofts Framework für plattformübergreifende Apps. Du erfährst, wie du deine erste App erstellst und auf Windows, macOS, Android und iOS testest. Zum Abschluss baust du eine einfache To-do-App, die dir als Ausgangspunkt für weitere Projekte dient.\n'parentId': 'dd0d8f751be8d368f2f60eb9'\n'parentDescription': Zusammen mit Microsoft MVP André Krämer lernst du Schritt für Schritt, wie du mit .NET MAUI in C# und .NET native Apps für Android, iOS, macOS und Windows aus einer einzigen Codebasis erstellst. Du gestaltest ansprechende Benutzeroberflächen mit XAML und dem MVVM-Design-Pattern, stellst Daten in Listen übersichtlich dar und navigierst dabei nahtlos zwischen verschiedenen Ansichten. Zudem erfährst du, wie du Dependency Injection effizient einsetzt und native Gerätefunktionen wie die Kamera nutzt. Das praxisorientierte Tutorial ermöglicht dir, moderne Cross-Platform-Apps eigenständig zu entwickeln.\n'indexBrandName': 'BASTA!'\n'indexSeriesName': ''\n'author': 'André Krämer'\n'chunkSource': 'text'\n'text': Bestandteil und zwar in Form eines optionalen Workloads von .NET. Was bedeutet das? Naja, bei Xamarin war es so, das war halt ein Zusatzprodukt, was irgendwie so in diesem Microsoft Universum herumschwörbte. Es hatte seinen eigenen Releasezyklus und das ist bei MAUI jetzt eben anders. MAUI wird jedes Mal released, wenn eine neue .NET Version auf den Markt herauskommt. Bei MAUI handelt es sich wie eben schon angedeutet, um ein Cross-Plattform-Framework, mit dem ich auf Basis von .NET und C-Sharp mit einer gemeinsamen Code-Basis eine Anwendung schreiben kann, die sowohl unter Android als auch unter iOS, unter macOS und unter Windows läuft. Aber wie funktioniert das Ganze? Schauen wir uns jetzt also hier einmal im Architekturüberblick an. Ihr programmiert euren Anwendungscode und dieser kann dann, wie gesagt, unter all diesen verschiedenen Plattformen ausgeführt werden. Natürlich ist es so, dass er dort nicht direkt läuft, sondern es gibt noch ein paar Ebenen dazwischen. Ganz typisch für .NET haben wir zunächst einmal eine Laufzeitumgebung oder besser gesagt zwei. Denn unter Android, iOS und macOS wird die Mono-Laufzeitumgebung die Mono-Runtime genutzt und unter Windows ist es Win32. Direkt darüber liegt dann die Base-Class-Library, die uns Standardfunktionen liefert, wie zum Beispiel alle möglichen Klassen unter System.io oder System.Math und so weiter. Darüber gibt es jetzt wieder spezifische .NET-Implementierungen für die jeweiligen Zielbetriebssysteme. Was machen die? Die rappen zum einen das Hersteller-SDK für uns, also sämtliche Steuerelemente die wir brauchen, um eine nativaussehende App für Android, für iOS, für macOS und für Windows zu schreiben. Darüber hinaus sieht sie aber auch die Brücke, die es uns erlaubt, Anwendungen bzw. besser gesagt Bibliotheken der jeweiligen Zielplattform aufzurufen, auch wenn sie nicht direkt vom Hersteller-SDK kommen. Beispiel wäre vielleicht ein bestimmtes Software-Paket zur Ansteuerung eines Barcode-Scanners oder Ähnliches. Alleine mit dem wären wir schon in der Lage, C-Sharp und mit .NET eine Anwendung zu schreiben für Android, iOS, macOS und Windows. Allerdings nicht auf einer geteilten Quellcode-Basis, denn wir müssten ja das UI also die Benutzeroberfläche, jedes Mal neu\n'slidetext': ''\n'from': 'index'\n'score': 39.998435974121094\n'normalizedScore': 0.39998435974121094\n'beforeDatePenaltyScore': 0.39998435974121094\n\n'documentId': '535b45361ad6c9e12a423cbc'\n'chunk_id': '6876d392225e92fc1ac79d12'\n'access': 'granted'\n'part_number': 4\n'total_parts': 35\n'contentType': 'TUTORIAL'\n'title': Das ist .NET MAUI\n'parentName': Mit .NET MAUI zur erfolgreichen Cross-Platform-App\n'language': 'DE'\n'date': '2025-02-07T10:45:08.000Z'\n'abstract': In der ersten Lesson des Tutorials zeigt dir André Krämer die Grundlagen von .NET MAUI, Microsofts Framework für plattformübergreifende Apps. Du erfährst, wie du deine erste App erstellst und auf Windows, macOS, Android und iOS testest. Zum Abschluss baust du eine einfache To-do-App, die dir als Ausgangspunkt für weitere Projekte dient.\n'parentId': 'dd0d8f751be8d368f2f60eb9'\n'parentDescription': Zusammen mit Microsoft MVP André Krämer lernst du Schritt für Schritt, wie du mit .NET MAUI in C# und .NET native Apps für Android, iOS, macOS und Windows aus einer einzigen Codebasis erstellst. Du gestaltest ansprechende Benutzeroberflächen mit XAML und dem MVVM-Design-Pattern, stellst Daten in Listen übersichtlich dar und navigierst dabei nahtlos zwischen verschiedenen Ansichten. Zudem erfährst du, wie du Dependency Injection effizient einsetzt und native Gerätefunktionen wie die Kamera nutzt. Das praxisorientierte Tutorial ermöglicht dir, moderne Cross-Platform-Apps eigenständig zu entwickeln.\n'indexBrandName': 'BASTA!'\n'indexSeriesName': ''\n'author': 'André Krämer'\n'chunkSource': 'text'\n'text': C-Sharp und mit .NET eine Anwendung zu schreiben für Android, iOS, macOS und Windows. Allerdings nicht auf einer geteilten Quellcode-Basis, denn wir müssten ja das UI also die Benutzeroberfläche, jedes Mal neu programmieren. Und genau da kommt .NET-MAUI ins Spiel. Bei .NET-MAUI sieht es wie folgt aus. Unser Anwendungscode ruft in der Regel jetzt einfach mal nur die .NET-MAUI-Bibliotheken auf und sagt, hey, hier würde ich gerne ein Eingabefeld positionieren und hier ein Button. Was dann passiert ist, ist, dass .NET-MAUI mit dem jeweiligen Zielplattform-SDK spricht, auf dem es gerade läuft und dann dafür sorgt, dass das native Steuerelement der Zielplattform dargestellt wird. Das bedeutet also, .NET-MAUI rendert gar nicht selber, sondern delegiert die Darstellung der Benutzeroberfläche an die Controls aus dem jeweiligen Ziel-SDK der Zielplattform. Das ist aber nicht alles, was-MAUI macht. Daneben hat es noch so paar Rapper, um zum Beispiel über ein gemeinsames Interface oder eine gemeinsame Schnittstelle auf die Hardware zuzugreifen, wie zum Beispiel die Kamera, das GPS oder Ähnliches. Natürlich muss sich diesen Weg nicht gehen. Ich habe jederzeit die Möglichkeit als Entwickler direkt auf die jeweiligen Bibliotheken des Zielbetriebssystems zuzugreifen, wenn es notwendig ist. Da verschiedene Fälle, wenn das notwendig ist. Einer ist zum Beispiel, dass es bestimmte Funktionalität gibt, die .NET-MAUI selber nicht gerappt hat und die ich jetzt aufrufen möchte. Vielleicht eine Spezialbibliothek, die es nur in einer der Plattformen gibt und deswegen mit .NET-MAUI nicht gerappt worden ist oder eben irgendetwas anderes. Wenn wir uns das Ganze jetzt einmal so im .NET Cross-Plattform-Universum ansehen, dann haben wir da ja mehrere Optionen. Wenn wir sagen, wir brauchen unheimlich viel Reichweite, dann nutzen wir in der Regel Blazor, also ein webbasiertes Framework, das kann überall dort ausgeführt werden, wo ich einen modernen Browser habe. Das sieht dann so aus, ich schreibe meine Oberflächen mit C-Sharp, mit HTML, mit der Razor-Syntax und mit CSS. Der Nachteil ist bei dieser Variante, dass ich obwohl ich eine große Breite an Zielplattformen\n'slidetext': ''\n'from': 'index'\n'score': 39.998435974121094\n'normalizedScore': 0.39998435974121094\n'beforeDatePenaltyScore': 0.39998435974121094\n\n'documentId': 'a5dcfc84b51456a6b4b27fce'\n'chunk_id': '6878ecf022599b00136894bf'\n'access': 'granted'\n'part_number': 1\n'total_parts': 77\n'contentType': 'TUTORIAL'\n'title': Die Welt der Web Components\n'parentName': Web Components von 0 auf 100\n'language': 'DE'\n'date': '2025-06-05T13:45:07.000Z'\n'abstract': In der ersten Lesson steigen wir in die Welt der Web Components ein. Wir richten unser Setup ein, klären die Ziele des Tutorials – und schreiben unser erstes „Hello World“. Dabei beantworten wir die Grundfrage: Was sind Web Components eigentlich? Wir schauen uns Content-Attribute und DOM-Properties an, ziehen den Vergleich zu Frameworks und klären, wo Web Components glänzen – und wo nicht. Best Practices und erste UI-Beispiele runden den Einstieg ab.\n'parentId': '54cce7e83417cbefa7c0d3f0'\n'parentDescription': Web Components versprechen universelle Frontend-Komponenten, frei von Framework-Fesseln und Dependency-Depression. Das Problem: Web Components sind komplex, manche APIs wirken eigenartig, und das sie umgebende Ökosystem ist unübersichtlich. Was können Web Components leisten – und was nicht? Brauche ich wirklich Shadow DOM oder kann ich darauf verzichten? Vanilla-Komponenten, Lit – oder etwas dazwischen? In diesem Tutorial lernen wir, wie der Komponenten-Eintopf wirklich gemacht wird. Wir orientieren uns im Ökosystem und erhalten einen Überblick über die Fähigkeiten und Grenzen der Standards rund um Web Components. Von den absoluten API-Grundlagen bis zum Einsatz ausgewachsener Komponenten-Frameworks lassen wir keinen Schritt aus. In jedem Abschnitt unserer Reise erfahren wir nicht nur, wie etwas funktioniert, sondern auch, warum. Dieses Tutorial macht uns nicht nur zu Web-Component-Expert:innen, sondern vertieft auch unser Verständnis der Web-Plattform insgesamt.\n'indexBrandName': 'InternationalJavaScriptCon'\n'indexSeriesName': ''\n'author': 'Peter Kröner'\n'chunkSource': 'text'\n'text': Die Welt der Web Components In der ersten Lesson steigen wir in die Welt der Web Components ein. Wir richten unser Setup ein, klären die Ziele des Tutorials – und schreiben unser erstes „Hello World“. Dabei beantworten wir die Grundfrage: Was sind Web Components eigentlich? Wir schauen uns Content-Attribute und DOM-Properties an, ziehen den Vergleich zu Frameworks und klären, wo Web Components glänzen – und wo nicht. Best Practices und erste UI-Beispiele runden den Einstieg ab. Hallo und herzlich willkommen zu diesem Video-Tutorial zu Web-Components. Web-Components von 0 auf 100. Mein Name ist Peter Kröner und ich bin so ein bisschen der Low-Level-Web-Tag-Erklär-Bär. Was ich eigentlich den lieben langen Tag mache, nicht wirklich primär Web-Entwicklung, obwohl ich das auch machen kann, wenn ich muss. Ich verbringe viel mehr meine Zeit damit, Vorträge zu machen, Workshops zu halten, meistens zu Themen, die halt mit Low-Level-Web-Technologie zu tun haben. Also HTML, DOM, JavaScript, CSS. Wie funktioniert dieser ganze Krämpel wirklich unterhalb der Ebene von Frameworks? Und aus dieser Perspektive kommend, möchte ich euch gerne in den folgenden paar Videos Web-Components ein bisschen näher bringen. Es ist ja so, die meisten Web-Entwicklerinnen und Entwickler nehmen heutzutage ihren Tech-Stack durch die Membran von Frameworks wahr. Angular React, was auch immer. Und das ist ja erstmal auch nicht verkehrt Das sorgt dafür, dass alle die gleiche Sprache sprechen, die gleiche Idee davon haben. Was es für Konzepte und Patterns gibt, ist alles ja wunderbar und schön. Und das Gleiche gilt auch für Web-Components. Web-Components werden oft in Form von Frameworks an Entwicklerinnen und Entwickler angereicht. Man nutzt also irgendwelche Frameworks, um die Dinger zu schreiben und auch daran ist erstmal nichts verkehrt. Aber man kann theoretisch mit Web-Components auch aus dem Framework-Zirkus aussteigen und sich seine eigene Welt schaffen. Sein eigenes Framework schreiben oder vanilla JavaScript mäßig unterwegs sein und sich komplett von irgendwelchen Dependencies und so frei machen. Um aber die Entscheidung zu treffen, man das machen möchte und wenn ja, auf welche Weise, muss man die ganzen Basics verstanden haben. Und das ist so ein bisschen meine Idee mit diesem Videotraining. Ich\n'slidetext': ''\n'from': 'index'\n'score': 44.21614074707031\n'normalizedScore': 0.44216140747070315\n'beforeDatePenaltyScore': 0.44216140747070315\n\n'documentId': 'a5dcfc84b51456a6b4b27fce'\n'chunk_id': '6878ecf122599b00136894c5'\n'access': 'granted'\n'part_number': 6\n'total_parts': 77\n'contentType': 'TUTORIAL'\n'title': Die Welt der Web Components\n'parentName': Web Components von 0 auf 100\n'language': 'DE'\n'date': '2025-06-05T13:45:07.000Z'\n'abstract': In der ersten Lesson steigen wir in die Welt der Web Components ein. Wir richten unser Setup ein, klären die Ziele des Tutorials – und schreiben unser erstes „Hello World“. Dabei beantworten wir die Grundfrage: Was sind Web Components eigentlich? Wir schauen uns Content-Attribute und DOM-Properties an, ziehen den Vergleich zu Frameworks und klären, wo Web Components glänzen – und wo nicht. Best Practices und erste UI-Beispiele runden den Einstieg ab.\n'parentId': '54cce7e83417cbefa7c0d3f0'\n'parentDescription': Web Components versprechen universelle Frontend-Komponenten, frei von Framework-Fesseln und Dependency-Depression. Das Problem: Web Components sind komplex, manche APIs wirken eigenartig, und das sie umgebende Ökosystem ist unübersichtlich. Was können Web Components leisten – und was nicht? Brauche ich wirklich Shadow DOM oder kann ich darauf verzichten? Vanilla-Komponenten, Lit – oder etwas dazwischen? In diesem Tutorial lernen wir, wie der Komponenten-Eintopf wirklich gemacht wird. Wir orientieren uns im Ökosystem und erhalten einen Überblick über die Fähigkeiten und Grenzen der Standards rund um Web Components. Von den absoluten API-Grundlagen bis zum Einsatz ausgewachsener Komponenten-Frameworks lassen wir keinen Schritt aus. In jedem Abschnitt unserer Reise erfahren wir nicht nur, wie etwas funktioniert, sondern auch, warum. Dieses Tutorial macht uns nicht nur zu Web-Component-Expert:innen, sondern vertieft auch unser Verständnis der Web-Plattform insgesamt.\n'indexBrandName': 'InternationalJavaScriptCon'\n'indexSeriesName': ''\n'author': 'Peter Kröner'\n'chunkSource': 'text'\n'text': wir werden einfach mal das dadurch exerzieren, weil das, glaube ich, eine gute Demonstration ist, wo man dann auch wirklich mal jeden Aspekt von allem, was wir bisher besprochen haben, werden einmal in Aktion sehen kann. Es ist also überschaubar und verständlich und klar abgegrenzt, aber nicht trivial. Das ist so im Wesentlichen mein Plan und die Ziele sind, wie gesagt, vor allen Dingen für mich Orientierung, dass ihr genau wisst, was es alles gibt und wie die Dinge zusammengehören. Dann auch ein bisschen Verständnis dafür, warum die Technologien so sind, wie sie sind, warum es auch nach diesem Videotutorial für euch viel, einfacher sein wird, ne Angular oder ne React-Komponente zu bauen. Die sind nämlich einfacher zu bauen, aber ein bisschen Verständnis dafür, warum das so ist und ne Einsicht in die Trade-offs, sodass man sich dann eventuell entscheiden kann. Ich wirklich mit meinem klassischen Frontend-Framework arbeite oder brauche ich ein Web-Component-Framework oder möglicherweise auch die Kombination aus beidem das gibt es nämlich auch. Dann möchte ich natürlich euch auch in die Lage versetzen, zur Not die ganzen Sachen manuell selber zu schreiben, also nicht nur die Frameworks zu bedienen. wenn wir das alles dann zusammen haben, dann glaube ich seid ihr ganz brauchbare Nerds Sachen Web-Components. Ihr wisst, wie die Wurst gemacht wird und ihr wisst, wann ihr euch wirklich mit diesen Details befassen wollt und wann nicht. Und das ist im Wesentlichen mein Plan für dieses Videotutorial. Und ich würde sagen, jetzt wo wir die ganzen Basics und die Planung und die Agenda aus dem Weg geräumt haben, bleibt nur eins, wir müssen anfangen. Wir müssen anfangen mit dem, womit wir bei solchen Tutorials immer anfangen müssen, nämlich mit Hallo Welt. Und genau das machen wir jetzt. Das war jetzt wirklich genug Gephasel von Dingen die man mal machen könnte, Zielen, die man haben könnte und Dingen, die vielleicht mal kompliziert sein werden. Was wir jetzt machen, ist ne richtige Web-Component bauen. Wir schauen uns an, wie die einzelnen Dinge zusammenspielen und wie das so grob funktionieren kann. Grundsätzlich\n'slidetext': ''\n'from': 'index'\n'score': 42.584651947021484\n'normalizedScore': 0.42584651947021485\n'beforeDatePenaltyScore': 0.42584651947021485\n\n'documentId': '50c03dd02cf9b7c2ff4480f2'\n'chunk_id': '68b55eab33a5bf00132cb688'\n'access': 'granted'\n'part_number': 7\n'total_parts': 47\n'contentType': 'TUTORIAL'\n'title': React-Grundlagen\n'parentName': Modern React: von Null auf Full-Stack\n'language': 'DE'\n'date': '2025-08-27T09:53:51.000Z'\n'abstract': In der ersten Lesson lernst du, was React ist und wie es funktioniert. Anhand einer Beispielanwendung schauen wir uns den Projektaufbau und den Workspace an. Du erfährst, wie Komponenten aufgebaut sind, wie man mit Props, Listen und State arbeitet und wie Interaktionen in React abgebildet werden.\n'parentId': 'b2c71c7c41dfe8eab4593f02'\n'parentDescription': In diesem Videotutorial lernst du React von Grund auf – bis hin zur Full-Stack-Entwicklung mit Next.js. Du baust Single Page Applications, verwaltest State, entwickelst moderne Formulare, arbeitest mit serverseitigen Daten und setzt Routing effizient um. Zum Abschluss bekommst du eine Einführung in React Server Components und Next.js. Benötigte Vorkenntnisse: JavaScript-Grundlagen, TypeScript ist hilfreich, aber nicht zwingend nötig. Nach dem Tutorial bist du bereit, eigene client- und serverseitige Anwendungen mit React umzusetzen.\n'indexBrandName': 'InternationalJavaScriptCon'\n'indexSeriesName': ''\n'author': 'Nils Hartmann'\n'chunkSource': 'text'\n'text': serverseitigen Daten umgehen? Denn diese ganzen Daten, die wir hier sehen, die sind ja alle irgendwo auf dem Server abgelegt. Wir wollen uns angucken, wie kann ich Formulare bauen? Und schlussendlich wollen wir uns angucken, wie kann ich eigentlich mit verschiedenen Routen in meiner Anwendung umgehen? Also sprich, mit verschiedenen Seiten, wenn man so will. Obwohl wir eine Single-Page-Anwendung bauen, wir ja sowas wie mehrere Seiten in dieser Anwendung. Wir haben hier zum Beispiel diese Dashboard-Seite. Wir haben diese Einstiegsseite. Und letzten Endes haben wir ja auch diese Seite zum Anlegen oder Bearbeiten von Rezepten. Also wir haben durchaus mehrere Seiten. Obwohl wir technisch eine Single-Page-Anwendung bauen, haben wir fachlich eine Multi-Page-Anwendung, wenn man so möchte. Bevor wir jetzt gleich in den Code einsteigen, möchte ich euch eine Sache noch zeigen. Und zwar, ist sozusagen die Architektur wenn man so will, von dieser Anwendung auf einer sehr sehr hohen Ebene. Und zwar sieht das bei mir wie folgt aus, damit wir wissen, wovon wir sprechen. Wir haben sozusagen ein Recipe-File-Backend. Wollen wir die Schrift hier ein klein bisschen größer machen und das vorhin nach oben schieben. Und dieses Recipe-File-Backend das stellt uns eine Rest-API zur Verfügung, mit der ich Rezepte lesen und schreiben kann. Rezepte lesen und schreiben. Und ich kann mich damit auch einloggen. Wobei, das werden wir erst im zweiten Schritt machen. Trotz allem kann ich das damit machen. Und man kann da auch Bewertungen abgeben. Und die Idee von diesem Backend ist, das ist fertig. Das gucken wir uns gar nicht an. Wen es technisch interessiert ist eine Spring-Boot-Anwendung. Für uns ist aber eigentlich relevant, dass es hier eine Rest-API gibt, die wir in unserer Anwendung konsumieren. Wir tun mal für dieses Tutorial so, als ob wir eine bestehende Rest-API haben. Vielleicht haben wir irgendeinen Dienst im Internet, den wir anschließen wollen. Und diese API konsumieren wir Die ist schon fertig gemacht für uns. Da beschäftigen wir uns weiter dann nicht mit, außer dass wir sie eben benutzen. So und jetzt haben\n'slidetext': ''\n'from': 'vector'\n'score': 0.8981435298919678\n'normalizedScore': 0.8940202732500347\n'beforeDatePenaltyScore': 0.8981435298919678\n\n\nReferenceChunks:\n'documentId': '50c03dd02cf9b7c2ff4480f2'\n'chunk_id': '68b55eab33a5bf00132cb688'\n'access': 'granted'\n'part_number': 7\n'total_parts': 47\n'poc_summary': 'This tutorial lesson introduces React fundamentals by building interactive components, managing state, and handling lists in a practical recipe application.'\n'chunk_summary': 'It explains the application’s high-level architecture, using a REST API backend and separating admin and frontend clients.'\n'access_message': '✅ This content is included with your elevate membership.'\n\n'documentId': 'a5dcfc84b51456a6b4b27fce'\n'chunk_id': '6878ecf122599b00136894c5'\n'access': 'granted'\n'part_number': 6\n'total_parts': 77\n'poc_summary': 'This tutorial lesson thoroughly explains Web Components basics, their integration with HTML, DOM, and JavaScript, and the complexities of attribute handling and script execution.'\n'chunk_summary': 'A Dark Mode selector Web Component will be built to demonstrate practical application of discussed concepts.'\n'access_message': '✅ This content is included with your elevate membership.'\n\n'documentId': '535b45361ad6c9e12a423cbc'\n'chunk_id': '6876d392225e92fc1ac79d12'\n'access': 'granted'\n'part_number': 4\n'total_parts': 35\n'poc_summary': 'This tutorial lesson introduces .NET MAUI, guiding you through its architecture, setup, and building your first cross-platform app.'\n'chunk_summary': 'It contrasts .NET MAUI with Blazor, outlining their differences in hardware access and platform reach.'\n'access_message': '✅ This content is included with your elevate membership.'\n\n'documentId': '283cdcdb068c7c636571eee9'\n'chunk_id': '6908c315eec9d90012dc48ee'\n'access': 'granted'\n'part_number': 1\n'total_parts': 1\n'poc_summary': 'This tutorial lesson focuses on building scalable frontend architectures using Micro Frontends within modern Angular applications.'\n'chunk_summary': 'It explains the principles of Module and Native Federation and demonstrates independent development and integration of frontend modules.'\n'access_message': '✅ This content is included with your elevate membership.'\n\n'documentId': 'ed6b19fe4c4328050dad69e5'\n'chunk_id': '68c2ee68787074001356ea86'\n'access': 'granted'\n'part_number': 40\n'total_parts': 40\n'poc_summary': 'This tutorial lesson introduces type-safe routing in React applications using TanStack Router, focusing on modern navigation, dynamic routes, and performance optimization.'\n'chunk_summary': 'It briefly mentions server-side rendering options like TanStack Start and Next.js for further optimization.'\n'access_message': '✅ This content is included with your elevate membership.'\n\n'documentId': 'fb34eb7009846674dee32bf6'\n'chunk_id': '68c0399287c67b0014cf549d'\n'access': 'granted'\n'part_number': 1\n'total_parts': 1\n'poc_summary': 'This tutorial lesson focuses on efficient data fetching and management in React applications using TanStack Query.'\n'chunk_summary': 'It explains how to validate data with Zod and TypeScript and generate types from OpenAPI.'\n'access_message': '✅ This content is included with your elevate membership.'\n\n'documentId': 'e041b16a103e515fb3ff7fa7'\n'chunk_id': '6876df647899910dd58c1019'\n'access': 'granted'\n'part_number': 34\n'total_parts': 35\n'poc_summary': 'This tutorial lesson guides you through integrating a local SQLite database into a .NET MAUI cross-platform app using dependency injection.'\n'chunk_summary': 'It points to GitHub repositories containing the full source code and additional example projects for further learning.'\n'access_message': '✅ This content is included with your elevate membership.'\n\n'documentId': 'f84097699062ea49829a9ba7'\n'chunk_id': '6887448a2d7a080012cea4e3'\n'access': 'granted'\n'part_number': 43\n'total_parts': 63\n'poc_summary': 'This tutorial lesson examines server-side rendering for Web Components, covering Shadow DOM strategies, generated HTML, CSS integration, tooling with HappyDOM, and related accessibility considerations.'\n'chunk_summary': 'It discusses options for organizing component CSS, from inline styles to design-system frameworks.'\n'access_message': '✅ This content is included with your elevate membership.'\n\n'documentId': '123e7a2a785d7f6f78671362'\n'chunk_id': '6876cc7f225e92fc1ac78759'\n'access': 'granted'\n'part_number': 17\n'total_parts': 31\n'poc_summary': 'This tutorial lesson examines practical use of GitHub Copilot for code completion and CLI tasks, highlighting its features and comparing it to Cursor.'\n'chunk_summary': 'It contrasts Copilot’s quick inline completions with the more advanced reasoning available in the chat interface.'\n'access_message': '✅ This content is included with your elevate membership.'\n\n'documentId': 'ff0a5cf3f58b38ddfe7d481c'\n'chunk_id': '6876e19a7899910dd58c1bc6'\n'access': 'granted'\n'part_number': 13\n'total_parts': 13\n'poc_summary': 'This tutorial lesson examines how Retrieval Augmented Generation (RAG) enhances code exploration in developer tools like GitHub Copilot and Cursor.'\n'chunk_summary': 'It concludes by encouraging developers to explore these tools and stay critical of AI-generated code.'\n'access_message': '✅ This content is included with your elevate membership.'\n\n'documentId': '2ed8aad14972c165c82e16e1'\n'chunk_id': '6876ce4a225e92fc1ac79115'\n'access': 'granted'\n'part_number': 16\n'total_parts': 20\n'poc_summary': 'This tutorial lesson examines agentic workflows with GitHub Copilot in Visual Studio Code, focusing on prompt engineering, instruction files, and .NET development.'\n'chunk_summary': 'It emphasizes the value of explicit, well-structured prompts for complex logic and requirements engineering.'\n'access_message': '✅ This content is included with your elevate membership.'\n\n'documentId': 'bfcf46ef07492f36a37f0212'\n'chunk_id': '6876daaf225e92fc1ac7c46f'\n'access': 'granted'\n'part_number': 25\n'total_parts': 37\n'poc_summary': 'This tutorial lesson guides you through building dynamic lists and implementing navigation in .NET MAUI mobile apps using BindableLayout and CollectionView.'\n'chunk_summary': 'It prepares for navigation improvements by planning filtered list views and dynamic navigation from the home page.'\n'access_message': '✅ This content is included with your elevate membership.'\n\n'documentId': '554842349c829ccc79d45375'\n'chunk_id': '687a2b1a495b49563aa8787e'\n'access': 'granted'\n'part_number': 1\n'total_parts': 1\n'poc_summary': 'This tutorial lesson focuses on testing strategies and frontend architecture in React applications.'\n'chunk_summary': 'It highlights the importance of debugging and thinking in React when building interfaces.'\n'access_message': '✅ This content is included with your elevate membership.'\n\n'documentId': 'bc32faafecf246529545044f'\n'chunk_id': '687a2ec29bbcb45d2a11f9a8'\n'access': 'granted'\n'part_number': 5\n'total_parts': 7\n'poc_summary': 'This tutorial lesson examines secure API authentication and authorization, focusing on common vulnerabilities and practical defense strategies.'\n'chunk_summary': 'It highlights the use of Data Transfer Objects and property-level authorization to limit sensitive data exposure.'\n'access_message': '✅ This content is included with your elevate membership.'\n\n'documentId': 'xv6mWjJ7P65853SYR'\n'chunk_id': '687a3121ca798166d3ba4322'\n'access': 'granted'\n'part_number': 3\n'total_parts': 31\n'poc_summary': 'This tutorial lesson demonstrates programming with GitHub Copilot in .NET by building a TicTacToe game and sharing practical Copilot usage tips.'\n'chunk_summary': 'It shows how to start a .NET console application for TicTacToe and highlights Copilot’s adaptability to different languages.'\n'access_message': '✅ This content is included with your elevate membership.'\n\n\nTop Atlas:\n'documentId': '535b45361ad6c9e12a423cbc'\n'chunk_id': '6876d392225e92fc1ac79d0f'\n'access': 'granted'\n'part_number': 1\n'total_parts': 35\n'contentType': 'TUTORIAL'\n'title': Das ist .NET MAUI\n'parentName': Mit .NET MAUI zur erfolgreichen Cross-Platform-App\n'language': 'DE'\n'date': '2025-02-07T10:45:08.000Z'\n'abstract': In der ersten Lesson des Tutorials zeigt dir André Krämer die Grundlagen von .NET MAUI, Microsofts Framework für plattformübergreifende Apps. Du erfährst, wie du deine erste App erstellst und auf Windows, macOS, Android und iOS testest. Zum Abschluss baust du eine einfache To-do-App, die dir als Ausgangspunkt für weitere Projekte dient.\n'parentId': 'dd0d8f751be8d368f2f60eb9'\n'parentDescription': Zusammen mit Microsoft MVP André Krämer lernst du Schritt für Schritt, wie du mit .NET MAUI in C# und .NET native Apps für Android, iOS, macOS und Windows aus einer einzigen Codebasis erstellst. Du gestaltest ansprechende Benutzeroberflächen mit XAML und dem MVVM-Design-Pattern, stellst Daten in Listen übersichtlich dar und navigierst dabei nahtlos zwischen verschiedenen Ansichten. Zudem erfährst du, wie du Dependency Injection effizient einsetzt und native Gerätefunktionen wie die Kamera nutzt. Das praxisorientierte Tutorial ermöglicht dir, moderne Cross-Platform-Apps eigenständig zu entwickeln.\n'indexBrandName': 'BASTA!'\n'indexSeriesName': ''\n'author': 'André Krämer'\n'chunkSource': 'text'\n'text': Das ist .NET MAUI In der ersten Lesson des Tutorials zeigt dir André Krämer die Grundlagen von .NET MAUI, Microsofts Framework für plattformübergreifende Apps. Du erfährst, wie du deine erste App erstellst und auf Windows, macOS, Android und iOS testest. Zum Abschluss baust du eine einfache To-do-App, die dir als Ausgangspunkt für weitere Projekte dient. Hallo und herzlich willkommen zu diesem Entwickler.de-Tutorial Einstieg in die Appentwicklung mit .NET MAUI. Im Rahmen dieses Tutorials werden wir uns gemeinsam ansehen, was .NET MAUI eigentlich ist und wie die Architektur darunter funktioniert. Sobald wir diesen Überblick geschaffen haben, werden wir danach zusammen eine erste einfache kleine App anlegen und dann schon sehen, wie leicht es mit .NET MAUI eigentlich ist, eine Anwendung zu schreiben, die sowohl unter Android als auch unter iOS und unter Windows oder Mac lauffähig ist. Natürlich werden wir dort nicht Halt machen, sondern danach werden wir zusammen ein Eingabeformular anlegen. werden darin das ModelView ViewModel, also das MVVM-Muster, benutzen und beides über die dependency injection miteinander verbinden. Ja da so eine Mobile App in der Regel aus mehr als einer Seite besteht, werden wir uns natürlich auch mit dem Thema Navigation beschäftigen. Also wie komme ich eigentlich von der ersten zur zweiten Seite und wieder zurück und zu ganz anderen Seiten noch? Und dazu wenn wir das Navigations Framework von .NET MAUI die Shell verwenden. Ja und schlussendlich werfen wir einen Blick darauf, wie können wir eigentlich in so einer Mobile App Listen anzeigen? Wie können wir Grafiken in einer .NET MAUI App anzeigen? Und wie kommen wir an die Hardware und zwar insbesondere an die Kamera? Ihr seht schon, wir haben eine ganze Menge bevor. Bevor wir jetzt aber in die Materie eintauchen, möchte ich mich ganz kurz vorstellen. Mein Name ist André Krämer. bin Gründer und Geschäftsführer der Quality Bites GmbH aus der Nähe von Koblenz. Und unser Fokus der liegt auf der Entwicklung maßgeschneideter Business Apps mit .NET MAUI. Außerdem haben wir uns in den letzten Monaten für unsere Kunden sehr mit dem Thema Migration von Xamarin Forms zu .NET MAUI beschäftigt und auch vieles im Blazer-Umfeld gemacht. Außerdem\n'slidetext': ''\n'from': 'index'\n'score': 48.361122131347656\n'normalizedScore': 0.48361122131347656\n'beforeDatePenaltyScore': 0.48361122131347656\n\n'documentId': '535b45361ad6c9e12a423cbc'\n'chunk_id': '6876d392225e92fc1ac79d16'\n'access': 'granted'\n'part_number': 8\n'total_parts': 35\n'contentType': 'TUTORIAL'\n'title': Das ist .NET MAUI\n'parentName': Mit .NET MAUI zur erfolgreichen Cross-Platform-App\n'language': 'DE'\n'date': '2025-02-07T10:45:08.000Z'\n'abstract': In der ersten Lesson des Tutorials zeigt dir André Krämer die Grundlagen von .NET MAUI, Microsofts Framework für plattformübergreifende Apps. Du erfährst, wie du deine erste App erstellst und auf Windows, macOS, Android und iOS testest. Zum Abschluss baust du eine einfache To-do-App, die dir als Ausgangspunkt für weitere Projekte dient.\n'parentId': 'dd0d8f751be8d368f2f60eb9'\n'parentDescription': Zusammen mit Microsoft MVP André Krämer lernst du Schritt für Schritt, wie du mit .NET MAUI in C# und .NET native Apps für Android, iOS, macOS und Windows aus einer einzigen Codebasis erstellst. Du gestaltest ansprechende Benutzeroberflächen mit XAML und dem MVVM-Design-Pattern, stellst Daten in Listen übersichtlich dar und navigierst dabei nahtlos zwischen verschiedenen Ansichten. Zudem erfährst du, wie du Dependency Injection effizient einsetzt und native Gerätefunktionen wie die Kamera nutzt. Das praxisorientierte Tutorial ermöglicht dir, moderne Cross-Platform-Apps eigenständig zu entwickeln.\n'indexBrandName': 'BASTA!'\n'indexSeriesName': ''\n'author': 'André Krämer'\n'chunkSource': 'text'\n'text': sogar schon zum Release-Candidate von .NET 8 auf MAUI 8 gegangen, einfach die Qualität besser war als bei 7 und auch bei 9 sehr schnell gewechselt. Die neuen Features sind in Regel so gut, es lohnt sich und die Stabilität ist auch höher. Wenn ihr jetzt sagt, Mensch, das klingt alles spannend, ihr wollt hier wirklich mitmachen bei diesem Tutorial, dann müssen wir natürlich auch mal schauen, was ihr eigentlich dafür. Also braucht erstmal ein Betriebssystem und das könnte zum Beispiel ein Mac sein. Und auf eure Mac, da braucht ihr Visual Studio Code und .NET 9. So, wenn ihr beides habt, dann könnt ihr dem Tutorial auf dem Mac folgen. Und zwar könnt ihr dann Anwendungen auf eure Mac für macOS schreiben und für iOS. Außerdem, auch natürlich, wenn ihr alle Abhängigkeiten inszeniert habt und wie das geht, das seht ihr auf der Microsoft .NET Homepage, dann könnt ihr auch für Android entwickeln. Ganz wichtig, für macOS und für iOS braucht ihr auch außerdem Xcode auf eurem Rechner. Xcode, das ist die kostenfreie Entwicklungsbewebung von Apple, die bekommt ihr über den Apple App Store. Und wenn ihr die nicht habt, dann könnt ihr weder für macOS noch für iOS entwickeln. Ja, natürlich könnt ihr auch unter Windows entwickeln, das werde ich auch im Rahmen dieses Tutorials machen. Und unter Windows, da könnt ihr einfach Visual Studio installieren und dann könnt ihr für Windows entwickeln. Aber natürlich auch für Android. Es gibt auch einen kleinen Trick und zwar, ihr bei euch im Netzwerk oder in dem Netzwerk, in dem sich euer Windows Rechner befindet, auch einen Mac habt, auf dem die .NET Tools installiert sind, dann könnt ihr eine SSH-Verbindung über Visual Studio zu diesem Mac machen. Dann könnt ihr remote unter Windows Apps für iOS kompilieren und debuggen. Das Ganze funktioniert aber nur unter Windows für iOS. Das funktioniert nicht unter Windows für macOS und auch nicht unter macOS für Windows. Also also nutzt ihr ein Mac, dann könnt ihr für Mac iOS und Android entwickeln. Habt ihr ein Windows Rechner, dann könnt ihr für Android und für Windows entwickeln und natürlich auch\n'slidetext': ''\n'from': 'index'\n'score': 47.39795684814453\n'normalizedScore': 0.4739795684814453\n'beforeDatePenaltyScore': 0.4739795684814453\n\n'documentId': '535b45361ad6c9e12a423cbc'\n'chunk_id': '6876d395225e92fc1ac79d2d'\n'access': 'granted'\n'part_number': 31\n'total_parts': 35\n'contentType': 'TUTORIAL'\n'title': Das ist .NET MAUI\n'parentName': Mit .NET MAUI zur erfolgreichen Cross-Platform-App\n'language': 'DE'\n'date': '2025-02-07T10:45:08.000Z'\n'abstract': In der ersten Lesson des Tutorials zeigt dir André Krämer die Grundlagen von .NET MAUI, Microsofts Framework für plattformübergreifende Apps. Du erfährst, wie du deine erste App erstellst und auf Windows, macOS, Android und iOS testest. Zum Abschluss baust du eine einfache To-do-App, die dir als Ausgangspunkt für weitere Projekte dient.\n'parentId': 'dd0d8f751be8d368f2f60eb9'\n'parentDescription': Zusammen mit Microsoft MVP André Krämer lernst du Schritt für Schritt, wie du mit .NET MAUI in C# und .NET native Apps für Android, iOS, macOS und Windows aus einer einzigen Codebasis erstellst. Du gestaltest ansprechende Benutzeroberflächen mit XAML und dem MVVM-Design-Pattern, stellst Daten in Listen übersichtlich dar und navigierst dabei nahtlos zwischen verschiedenen Ansichten. Zudem erfährst du, wie du Dependency Injection effizient einsetzt und native Gerätefunktionen wie die Kamera nutzt. Das praxisorientierte Tutorial ermöglicht dir, moderne Cross-Platform-Apps eigenständig zu entwickeln.\n'indexBrandName': 'BASTA!'\n'indexSeriesName': ''\n'author': 'André Krämer'\n'chunkSource': 'text'\n'text': Studio. Ich lege also ein neues Projekt an und das Ganze kennt ihr schon. Ich werde hier oben die Maui auch hier klicke ich wieder auf weiter. Achtet darauf, dass hier .NET 9 ausgewählt ist und ganz wichtig, dieses mal werde ich auch diesen Haken hier setzen. Also Haken gesetzt und weiter geht's. Das Ganze dauert jetzt einen Augenblick, das Ganze zu stellen, weil es ja doch etwas umfangreichere Anwendungen ist. Ich sehe, dieses Mal ging es doch relativ schnell und ich starte einfach mal die App. Dann ihr schon mal was ihr bekommt und danach gucken wir uns ganz kurz die Struktur an. werde euch das jetzt nicht bis ins letzte Detail erklären, das könnt ihr gerne selber im Nachgang noch einmal machen, aber zumindest, dass ihr mal gesehen habt, wie sieht die App aus, was wird darin genutzt und was sind so die wichtigen Punkte, die ihr euch einmal ansehen solltet. Viele der Dinge, die wir hier auch in der App sehen, werden wir im Rahmen dieses Tutorials auch ganz detailliert besprechen, also keine Sorge, wenn ihr das jetzt noch nicht alles auf den ersten Blick versteht. So hier haben wir die App. Ich starte jetzt einfach mal nur unter Windows und wie wir sehen, habe ich hier so eine kleine To-Do-App. Wie ist die aufgebaut? Ich habe hier oben so ein kleines Diagramm, im Endeffekt also hier so ein Chart. Darunter sehe ich eine ganze Reihe von Projekten, irgendwie ja Balance, Personal, Fitness und Family and dazu gibt es dann hier unten noch eine Reihe von Aufgaben. Diese Aufgaben, kann ich abhaken. Ich kann aber auch genauso hingehen und könnte hier eine neue Aufgabe anlegen, indem ich auf das Plus drücke und jetzt eintippe, neue Aufgabe für Entwickler.de und kann jetzt hier ein Projekt auswählen und sagt, ist Business gibt es nicht, das ist Personal, Safe. Und damit werden wir jetzt auch hier unten diese neue Aufgabe für Entwickler.de haben. Kann ich öffnen, die kann ich jetzt wieder löschen, wenn ich das möchte. Ich kann sie bearbeiten, ich kann zurück navigieren. Was kann ich in der Anwendung noch machen? Ich kann zum\n'slidetext': ''\n'from': 'index'\n'score': 44.972877502441406\n'normalizedScore': 0.44972877502441405\n'beforeDatePenaltyScore': 0.44972877502441405\n\n'documentId': '535b45361ad6c9e12a423cbc'\n'chunk_id': '6876d393225e92fc1ac79d20'\n'access': 'granted'\n'part_number': 18\n'total_parts': 35\n'contentType': 'TUTORIAL'\n'title': Das ist .NET MAUI\n'parentName': Mit .NET MAUI zur erfolgreichen Cross-Platform-App\n'language': 'DE'\n'date': '2025-02-07T10:45:08.000Z'\n'abstract': In der ersten Lesson des Tutorials zeigt dir André Krämer die Grundlagen von .NET MAUI, Microsofts Framework für plattformübergreifende Apps. Du erfährst, wie du deine erste App erstellst und auf Windows, macOS, Android und iOS testest. Zum Abschluss baust du eine einfache To-do-App, die dir als Ausgangspunkt für weitere Projekte dient.\n'parentId': 'dd0d8f751be8d368f2f60eb9'\n'parentDescription': Zusammen mit Microsoft MVP André Krämer lernst du Schritt für Schritt, wie du mit .NET MAUI in C# und .NET native Apps für Android, iOS, macOS und Windows aus einer einzigen Codebasis erstellst. Du gestaltest ansprechende Benutzeroberflächen mit XAML und dem MVVM-Design-Pattern, stellst Daten in Listen übersichtlich dar und navigierst dabei nahtlos zwischen verschiedenen Ansichten. Zudem erfährst du, wie du Dependency Injection effizient einsetzt und native Gerätefunktionen wie die Kamera nutzt. Das praxisorientierte Tutorial ermöglicht dir, moderne Cross-Platform-Apps eigenständig zu entwickeln.\n'indexBrandName': 'BASTA!'\n'indexSeriesName': ''\n'author': 'André Krämer'\n'chunkSource': 'text'\n'text': hier gibt es ein paar Spielregeln, wie ich die benennen muss, aber auch das in einem späteren Video dieses Tutorials. Dann habe ich den Ordner Raw, da kann ich irgendwelche Dateien ausliefern, ich in meiner Anwendung später brauche, ich vielleicht selber einlesen möchte, irgendwie Basisdaten für meine Datenbank, was auch immer. Dann ein Ordner Splash, dort habe ich die Hintergrundgrafik für den Splash-Screen und Splash-Screens, also diese Begrüßungsbildschirme, die sehen wir nur unter Android oder iOS, die sehen wir nicht unter Windows. Und dann den Ordner Styles, da wird definiert, wie meine Controls aussieht. habt ja gesehen, dass ich hier diese lila Buttonfarbe zum Beispiel hatte, und das kommt hier aus der Colors XAML. Das ist einfach nur eine Style-Datei, über die ich sehr schnell meine App an mein Corporate Identity anpassen kann, indem ich hier diese Farben ändere. So, und das schlussendlich hat eigentlich schon einen guten Überblick gegeben über das, was wir hier in einer Maui-App an Ordnern und Dateien haben. Wir haben also gelernt, es Dateien, sind plattformspezifisch, die befinden sich hier in diesem Ordner Platforms, und es gibt Dateien, die sind plattformübergreifend, die befinden sich halt überall anders, aber eben nicht in dem Ordner Platforms. Oder gibt es noch den Ordner Resources, der hat so eine Sonderbedeutung, weil dort Schriftarten und so weiter hereinkommen. Damit sind wir mit dem Überblick über die Grundstruktur einer Maui-App auch erstmal fertig. Was wir uns jetzt im nächsten Video anschauen werden, ist, wie wir unsere Anwendung nicht nur sondern auch unter Android oder iOS starten können. Für euch an der Stelle auch ganz wichtig, wenn ihr das im ersten Mal mit der Windows startet, dann bekommt ihr gegebenenfalls eine Meldung, dass ihr den Entwicklermodus von der Windows aktivieren müsst. Das ist wichtig weil ihr sonst nicht unter Windows debuggen könnt. Damit ihr das aktivieren könnt, müsst ihr ein lokales Administratorkonto auf eurem Rechner haben. Ganz wichtig, habt ihr kein lokales Administratorkonto, dann könnt ihr hier diese Einstellung nicht aktivieren, müsst ihr euren Admin fragen, damit er das macht.\n'slidetext': ''\n'from': 'index'\n'score': 44.972877502441406\n'normalizedScore': 0.44972877502441405\n'beforeDatePenaltyScore': 0.44972877502441405\n\n'documentId': '535b45361ad6c9e12a423cbc'\n'chunk_id': '6876d393225e92fc1ac79d1f'\n'access': 'granted'\n'part_number': 17\n'total_parts': 35\n'contentType': 'TUTORIAL'\n'title': Das ist .NET MAUI\n'parentName': Mit .NET MAUI zur erfolgreichen Cross-Platform-App\n'language': 'DE'\n'date': '2025-02-07T10:45:08.000Z'\n'abstract': In der ersten Lesson des Tutorials zeigt dir André Krämer die Grundlagen von .NET MAUI, Microsofts Framework für plattformübergreifende Apps. Du erfährst, wie du deine erste App erstellst und auf Windows, macOS, Android und iOS testest. Zum Abschluss baust du eine einfache To-do-App, die dir als Ausgangspunkt für weitere Projekte dient.\n'parentId': 'dd0d8f751be8d368f2f60eb9'\n'parentDescription': Zusammen mit Microsoft MVP André Krämer lernst du Schritt für Schritt, wie du mit .NET MAUI in C# und .NET native Apps für Android, iOS, macOS und Windows aus einer einzigen Codebasis erstellst. Du gestaltest ansprechende Benutzeroberflächen mit XAML und dem MVVM-Design-Pattern, stellst Daten in Listen übersichtlich dar und navigierst dabei nahtlos zwischen verschiedenen Ansichten. Zudem erfährst du, wie du Dependency Injection effizient einsetzt und native Gerätefunktionen wie die Kamera nutzt. Das praxisorientierte Tutorial ermöglicht dir, moderne Cross-Platform-Apps eigenständig zu entwickeln.\n'indexBrandName': 'BASTA!'\n'indexSeriesName': ''\n'author': 'André Krämer'\n'chunkSource': 'text'\n'text': jetzt hier auf den Button, dann wird er nicht ausgeführt, sondern er wird hier markiert, also heißt, ich habe immer die Möglichkeit, wenn ich auf irgendwas klicke und ich klicke jetzt mal hier auf das Bild, direkt zu dem entsprechenden Mark abzuspringen und sehe dann sofort, wo das in meinem XAML definiert worden ist. Gehen wir aber mal zurück zu unserer Anwendung, dazu hole ich die wieder nach vorne, denn hier war sie ja nicht interaktiv. Hier haben wir zum einen ein Menü mit einem Menüpunkt, das wurde ja über die App XAML definiert. haben wir hier noch? Wir haben hier einen Button, da kann ich draufklicken und dann wird hier hochgezählt. Wo kommt das her mit dem Hochzählen? Schauen wir mal, unser Button, der hier in der Mainpage XAML definiert ist, der hat hier einen Click Event Handler definiert, nämlich onCounterClick und onCounterClicked, schauen wir mal da rein und zwar ist das hier eine Ereignisbehandlungsroutine, nutzt diese Variable count und erhöht die und dann wird der Text des Buttons hier entsprechend angepasst. Der Button hat hier einen Namen bekommen, ich habe hier gesagt, Name ist counterButton und dann wird hier darauf zugegriffen und der Text verändert. Ob das ein guter Weg ist oder nicht, das so zu zusammen angucken. Wichtig ist nur mal, es funktioniert grundsätzlich mal so. So was haben wir noch in unserer Anwendung? Ich schließe die einmal ganz kurz und gucke mal durch die Ordner rein. Ich habe also hier noch ein Ordner App Icon. Dieser Ordner App Icon, definiert das Symbol, was ich in der Taskleiste sehe, der definiert auch das Symbol, was ich auf dem Startbildschirm einer Android Gerät oder eines iPhones sehen würde. Es definiert außerdem das Icon, was ich im Startmenü oder Windows sehen würde. Dann haben wir den Ordner Fonts den haben wir schon besprochen, da kommen Schriftdaten rein. In den Ordner Images kommen Bilder, die ich mit der App ausliefern möchte und ganz wichtig, hier gibt es ein paar Spielregeln, wie ich die benennen muss, aber auch das in einem späteren Video dieses Tutorials. Dann habe ich den Ordner Raw, da kann ich irgendwelche Dateien ausliefern, ich\n'slidetext': ''\n'from': 'index'\n'score': 44.972877502441406\n'normalizedScore': 0.44972877502441405\n'beforeDatePenaltyScore': 0.44972877502441405\n\n'documentId': '535b45361ad6c9e12a423cbc'\n'chunk_id': '6876d395225e92fc1ac79d31'\n'access': 'granted'\n'part_number': 35\n'total_parts': 35\n'contentType': 'TUTORIAL'\n'title': Das ist .NET MAUI\n'parentName': Mit .NET MAUI zur erfolgreichen Cross-Platform-App\n'language': 'DE'\n'date': '2025-02-07T10:45:08.000Z'\n'abstract': In der ersten Lesson des Tutorials zeigt dir André Krämer die Grundlagen von .NET MAUI, Microsofts Framework für plattformübergreifende Apps. Du erfährst, wie du deine erste App erstellst und auf Windows, macOS, Android und iOS testest. Zum Abschluss baust du eine einfache To-do-App, die dir als Ausgangspunkt für weitere Projekte dient.\n'parentId': 'dd0d8f751be8d368f2f60eb9'\n'parentDescription': Zusammen mit Microsoft MVP André Krämer lernst du Schritt für Schritt, wie du mit .NET MAUI in C# und .NET native Apps für Android, iOS, macOS und Windows aus einer einzigen Codebasis erstellst. Du gestaltest ansprechende Benutzeroberflächen mit XAML und dem MVVM-Design-Pattern, stellst Daten in Listen übersichtlich dar und navigierst dabei nahtlos zwischen verschiedenen Ansichten. Zudem erfährst du, wie du Dependency Injection effizient einsetzt und native Gerätefunktionen wie die Kamera nutzt. Das praxisorientierte Tutorial ermöglicht dir, moderne Cross-Platform-Apps eigenständig zu entwickeln.\n'indexBrandName': 'BASTA!'\n'indexSeriesName': ''\n'author': 'André Krämer'\n'chunkSource': 'text'\n'text': können auch für iOS entwickeln. Ich kann das sogar unter Windows starten aber ich brauche später zu paketieren davon auf jeden Fall immer einen Mac. Im einfachsten Fall, wenn ich jetzt selber mit dem Mac noch nicht ganz so warm geworden bin, dann kann ich einfach hingehen und kann ja meinen Mac remote verbinden, indem ich die entfernte Anmeldung aktiviere und dann kann ich aus Visual Studio heraus meine Anwendung auf dem Mac starten, debuggen, paketieren und so weiter. Natürlich kann ich aber auch direkt auf dem Mac arbeiten und dort habe ich zwei Optionen. Ich kann Visual Studio Code benutzen oder eben JetBrains Rider. Was nicht mehr geht, ist Visual Studio for Mac zu nutzen. Das Ganze wurde ja entsprechend abgekündigt. Zum Abschluss haben wir dann folgendes gemacht. haben mal diese neue Option gewählt, nämlich, dass ich beim Anlegen eines Projektes Beispieldaten hereinholen möchte und dann bekomme ich tatsächlich eigentlich keine leere App mehr. Noch einmal. Und dann bekomme ich tatsächlich gar keine leere App mehr, sondern was ich dann bekomme, ist eine vollständige To-Do App, in der ich mir angucken kann, wie funktioniert eigentlich das Model View View Model Muster? Wie mache ich Datenzugriff in eine SQLite Datenbank? Wie kann ich schicke Controls mit schicken Charts und so weiter einbinden? All das findet ihr in dieser App, so bisschen als Sammlung von Best Practices. Ja und damit sind wir, wie gesagt, am Ende der ersten Lektion angekommen. Ich hoffe, es hat euch soweit Spaß gemacht. Ich freue mich auf die nächste Lektion, denn jetzt sind wir eigentlich gewappnet, um unsere richtige App, die wir Laufe dieses Tutorials entwickeln möchten, zu programmieren. Schonmal als kleine Vorschau, worum es geht. Wir werden zusammen eine App entwickeln, mit der wir verwalten können, welche Gegenstände wir an jemanden ausgeliehen haben und sehen können, ob wir die eigentlich pünktlich zurückbekommen haben. Wie das Ganze funktioniert, das folgt dann in den nächsten Lektionen. Ich wünsche euch dabei schon mal viel Spaß und bis dahin.\n'slidetext': ''\n'from': 'index'\n'score': 44.79252624511719\n'normalizedScore': 0.44792526245117187\n'beforeDatePenaltyScore': 0.44792526245117187\n\n'documentId': 'a5dcfc84b51456a6b4b27fce'\n'chunk_id': '6878ecf022599b00136894bf'\n'access': 'granted'\n'part_number': 1\n'total_parts': 77\n'contentType': 'TUTORIAL'\n'title': Die Welt der Web Components\n'parentName': Web Components von 0 auf 100\n'language': 'DE'\n'date': '2025-06-05T13:45:07.000Z'\n'abstract': In der ersten Lesson steigen wir in die Welt der Web Components ein. Wir richten unser Setup ein, klären die Ziele des Tutorials – und schreiben unser erstes „Hello World“. Dabei beantworten wir die Grundfrage: Was sind Web Components eigentlich? Wir schauen uns Content-Attribute und DOM-Properties an, ziehen den Vergleich zu Frameworks und klären, wo Web Components glänzen – und wo nicht. Best Practices und erste UI-Beispiele runden den Einstieg ab.\n'parentId': '54cce7e83417cbefa7c0d3f0'\n'parentDescription': Web Components versprechen universelle Frontend-Komponenten, frei von Framework-Fesseln und Dependency-Depression. Das Problem: Web Components sind komplex, manche APIs wirken eigenartig, und das sie umgebende Ökosystem ist unübersichtlich. Was können Web Components leisten – und was nicht? Brauche ich wirklich Shadow DOM oder kann ich darauf verzichten? Vanilla-Komponenten, Lit – oder etwas dazwischen? In diesem Tutorial lernen wir, wie der Komponenten-Eintopf wirklich gemacht wird. Wir orientieren uns im Ökosystem und erhalten einen Überblick über die Fähigkeiten und Grenzen der Standards rund um Web Components. Von den absoluten API-Grundlagen bis zum Einsatz ausgewachsener Komponenten-Frameworks lassen wir keinen Schritt aus. In jedem Abschnitt unserer Reise erfahren wir nicht nur, wie etwas funktioniert, sondern auch, warum. Dieses Tutorial macht uns nicht nur zu Web-Component-Expert:innen, sondern vertieft auch unser Verständnis der Web-Plattform insgesamt.\n'indexBrandName': 'InternationalJavaScriptCon'\n'indexSeriesName': ''\n'author': 'Peter Kröner'\n'chunkSource': 'text'\n'text': Die Welt der Web Components In der ersten Lesson steigen wir in die Welt der Web Components ein. Wir richten unser Setup ein, klären die Ziele des Tutorials – und schreiben unser erstes „Hello World“. Dabei beantworten wir die Grundfrage: Was sind Web Components eigentlich? Wir schauen uns Content-Attribute und DOM-Properties an, ziehen den Vergleich zu Frameworks und klären, wo Web Components glänzen – und wo nicht. Best Practices und erste UI-Beispiele runden den Einstieg ab. Hallo und herzlich willkommen zu diesem Video-Tutorial zu Web-Components. Web-Components von 0 auf 100. Mein Name ist Peter Kröner und ich bin so ein bisschen der Low-Level-Web-Tag-Erklär-Bär. Was ich eigentlich den lieben langen Tag mache, nicht wirklich primär Web-Entwicklung, obwohl ich das auch machen kann, wenn ich muss. Ich verbringe viel mehr meine Zeit damit, Vorträge zu machen, Workshops zu halten, meistens zu Themen, die halt mit Low-Level-Web-Technologie zu tun haben. Also HTML, DOM, JavaScript, CSS. Wie funktioniert dieser ganze Krämpel wirklich unterhalb der Ebene von Frameworks? Und aus dieser Perspektive kommend, möchte ich euch gerne in den folgenden paar Videos Web-Components ein bisschen näher bringen. Es ist ja so, die meisten Web-Entwicklerinnen und Entwickler nehmen heutzutage ihren Tech-Stack durch die Membran von Frameworks wahr. Angular React, was auch immer. Und das ist ja erstmal auch nicht verkehrt Das sorgt dafür, dass alle die gleiche Sprache sprechen, die gleiche Idee davon haben. Was es für Konzepte und Patterns gibt, ist alles ja wunderbar und schön. Und das Gleiche gilt auch für Web-Components. Web-Components werden oft in Form von Frameworks an Entwicklerinnen und Entwickler angereicht. Man nutzt also irgendwelche Frameworks, um die Dinger zu schreiben und auch daran ist erstmal nichts verkehrt. Aber man kann theoretisch mit Web-Components auch aus dem Framework-Zirkus aussteigen und sich seine eigene Welt schaffen. Sein eigenes Framework schreiben oder vanilla JavaScript mäßig unterwegs sein und sich komplett von irgendwelchen Dependencies und so frei machen. Um aber die Entscheidung zu treffen, man das machen möchte und wenn ja, auf welche Weise, muss man die ganzen Basics verstanden haben. Und das ist so ein bisschen meine Idee mit diesem Videotraining. Ich\n'slidetext': ''\n'from': 'index'\n'score': 44.21614074707031\n'normalizedScore': 0.44216140747070315\n'beforeDatePenaltyScore': 0.44216140747070315\n\n'documentId': 'a5dcfc84b51456a6b4b27fce'\n'chunk_id': '6878ecf122599b00136894c5'\n'access': 'granted'\n'part_number': 6\n'total_parts': 77\n'contentType': 'TUTORIAL'\n'title': Die Welt der Web Components\n'parentName': Web Components von 0 auf 100\n'language': 'DE'\n'date': '2025-06-05T13:45:07.000Z'\n'abstract': In der ersten Lesson steigen wir in die Welt der Web Components ein. Wir richten unser Setup ein, klären die Ziele des Tutorials – und schreiben unser erstes „Hello World“. Dabei beantworten wir die Grundfrage: Was sind Web Components eigentlich? Wir schauen uns Content-Attribute und DOM-Properties an, ziehen den Vergleich zu Frameworks und klären, wo Web Components glänzen – und wo nicht. Best Practices und erste UI-Beispiele runden den Einstieg ab.\n'parentId': '54cce7e83417cbefa7c0d3f0'\n'parentDescription': Web Components versprechen universelle Frontend-Komponenten, frei von Framework-Fesseln und Dependency-Depression. Das Problem: Web Components sind komplex, manche APIs wirken eigenartig, und das sie umgebende Ökosystem ist unübersichtlich. Was können Web Components leisten – und was nicht? Brauche ich wirklich Shadow DOM oder kann ich darauf verzichten? Vanilla-Komponenten, Lit – oder etwas dazwischen? In diesem Tutorial lernen wir, wie der Komponenten-Eintopf wirklich gemacht wird. Wir orientieren uns im Ökosystem und erhalten einen Überblick über die Fähigkeiten und Grenzen der Standards rund um Web Components. Von den absoluten API-Grundlagen bis zum Einsatz ausgewachsener Komponenten-Frameworks lassen wir keinen Schritt aus. In jedem Abschnitt unserer Reise erfahren wir nicht nur, wie etwas funktioniert, sondern auch, warum. Dieses Tutorial macht uns nicht nur zu Web-Component-Expert:innen, sondern vertieft auch unser Verständnis der Web-Plattform insgesamt.\n'indexBrandName': 'InternationalJavaScriptCon'\n'indexSeriesName': ''\n'author': 'Peter Kröner'\n'chunkSource': 'text'\n'text': wir werden einfach mal das dadurch exerzieren, weil das, glaube ich, eine gute Demonstration ist, wo man dann auch wirklich mal jeden Aspekt von allem, was wir bisher besprochen haben, werden einmal in Aktion sehen kann. Es ist also überschaubar und verständlich und klar abgegrenzt, aber nicht trivial. Das ist so im Wesentlichen mein Plan und die Ziele sind, wie gesagt, vor allen Dingen für mich Orientierung, dass ihr genau wisst, was es alles gibt und wie die Dinge zusammengehören. Dann auch ein bisschen Verständnis dafür, warum die Technologien so sind, wie sie sind, warum es auch nach diesem Videotutorial für euch viel, einfacher sein wird, ne Angular oder ne React-Komponente zu bauen. Die sind nämlich einfacher zu bauen, aber ein bisschen Verständnis dafür, warum das so ist und ne Einsicht in die Trade-offs, sodass man sich dann eventuell entscheiden kann. Ich wirklich mit meinem klassischen Frontend-Framework arbeite oder brauche ich ein Web-Component-Framework oder möglicherweise auch die Kombination aus beidem das gibt es nämlich auch. Dann möchte ich natürlich euch auch in die Lage versetzen, zur Not die ganzen Sachen manuell selber zu schreiben, also nicht nur die Frameworks zu bedienen. wenn wir das alles dann zusammen haben, dann glaube ich seid ihr ganz brauchbare Nerds Sachen Web-Components. Ihr wisst, wie die Wurst gemacht wird und ihr wisst, wann ihr euch wirklich mit diesen Details befassen wollt und wann nicht. Und das ist im Wesentlichen mein Plan für dieses Videotutorial. Und ich würde sagen, jetzt wo wir die ganzen Basics und die Planung und die Agenda aus dem Weg geräumt haben, bleibt nur eins, wir müssen anfangen. Wir müssen anfangen mit dem, womit wir bei solchen Tutorials immer anfangen müssen, nämlich mit Hallo Welt. Und genau das machen wir jetzt. Das war jetzt wirklich genug Gephasel von Dingen die man mal machen könnte, Zielen, die man haben könnte und Dingen, die vielleicht mal kompliziert sein werden. Was wir jetzt machen, ist ne richtige Web-Component bauen. Wir schauen uns an, wie die einzelnen Dinge zusammenspielen und wie das so grob funktionieren kann. Grundsätzlich\n'slidetext': ''\n'from': 'index'\n'score': 42.584651947021484\n'normalizedScore': 0.42584651947021485\n'beforeDatePenaltyScore': 0.42584651947021485\n\n'documentId': '535b45361ad6c9e12a423cbc'\n'chunk_id': '6876d392225e92fc1ac79d13'\n'access': 'granted'\n'part_number': 5\n'total_parts': 35\n'contentType': 'TUTORIAL'\n'title': Das ist .NET MAUI\n'parentName': Mit .NET MAUI zur erfolgreichen Cross-Platform-App\n'language': 'DE'\n'date': '2025-02-07T10:45:08.000Z'\n'abstract': In der ersten Lesson des Tutorials zeigt dir André Krämer die Grundlagen von .NET MAUI, Microsofts Framework für plattformübergreifende Apps. Du erfährst, wie du deine erste App erstellst und auf Windows, macOS, Android und iOS testest. Zum Abschluss baust du eine einfache To-do-App, die dir als Ausgangspunkt für weitere Projekte dient.\n'parentId': 'dd0d8f751be8d368f2f60eb9'\n'parentDescription': Zusammen mit Microsoft MVP André Krämer lernst du Schritt für Schritt, wie du mit .NET MAUI in C# und .NET native Apps für Android, iOS, macOS und Windows aus einer einzigen Codebasis erstellst. Du gestaltest ansprechende Benutzeroberflächen mit XAML und dem MVVM-Design-Pattern, stellst Daten in Listen übersichtlich dar und navigierst dabei nahtlos zwischen verschiedenen Ansichten. Zudem erfährst du, wie du Dependency Injection effizient einsetzt und native Gerätefunktionen wie die Kamera nutzt. Das praxisorientierte Tutorial ermöglicht dir, moderne Cross-Platform-Apps eigenständig zu entwickeln.\n'indexBrandName': 'BASTA!'\n'indexSeriesName': ''\n'author': 'André Krämer'\n'chunkSource': 'text'\n'text': dann so aus, ich schreibe meine Oberflächen mit C-Sharp, mit HTML, mit der Razor-Syntax und mit CSS. Der Nachteil ist bei dieser Variante, dass ich obwohl ich eine große Breite an Zielplattformen erreiche, nicht in die Tiefe komme. Was bedeutet das? Wenn ich auf die Hardware zugreife, dadurch dass ich bei Blazor in einem Browser laufe, laufe ich an der Sandbox und habe deswegen nicht vollen Zugriff auf die Hardware. Wenn ich das brauche, dann benutze ich .NET MAUI und darum geht ja auch dieses Tutorial. Bei .NET MAUI da komme ich wirklich an alles dran, was es auf dem jeweiligen Zielbetriebssystem gibt. Allerdings habe ich kleine Einschränkungen, was die Zielplattform angeht. Ich habe die vier Plattformen eben schon genannt. Das natürlich eine dabei, die gefehlt hat, nämlich Linux. Da komme ich also mit .NET MAUI zum jetzigen Zeitpunkt nicht drauf. Der MAUI selbst nutze ich wie gesagt C Sharp und dann in der Regel XAML, um meine Oberflächen zu rendern und ich bekomme eine nativaussehende Anwendung. Das ist Blazor ein bisschen anders, da wird das Ganze ja durch den Browser einfach gerendert. Aber hier bei .NET MAUI habe ich eben eine native Anwendung. Und dann gibt es noch die Kombination von beiden. Blazor mit .NET MAUI zu einer Form von Blazor MAUI Hybrid. Ihr müsst euch das vorstellen. Ihr euch das so vorstellen. habt eine große MAUI App, die vielleicht nur aus einem Webview besteht. Also einer Komponente, die Webinhalte darstellen kann. Und dort lade ich meine Blazor Anwendung rein. Diese Blazor Anwendung wird übrigens dann lokal ausgeführt. Die braucht keine Internetverbindung. Was ich dann machen kann ist, ich kann eben mein UI statt mit C Sharp und XAML mit C Sharp, mit HTML, mit Razor schreiben. Ich sogar mit XAML bisschen XAML einfließen lassen. Und habe dann aber die Möglichkeit, auf sämtliche Betriebssystemfunktionen zuzugreifen. Weil ich hier eine native MAUI App habe, die einfach nur eine hybride App rappt. Tja, wo benutze ich jetzt welche der Optionen Wie gesagt, Blazor immer dann, wenn ich sage, ich will auf alle Plattformen inklusive Linux und es soll eine\n'slidetext': ''\n'from': 'index'\n'score': 42.09585189819336\n'normalizedScore': 0.4209585189819336\n'beforeDatePenaltyScore': 0.4209585189819336\n\n'documentId': '535b45361ad6c9e12a423cbc'\n'chunk_id': '6876d392225e92fc1ac79d12'\n'access': 'granted'\n'part_number': 4\n'total_parts': 35\n'contentType': 'TUTORIAL'\n'title': Das ist .NET MAUI\n'parentName': Mit .NET MAUI zur erfolgreichen Cross-Platform-App\n'language': 'DE'\n'date': '2025-02-07T10:45:08.000Z'\n'abstract': In der ersten Lesson des Tutorials zeigt dir André Krämer die Grundlagen von .NET MAUI, Microsofts Framework für plattformübergreifende Apps. Du erfährst, wie du deine erste App erstellst und auf Windows, macOS, Android und iOS testest. Zum Abschluss baust du eine einfache To-do-App, die dir als Ausgangspunkt für weitere Projekte dient.\n'parentId': 'dd0d8f751be8d368f2f60eb9'\n'parentDescription': Zusammen mit Microsoft MVP André Krämer lernst du Schritt für Schritt, wie du mit .NET MAUI in C# und .NET native Apps für Android, iOS, macOS und Windows aus einer einzigen Codebasis erstellst. Du gestaltest ansprechende Benutzeroberflächen mit XAML und dem MVVM-Design-Pattern, stellst Daten in Listen übersichtlich dar und navigierst dabei nahtlos zwischen verschiedenen Ansichten. Zudem erfährst du, wie du Dependency Injection effizient einsetzt und native Gerätefunktionen wie die Kamera nutzt. Das praxisorientierte Tutorial ermöglicht dir, moderne Cross-Platform-Apps eigenständig zu entwickeln.\n'indexBrandName': 'BASTA!'\n'indexSeriesName': ''\n'author': 'André Krämer'\n'chunkSource': 'text'\n'text': C-Sharp und mit .NET eine Anwendung zu schreiben für Android, iOS, macOS und Windows. Allerdings nicht auf einer geteilten Quellcode-Basis, denn wir müssten ja das UI also die Benutzeroberfläche, jedes Mal neu programmieren. Und genau da kommt .NET-MAUI ins Spiel. Bei .NET-MAUI sieht es wie folgt aus. Unser Anwendungscode ruft in der Regel jetzt einfach mal nur die .NET-MAUI-Bibliotheken auf und sagt, hey, hier würde ich gerne ein Eingabefeld positionieren und hier ein Button. Was dann passiert ist, ist, dass .NET-MAUI mit dem jeweiligen Zielplattform-SDK spricht, auf dem es gerade läuft und dann dafür sorgt, dass das native Steuerelement der Zielplattform dargestellt wird. Das bedeutet also, .NET-MAUI rendert gar nicht selber, sondern delegiert die Darstellung der Benutzeroberfläche an die Controls aus dem jeweiligen Ziel-SDK der Zielplattform. Das ist aber nicht alles, was-MAUI macht. Daneben hat es noch so paar Rapper, um zum Beispiel über ein gemeinsames Interface oder eine gemeinsame Schnittstelle auf die Hardware zuzugreifen, wie zum Beispiel die Kamera, das GPS oder Ähnliches. Natürlich muss sich diesen Weg nicht gehen. Ich habe jederzeit die Möglichkeit als Entwickler direkt auf die jeweiligen Bibliotheken des Zielbetriebssystems zuzugreifen, wenn es notwendig ist. Da verschiedene Fälle, wenn das notwendig ist. Einer ist zum Beispiel, dass es bestimmte Funktionalität gibt, die .NET-MAUI selber nicht gerappt hat und die ich jetzt aufrufen möchte. Vielleicht eine Spezialbibliothek, die es nur in einer der Plattformen gibt und deswegen mit .NET-MAUI nicht gerappt worden ist oder eben irgendetwas anderes. Wenn wir uns das Ganze jetzt einmal so im .NET Cross-Plattform-Universum ansehen, dann haben wir da ja mehrere Optionen. Wenn wir sagen, wir brauchen unheimlich viel Reichweite, dann nutzen wir in der Regel Blazor, also ein webbasiertes Framework, das kann überall dort ausgeführt werden, wo ich einen modernen Browser habe. Das sieht dann so aus, ich schreibe meine Oberflächen mit C-Sharp, mit HTML, mit der Razor-Syntax und mit CSS. Der Nachteil ist bei dieser Variante, dass ich obwohl ich eine große Breite an Zielplattformen\n'slidetext': ''\n'from': 'index'\n'score': 39.998435974121094\n'normalizedScore': 0.39998435974121094\n'beforeDatePenaltyScore': 0.39998435974121094\n\n'documentId': '535b45361ad6c9e12a423cbc'\n'chunk_id': '6876d392225e92fc1ac79d11'\n'access': 'granted'\n'part_number': 3\n'total_parts': 35\n'contentType': 'TUTORIAL'\n'title': Das ist .NET MAUI\n'parentName': Mit .NET MAUI zur erfolgreichen Cross-Platform-App\n'language': 'DE'\n'date': '2025-02-07T10:45:08.000Z'\n'abstract': In der ersten Lesson des Tutorials zeigt dir André Krämer die Grundlagen von .NET MAUI, Microsofts Framework für plattformübergreifende Apps. Du erfährst, wie du deine erste App erstellst und auf Windows, macOS, Android und iOS testest. Zum Abschluss baust du eine einfache To-do-App, die dir als Ausgangspunkt für weitere Projekte dient.\n'parentId': 'dd0d8f751be8d368f2f60eb9'\n'parentDescription': Zusammen mit Microsoft MVP André Krämer lernst du Schritt für Schritt, wie du mit .NET MAUI in C# und .NET native Apps für Android, iOS, macOS und Windows aus einer einzigen Codebasis erstellst. Du gestaltest ansprechende Benutzeroberflächen mit XAML und dem MVVM-Design-Pattern, stellst Daten in Listen übersichtlich dar und navigierst dabei nahtlos zwischen verschiedenen Ansichten. Zudem erfährst du, wie du Dependency Injection effizient einsetzt und native Gerätefunktionen wie die Kamera nutzt. Das praxisorientierte Tutorial ermöglicht dir, moderne Cross-Platform-Apps eigenständig zu entwickeln.\n'indexBrandName': 'BASTA!'\n'indexSeriesName': ''\n'author': 'André Krämer'\n'chunkSource': 'text'\n'text': Bestandteil und zwar in Form eines optionalen Workloads von .NET. Was bedeutet das? Naja, bei Xamarin war es so, das war halt ein Zusatzprodukt, was irgendwie so in diesem Microsoft Universum herumschwörbte. Es hatte seinen eigenen Releasezyklus und das ist bei MAUI jetzt eben anders. MAUI wird jedes Mal released, wenn eine neue .NET Version auf den Markt herauskommt. Bei MAUI handelt es sich wie eben schon angedeutet, um ein Cross-Plattform-Framework, mit dem ich auf Basis von .NET und C-Sharp mit einer gemeinsamen Code-Basis eine Anwendung schreiben kann, die sowohl unter Android als auch unter iOS, unter macOS und unter Windows läuft. Aber wie funktioniert das Ganze? Schauen wir uns jetzt also hier einmal im Architekturüberblick an. Ihr programmiert euren Anwendungscode und dieser kann dann, wie gesagt, unter all diesen verschiedenen Plattformen ausgeführt werden. Natürlich ist es so, dass er dort nicht direkt läuft, sondern es gibt noch ein paar Ebenen dazwischen. Ganz typisch für .NET haben wir zunächst einmal eine Laufzeitumgebung oder besser gesagt zwei. Denn unter Android, iOS und macOS wird die Mono-Laufzeitumgebung die Mono-Runtime genutzt und unter Windows ist es Win32. Direkt darüber liegt dann die Base-Class-Library, die uns Standardfunktionen liefert, wie zum Beispiel alle möglichen Klassen unter System.io oder System.Math und so weiter. Darüber gibt es jetzt wieder spezifische .NET-Implementierungen für die jeweiligen Zielbetriebssysteme. Was machen die? Die rappen zum einen das Hersteller-SDK für uns, also sämtliche Steuerelemente die wir brauchen, um eine nativaussehende App für Android, für iOS, für macOS und für Windows zu schreiben. Darüber hinaus sieht sie aber auch die Brücke, die es uns erlaubt, Anwendungen bzw. besser gesagt Bibliotheken der jeweiligen Zielplattform aufzurufen, auch wenn sie nicht direkt vom Hersteller-SDK kommen. Beispiel wäre vielleicht ein bestimmtes Software-Paket zur Ansteuerung eines Barcode-Scanners oder Ähnliches. Alleine mit dem wären wir schon in der Lage, C-Sharp und mit .NET eine Anwendung zu schreiben für Android, iOS, macOS und Windows. Allerdings nicht auf einer geteilten Quellcode-Basis, denn wir müssten ja das UI also die Benutzeroberfläche, jedes Mal neu\n'slidetext': ''\n'from': 'index'\n'score': 39.998435974121094\n'normalizedScore': 0.39998435974121094\n'beforeDatePenaltyScore': 0.39998435974121094\n\n'documentId': '535b45361ad6c9e12a423cbc'\n'chunk_id': '6876d392225e92fc1ac79d10'\n'access': 'granted'\n'part_number': 2\n'total_parts': 35\n'contentType': 'TUTORIAL'\n'title': Das ist .NET MAUI\n'parentName': Mit .NET MAUI zur erfolgreichen Cross-Platform-App\n'language': 'DE'\n'date': '2025-02-07T10:45:08.000Z'\n'abstract': In der ersten Lesson des Tutorials zeigt dir André Krämer die Grundlagen von .NET MAUI, Microsofts Framework für plattformübergreifende Apps. Du erfährst, wie du deine erste App erstellst und auf Windows, macOS, Android und iOS testest. Zum Abschluss baust du eine einfache To-do-App, die dir als Ausgangspunkt für weitere Projekte dient.\n'parentId': 'dd0d8f751be8d368f2f60eb9'\n'parentDescription': Zusammen mit Microsoft MVP André Krämer lernst du Schritt für Schritt, wie du mit .NET MAUI in C# und .NET native Apps für Android, iOS, macOS und Windows aus einer einzigen Codebasis erstellst. Du gestaltest ansprechende Benutzeroberflächen mit XAML und dem MVVM-Design-Pattern, stellst Daten in Listen übersichtlich dar und navigierst dabei nahtlos zwischen verschiedenen Ansichten. Zudem erfährst du, wie du Dependency Injection effizient einsetzt und native Gerätefunktionen wie die Kamera nutzt. Das praxisorientierte Tutorial ermöglicht dir, moderne Cross-Platform-Apps eigenständig zu entwickeln.\n'indexBrandName': 'BASTA!'\n'indexSeriesName': ''\n'author': 'André Krämer'\n'chunkSource': 'text'\n'text': Business Apps mit .NET MAUI. Außerdem haben wir uns in den letzten Monaten für unsere Kunden sehr mit dem Thema Migration von Xamarin Forms zu .NET MAUI beschäftigt und auch vieles im Blazer-Umfeld gemacht. Außerdem ist so eines meiner Herzensthemen neben der Mobile-Entwicklung das Thema Dokumenten-Automatisierung mit Take-Stacks-Control. Neben meiner Tätigkeit bei der Quality Bites engagiere mich jetzt auch schon seit vielen Jahren als Sprecher auf Konferenzen rund um das Thema .NET MAUI oder früher eben Xamarin. Ich teile mein Wissen auch gerne schriftlich in der Form von Artikeln oder auch in meinen Büchern, die ich zu Xamarin und .NET MAUI geschrieben habe. Als Anerkennung für mein Community Engagement hat Microsoft mich mittlerweile zum zwölften Mal in Folge mit dem MVP-Titel ausgezeichnet. So, damit genug der Vorrede. Im nächsten Film werden wir uns jetzt gemeinsam anschauen, was ist eigentlich .NET MAUI? Was hat es damit auf sich? Ja wie versprochen sehen wir uns jetzt einmal ein paar Grundlagen zu .NET MAUI an und verschaffen uns somit einen Überblick über die Plattform. Ja, für alle die noch gar nichts damit zu tun hatten, MAUI selbst ist der Nachfolger oder besser gesagt die Weiterentwicklung von Xamarin Forms und tritt damit kein leichtes Erbe an. Denn gerade in letzten Versionen war Xamarin doch ein grundsolides Framework von Mobile Apps mit .NET und C-Sharp zu schreiben. Xamarin hatte allerdings schon immer so einen Fokus auf Mobile und Tablet und eine der großen Änderungen oder eben Weiterentwicklungen bei .NET MAUI ist, dass man als weitere Plattform den Desktop dazu genommen hat. So aber jetzt nicht die einzige Änderung, denn das hätte vielleicht einen Versionssprung bei Xamarin gerechtfertigt, aber nicht direkt einen neuen Namen. Und die nächste große Änderung wirklich war, dass man eine komplett neue Steuerelement Architektur aufgebaut hat, die jetzt weitaus flexibler ist als das noch unter Xamarin Forms der Fall war. Ja, MAUI selbst ist jetzt auch im Gegensatz zu Xamarin fester Bestandteil und zwar in Form eines optionalen Workloads von .NET. Was bedeutet das? Naja, bei Xamarin war es so, das war halt ein Zusatzprodukt, was irgendwie so in diesem Microsoft Universum herumschwörbte. Es\n'slidetext': ''\n'from': 'index'\n'score': 39.998435974121094\n'normalizedScore': 0.39998435974121094\n'beforeDatePenaltyScore': 0.39998435974121094\n\n'documentId': '535b45361ad6c9e12a423cbc'\n'chunk_id': '6876d393225e92fc1ac79d22'\n'access': 'granted'\n'part_number': 20\n'total_parts': 35\n'contentType': 'TUTORIAL'\n'title': Das ist .NET MAUI\n'parentName': Mit .NET MAUI zur erfolgreichen Cross-Platform-App\n'language': 'DE'\n'date': '2025-02-07T10:45:08.000Z'\n'abstract': In der ersten Lesson des Tutorials zeigt dir André Krämer die Grundlagen von .NET MAUI, Microsofts Framework für plattformübergreifende Apps. Du erfährst, wie du deine erste App erstellst und auf Windows, macOS, Android und iOS testest. Zum Abschluss baust du eine einfache To-do-App, die dir als Ausgangspunkt für weitere Projekte dient.\n'parentId': 'dd0d8f751be8d368f2f60eb9'\n'parentDescription': Zusammen mit Microsoft MVP André Krämer lernst du Schritt für Schritt, wie du mit .NET MAUI in C# und .NET native Apps für Android, iOS, macOS und Windows aus einer einzigen Codebasis erstellst. Du gestaltest ansprechende Benutzeroberflächen mit XAML und dem MVVM-Design-Pattern, stellst Daten in Listen übersichtlich dar und navigierst dabei nahtlos zwischen verschiedenen Ansichten. Zudem erfährst du, wie du Dependency Injection effizient einsetzt und native Gerätefunktionen wie die Kamera nutzt. Das praxisorientierte Tutorial ermöglicht dir, moderne Cross-Platform-Apps eigenständig zu entwickeln.\n'indexBrandName': 'BASTA!'\n'indexSeriesName': ''\n'author': 'André Krämer'\n'chunkSource': 'text'\n'text': einen kleinen Augenblick dauern. Die App wird jetzt Hintergrund kompiliert und auf das Gerät deploit bzw. meinem Fall in den Emulator herein. Der Emulator hat sich schon im Hintergrund gestartet, währenddessen habe ich die Aufnahme kurz beendet und in einem kurzen Augenblick sollte jetzt auch die App auf den Emulator deploit werden und dann gestartet und da ist sie auch schon. Vom Grundverhalten sieht das ganz ähnlich aus wie eben unter Windows. Der größte Unterschied ist, wir haben einen Splash-Screen gesehen, aber ansonsten funktioniert die App hier genauso wie unter Windows auch. Ich habe also hier meinen Emulator und sehe hier genauso wieder im XAML Live Preview bzw. der Live-Vorschau, wie sich mein UI eigentlich zusammensetzt. Kann hier klicken und ich kann natürlich auch hingehen und wenn ich jetzt mal in eine Codetatel reingehe, kann ich auch hier einen Breakpoint setzen. Ich setze ihn zum Beispiel mal hier, gehe zurück in den Emulator und wenn ich jetzt eine Aktion ausführe, wird Breakpoint auch entsprechend getroffen und hier wird angehalten. So, gehen wir einmal an der Stelle weiter. Damit haben wir schon mal gesehen, wie wir das Ganze im Emulator starten können und wie wir mitbekommen haben, ist das relativ einfach. Das Ganze wird für mich automatisch angelegt, wenn ich bereits einen habe, dann kann ich ihn einfach auswählen und das starten. Wichtig ist, ihr müsst auf eurem System die Hardware Beschleunigung für die Virtualisierung aktiviert haben. ist auf modernen Betriebssystemen bzw. modernen Computern von Haus aus schon der Fall. Falls das bei euch nicht der Fall ist, müsst ihr das in Bios ändern und ihr müsst außerdem auch Hyper-V auf eurem System aktivieren, denn der Android Emulator wird über Hyper-V standardmäßig beschleunigt. Wie das funktioniert, dazu gibt es einen ganz ausführlichen Beitrag in der Microsoft Dokumentation. Ja was ist zum Emulator sonst noch zu sagen? Im Endeffekt könnt ihr hier relativ viel machen. Ihr könnt euch verschiedene Emulatoren für Android-Versionen und Bildschirmauflösungen erstellen und ihr habt auch die Möglichkeit, hier verschiedene Aktionen auszuführen. Zum Beispiel könntet ihr hier über\n'slidetext': ''\n'from': 'index'\n'score': 39.998435974121094\n'normalizedScore': 0.39998435974121094\n'beforeDatePenaltyScore': 0.39998435974121094\n\n'documentId': '535b45361ad6c9e12a423cbc'\n'chunk_id': '6876d393225e92fc1ac79d21'\n'access': 'granted'\n'part_number': 19\n'total_parts': 35\n'contentType': 'TUTORIAL'\n'title': Das ist .NET MAUI\n'parentName': Mit .NET MAUI zur erfolgreichen Cross-Platform-App\n'language': 'DE'\n'date': '2025-02-07T10:45:08.000Z'\n'abstract': In der ersten Lesson des Tutorials zeigt dir André Krämer die Grundlagen von .NET MAUI, Microsofts Framework für plattformübergreifende Apps. Du erfährst, wie du deine erste App erstellst und auf Windows, macOS, Android und iOS testest. Zum Abschluss baust du eine einfache To-do-App, die dir als Ausgangspunkt für weitere Projekte dient.\n'parentId': 'dd0d8f751be8d368f2f60eb9'\n'parentDescription': Zusammen mit Microsoft MVP André Krämer lernst du Schritt für Schritt, wie du mit .NET MAUI in C# und .NET native Apps für Android, iOS, macOS und Windows aus einer einzigen Codebasis erstellst. Du gestaltest ansprechende Benutzeroberflächen mit XAML und dem MVVM-Design-Pattern, stellst Daten in Listen übersichtlich dar und navigierst dabei nahtlos zwischen verschiedenen Ansichten. Zudem erfährst du, wie du Dependency Injection effizient einsetzt und native Gerätefunktionen wie die Kamera nutzt. Das praxisorientierte Tutorial ermöglicht dir, moderne Cross-Platform-Apps eigenständig zu entwickeln.\n'indexBrandName': 'BASTA!'\n'indexSeriesName': ''\n'author': 'André Krämer'\n'chunkSource': 'text'\n'text': Administratorkonto auf eurem Rechner haben. Ganz wichtig, habt ihr kein lokales Administratorkonto, dann könnt ihr hier diese Einstellung nicht aktivieren, müsst ihr euren Admin fragen, damit er das macht. Dann könnt ihr die Anwendung auch debuggen. Im letzten Video haben wir zusammen eine neue App angelegt und die unter Windows gestartet. Aber natürlich ist Windows nicht das einzige Betriebssystem, was von Maui unterstützt wird. Schließlich haben wir hier ja ein Cross-Platform-Framework, was auch ermöglicht, dass wir Apps unter Android, unter iOS und auf dem Mac starten können. Wie das funktioniert, das gucken wir uns jetzt hier in diesem Video an. Dazu wechsle ich erst einmal zurück zu Visual Studio. Hier in Visual Studio ist unsere App aus dem letzten Video und hier hatten wir die Möglichkeit, das Ganze hier oben über die Schaltfläche zu starten. Wenn wir jetzt unter einem anderen Betriebssystem starten möchten, zum Beispiel unter Android, dann klicke ich einfach hier auf diesen kleinen Pfeil der rechts daneben ist. Dann öffnet sich ein Menü mit allen unterstützten Betriebssystemen, unter denen wir unsere App starten können. Wir fangen mal an, nämlich mit einem Android Emulator. Wenn ich jetzt hier das Menü öffne, dann seht ihr hier, dass bereits ein Emulator von einem System angelegt wurde, nämlich der Pixel 7 Emulator. Wenn auf eurem System noch kein Emulator angelegt ist, dann steht dort einfach Android Emulator und wenn ihr dann auf diese Schaltfläche klickt, dann wird ein neuer Emulator angelegt. Das Ganze passiert in so einem Assistenten, durch den ihr durchgeführt werdet. Ihr habt auch die Möglichkeit, den Device Manager zu starten über Visual Studio und dort selber neue Geräte anzulegen. werden wir hier nicht machen, sondern ich gehe einfach mal hin und sage, ich starte das Ganze im Android Emulator. Beim ersten Klick wird erstmal nur mein aktives Debug-Ziel geändert und mit dem zweiten kann ich schlussendlich dort starten. jetzt einen kleinen Augenblick dauern. Die App wird jetzt Hintergrund kompiliert und auf das Gerät deploit bzw. meinem Fall in den Emulator herein. Der Emulator hat sich schon im Hintergrund gestartet, währenddessen\n'slidetext': ''\n'from': 'index'\n'score': 39.998435974121094\n'normalizedScore': 0.39998435974121094\n'beforeDatePenaltyScore': 0.39998435974121094\n\n'documentId': '535b45361ad6c9e12a423cbc'\n'chunk_id': '6876d393225e92fc1ac79d1e'\n'access': 'granted'\n'part_number': 16\n'total_parts': 35\n'contentType': 'TUTORIAL'\n'title': Das ist .NET MAUI\n'parentName': Mit .NET MAUI zur erfolgreichen Cross-Platform-App\n'language': 'DE'\n'date': '2025-02-07T10:45:08.000Z'\n'abstract': In der ersten Lesson des Tutorials zeigt dir André Krämer die Grundlagen von .NET MAUI, Microsofts Framework für plattformübergreifende Apps. Du erfährst, wie du deine erste App erstellst und auf Windows, macOS, Android und iOS testest. Zum Abschluss baust du eine einfache To-do-App, die dir als Ausgangspunkt für weitere Projekte dient.\n'parentId': 'dd0d8f751be8d368f2f60eb9'\n'parentDescription': Zusammen mit Microsoft MVP André Krämer lernst du Schritt für Schritt, wie du mit .NET MAUI in C# und .NET native Apps für Android, iOS, macOS und Windows aus einer einzigen Codebasis erstellst. Du gestaltest ansprechende Benutzeroberflächen mit XAML und dem MVVM-Design-Pattern, stellst Daten in Listen übersichtlich dar und navigierst dabei nahtlos zwischen verschiedenen Ansichten. Zudem erfährst du, wie du Dependency Injection effizient einsetzt und native Gerätefunktionen wie die Kamera nutzt. Das praxisorientierte Tutorial ermöglicht dir, moderne Cross-Platform-Apps eigenständig zu entwickeln.\n'indexBrandName': 'BASTA!'\n'indexSeriesName': ''\n'author': 'André Krämer'\n'chunkSource': 'text'\n'text': wir also ein bisschen XAML, falls ihr das vorher noch nicht gesehen habt nicht erschrecken. wird auch im Rahmen dieses Kurses lernen. Die steht jetzt also okay, dass wir halt hier irgendwie ein paar Elemente haben. werden untereinander dargestellt, also vertikal. Das heißt ein Bild von einem Dotnet-Bot. Dann zwei Label und ein Button. Ich würde sagen, wir starten das Ganze jetzt auch einmal, damit wir auch ein Gefühl dafür bekommen, wie das eigentlich aussieht. Standardmäßig steht hier oben jetzt Windows Machine und ich kann da raufklicken. Ich könnte darüber hinaus. Es geht nur gerade nicht, weil die Anwendung schon startet und sie debuggt. Auch hier auf diesen kleinen Pfeil klicken. Wenn ich das mache, dann kann ich auch meine Anwendung unter anderen Betriebssystemen starten. Wie das aber funktioniert, das gucken wir uns dann im nächsten Kapitel an. In diesem gucken wir uns rein die Beispelanwendung einmal unter Windows an., hier haben wir unsere Beispelanwendung. Und schaut mal her. Ich werde jetzt mal Visual Studio nach vorne nehmen. Vorher mache ich die Anwendung hier, ziehe ich die ein bisschen zusammen. Dann sehen wir ein ganz tolles Feature. sehen hier die Xamarin Live Vorschau. Schaut mal, ich habe hier meine Anwendung und die sehe ich hier nochmal. Das Tolle ist dabei, kann jetzt dieses Fenster was ich hier habe, einfach... in den Hintergrund bringe, nämlich Visual Studio in den Vordergrund hole und sehe trotzdem hier noch, was in meiner Anlehnung passiert. Das Tolle ist hier, ihr seht schon, wenn ich da drüber habe, dann kommen da so Kästen und die zeichne ich gerade nicht herein, wie ich das eben mit den roten Kästen gemacht habe, sondern die zeichnet Visual Studio hier herein. Das kann es jetzt nämlich so ein bisschen, wie man das aus der Webentwicklung in den Browser Developer Tools kennt. Ich habe hier die Möglichkeit Elemente zu markieren, darauf zu klicken und schaut mal, ich klicke jetzt hier auf den Button, dann wird er nicht ausgeführt, sondern er wird hier markiert, also heißt, ich habe immer die Möglichkeit, wenn ich auf irgendwas klicke und ich klicke jetzt mal hier\n'slidetext': ''\n'from': 'index'\n'score': 39.998435974121094\n'normalizedScore': 0.39998435974121094\n'beforeDatePenaltyScore': 0.39998435974121094\n\n'documentId': '535b45361ad6c9e12a423cbc'\n'chunk_id': '6876d393225e92fc1ac79d1d'\n'access': 'granted'\n'part_number': 15\n'total_parts': 35\n'contentType': 'TUTORIAL'\n'title': Das ist .NET MAUI\n'parentName': Mit .NET MAUI zur erfolgreichen Cross-Platform-App\n'language': 'DE'\n'date': '2025-02-07T10:45:08.000Z'\n'abstract': In der ersten Lesson des Tutorials zeigt dir André Krämer die Grundlagen von .NET MAUI, Microsofts Framework für plattformübergreifende Apps. Du erfährst, wie du deine erste App erstellst und auf Windows, macOS, Android und iOS testest. Zum Abschluss baust du eine einfache To-do-App, die dir als Ausgangspunkt für weitere Projekte dient.\n'parentId': 'dd0d8f751be8d368f2f60eb9'\n'parentDescription': Zusammen mit Microsoft MVP André Krämer lernst du Schritt für Schritt, wie du mit .NET MAUI in C# und .NET native Apps für Android, iOS, macOS und Windows aus einer einzigen Codebasis erstellst. Du gestaltest ansprechende Benutzeroberflächen mit XAML und dem MVVM-Design-Pattern, stellst Daten in Listen übersichtlich dar und navigierst dabei nahtlos zwischen verschiedenen Ansichten. Zudem erfährst du, wie du Dependency Injection effizient einsetzt und native Gerätefunktionen wie die Kamera nutzt. Das praxisorientierte Tutorial ermöglicht dir, moderne Cross-Platform-Apps eigenständig zu entwickeln.\n'indexBrandName': 'BASTA!'\n'indexSeriesName': ''\n'author': 'André Krämer'\n'chunkSource': 'text'\n'text': schon aus ASP.NET zum Beispiel kennt. Heißt also hier wird erstmal meine Anwendung gebootstrapped. In dieser Methode wird dieser Bilder erzeugt und wird hier gesagt, also alles klar, ich möchte gerne eine neue Maui-App hier erzeugen. Und zwar mit der Klasse App. Das ist dann eben hier diese App XAML, die im Maui-Ordner bzw. im Root-Ordner meine Anwendung legt. Da gucken wir gleich auch nochmal rein. Aber vorher schauen wir mal weiter an. Danach wird gesagt, also wir wollen zusätzliche Schriftarten nutzen. Standardmäßig wird ja immer die System-Schriftart in einer App verwendet. Hier kann ich aber sagen, naja es gibt hier zwei Schriftarten, die liefere ich mit meiner Anwendung aus. Und zwar sind das Open Sans Regular und Open Sans Semi-Bolt. Und die liegen hier im Resources-Fonds-Ordner. Die sehen wir hier. Und diese beiden Schriftarten die registrieren wir jetzt und geben denen einen Alias. Wie das funktioniert, das lernen wir auch noch in einem späteren Kapitel unseres Trainings hier. Ja und dann schlussendlich wird die Anwendung ja, gebaut. Beziehungsweise das Bootstrapping beendet und dann dadurch die Anwendung gestartet. Gucken wir mal in diese App XAML rein. Was steht dort drin? In der App XAML steht im Endeffekt drin, dass die Klasse App von der Basis Klasse Application erbt. Die überschreibt die Tote Create Window und die sagt wiederum, dass ein neues Fenster erzeugt wird. Und dieses Fenster zeigt die App Shell an. Die App Shell, das ist unsere ja, Navigations- oder unser Navigationsgerüst. Was bedeutet das? In der App Shell und auch das werden wir detailliert an einem späteren Zeitpunkt lernen, definieren wir, welche Menüeinträge unser Menü hat und welche Seiten dort dargestellt werden. Hier steht zum Beispiel, es gibt einen Menüeintrag, der heißt Home. Und der zeigt an die Datei Mainpage. Und Mainpage, das ist schlussendlich die Datei, wir hier sehen. Gucken wir nochmal herein. Hier sehen wir also ein bisschen XAML, falls ihr das vorher noch nicht gesehen habt nicht erschrecken. wird auch im Rahmen dieses Kurses lernen. Die steht jetzt also okay, dass wir halt hier irgendwie ein\n'slidetext': ''\n'from': 'index'\n'score': 39.998435974121094\n'normalizedScore': 0.39998435974121094\n'beforeDatePenaltyScore': 0.39998435974121094\n\n'documentId': '535b45361ad6c9e12a423cbc'\n'chunk_id': '6876d393225e92fc1ac79d1c'\n'access': 'granted'\n'part_number': 14\n'total_parts': 35\n'contentType': 'TUTORIAL'\n'title': Das ist .NET MAUI\n'parentName': Mit .NET MAUI zur erfolgreichen Cross-Platform-App\n'language': 'DE'\n'date': '2025-02-07T10:45:08.000Z'\n'abstract': In der ersten Lesson des Tutorials zeigt dir André Krämer die Grundlagen von .NET MAUI, Microsofts Framework für plattformübergreifende Apps. Du erfährst, wie du deine erste App erstellst und auf Windows, macOS, Android und iOS testest. Zum Abschluss baust du eine einfache To-do-App, die dir als Ausgangspunkt für weitere Projekte dient.\n'parentId': 'dd0d8f751be8d368f2f60eb9'\n'parentDescription': Zusammen mit Microsoft MVP André Krämer lernst du Schritt für Schritt, wie du mit .NET MAUI in C# und .NET native Apps für Android, iOS, macOS und Windows aus einer einzigen Codebasis erstellst. Du gestaltest ansprechende Benutzeroberflächen mit XAML und dem MVVM-Design-Pattern, stellst Daten in Listen übersichtlich dar und navigierst dabei nahtlos zwischen verschiedenen Ansichten. Zudem erfährst du, wie du Dependency Injection effizient einsetzt und native Gerätefunktionen wie die Kamera nutzt. Das praxisorientierte Tutorial ermöglicht dir, moderne Cross-Platform-Apps eigenständig zu entwickeln.\n'indexBrandName': 'BASTA!'\n'indexSeriesName': ''\n'author': 'André Krämer'\n'chunkSource': 'text'\n'text': die leitet dann aber nur weiter an Maui Program, CreateMauiApp. Da schauen wir gleich auch mal rein. Gucken wir aber mal, wie das weiter ausschaut unter den anderen Ordnern. Interessant erst mal, hier in diesem Unterordner Android, habe ich tatsächlich die Möglichkeit, Android-spezifische Bibliotheken aufzurufen. Das Ganze geht hier im iOS-Ordner nicht. Hier gibt es eine Klasse App Delegate, die wiederum auch von Maui Application Delegate erbt und die Methode CreateMauiApp überschreibt. Und hier kann ich halt eben iOS-Funktionen aufrufen, zum Beispiel aus dem Foundation-Namespace. Was ich hier nicht machen kann, ist sowas hier wie Using Android. Das funktioniert nicht, wird hier gar nicht erlaubt. Das ist nämlich auch eine der wichtigen Dinge, die man einfach beherrschen muss oder beherzigen muss. Es sieht so aus, dass ich plattform-spezifischen Code nur in diese Plattform- Unterordner im Standard schreiben kann. Also heißt, hier kann ich alles reinschreiben, was mit Android zu tun hat und auch Android SDKs aufrufen. Hier kann ich iOS-Bibliotheken aufrufen. Und hier für den Mac, aber eben kann ich nicht hier hingehen und hier in dem Unterordner eine Android-Bibliotheke aufrufen. Gucken wir uns das zu guter Letzt auch der Windows an. Da habe ich eine App XAML. Achtung, App XAMLs habe ich zwei in meinem Projekt, eine von Maui. Die sehen wir mal hier reingucken. Die Maui-App XAML, die sehen wir hier. Und in der Windows-Ordner habe ich meine eigene App XAML. So und das ist halt eben die Starter-Zeit einer Windows-Anwender. Gucken wir dort einmal zusammen herein. Auch hier haben wir von einer Maui-Basis-Klasse und auch hier wird wieder Create-Maui-App aufgerufen. diese Klasse Maui-Program scheint irgendwie wichtig zu sein. Deswegen würde ich sagen, gucken wir da einmal zusammen herein. So, was macht die Klasse Maui-Program? Naja, die benutzt das sogenannte Bilder-Pattern, was man auch schon aus ASP.NET zum Beispiel kennt. Heißt also hier wird erstmal meine Anwendung gebootstrapped. In dieser Methode wird dieser Bilder erzeugt und wird hier gesagt, also alles klar, ich möchte\n'slidetext': ''\n'from': 'index'\n'score': 39.998435974121094\n'normalizedScore': 0.39998435974121094\n'beforeDatePenaltyScore': 0.39998435974121094\n\n'documentId': '535b45361ad6c9e12a423cbc'\n'chunk_id': '6876d393225e92fc1ac79d1b'\n'access': 'granted'\n'part_number': 13\n'total_parts': 35\n'contentType': 'TUTORIAL'\n'title': Das ist .NET MAUI\n'parentName': Mit .NET MAUI zur erfolgreichen Cross-Platform-App\n'language': 'DE'\n'date': '2025-02-07T10:45:08.000Z'\n'abstract': In der ersten Lesson des Tutorials zeigt dir André Krämer die Grundlagen von .NET MAUI, Microsofts Framework für plattformübergreifende Apps. Du erfährst, wie du deine erste App erstellst und auf Windows, macOS, Android und iOS testest. Zum Abschluss baust du eine einfache To-do-App, die dir als Ausgangspunkt für weitere Projekte dient.\n'parentId': 'dd0d8f751be8d368f2f60eb9'\n'parentDescription': Zusammen mit Microsoft MVP André Krämer lernst du Schritt für Schritt, wie du mit .NET MAUI in C# und .NET native Apps für Android, iOS, macOS und Windows aus einer einzigen Codebasis erstellst. Du gestaltest ansprechende Benutzeroberflächen mit XAML und dem MVVM-Design-Pattern, stellst Daten in Listen übersichtlich dar und navigierst dabei nahtlos zwischen verschiedenen Ansichten. Zudem erfährst du, wie du Dependency Injection effizient einsetzt und native Gerätefunktionen wie die Kamera nutzt. Das praxisorientierte Tutorial ermöglicht dir, moderne Cross-Platform-Apps eigenständig zu entwickeln.\n'indexBrandName': 'BASTA!'\n'indexSeriesName': ''\n'author': 'André Krämer'\n'chunkSource': 'text'\n'text': Unterordner für alle Zielplattformen die wir bisher angesprochen haben. Also für Android, für iOS, für den Mac und für Windows. Und hier ist noch was drin, nämlich Tizen. Tizen gucken wir uns in diesem Training nicht an. Tizen ist ein Framework von Samsung. Das läuft dann irgendwie auf deren Smart TVs und auf deren smarten Kühlschränken. Ich habe keins von beiden bei mir zu Hause oder auch nicht im Büro. Deswegen kann ich euch das jetzt hier nicht zeigen. Wenn ihr da Interesse habt, dann ist alles, was ihr machen müsst, ihr müsst die Projektdatei öffnen. Ihr müsst das Tizen SDK installieren. Da seht ihr hier schon einen entsprechenden Link, unter dem das erklärt wird. Und danach müsst ihr noch hingehen und müsst hier das Target Framework Tizen aktivieren., aber das will ich gar nicht an der Stelle weiter mir ansehen, sondern gucken wir mal weiter an diesen Plattformsordner herein. So wie gesagt, in diesem Ordner gibt es ja Unterordner für jede Plattform. Wenn wir unter Android mal reinschauen, dann sehen wir, dass es hier eine Main Activity gibt. Das ist also eine ganz typische Datei unter Android. Unter Android programmiert man sogenannte Activities. Und diese Activity die erbt hier von Maui App Comeback Activity. Und es gibt eine Main Application. Das ist so der Haupteinsprungspunkt für so eine Android App. Und hier ist schon mal ganz spannend, diese Main Application, die erbt von Maui Application. Und Maui Application definiert eine Methode CreateMauiApp. Die kommt hier aus dieser Basis-Klasse. Und die wird hier überschrieben. Und hier wird dann entsprechend angegeben, dass bitte in der Klasse Maui Program, die finden wir hier unten, dass dort also die Methode CreateMauiApp aufgerufen wird. Heißt also, ich muss euch vorstellen, wenn so eine Mobile App startet, unser Android, dann wird hier erst mal der Haupteinsprungspunkt aufgerufen, der wird vom Betriebssystem definiert, nämlich die Maui Application bzw. Main Application. Und die leitet dann aber nur weiter an Maui Program, CreateMauiApp. Da schauen wir gleich auch mal rein. Gucken wir aber mal, wie das weiter ausschaut unter den anderen Ordnern. Interessant erst mal, hier\n'slidetext': ''\n'from': 'index'\n'score': 39.998435974121094\n'normalizedScore': 0.39998435974121094\n'beforeDatePenaltyScore': 0.39998435974121094\n\n'documentId': '535b45361ad6c9e12a423cbc'\n'chunk_id': '6876d393225e92fc1ac79d1a'\n'access': 'granted'\n'part_number': 12\n'total_parts': 35\n'contentType': 'TUTORIAL'\n'title': Das ist .NET MAUI\n'parentName': Mit .NET MAUI zur erfolgreichen Cross-Platform-App\n'language': 'DE'\n'date': '2025-02-07T10:45:08.000Z'\n'abstract': In der ersten Lesson des Tutorials zeigt dir André Krämer die Grundlagen von .NET MAUI, Microsofts Framework für plattformübergreifende Apps. Du erfährst, wie du deine erste App erstellst und auf Windows, macOS, Android und iOS testest. Zum Abschluss baust du eine einfache To-do-App, die dir als Ausgangspunkt für weitere Projekte dient.\n'parentId': 'dd0d8f751be8d368f2f60eb9'\n'parentDescription': Zusammen mit Microsoft MVP André Krämer lernst du Schritt für Schritt, wie du mit .NET MAUI in C# und .NET native Apps für Android, iOS, macOS und Windows aus einer einzigen Codebasis erstellst. Du gestaltest ansprechende Benutzeroberflächen mit XAML und dem MVVM-Design-Pattern, stellst Daten in Listen übersichtlich dar und navigierst dabei nahtlos zwischen verschiedenen Ansichten. Zudem erfährst du, wie du Dependency Injection effizient einsetzt und native Gerätefunktionen wie die Kamera nutzt. Das praxisorientierte Tutorial ermöglicht dir, moderne Cross-Platform-Apps eigenständig zu entwickeln.\n'indexBrandName': 'BASTA!'\n'indexSeriesName': ''\n'author': 'André Krämer'\n'chunkSource': 'text'\n'text': ich das hier anhake, dann bekomme ich direkt so eine kleine To-Do-App angelegt. Heißt also, ich habe keine leere App, sondern ich habe eine App mit einer Möglichkeit ja, To-Do's zu erfassen, inklusive Kategorien und so weiter. da sind schon MBWM drin, sind die Controls von Syncfusion drin, die Open-Source-Controls und so weiter. Ist wirklich toll zum Lernen. Allerdings, für den ersten Blick ist man schnell überfordert. Darum werden wir das hier nicht aus. So und jetzt klicke ich auf erstellen und muss jetzt schlussendlich einen kurzen Augenblick warten, bis mein Projekt fertig erstellt ist. So hier ist mein Projekt auch schon. Ich habe die Aufnahme pausiert, damit ihr nicht so lange warten müsst. Hat bei mir ungefähr so eine Minute gedauert, bis das Ganze angelegt war. So schauen wir einmal, was ich jetzt hier habe. Ich habe jetzt also hier eine Projektdatei. Und in dieser Projektdatei befindet sich der komplette Quellcode für meine App, die unter Android, iOS, Windows und MacOS laufen wird. Wundert euch nicht. Es gibt aktuell irgendwie ein Problem in Visual Studio, dass hier die, das noch einmal. Es gibt aktuell ein Problem in Visual Studio, dass hier das Nesting der Datei manchmal nicht so richtig funktioniert. Also hier die CS-Datei, die sich darunter genestet. Manchmal hilft das Projekt zu entladen. Ich kann das mal ganz kurz machen und danach wieder zuladen. Manchmal verschwindet es nach dem Kompilieren. Ich denke mal, Microsoft wird es irgendwann, hoffentlich wieder beheben. Also ich entlade und lade mal neu. Und ihr seht schon, das sieht viel besser aus. Jetzt haben wir hier wieder das komplette Nesting drin. Und dann werden wir auch nicht verwirrt von so vielen Dateien. Aber gucken wir uns mal an, was wir bekommen haben. Wir haben hier ein Ordner Platforms. Das ist also hier dieser Ordner. Und in diesem Ordner Platforms seht ihr schon, dort sind Unterordner für alle Zielplattformen die wir bisher angesprochen haben. Also für Android, für iOS, für den Mac und für Windows. Und hier ist noch was drin, nämlich Tizen. Tizen gucken wir uns\n'slidetext': ''\n'from': 'index'\n'score': 39.998435974121094\n'normalizedScore': 0.39998435974121094\n'beforeDatePenaltyScore': 0.39998435974121094\n\n'documentId': '535b45361ad6c9e12a423cbc'\n'chunk_id': '6876d392225e92fc1ac79d19'\n'access': 'granted'\n'part_number': 11\n'total_parts': 35\n'contentType': 'TUTORIAL'\n'title': Das ist .NET MAUI\n'parentName': Mit .NET MAUI zur erfolgreichen Cross-Platform-App\n'language': 'DE'\n'date': '2025-02-07T10:45:08.000Z'\n'abstract': In der ersten Lesson des Tutorials zeigt dir André Krämer die Grundlagen von .NET MAUI, Microsofts Framework für plattformübergreifende Apps. Du erfährst, wie du deine erste App erstellst und auf Windows, macOS, Android und iOS testest. Zum Abschluss baust du eine einfache To-do-App, die dir als Ausgangspunkt für weitere Projekte dient.\n'parentId': 'dd0d8f751be8d368f2f60eb9'\n'parentDescription': Zusammen mit Microsoft MVP André Krämer lernst du Schritt für Schritt, wie du mit .NET MAUI in C# und .NET native Apps für Android, iOS, macOS und Windows aus einer einzigen Codebasis erstellst. Du gestaltest ansprechende Benutzeroberflächen mit XAML und dem MVVM-Design-Pattern, stellst Daten in Listen übersichtlich dar und navigierst dabei nahtlos zwischen verschiedenen Ansichten. Zudem erfährst du, wie du Dependency Injection effizient einsetzt und native Gerätefunktionen wie die Kamera nutzt. Das praxisorientierte Tutorial ermöglicht dir, moderne Cross-Platform-Apps eigenständig zu entwickeln.\n'indexBrandName': 'BASTA!'\n'indexSeriesName': ''\n'author': 'André Krämer'\n'chunkSource': 'text'\n'text': Wir können uns das Leben deutlich leichter machen, indem wir hier oben, in diesem Bereich, filtern, und zwar filtern nach Maui. So, wenn ich das mache, dann wird hier diese Liste direkt um einiges kleiner. Und ihr seht hier, ich habe eine Maui-App, eine Maui-Blazer-App. Das sind diese hybriden Apps, die wir schon besprochen haben. Dann gibt es die Maui-Klassenbibliothek. Dann gibt es die Maui-Blazer-Hybrid-And-Web-App. Das ist eine hybride Maui-App, in der dann aber auch noch eine Web-Anwendung, also weiteres Projekt, angelegt worden ist, und wo sich der Code geteilt wird zwischen all diesen verschiedenen Anwendungstypen. Und dann gibt es die .NET Maui-Multi-Project-App. Die Multi-Project-App, die sieht so bisschen aus, wie das früher der Xamarin der Fall war, bedeutet, habe ich wieder je Plattform ein eigenes Projekt, das wir eigentlich bei Maui nicht mehr brauchen, weil wir jetzt hier diesen Single-Project-Ansatz haben. So, ich wähle mal hier die .NET Maui-App aus und klicke auf weiter. Als nächstes kann ich einen Ordner für meine Anwendung auswählen. Ich das jetzt hier mal unter Source-Temp gelegt. Das natürlich kein guter Ordner für eine Praxis-App, aber für diese Demo hier soll es ausreichen. Und ich gebe dem ganzen den Namen Maui-Demo-App. So, jetzt klicke ich auf weiter. Und jetzt kommen zwei wichtige Fragen. Frage Nummer eins ist, welche Framework-Versionen wollen wir verwenden? Und ich werde hier ganz bewusst .NET 9 aus. Bei der Demo hier ist es vielleicht noch nicht ganz so wichtig, aber wenn wir später in unser Praxisprojekt einsteigen, da ist es wichtig, dass ihr hier Maui 9 ausgewählt habt, bzw. .NET 9. Außerdem gibt es hier einen neuen Haken, der ist jetzt mit dem .NET 9 hinzugekommen. Und zwar werde ich gefragt, ob ich Beispiel-Inhalte, also Sample-Contact mit in mein Projekt hereinladen möchte. Und das möchte ich erst mal nicht. Wenn ich das hier anhake, dann bekomme ich direkt so eine kleine To-Do-App angelegt. Heißt also, ich habe keine leere App, sondern ich habe eine App mit einer Möglichkeit ja, To-Do's zu\n'slidetext': ''\n'from': 'index'\n'score': 39.998435974121094\n'normalizedScore': 0.39998435974121094\n'beforeDatePenaltyScore': 0.39998435974121094\n\n'documentId': '535b45361ad6c9e12a423cbc'\n'chunk_id': '6876d392225e92fc1ac79d18'\n'access': 'granted'\n'part_number': 10\n'total_parts': 35\n'contentType': 'TUTORIAL'\n'title': Das ist .NET MAUI\n'parentName': Mit .NET MAUI zur erfolgreichen Cross-Platform-App\n'language': 'DE'\n'date': '2025-02-07T10:45:08.000Z'\n'abstract': In der ersten Lesson des Tutorials zeigt dir André Krämer die Grundlagen von .NET MAUI, Microsofts Framework für plattformübergreifende Apps. Du erfährst, wie du deine erste App erstellst und auf Windows, macOS, Android und iOS testest. Zum Abschluss baust du eine einfache To-do-App, die dir als Ausgangspunkt für weitere Projekte dient.\n'parentId': 'dd0d8f751be8d368f2f60eb9'\n'parentDescription': Zusammen mit Microsoft MVP André Krämer lernst du Schritt für Schritt, wie du mit .NET MAUI in C# und .NET native Apps für Android, iOS, macOS und Windows aus einer einzigen Codebasis erstellst. Du gestaltest ansprechende Benutzeroberflächen mit XAML und dem MVVM-Design-Pattern, stellst Daten in Listen übersichtlich dar und navigierst dabei nahtlos zwischen verschiedenen Ansichten. Zudem erfährst du, wie du Dependency Injection effizient einsetzt und native Gerätefunktionen wie die Kamera nutzt. Das praxisorientierte Tutorial ermöglicht dir, moderne Cross-Platform-Apps eigenständig zu entwickeln.\n'indexBrandName': 'BASTA!'\n'indexSeriesName': ''\n'author': 'André Krämer'\n'chunkSource': 'text'\n'text': häufig auch noch die Bildschirmfreigabe zu aktivieren. Und ganz wichtig, wann immer ihr und der Visual Studio Code entwickelt, braucht ihr zwingend die .NET Maui Extension, damit ihr produktiv darin arbeiten könnt. So und damit haben wir uns eigentlich einen Überblick geschaffen. Wir haben uns einmal zusammen angeschaut, was ist eigentlich .NET Maui? Wie sieht die Architektur auf? Und was braucht ihr auf eurem Rechner, um mit der Entwicklung mit .NET Maui starten zu können? So im letzten Video, haben wir uns ja mit den Grundlagen von .NET Maui befasst. Und in diesem Video, dort wollen wir uns einmal ansehen, wie das Ganze in der Praxis aussieht. Und dazu, wenn wir jetzt gemeinsam eine kleine App anlegen. Ich werde das Ganze bei mir unter Windows durchführen. Ihr könnt es auch auf dem Mac machen, aber bei mir demonstriere ich erstmal Windows. So, schauen wir einmal auf meinen PC. Ich habe hier schon Visual Studio geöffnet. Und hier hinten seht ihr den Visual Studio Installer. Da möchte ich einmal ganz kurz reinklicken, um euch zu zeigen, was ich eigentlich bei mir unter Visual Studio installiert habe, damit ich Maui nutzen kann. Und zwar ist das hier, wie vorher schon einmal angekündigt, die .NET Multiplattform App UI-Entwicklung, die ich auswählen muss, damit ich unter Visual Studio für Maui entwickeln kann. Es empfiehlt sich außerdem, obwohl es nicht zwingend notwendig ist, auch die Entwicklung der Windows-Anwendung hier zu installieren. Das ist WinUI. Das hilft einfach manchmal, wenn man unter Windows ein paar weitere Dinge testen möchte. So, wenn ihr das gemacht habt, dann seid ihr schon startklar Falls nicht, dann öffnet bitte einmal den Installer von Visual Studio und installiert diese beiden Komponenten, gegebenenfalls noch nach. So, wie lege ich jetzt aber ein neues Projekt an? Dazu, seht ihr hier, bin ich in Visual Studio im Dialog zur Anlage eines neuen Projektes. Und hier gibt es jetzt eine ganze Menge an Projekttypen. Wir können uns das Leben deutlich leichter machen, indem wir hier oben, in diesem Bereich, filtern, und zwar filtern nach Maui. So, wenn ich das mache, dann wird hier diese Liste\n'slidetext': ''\n'from': 'index'\n'score': 39.998435974121094\n'normalizedScore': 0.39998435974121094\n'beforeDatePenaltyScore': 0.39998435974121094\n\n'documentId': '535b45361ad6c9e12a423cbc'\n'chunk_id': '6876d392225e92fc1ac79d17'\n'access': 'granted'\n'part_number': 9\n'total_parts': 35\n'contentType': 'TUTORIAL'\n'title': Das ist .NET MAUI\n'parentName': Mit .NET MAUI zur erfolgreichen Cross-Platform-App\n'language': 'DE'\n'date': '2025-02-07T10:45:08.000Z'\n'abstract': In der ersten Lesson des Tutorials zeigt dir André Krämer die Grundlagen von .NET MAUI, Microsofts Framework für plattformübergreifende Apps. Du erfährst, wie du deine erste App erstellst und auf Windows, macOS, Android und iOS testest. Zum Abschluss baust du eine einfache To-do-App, die dir als Ausgangspunkt für weitere Projekte dient.\n'parentId': 'dd0d8f751be8d368f2f60eb9'\n'parentDescription': Zusammen mit Microsoft MVP André Krämer lernst du Schritt für Schritt, wie du mit .NET MAUI in C# und .NET native Apps für Android, iOS, macOS und Windows aus einer einzigen Codebasis erstellst. Du gestaltest ansprechende Benutzeroberflächen mit XAML und dem MVVM-Design-Pattern, stellst Daten in Listen übersichtlich dar und navigierst dabei nahtlos zwischen verschiedenen Ansichten. Zudem erfährst du, wie du Dependency Injection effizient einsetzt und native Gerätefunktionen wie die Kamera nutzt. Das praxisorientierte Tutorial ermöglicht dir, moderne Cross-Platform-Apps eigenständig zu entwickeln.\n'indexBrandName': 'BASTA!'\n'indexSeriesName': ''\n'author': 'André Krämer'\n'chunkSource': 'text'\n'text': für Windows. Also also nutzt ihr ein Mac, dann könnt ihr für Mac iOS und Android entwickeln. Habt ihr ein Windows Rechner, dann könnt ihr für Android und für Windows entwickeln und natürlich auch für iOS. Wenn ich jetzt entwickeln sage, natürlich so, ihr könnt immer für alle Plattformen entwickeln, aber wenn es ans Testen geht, ans Debuggen, aber vor allem auch ans Paketieren der App, also das Deploy-Paket zu bauen, was in den Store geht, dann geht es halt nur an den hier vorgestellten Kombinationen. Als kleine Anmerkung, natürlich müsst ihr nicht zwangsläufig unter Windows Visual Studio benutzen. Ihr könnt auch dort Visual Studio Code nutzen, da gibt es eine kleine Extension zu. Dann habt ihr auf beiden Betriebssystemen die gleiche Entwicklungsumgebung. Oder ihr möchtet, könnt ihr auch sowohl unter Windows als auch unter macOS Rider von der Firma JetBrains benutzen. Auch da gibt es eine wirklich tolle Unterstützung für .NET Maui. Ja, wie installiert ihr das könnt ihr jetzt unter Windows? Das ist relativ einfach. Im besten Fall installiert ihr euch Visual Studio und dort hakt ihr dann hier die .NET Multiplattform App UI Entwicklung an und das war es schon. Den ganzen Rest bekommt ihr dann bei euch auf eurem Windows Rechner automatisch installiert. Also .NET Maui, das Android SDK und so weiter. Wenn ihr auf einem Mac entwickelt, dann müsst ihr dort .NET erstmal ganz normal über den Download von der Webseite entwickeln. Dann müsst ihr dort .NET erstmal ganz normal über die Webseite von .NET herunterladen und installieren. Und dann darüber hinaus noch eure Entwicklungsumgebungen installieren. Also Visual Studio Code oder eben Rider. Ja, wenn ihr dann noch aus dem Mac heraus unter Windows debuggen möchtet, dann empfiehlt es sich, dass ihr die Entfernte Anmeldung aktiviert. Seht ihr hier in dem Screenshot, wie das geht. Das sind die Mac OS Einstellungen dort. allgemein müsst ihr die Entfernte Anmeldung aktivieren. Und dann empfiehlt es sich häufig auch noch die Bildschirmfreigabe zu aktivieren. Und ganz wichtig, wann immer ihr und der Visual Studio Code entwickelt, braucht ihr zwingend die .NET Maui Extension, damit ihr produktiv darin arbeiten könnt.\n'slidetext': ''\n'from': 'index'\n'score': 39.998435974121094\n'normalizedScore': 0.39998435974121094\n'beforeDatePenaltyScore': 0.39998435974121094\n\n'documentId': '535b45361ad6c9e12a423cbc'\n'chunk_id': '6876d392225e92fc1ac79d15'\n'access': 'granted'\n'part_number': 7\n'total_parts': 35\n'contentType': 'TUTORIAL'\n'title': Das ist .NET MAUI\n'parentName': Mit .NET MAUI zur erfolgreichen Cross-Platform-App\n'language': 'DE'\n'date': '2025-02-07T10:45:08.000Z'\n'abstract': In der ersten Lesson des Tutorials zeigt dir André Krämer die Grundlagen von .NET MAUI, Microsofts Framework für plattformübergreifende Apps. Du erfährst, wie du deine erste App erstellst und auf Windows, macOS, Android und iOS testest. Zum Abschluss baust du eine einfache To-do-App, die dir als Ausgangspunkt für weitere Projekte dient.\n'parentId': 'dd0d8f751be8d368f2f60eb9'\n'parentDescription': Zusammen mit Microsoft MVP André Krämer lernst du Schritt für Schritt, wie du mit .NET MAUI in C# und .NET native Apps für Android, iOS, macOS und Windows aus einer einzigen Codebasis erstellst. Du gestaltest ansprechende Benutzeroberflächen mit XAML und dem MVVM-Design-Pattern, stellst Daten in Listen übersichtlich dar und navigierst dabei nahtlos zwischen verschiedenen Ansichten. Zudem erfährst du, wie du Dependency Injection effizient einsetzt und native Gerätefunktionen wie die Kamera nutzt. Das praxisorientierte Tutorial ermöglicht dir, moderne Cross-Platform-Apps eigenständig zu entwickeln.\n'indexBrandName': 'BASTA!'\n'indexSeriesName': ''\n'author': 'André Krämer'\n'chunkSource': 'text'\n'text': Der ist verhältnismäßig kurz. Das waren hier nur wenige Monate an der Stelle. Gucken wir wie das bei .NET 7 aussieht. Bei .NET 7 sind das 18 Monate. Das ist ja auch normal, weil 18 Monate ist genau die Supportdauer, die die ungeraden, also die STS oder Standard-Term-Version von .NET ja bekommen. Werfen wir einen Blick auf .NET 8, dann fällt auf, dass der Balken von 7 und 8 hier im Support gleich lang ist. Weil unter .NET 8, obwohl das eine LTS-Version ist, also eine Long-Term-Support-Version von .NET, die eigentlich drei Jahre Support bekommt, ist das bei MAUI nicht der Fall. Bei MAUI bekomme ich immer nur 18 Monate Support für jede Version. Und der Grund, warum der Balken von MAUI 6 so kurz ist, liegt daran, dass auch wenn MAUI 6 später, und zwar ein halbes Jahr später, als .NET 6 herauskam, man von dem Release von .NET 6 was dann ja im November 2021 war, 18 Monate gerechnet hat. So warum ist das jetzt so, dass wir hier eine kürzere Supportdauer haben, als das bei .NET normalerweise der Fall ist vor allem bei den LTS-Versionen? Das liegt ganz einfach daran, dass das MAUI-Team ja einige Abhängigkeiten hat, die das .NET-Team nicht hat. Es gibt Abhängigkeiten an die SDKs von Android und von iOS und natürlich auch von Windows. Jedes Mal, wenn dort eines der Teams etwas ändert, muss das MAUI-Team nachziehen. Wenn wir uns jetzt vorstellen, wir hätten jetzt hier drei Jahre Support, dann würde das ja bedeuten, dass ich immer drei parallele Versionen im gleichzeitigem Support habe. Das bedeutet, immer wenn sich etwas in einem der SDKs ändert, müssen drei Versionen aktualisiert werden. Und da würde das MAUI-Team einfach nicht mehr hinterherkommen. Und deswegen gibt es hier einfach nur 18 Monate Support. Kleiner Tipp aus der Praxis, am besten geht ihr hin und datet relativ fix ab. Wir es bei der Quality-Beilse wirklich so gehalten, wir gesagt haben, wir sind sogar schon zum Release-Candidate von .NET 8 auf MAUI 8 gegangen, einfach die Qualität besser war als bei 7 und auch bei 9 sehr schnell gewechselt. Die neuen Features sind in Regel so gut, es\n'slidetext': ''\n'from': 'index'\n'score': 39.998435974121094\n'normalizedScore': 0.39998435974121094\n'beforeDatePenaltyScore': 0.39998435974121094\n\n'documentId': '535b45361ad6c9e12a423cbc'\n'chunk_id': '6876d392225e92fc1ac79d14'\n'access': 'granted'\n'part_number': 6\n'total_parts': 35\n'contentType': 'TUTORIAL'\n'title': Das ist .NET MAUI\n'parentName': Mit .NET MAUI zur erfolgreichen Cross-Platform-App\n'language': 'DE'\n'date': '2025-02-07T10:45:08.000Z'\n'abstract': In der ersten Lesson des Tutorials zeigt dir André Krämer die Grundlagen von .NET MAUI, Microsofts Framework für plattformübergreifende Apps. Du erfährst, wie du deine erste App erstellst und auf Windows, macOS, Android und iOS testest. Zum Abschluss baust du eine einfache To-do-App, die dir als Ausgangspunkt für weitere Projekte dient.\n'parentId': 'dd0d8f751be8d368f2f60eb9'\n'parentDescription': Zusammen mit Microsoft MVP André Krämer lernst du Schritt für Schritt, wie du mit .NET MAUI in C# und .NET native Apps für Android, iOS, macOS und Windows aus einer einzigen Codebasis erstellst. Du gestaltest ansprechende Benutzeroberflächen mit XAML und dem MVVM-Design-Pattern, stellst Daten in Listen übersichtlich dar und navigierst dabei nahtlos zwischen verschiedenen Ansichten. Zudem erfährst du, wie du Dependency Injection effizient einsetzt und native Gerätefunktionen wie die Kamera nutzt. Das praxisorientierte Tutorial ermöglicht dir, moderne Cross-Platform-Apps eigenständig zu entwickeln.\n'indexBrandName': 'BASTA!'\n'indexSeriesName': ''\n'author': 'André Krämer'\n'chunkSource': 'text'\n'text': einfach nur eine hybride App rappt. Tja, wo benutze ich jetzt welche der Optionen Wie gesagt, Blazor immer dann, wenn ich sage, ich will auf alle Plattformen inklusive Linux und es soll eine Webanwendung sein. MAUI, wenn ich sage, ich brauche die Tiefe und Linux ist mir nicht so wichtig. Und ich habe schon ein Team, C Sharp und vielleicht auch XAML kann, weil man vorher mal WPF gemacht hat. Oder auch Silverlight. Ganz klar, der XAML Dialekt von WPF und MAUI der unterscheidet sich. Aber das sind kleinere Änderungen, die man relativ schnell lernen kann. Ja und wann nutze ich das in der Mitte? Blazor und dort mit MAUI. Das benutze ich immer dann, wenn ich in die Tiefe möchte. Aber vielleicht ein Team habe, was bisher sehr gut Webentwicklung kann, aber noch nie im Leben XAML gemacht hat. Oder aber das finde ich ein sehr interessanter Anwendungsfall, wenn ich sage, naja, ich möchte gerne Code schreiben, den ich im Web wieder verwenden kann. Den ich auf dem Desktop wieder verwenden kann und in einer App. Das kann dann nämlich eine Razer Komponente sein, die ich an all diesen Plattformen wieder verwenden kann. So nachdem wir jetzt wissen, wo MAUI einzuordnen ist, lasst uns mal kurz darauf gucken, ja seit wann es MAUI gibt und wie da so die Zukunft aussieht. Also MAUI selbst kam irgendwann im Mai 2022 heraus und zwar als etwas verspäteter Teil von .NET 6. Im November 2022 kam dann mit .NET 7 die nächste Version raus. Ab da waren wir im normalen Produktzyklus. Heißt also, danach ging es weiter mit .NET 8 im November 2023 und dann mit .NET MAUI und .NET 9 im November 2024. Wenn wir jetzt einen Blick auf die Supportlebenszeiten gucken, also auf die Supportdauern, dann sehen wir etwas was so bisschen eigenartig aussieht. zwar seht ihr schon, der Balken dieser hellblaue Balken unten, der zeigt, wann das Support von .NET MAUI 6 endete. Der ist verhältnismäßig kurz. Das waren hier nur wenige Monate an der Stelle. Gucken wir wie das bei .NET 7 aussieht. Bei .NET 7 sind das 18 Monate. Das ist ja auch normal, weil 18\n'slidetext': ''\n'from': 'index'\n'score': 39.998435974121094\n'normalizedScore': 0.39998435974121094\n'beforeDatePenaltyScore': 0.39998435974121094\n\n'documentId': '535b45361ad6c9e12a423cbc'\n'chunk_id': '6876d395225e92fc1ac79d2f'\n'access': 'granted'\n'part_number': 33\n'total_parts': 35\n'contentType': 'TUTORIAL'\n'title': Das ist .NET MAUI\n'parentName': Mit .NET MAUI zur erfolgreichen Cross-Platform-App\n'language': 'DE'\n'date': '2025-02-07T10:45:08.000Z'\n'abstract': In der ersten Lesson des Tutorials zeigt dir André Krämer die Grundlagen von .NET MAUI, Microsofts Framework für plattformübergreifende Apps. Du erfährst, wie du deine erste App erstellst und auf Windows, macOS, Android und iOS testest. Zum Abschluss baust du eine einfache To-do-App, die dir als Ausgangspunkt für weitere Projekte dient.\n'parentId': 'dd0d8f751be8d368f2f60eb9'\n'parentDescription': Zusammen mit Microsoft MVP André Krämer lernst du Schritt für Schritt, wie du mit .NET MAUI in C# und .NET native Apps für Android, iOS, macOS und Windows aus einer einzigen Codebasis erstellst. Du gestaltest ansprechende Benutzeroberflächen mit XAML und dem MVVM-Design-Pattern, stellst Daten in Listen übersichtlich dar und navigierst dabei nahtlos zwischen verschiedenen Ansichten. Zudem erfährst du, wie du Dependency Injection effizient einsetzt und native Gerätefunktionen wie die Kamera nutzt. Das praxisorientierte Tutorial ermöglicht dir, moderne Cross-Platform-Apps eigenständig zu entwickeln.\n'indexBrandName': 'BASTA!'\n'indexSeriesName': ''\n'author': 'André Krämer'\n'chunkSource': 'text'\n'text': eine weitere Steuerelement- Bibliothek genutzt wird, nämlich die Controls von Syncfusion. sind diese ganzen Sachen, hier mit SF anfangen. Syncfusion, ist ein eigentlich kommerzieller Komponentenhersteller, die haben sich aber dazu entschieden, einen Teil ihrer Komponenten Open Source zu machen und diese somit kostenfrei zur Verfügung zu stellen. Und die werden hier auch durchgängig genutzt, zum Beispiel für dieses Chart-Control, was wir eben gesehen haben. So, was haben wir hier noch? An der Stelle, gucken wir mal kurz weiter, wir haben neben diesen Pages, haben wir auch sogenannte Page Models. Page Models, das sind im Endeffekt View Models, die für unsere App genutzt werden. Da wird also das MVVM-Muster, das Model View View Model Muster verwendet. Wie das Ganze im Detail funktioniert, das lernt ihr noch in einer späteren Lektion. hier soll es erst mal reichen dass ihr wisst,, hier wird das Model View View Model Muster genutzt und das Ganze wird halt hier Page Models statt View Models genutzt. Zum Einsatz kommt hier übrigens dann auch das CommunityToolkit.mvvm. sehen wir hier, wenn wir uns mal die NuGet-Pakete anschauen. Und das CommunityToolkit.mvvm, ist so ein leichtgewichtiges Model View View Model Framework, was uns so bisschen Boilerplate-Code abnimmt. Hier ist der Verweis drin. Wir sehen außerdem das CommunityToolkit.maui das ist auch so eine Open Source Bibliothek, wenn wir auch in einer späteren Lektion nutzen, die es uns ermöglicht, Standardaufgaben schneller und effizient zu erledigen. Was haben wir noch hier an spannenden Sachen drin? Wir sehen hier SQLite hier wird also auch eine lokale Datenbank zugegriffen und wir sehen hier eben das Syncfusion.maui Toolkit. Den Zug auf die Datenbank, den sehen wir hier in diesem Ordner Data zum Beispiel. gibt es ja Repositories und hier ist dann genau beschrieben, wie ich auf so einer Datenbank zugreifen kann. kann euch nur empfehlen, startet mal noch einmal. Ich kann euch nur empfehlen legt mal genau so eine App an, wie ich das gerade gemacht habe. Also setzt diesen Haken, dass die Beispieldaten mit ins Projekt herein sollen und guckt euch mal an, wie Microsoft das Ganze hier eigentlich gelöst hat, dann\n'slidetext': ''\n'from': 'index'\n'score': 39.998435974121094\n'normalizedScore': 0.39998435974121094\n'beforeDatePenaltyScore': 0.39998435974121094\n\n'documentId': '535b45361ad6c9e12a423cbc'\n'chunk_id': '6876d395225e92fc1ac79d2e'\n'access': 'granted'\n'part_number': 32\n'total_parts': 35\n'contentType': 'TUTORIAL'\n'title': Das ist .NET MAUI\n'parentName': Mit .NET MAUI zur erfolgreichen Cross-Platform-App\n'language': 'DE'\n'date': '2025-02-07T10:45:08.000Z'\n'abstract': In der ersten Lesson des Tutorials zeigt dir André Krämer die Grundlagen von .NET MAUI, Microsofts Framework für plattformübergreifende Apps. Du erfährst, wie du deine erste App erstellst und auf Windows, macOS, Android und iOS testest. Zum Abschluss baust du eine einfache To-do-App, die dir als Ausgangspunkt für weitere Projekte dient.\n'parentId': 'dd0d8f751be8d368f2f60eb9'\n'parentDescription': Zusammen mit Microsoft MVP André Krämer lernst du Schritt für Schritt, wie du mit .NET MAUI in C# und .NET native Apps für Android, iOS, macOS und Windows aus einer einzigen Codebasis erstellst. Du gestaltest ansprechende Benutzeroberflächen mit XAML und dem MVVM-Design-Pattern, stellst Daten in Listen übersichtlich dar und navigierst dabei nahtlos zwischen verschiedenen Ansichten. Zudem erfährst du, wie du Dependency Injection effizient einsetzt und native Gerätefunktionen wie die Kamera nutzt. Das praxisorientierte Tutorial ermöglicht dir, moderne Cross-Platform-Apps eigenständig zu entwickeln.\n'indexBrandName': 'BASTA!'\n'indexSeriesName': ''\n'author': 'André Krämer'\n'chunkSource': 'text'\n'text': haben. Kann ich öffnen, die kann ich jetzt wieder löschen, wenn ich das möchte. Ich kann sie bearbeiten, ich kann zurück navigieren. Was kann ich in der Anwendung noch machen? Ich kann zum einen hingehen und kann hier meine Projekte verwalten, indem ich im Menü auf Projects klicke. Könnte zu .NET MAUI und kann jetzt hier sagen, das ist Arbeit, kann ein Icon hinterlegen und hier jetzt noch paar Tags hinzufügen. Ich speichere das Ganze mal und gehe wieder zurück. kann ich noch machen? Ich kann jetzt zwischen dem Dark und dem Light Mode in meine App wechseln und ich kann auch hier hingehen und kann Kategorien neu anlegen, den Farben geben und so weiter. So, hier sehen wir jetzt die App auch entsprechend im Light Mode und jetzt könnte ich auch hier zu meinem Projekt, was wir jetzt hier drüben sehen, neue Tasken anlegen. Das möchte ich aber gar nicht machen, sondern ich will euch mal zeigen, wie ist das Ganze eigentlich so aufgebaut. Denn die App die sieht auf den ersten Blick schon echt gut aus. So, dazu wechseln wir einmal zurück in Visual Studio und hier sehen wir jetzt eine Struktur, die ein bisschen umfangreicher ist als bei der einfachen. So, was wir wieder haben, ist hier im rechten Bereich, der Bereich des Plattforms Ordners. Wir haben Resources und wir haben hier unten auch wieder unsere App XAML, unsere App Shell XAML und die MAUI Program CS. Ja was wir nicht mehr haben, ist die Mainpage, denn die Seiten, finden sich jetzt hier in dem Unterordner Pages. Schauen wir mal da rein. Hier sehen wir also, dass jetzt hier die Mainpage entsprechend hinterlegt ist und bei einem Doppelklick darauf öffnet sich das Ganze. Ihr seht schon, das Markup ist ein bisschen umfangreicher als das, was in unserer einfachen App stand. Das liegt unter anderem daran, dass wir hier natürlich ein weitaus komplexeres Layout haben, aber es liegt auch daran, dass hier noch eine weitere Steuerelement- Bibliothek genutzt wird, nämlich die Controls von Syncfusion. sind diese ganzen Sachen, hier mit SF anfangen. Syncfusion, ist ein eigentlich kommerzieller Komponentenhersteller, die haben sich aber\n'slidetext': ''\n'from': 'index'\n'score': 39.998435974121094\n'normalizedScore': 0.39998435974121094\n'beforeDatePenaltyScore': 0.39998435974121094\n\n'documentId': '535b45361ad6c9e12a423cbc'\n'chunk_id': '6876d395225e92fc1ac79d2c'\n'access': 'granted'\n'part_number': 30\n'total_parts': 35\n'contentType': 'TUTORIAL'\n'title': Das ist .NET MAUI\n'parentName': Mit .NET MAUI zur erfolgreichen Cross-Platform-App\n'language': 'DE'\n'date': '2025-02-07T10:45:08.000Z'\n'abstract': In der ersten Lesson des Tutorials zeigt dir André Krämer die Grundlagen von .NET MAUI, Microsofts Framework für plattformübergreifende Apps. Du erfährst, wie du deine erste App erstellst und auf Windows, macOS, Android und iOS testest. Zum Abschluss baust du eine einfache To-do-App, die dir als Ausgangspunkt für weitere Projekte dient.\n'parentId': 'dd0d8f751be8d368f2f60eb9'\n'parentDescription': Zusammen mit Microsoft MVP André Krämer lernst du Schritt für Schritt, wie du mit .NET MAUI in C# und .NET native Apps für Android, iOS, macOS und Windows aus einer einzigen Codebasis erstellst. Du gestaltest ansprechende Benutzeroberflächen mit XAML und dem MVVM-Design-Pattern, stellst Daten in Listen übersichtlich dar und navigierst dabei nahtlos zwischen verschiedenen Ansichten. Zudem erfährst du, wie du Dependency Injection effizient einsetzt und native Gerätefunktionen wie die Kamera nutzt. Das praxisorientierte Tutorial ermöglicht dir, moderne Cross-Platform-Apps eigenständig zu entwickeln.\n'indexBrandName': 'BASTA!'\n'indexSeriesName': ''\n'author': 'André Krämer'\n'chunkSource': 'text'\n'text': schnell zu starten und das Layout zu prüfen, zu gucken, ob alles gut ausschaut. Denn ich kann ja auch Folgendes machen, ich habe hier auch Hard Reload, das Ganze kennt ihr vielleicht von anderen .NET Plattformen heißt also ich kann ja auch hier hingehen und kann entsprechend meinen Text hier ändern. Kannst euch mal schreiben, welcome to Entwickler.de, zieh das hier raus und dann seht ihr auch, dass hier mein UI direkt akkreditiert wird und für solche Dinge ist Hard Restart super, heißt ich verbinde das mal schnell mit meinem Gerät, starte die App da drauf und kann dann das Layout anpassen. Wie gesagt, aber es eignet sich nicht fürs Paketieren. Ja und damit sind wir durch, heißt also, haben gesehen, dass wir den gleichen Quellcode auf Windows, auf Android, in Simulatoren, auf Remote-Geräten, auf Lokalgeräten und das war alles problemlos mit .NET Maui möglich und da sieht man auch schon direkt die entsprechende, noch einmal oder sieht man auch wirklich direkt, was wirklich mit Maui alles möglich ist, denn mit einem Quellcode war ich in der Lage, all diese Plattformen zu gehen. Im Verlauf dieser Lektion haben wir gelernt, was .NET Maui eigentlich ist und wir haben zusammen eine erste einfache kleine App angelegt. Diese App die bestand nur aus einer einzelnen Bildschirmmaske und wir haben gesehen, wie wir das auf verschiedenen Betriebssystemen starten können. Seit der Version 9 von .NET Maui haben wir bei der Projektanlage die Möglichkeit, neben einer einfachen App auch schon so eine vorkonfigurierte App, das ist so eine kleine To-Do-App anzulegen und der Hintergrund davon ist, dass Microsoft zeigen wollte, was sind eigentlich best practices oder gängige Muster, um eine mobile App zu schreiben. Wie wir jetzt genau dieses Beispielprojekt anlegen, was dann ein bisschen umfangreich ist, das zeige ich euch jetzt. Dazu wechseln wir noch einmal zurück auf meinen Windows PC und befinden uns hier in Visual Studio. Ich lege also ein neues Projekt an und das Ganze kennt ihr schon. Ich werde hier oben die Maui auch hier klicke ich wieder auf weiter. Achtet darauf, dass hier .NET 9 ausgewählt\n'slidetext': ''\n'from': 'index'\n'score': 39.998435974121094\n'normalizedScore': 0.39998435974121094\n'beforeDatePenaltyScore': 0.39998435974121094\n\n'documentId': '535b45361ad6c9e12a423cbc'\n'chunk_id': '6876d394225e92fc1ac79d2b'\n'access': 'granted'\n'part_number': 29\n'total_parts': 35\n'contentType': 'TUTORIAL'\n'title': Das ist .NET MAUI\n'parentName': Mit .NET MAUI zur erfolgreichen Cross-Platform-App\n'language': 'DE'\n'date': '2025-02-07T10:45:08.000Z'\n'abstract': In der ersten Lesson des Tutorials zeigt dir André Krämer die Grundlagen von .NET MAUI, Microsofts Framework für plattformübergreifende Apps. Du erfährst, wie du deine erste App erstellst und auf Windows, macOS, Android und iOS testest. Zum Abschluss baust du eine einfache To-do-App, die dir als Ausgangspunkt für weitere Projekte dient.\n'parentId': 'dd0d8f751be8d368f2f60eb9'\n'parentDescription': Zusammen mit Microsoft MVP André Krämer lernst du Schritt für Schritt, wie du mit .NET MAUI in C# und .NET native Apps für Android, iOS, macOS und Windows aus einer einzigen Codebasis erstellst. Du gestaltest ansprechende Benutzeroberflächen mit XAML und dem MVVM-Design-Pattern, stellst Daten in Listen übersichtlich dar und navigierst dabei nahtlos zwischen verschiedenen Ansichten. Zudem erfährst du, wie du Dependency Injection effizient einsetzt und native Gerätefunktionen wie die Kamera nutzt. Das praxisorientierte Tutorial ermöglicht dir, moderne Cross-Platform-Apps eigenständig zu entwickeln.\n'indexBrandName': 'BASTA!'\n'indexSeriesName': ''\n'author': 'André Krämer'\n'chunkSource': 'text'\n'text': dann werde ich aufgefordert iTunes auf meinem Rechner zu installieren. Ich werde aufgefordert, ich habe mein Apple Developer Konto unterlege, so ich habe irgendwas gerade nicht funktioniert, ihr seht schon, steht der Objektverweis wurde nicht auf einer Objektinstanz festgelegt. Schauen wir nochmal, was hier los ist. Manchmal muss man einfach nochmal abziehen und nochmal Einstecken. So jetzt hat es auch erkannt, eben stand hier nämlich noch lokales Gerät, steht hier Andres, iPhone, ja dauert manchmal ein Augenblickchen, aber es hat kein Problem und drücken wir hier nochmal auf Play und dann werden wir gleich sehen, dass die Anwendung auf meinem iPhone gestartet wird. Sobald das soweit ist, werde ich auch meinen Bildschirm wieder hier über Reflektor teilen, dann könnt ihr das auch entsprechend Sehen. Da ist schon mal die Reflektor App und die App kann ich jetzt gleich starten und dann zeige ich auch hier den Bildschirm wieder. So hier seht ihr jetzt schon eine kleine Besonderheit. Im Endeffekt kommt hier von hier steht, ich soll die App auf meinem iPhone starten und das mache ich auch einmal, denn erst, ich das gemacht habe, dann kann die hier gedebugt werden. Das ist so ein kleiner Unterschied zu dem, wir eben gesehen haben als das direkt am Mac verbunden war da wird die App automatisch gestartet, habe ich es unter Windows aktiviert, noch einmal habe ich es unter Windows verbunden, dann muss ich die App selber starten. Die Funktion, die das Ganze ermöglicht, die nennt sich übrigens Hard to restart und jetzt so ein paar Einschränkungen. Also Punkt Nummer eins ist es ist nur zum Debuggen, es ist nicht dafür da, dass ich die App hier paketieren und in eine Store bringen kann. Der nächste Punkt ist, ich kann nicht auf sämtliche Hardware-Dinge auf meinem Gerät zugreifen, es werden auch zum Beispiel keine Push Notifications unterstützt, sondern diese Funktion, die nutze ich persönlich hauptsächlich dazu, um die App mal schnell zu starten und das Layout zu prüfen, zu gucken, ob alles gut ausschaut. Denn ich kann ja auch Folgendes machen, ich habe hier auch Hard Reload, das Ganze kennt ihr vielleicht von anderen\n'slidetext': ''\n'from': 'index'\n'score': 39.998435974121094\n'normalizedScore': 0.39998435974121094\n'beforeDatePenaltyScore': 0.39998435974121094\n\n'documentId': '535b45361ad6c9e12a423cbc'\n'chunk_id': '6876d394225e92fc1ac79d2a'\n'access': 'granted'\n'part_number': 28\n'total_parts': 35\n'contentType': 'TUTORIAL'\n'title': Das ist .NET MAUI\n'parentName': Mit .NET MAUI zur erfolgreichen Cross-Platform-App\n'language': 'DE'\n'date': '2025-02-07T10:45:08.000Z'\n'abstract': In der ersten Lesson des Tutorials zeigt dir André Krämer die Grundlagen von .NET MAUI, Microsofts Framework für plattformübergreifende Apps. Du erfährst, wie du deine erste App erstellst und auf Windows, macOS, Android und iOS testest. Zum Abschluss baust du eine einfache To-do-App, die dir als Ausgangspunkt für weitere Projekte dient.\n'parentId': 'dd0d8f751be8d368f2f60eb9'\n'parentDescription': Zusammen mit Microsoft MVP André Krämer lernst du Schritt für Schritt, wie du mit .NET MAUI in C# und .NET native Apps für Android, iOS, macOS und Windows aus einer einzigen Codebasis erstellst. Du gestaltest ansprechende Benutzeroberflächen mit XAML und dem MVVM-Design-Pattern, stellst Daten in Listen übersichtlich dar und navigierst dabei nahtlos zwischen verschiedenen Ansichten. Zudem erfährst du, wie du Dependency Injection effizient einsetzt und native Gerätefunktionen wie die Kamera nutzt. Das praxisorientierte Tutorial ermöglicht dir, moderne Cross-Platform-Apps eigenständig zu entwickeln.\n'indexBrandName': 'BASTA!'\n'indexSeriesName': ''\n'author': 'André Krämer'\n'chunkSource': 'text'\n'text': es wie unter allen anderen Systemen auch. Ich kann hier wieder auf den Simulator klicken und dann wird hier mein Breakpoint entsprechend getroffen und ich kann jetzt hier auch weiter klicken. Meine App aktualisiert sich und ist auch hier ganz normal benutzbar. So, jetzt fehlt eigentlich nur noch ein letzter Trick und zwar bisher mal gesehen, ich brauchte ja diesen Mac, um sowohl mein iPhone am Mac zu anzuschließen und von dort aus die App zu starten oder um den Simulator über den Mac zu starten oder eben auch um auf dem Mac selber das Ganze zu starten. Und um diesen Mac komme ich, wenn ich für iOS entwickeln möchte, also fürs iPhone oder für das iPad oder eben auch für Mac OS, dann komme ich um diesen Mac nicht herum. Das ist eine Limitation von Apple, die besagt, so eine App, die in den App Store kommt, die muss mit dem offiziellen iOS SDK kompiliert werden und das bekomme ich nur über Xcode. Dann braucht ihr auch Xcode auf dem Rechner und Xcode kann ich halt eben nur auf einem Mac installieren. Es gibt aber einen Trick und zwar, wenn ihr auf eurem Windows Rechner iTunes installiert habt und ihr eine bezahlte Mitgliedschaft im Apple Developer Konto habt, die kostet so rund 100 Euro pro Jahr und ihr diese Mitgliedschaft auch in Studio hinterlegt habt, wie das geht, das zeige ich euch jetzt gleich, dann könnt ihr tatsächlich hingehen und Folgendes machen. Ihr könnt hier euer Gerät nehmen, ich habe das gerade mal abgezogen und gehe jetzt hin und werde das jetzt hier einmal auf noch einmal und werde das hier jetzt einmal an meinem Windows Rechner anschließen. Und dann machen wir einmal Folgendes, Stoppe hier die Anwendung und wähle jetzt lokale iOS Geräte aus. Nachdem ich das gemacht habe, drücke ich hier auf Play und muss jetzt einen kurzen Augenblick wieder warten und werde gleich die App auf meinem iPhone starten können. Wenn ich das übrigens zum ersten Mal mache, dann werde ich aufgefordert iTunes auf meinem Rechner zu installieren. Ich werde aufgefordert, ich habe mein Apple Developer Konto unterlege, so ich habe irgendwas gerade nicht funktioniert, ihr seht schon, steht der\n'slidetext': ''\n'from': 'index'\n'score': 39.998435974121094\n'normalizedScore': 0.39998435974121094\n'beforeDatePenaltyScore': 0.39998435974121094\n\n'documentId': '535b45361ad6c9e12a423cbc'\n'chunk_id': '6876d394225e92fc1ac79d29'\n'access': 'granted'\n'part_number': 27\n'total_parts': 35\n'contentType': 'TUTORIAL'\n'title': Das ist .NET MAUI\n'parentName': Mit .NET MAUI zur erfolgreichen Cross-Platform-App\n'language': 'DE'\n'date': '2025-02-07T10:45:08.000Z'\n'abstract': In der ersten Lesson des Tutorials zeigt dir André Krämer die Grundlagen von .NET MAUI, Microsofts Framework für plattformübergreifende Apps. Du erfährst, wie du deine erste App erstellst und auf Windows, macOS, Android und iOS testest. Zum Abschluss baust du eine einfache To-do-App, die dir als Ausgangspunkt für weitere Projekte dient.\n'parentId': 'dd0d8f751be8d368f2f60eb9'\n'parentDescription': Zusammen mit Microsoft MVP André Krämer lernst du Schritt für Schritt, wie du mit .NET MAUI in C# und .NET native Apps für Android, iOS, macOS und Windows aus einer einzigen Codebasis erstellst. Du gestaltest ansprechende Benutzeroberflächen mit XAML und dem MVVM-Design-Pattern, stellst Daten in Listen übersichtlich dar und navigierst dabei nahtlos zwischen verschiedenen Ansichten. Zudem erfährst du, wie du Dependency Injection effizient einsetzt und native Gerätefunktionen wie die Kamera nutzt. Das praxisorientierte Tutorial ermöglicht dir, moderne Cross-Platform-Apps eigenständig zu entwickeln.\n'indexBrandName': 'BASTA!'\n'indexSeriesName': ''\n'author': 'André Krämer'\n'chunkSource': 'text'\n'text': Starte. Da ist meine App und damit haben wir jetzt auch das letzte Betriebssystem abgehakt. Also wir haben gesehen, dass das Ganze unter Windows gestartet werden kann, unter Android im Emulator auf einem echten Gerät, dann auf einem echten angeschlossenen iOS Gerät und jetzt schlussendlich auf dem Mac. Eine Sache die habe ich bisher so bisschen verschwiegen, nämlich ich kann natürlich das Ganze auch in einem iPhone Simulator starten. Wie funktioniert das? Auch hier wechsle ich einfach einmal zurück auf meinen Windows Rechner kurz und dann gucken wir das Ganze in Visual Studio einmal An. Hier sind wir jetzt zurück in Visual Studio und was ich jetzt hier machen muss, um das Ganze in einem Simulator zu starten, ist ich wähle hier wieder das Menü aus, gehe auf iOS Simulatoren, jetzt wähle ich hier meinen Simulator aus. Ihr seht schon, auf meinem Rechner waren einige Simulatoren schon in Benutzung. Ich nutze jetzt hier einfach mal den iPhone 16 Simulator und dann kann ich das Ganze starten. Wichtig hier auch wieder, ich brauche die Verbindung auf dem Mac, denn der Simulator wird remote auf meinem Mac gestartet und dann per Bildschirmübertragung also per Screen Mirroring auf meinen Windows Rechner angezeigt. Das Ganze dauert auch wieder einen kurzen Augenblick, aber in wenigen Sekunden sollte der Simulator hier gestartet werden und dann auch sichtbar Sein. Da wird der Simulator auch schon im Hintergrund gestartet. Hier sehen wir ihn, es dauert jetzt nach dem Start noch mal einen kleinen Augenblick und dann ist die App auch hier ausführbar. Die wird jetzt zunächst einmal auf den Simulator drauf deployed und da dann auch gleich Gestartet. Hier übrigens nicht wundern, standardmäßig wenn eure App nicht signiert ist, wird mittlerweile kein Splash Screen mehr angezeigt. Sobald ihr aber einen Codesigning Zertifikat hinterlegt habt, bekommt ihr wieder den Splash Screen angezeigt. Der wird jetzt hier gerade eben noch nicht dargestellt. Auch hier funktioniert es wie unter allen anderen Systemen auch. Ich kann hier wieder auf den Simulator klicken und dann wird hier mein Breakpoint entsprechend getroffen und ich kann jetzt hier auch weiter klicken. Meine App aktualisiert\n'slidetext': ''\n'from': 'index'\n'score': 39.998435974121094\n'normalizedScore': 0.39998435974121094\n'beforeDatePenaltyScore': 0.39998435974121094\n\n'documentId': '535b45361ad6c9e12a423cbc'\n'chunk_id': '6876d394225e92fc1ac79d28'\n'access': 'granted'\n'part_number': 26\n'total_parts': 35\n'contentType': 'TUTORIAL'\n'title': Das ist .NET MAUI\n'parentName': Mit .NET MAUI zur erfolgreichen Cross-Platform-App\n'language': 'DE'\n'date': '2025-02-07T10:45:08.000Z'\n'abstract': In der ersten Lesson des Tutorials zeigt dir André Krämer die Grundlagen von .NET MAUI, Microsofts Framework für plattformübergreifende Apps. Du erfährst, wie du deine erste App erstellst und auf Windows, macOS, Android und iOS testest. Zum Abschluss baust du eine einfache To-do-App, die dir als Ausgangspunkt für weitere Projekte dient.\n'parentId': 'dd0d8f751be8d368f2f60eb9'\n'parentDescription': Zusammen mit Microsoft MVP André Krämer lernst du Schritt für Schritt, wie du mit .NET MAUI in C# und .NET native Apps für Android, iOS, macOS und Windows aus einer einzigen Codebasis erstellst. Du gestaltest ansprechende Benutzeroberflächen mit XAML und dem MVVM-Design-Pattern, stellst Daten in Listen übersichtlich dar und navigierst dabei nahtlos zwischen verschiedenen Ansichten. Zudem erfährst du, wie du Dependency Injection effizient einsetzt und native Gerätefunktionen wie die Kamera nutzt. Das praxisorientierte Tutorial ermöglicht dir, moderne Cross-Platform-Apps eigenständig zu entwickeln.\n'indexBrandName': 'BASTA!'\n'indexSeriesName': ''\n'author': 'André Krämer'\n'chunkSource': 'text'\n'text': und danach noch lokal den Workload installiere für maui. Wie das funktioniert, das findest du in der Microsoft Dokumentation. So, ich wechsle jetzt einmal in den entsprechend angelegten Ordner, der heißt immer so wie der Name der App und hier öffne ich jetzt Visual Studio Code. Visual Studio Code öffne ich, weil ich wie gesagt auf dem Mac kein Visual Studio mehr zur Verfügung habe. Es gab da mal eine Version, die ist Visual Studio von Mac. Das wurde aber von Microsoft jetzt entsprechend abgekündigt und nicht mehr weiter gepflegt und hier in Visual Studio von Mac, ganz wichtig, bin ich hingegangen und habe hier bei den Extensions die .net maui-Extension installiert. Die erlaubt es mir dann schlussendlich jetzt so eine maui-App auch zu debuggen. Wichtig ist dazu, muss mich mit dem Visual Studio Konto meiner Visual Studio Subscription einloggen, ansonsten wird hier nicht aktiviert die Extension. Wenn ich das aber gemacht habe, dann kann ich jetzt hier einfach eine C Sharp Datei auswählen und kann hier oben starten. Jetzt möchte ich ja vielleicht noch angeben, wo ich das Ganze eigentlich starten möchte, weil ich könnte auch hier wieder auf meinem iPhone starten oder auf meinem Mac oder unter Android und dazu klicke ich hier unten auf diese geschweiften Klammern. Ist ein bisschen versteckt, aber hier gibt es ein Debug Target, das ich auswählen kann. Wenn ich da drauf klicke, dann sehe ich hier alles was ich an Auswahlmöglichkeiten auf meinem Mac habe, also verschiedene iOS Simulatoren. Außerdem habe ich hier auch die Möglichkeit natürlich einen Android Abolator auszuwählen oder eben wie in meinem Fall direkt den Mac. Ich habe jetzt hier den Mac ausgewählt, ich drücke auf Play und jetzt wird die Anwendung im Hintergrund kompiliert und dann gleich auch auf meinem Mac gestartet. Das geht erfahrungsgemäß, wenn ihr einen modernen Mac habt, relativ schnell vonstatten, heißt also deutlich schneller als das zum Beispiel der Fall ist, wenn ich das Ganze unter Android oder unter iOS Starte. Da ist meine App und damit haben wir jetzt auch das letzte Betriebssystem abgehakt. Also wir haben gesehen, dass das Ganze unter Windows gestartet werden kann, unter Android im Emulator auf einem echten\n'slidetext': ''\n'from': 'index'\n'score': 39.998435974121094\n'normalizedScore': 0.39998435974121094\n'beforeDatePenaltyScore': 0.39998435974121094\n\n'documentId': '535b45361ad6c9e12a423cbc'\n'chunk_id': '6876d394225e92fc1ac79d27'\n'access': 'granted'\n'part_number': 25\n'total_parts': 35\n'contentType': 'TUTORIAL'\n'title': Das ist .NET MAUI\n'parentName': Mit .NET MAUI zur erfolgreichen Cross-Platform-App\n'language': 'DE'\n'date': '2025-02-07T10:45:08.000Z'\n'abstract': In der ersten Lesson des Tutorials zeigt dir André Krämer die Grundlagen von .NET MAUI, Microsofts Framework für plattformübergreifende Apps. Du erfährst, wie du deine erste App erstellst und auf Windows, macOS, Android und iOS testest. Zum Abschluss baust du eine einfache To-do-App, die dir als Ausgangspunkt für weitere Projekte dient.\n'parentId': 'dd0d8f751be8d368f2f60eb9'\n'parentDescription': Zusammen mit Microsoft MVP André Krämer lernst du Schritt für Schritt, wie du mit .NET MAUI in C# und .NET native Apps für Android, iOS, macOS und Windows aus einer einzigen Codebasis erstellst. Du gestaltest ansprechende Benutzeroberflächen mit XAML und dem MVVM-Design-Pattern, stellst Daten in Listen übersichtlich dar und navigierst dabei nahtlos zwischen verschiedenen Ansichten. Zudem erfährst du, wie du Dependency Injection effizient einsetzt und native Gerätefunktionen wie die Kamera nutzt. Das praxisorientierte Tutorial ermöglicht dir, moderne Cross-Platform-Apps eigenständig zu entwickeln.\n'indexBrandName': 'BASTA!'\n'indexSeriesName': ''\n'author': 'André Krämer'\n'chunkSource': 'text'\n'text': Bildschirm zu spiegeln. Das ist jetzt hier eine Live-Ansicht auf mein iPhone und ich drücke auf Play und jetzt wird im Hintergrund die App kompiliert und zwar passiert das ganze Remote auf meinem Mac. Das also der Source Code wird im Hintergrund übertragen, es wird kompiliert, es wird dann vom Mac auf mein iPhone deployed und hier dann auch gleich gestartet. Auch das dauert wieder einen ganz kurzen Augenblick. So und jetzt ist die App und wird gerade im Hintergrund gestartet. Das sehen wir übrigens immer hier unten in dieser Leiste in Visual Studio, was gerade passiert. Und auch das sollte jetzt nur noch wenige Sekunden dauern, bis die App dann schlussendlich auf meinem iPhone gestartet ist. So, da ist die App und auch hier kann ich natürlich die App interaktiv bedienen und das Ganze wird dann entsprechend auf meinem System aktualisiert. So, damit haben wir auch gesehen, wie wir das auf dem iPhone starten können. Ja, was fehlt jetzt noch? Jetzt fehlt noch der Mac. Bei Mac ist es leider so dass wir keine Möglichkeit haben, das Ganze einfach remote zu starten und deswegen werde ich die App jetzt hier einmal beenden und dann wechseln wir auf meinen Mac und dort werde ich einfach eine neue App starten. So, hier sind wir zurück auf meinem Mac und ich habe hier einmal ein Terminal geöffnet, also eine Eingabe-Aufforderung. Das liegt daran, dass ich auf dem Mac jetzt erst mal kein Visual Studio nutzen kann, um eine neue Anwendung zu erzeugen und deswegen mache ich jetzt hier folgend, ich nutze die Eingabe-Aufforderung und schreibe jetzt hier .net new maui, heißt also ich möchte eine neue maui-App anlegen und ich nutze dazu den Namen maui-demo. So, wenn ich jetzt Enter drücke, dann wird die App bei mir auf meinem Mac entsprechend erstellt. Das funktioniert aber natürlich nur, wenn ich vorher .net installiert habe. Ja das Ganze funktioniert, indem ich das von der .net Homebatch herunter lade und danach noch lokal den Workload installiere für maui. Wie das funktioniert, das findest du in der Microsoft Dokumentation. So, ich wechsle jetzt einmal in den entsprechend angelegten Ordner, der heißt immer so wie\n'slidetext': ''\n'from': 'index'\n'score': 39.998435974121094\n'normalizedScore': 0.39998435974121094\n'beforeDatePenaltyScore': 0.39998435974121094\n\n'documentId': '535b45361ad6c9e12a423cbc'\n'chunk_id': '6876d394225e92fc1ac79d26'\n'access': 'granted'\n'part_number': 24\n'total_parts': 35\n'contentType': 'TUTORIAL'\n'title': Das ist .NET MAUI\n'parentName': Mit .NET MAUI zur erfolgreichen Cross-Platform-App\n'language': 'DE'\n'date': '2025-02-07T10:45:08.000Z'\n'abstract': In der ersten Lesson des Tutorials zeigt dir André Krämer die Grundlagen von .NET MAUI, Microsofts Framework für plattformübergreifende Apps. Du erfährst, wie du deine erste App erstellst und auf Windows, macOS, Android und iOS testest. Zum Abschluss baust du eine einfache To-do-App, die dir als Ausgangspunkt für weitere Projekte dient.\n'parentId': 'dd0d8f751be8d368f2f60eb9'\n'parentDescription': Zusammen mit Microsoft MVP André Krämer lernst du Schritt für Schritt, wie du mit .NET MAUI in C# und .NET native Apps für Android, iOS, macOS und Windows aus einer einzigen Codebasis erstellst. Du gestaltest ansprechende Benutzeroberflächen mit XAML und dem MVVM-Design-Pattern, stellst Daten in Listen übersichtlich dar und navigierst dabei nahtlos zwischen verschiedenen Ansichten. Zudem erfährst du, wie du Dependency Injection effizient einsetzt und native Gerätefunktionen wie die Kamera nutzt. Das praxisorientierte Tutorial ermöglicht dir, moderne Cross-Platform-Apps eigenständig zu entwickeln.\n'indexBrandName': 'BASTA!'\n'indexSeriesName': ''\n'author': 'André Krämer'\n'chunkSource': 'text'\n'text': einmal das Menü und klicke auf den Abfüll und dann auf die Systemeinstellungen und in den Systemeinstellungen gibt es unser allgemein einen Unterpunkt teilen und wenn ich hier drauf klicke, dann seht ihr, dass es hier einen Punkt gibt, der heißt entfernte Anmeldung, den muss ich aktivieren und muss dafür Sorge tragen, dass ich, wenn ich hier auf das I drücke, dass ich hier sehe, dass hier auch tatsächlich mein Benutzer freigeschaltet ist. Mit diesem Benutzer der hier angegeben ist, ihr seht hier oben auch immer das, noch einmal, ihr seht hier oben auch immer den Benutzernamen, der dazu passt, dem kann ich mich danach dann von meinem Windows PC auf dem Mac anmelden. So, wenn man schon mal dabei ist, dann empfiehlt es sich immer, wenn ich ein Setup habe, wo der Mac nicht direkt auf dem gleichen Schreibtisch steht, so wie hier bei mir, sondern vielleicht irgendwo entfernt, dann empfiehlt es sich also immer, dass ich darüber hinaus auch hier die Bildschirmfreigabe noch aktiviere. Wenn ich das mache, dann kann ich mich danach nämlich mit einem beliebigen VNC Client über Windows auf meinen Mac verbinden. So was habe ich jetzt hier an meinem Mac gemacht? Ich habe zum einen die entfernte Anmeldung aktiviert und zum anderen habe ich per Kabel hier mein iPhone angeschlossen. Ich zeige euch das mal indem ich wieder zurückwechsle auf die Kamera. So also diesmal seht ihr hier, an meinem Mac ist mein iPhone angeschlossen und dieses iPhone das finde ich jetzt auch in Visual Studio. Dazu wechseln wir mal zurück ins Visual Studio und hier in Visual Studio kann ich nachdem ich die Verbindung hergestellt habe, dem Punkt iOS Remote Geräte mein iPhone auswählen. So ich klicke das einmal an und wir starten das Ganze. Dazu zeige ich euch jetzt hier direkt mal den Bildschirm von meinem iPhone. Dazu habe ich eine App installiert, die nennt sich Reflektor und die erlaubt es mir meinen iPhone Bildschirm zu spiegeln. Das ist jetzt hier eine Live-Ansicht auf mein iPhone und ich drücke auf Play und jetzt wird im Hintergrund die App kompiliert und zwar passiert das ganze Remote auf meinem Mac. Das also\n'slidetext': ''\n'from': 'index'\n'score': 39.998435974121094\n'normalizedScore': 0.39998435974121094\n'beforeDatePenaltyScore': 0.39998435974121094\n\n'documentId': '535b45361ad6c9e12a423cbc'\n'chunk_id': '6876d394225e92fc1ac79d25'\n'access': 'granted'\n'part_number': 23\n'total_parts': 35\n'contentType': 'TUTORIAL'\n'title': Das ist .NET MAUI\n'parentName': Mit .NET MAUI zur erfolgreichen Cross-Platform-App\n'language': 'DE'\n'date': '2025-02-07T10:45:08.000Z'\n'abstract': In der ersten Lesson des Tutorials zeigt dir André Krämer die Grundlagen von .NET MAUI, Microsofts Framework für plattformübergreifende Apps. Du erfährst, wie du deine erste App erstellst und auf Windows, macOS, Android und iOS testest. Zum Abschluss baust du eine einfache To-do-App, die dir als Ausgangspunkt für weitere Projekte dient.\n'parentId': 'dd0d8f751be8d368f2f60eb9'\n'parentDescription': Zusammen mit Microsoft MVP André Krämer lernst du Schritt für Schritt, wie du mit .NET MAUI in C# und .NET native Apps für Android, iOS, macOS und Windows aus einer einzigen Codebasis erstellst. Du gestaltest ansprechende Benutzeroberflächen mit XAML und dem MVVM-Design-Pattern, stellst Daten in Listen übersichtlich dar und navigierst dabei nahtlos zwischen verschiedenen Ansichten. Zudem erfährst du, wie du Dependency Injection effizient einsetzt und native Gerätefunktionen wie die Kamera nutzt. Das praxisorientierte Tutorial ermöglicht dir, moderne Cross-Platform-Apps eigenständig zu entwickeln.\n'indexBrandName': 'BASTA!'\n'indexSeriesName': ''\n'author': 'André Krämer'\n'chunkSource': 'text'\n'text': schon, da ist wieder der Start-Screen und auch hier, ich kann auf das Ganze hier draufklicken und dann wird auch mein Breakpoint hier wieder entsprechend getroffen, ich drücke mal auf weiter, ja, habe ein paar mal gedrückt, ein paar mal weiter drücken, so und hier aktualisiert sich unser UI. Wunderbar, damit haben wir bisher schon gesehen, wie wir unter einem Android-Emulator und unter einem Android-Gerät die App starten können. Damit haben wir jetzt neben Windows das zweite Betriebssystem abgehakt, aber wir ja noch ein Betriebssystem, was wichtig ist, nämlich iOS. Ja wie schaut es bei iOS aus? Ich bringe mal den Bildschirm von Vision Studio wieder nach vorne. Hier sieht es so aus, ich muss am ersten Schritt hingehen und muss eine Verbindung zu einem Mac in meinem Netzwerk haben. So wie funktioniert das? Ihr seht schon hier oben hier gibt es so ein Bildschirmsymbol, das ist aktuell grün, mit einem Stecker drin, was bedeutet ich bin mit einem Mac verbunden, ich klicke einmal da drauf. Ihr seht, wenn ihr auf diesen Bildschirm draufklickt, dann öffnet sich dieser Dialog und in dem werden alle Macs, in eurem Netzwerk sind, aufgelistet und dann müsst einfach euren Mac auswählen und dann verbinden. So ich habe das hier schon gemacht und für den Fall, dass bei euch der Mac fehlt, dann könnt ihr unten einfach hier auf Mac hinzufügen klicken und dann direkt die IP-Adresse angeben. Wichtig ist immer, der Mac muss im Netzwerk verfügbar sein und das darf nicht irgendwie durch die Firewall oder ähnliches blockiert werden. Sobald ihr das macht, wird dann auf eure Mac im Hintergrund die notwendige Software installiert und ihr könnt loslegen. Wichtig, ihr müsst auf eure Mac die entfernte Anmeldung aktivieren. Wie ihr das Ganze macht, das zeige ich euch jetzt und dazu wechsle ich einmal ganz schnell auf meinen Mac. So hier sehen wir jetzt meinen Mac und ich öffne hier oben einmal das Menü und klicke auf den Abfüll und dann auf die Systemeinstellungen und in den Systemeinstellungen gibt es unser allgemein einen Unterpunkt teilen und wenn ich hier drauf klicke, dann seht ihr,\n'slidetext': ''\n'from': 'index'\n'score': 39.998435974121094\n'normalizedScore': 0.39998435974121094\n'beforeDatePenaltyScore': 0.39998435974121094\n\n'documentId': '535b45361ad6c9e12a423cbc'\n'chunk_id': '6876d394225e92fc1ac79d24'\n'access': 'granted'\n'part_number': 22\n'total_parts': 35\n'contentType': 'TUTORIAL'\n'title': Das ist .NET MAUI\n'parentName': Mit .NET MAUI zur erfolgreichen Cross-Platform-App\n'language': 'DE'\n'date': '2025-02-07T10:45:08.000Z'\n'abstract': In der ersten Lesson des Tutorials zeigt dir André Krämer die Grundlagen von .NET MAUI, Microsofts Framework für plattformübergreifende Apps. Du erfährst, wie du deine erste App erstellst und auf Windows, macOS, Android und iOS testest. Zum Abschluss baust du eine einfache To-do-App, die dir als Ausgangspunkt für weitere Projekte dient.\n'parentId': 'dd0d8f751be8d368f2f60eb9'\n'parentDescription': Zusammen mit Microsoft MVP André Krämer lernst du Schritt für Schritt, wie du mit .NET MAUI in C# und .NET native Apps für Android, iOS, macOS und Windows aus einer einzigen Codebasis erstellst. Du gestaltest ansprechende Benutzeroberflächen mit XAML und dem MVVM-Design-Pattern, stellst Daten in Listen übersichtlich dar und navigierst dabei nahtlos zwischen verschiedenen Ansichten. Zudem erfährst du, wie du Dependency Injection effizient einsetzt und native Gerätefunktionen wie die Kamera nutzt. Das praxisorientierte Tutorial ermöglicht dir, moderne Cross-Platform-Apps eigenständig zu entwickeln.\n'indexBrandName': 'BASTA!'\n'indexSeriesName': ''\n'author': 'André Krämer'\n'chunkSource': 'text'\n'text': Bereich über das Telefon, hier. Hier geht ihr hin und müsst mehrfach hier unten auf die Bildnummer drauf tippen. mache das mal und hier steht jetzt schon ok, du bist bereits ein Entwickler, das ist eine Eigenheit von Android. Wenn ich in den Entwicklungsmodus einschalten möchte, dann muss ich zunächst hier in die Einstellungen gehen, dann auf über das Telefon, dann auf die Bildnummer, dann muss ich da mehrfach draufklicken, dann aktiviert sich der Entwicklermodus und im Entwicklermodus muss ich dann schlussendlich das USB-Debugging aktivieren. So wenn das alles so weit erledigt ist, dann können wir folgendes machen, dann können wir unser Gerät verbinden und es kann jedes Android-Gerät, also jedes beliebige sein. Wir machen es bei uns in der Firma so, wir haben in Regel ein Highend-Gerät, eins in so einer mittleren Geräteklasse und auch immer eines als Einsteigergerät, denn es ist wichtig, gerade wenn ich Apps im Store habe, die von Privatleuten auch installiert werden können, beziehungsweise von Firmen, die so eine Bring-your-on-Device-Strategie haben, dass ich auch wirklich auf leistungsschwachen Geräten meine App einmal teste., So, ich klicke jetzt hier auf Start, jetzt passiert im Endeffekt das gleiche wie eben, die App wird kompiliert, die wird auf dem Gerät installiert, ich bringe das mal wieder nach vorne und jetzt in einem kurzen Augenblick sollte das Ganze auch jetzt hier auf meinem Android-Gerät gestartet werden. Der große Vorteil von unserem echten Gerät ist natürlich, ja ich kann die App genauso testen, wie sie später auch verwendet wird, sprich ich kann sämtliche Touchgesten testen, ich kann schauen, ob mein Gerät besonders heiß wird, ich kann die ganzen Sensoren natürlich testen, heißt also irgendwie, wenn ich zum Beispiel Geo-Geschichten mache, kann ich mit dem Gerät ja mal durch die Gegend fahren und schauen, ob sich die Position entsprechend verändert und so weiter. So, da ist unsere App auch schon, da ist wieder der Start-Screen und auch hier, ich kann auf das Ganze hier draufklicken und dann wird auch mein Breakpoint hier wieder entsprechend getroffen, ich drücke mal auf weiter, ja,\n'slidetext': ''\n'from': 'index'\n'score': 39.998435974121094\n'normalizedScore': 0.39998435974121094\n'beforeDatePenaltyScore': 0.39998435974121094\n\n'documentId': '535b45361ad6c9e12a423cbc'\n'chunk_id': '6876d393225e92fc1ac79d23'\n'access': 'granted'\n'part_number': 21\n'total_parts': 35\n'contentType': 'TUTORIAL'\n'title': Das ist .NET MAUI\n'parentName': Mit .NET MAUI zur erfolgreichen Cross-Platform-App\n'language': 'DE'\n'date': '2025-02-07T10:45:08.000Z'\n'abstract': In der ersten Lesson des Tutorials zeigt dir André Krämer die Grundlagen von .NET MAUI, Microsofts Framework für plattformübergreifende Apps. Du erfährst, wie du deine erste App erstellst und auf Windows, macOS, Android und iOS testest. Zum Abschluss baust du eine einfache To-do-App, die dir als Ausgangspunkt für weitere Projekte dient.\n'parentId': 'dd0d8f751be8d368f2f60eb9'\n'parentDescription': Zusammen mit Microsoft MVP André Krämer lernst du Schritt für Schritt, wie du mit .NET MAUI in C# und .NET native Apps für Android, iOS, macOS und Windows aus einer einzigen Codebasis erstellst. Du gestaltest ansprechende Benutzeroberflächen mit XAML und dem MVVM-Design-Pattern, stellst Daten in Listen übersichtlich dar und navigierst dabei nahtlos zwischen verschiedenen Ansichten. Zudem erfährst du, wie du Dependency Injection effizient einsetzt und native Gerätefunktionen wie die Kamera nutzt. Das praxisorientierte Tutorial ermöglicht dir, moderne Cross-Platform-Apps eigenständig zu entwickeln.\n'indexBrandName': 'BASTA!'\n'indexSeriesName': ''\n'author': 'André Krämer'\n'chunkSource': 'text'\n'text': Ihr könnt euch verschiedene Emulatoren für Android-Versionen und Bildschirmauflösungen erstellen und ihr habt auch die Möglichkeit, hier verschiedene Aktionen auszuführen. Zum Beispiel könntet ihr hier über die drei Punkte so ein Menü öffnen und dann könnt ihr hier zum Beispiel bestimmte Geopositionen simulieren an der Stelle oder auch dafür sorgen, dass irgendwelche Sensoren hier angetriggert werden. All das wollen wir jetzt hier in dem Video nicht machen, sondern wir gucken uns jetzt noch die App auf anderen Geräten starten können, denn der Emulator ist zwar gut, aber es gibt einige Dinge die ich darauf nicht so gut testen kann. Zum Beispiel Touch-Interaktion geht nicht gut darauf zu testen oder auch ob meine App das Gerät vielleicht besonders warm werden lässt, es besonders viel CPU-Last oder weil die App besonders viel CPU-Last verursacht. Also beende ich einmal das Ganze wieder und jetzt möchte ich die App einmal auf einem echten Android-Gerät starten. Dazu habe ich hier einfach per Kabel ein Android-Gerät angeschlossen. Ich schalte mich nochmal kurz auf die Kamera groß. Hier seht ihr also das Gerät, auf dem werde ich gleich die App starten und ich habe Folgendes gemacht, damit ihr das auch sehen könnt was passiert, habe ich hier ein kleines Tool gestartet, über das ich mein aktuelles Android-Gerät spiegeln kann. Heißt also, jetzt werde ich auf dieses Gerät einmal meine App deployen. Dazu gehe ich hier wieder in das Menü und werde dann unser lokaler Android-Gerät mein angeschlossenes Gerät aus. Dazu ist wichtig, dass ihr das Gerät zuvor in den Entwicklermodus versetzt und das funktioniert, indem ihr in die Einstellungen reingeht und ich zeige das einmal hier auf meinem Gerät schnell. Dazu wechsle ich unten auf die Einstellungen und das erste was ihr machen müsst, ihr müsst bei den Einstellungen über das Gerät, die finden wir hier im Bereich System Noch Einmal, das finden wir hier im Bereich über das Telefon, hier. Hier geht ihr hin und müsst mehrfach hier unten auf die Bildnummer drauf tippen. mache das mal und hier steht jetzt schon ok, du bist bereits ein Entwickler, das\n'slidetext': ''\n'from': 'index'\n'score': 39.998435974121094\n'normalizedScore': 0.39998435974121094\n'beforeDatePenaltyScore': 0.39998435974121094\n\n'documentId': '535b45361ad6c9e12a423cbc'\n'chunk_id': '6876d395225e92fc1ac79d30'\n'access': 'granted'\n'part_number': 34\n'total_parts': 35\n'contentType': 'TUTORIAL'\n'title': Das ist .NET MAUI\n'parentName': Mit .NET MAUI zur erfolgreichen Cross-Platform-App\n'language': 'DE'\n'date': '2025-02-07T10:45:08.000Z'\n'abstract': In der ersten Lesson des Tutorials zeigt dir André Krämer die Grundlagen von .NET MAUI, Microsofts Framework für plattformübergreifende Apps. Du erfährst, wie du deine erste App erstellst und auf Windows, macOS, Android und iOS testest. Zum Abschluss baust du eine einfache To-do-App, die dir als Ausgangspunkt für weitere Projekte dient.\n'parentId': 'dd0d8f751be8d368f2f60eb9'\n'parentDescription': Zusammen mit Microsoft MVP André Krämer lernst du Schritt für Schritt, wie du mit .NET MAUI in C# und .NET native Apps für Android, iOS, macOS und Windows aus einer einzigen Codebasis erstellst. Du gestaltest ansprechende Benutzeroberflächen mit XAML und dem MVVM-Design-Pattern, stellst Daten in Listen übersichtlich dar und navigierst dabei nahtlos zwischen verschiedenen Ansichten. Zudem erfährst du, wie du Dependency Injection effizient einsetzt und native Gerätefunktionen wie die Kamera nutzt. Das praxisorientierte Tutorial ermöglicht dir, moderne Cross-Platform-Apps eigenständig zu entwickeln.\n'indexBrandName': 'BASTA!'\n'indexSeriesName': ''\n'author': 'André Krämer'\n'chunkSource': 'text'\n'text': App an, wie ich das gerade gemacht habe. Also setzt diesen Haken, dass die Beispieldaten mit ins Projekt herein sollen und guckt euch mal an, wie Microsoft das Ganze hier eigentlich gelöst hat, dann bekommt ihr einen relativ guten Überblick darüber, wie Microsoft sich vorstellt, wie eine vernünftige App aufgebaut ist. Das heißt natürlich nicht, dass das der einzige Weg ist, aber es ist ein guter Weg, der praxiserprobt ist und der auch von Microsoft mit empfohlen wird. Ja wir sind jetzt am Ende dieser Lektion angekommen und ich möchte noch mal kurz zusammenfassen, was wir eigentlich gelernt haben. Wir haben gelernt, dass .NET Maui ein Cross-Platform-Framework von Microsoft ist. Das ist der Nachfolger von Xamarin Forms und ich kann mit Apps für Android, für iOS, für Windows und für den Mac schreiben und zwar das Ganze mit einer gemeinsamen Quellcode-Basis, die ich mit .NET und mit C-Sharp schreibe. Wir haben gelernt, dass .NET Maui ein Teil von .NET ist und jedes Jahr im November gemeinsam mit .NET released wird. Wir haben außerdem gesehen, dass .NET Maui so eine Abstraktionsschicht liefert. Also ich habe nicht direkt Quellcode, der auf dem Gerät läuft, sondern ich schreibe Quellcode, der die Maui APIs aufruft. Diese Maui APIs definieren so abstrakte Steuerelemente, die dann zur Laufzeit in die nativen Steuerelemente übersetzt werden. Heißt also, Maui rendert selber nichts, sondern Maui delegiert das Rendern an die SDKs jeweiligen Betriebssysteme. Darüber hinaus bietet Maui mir noch so eine Abstraktionsschicht über gängige Hardware-Geschichten auf den Geräten, also zum Beispiel Zugriff auf die Kamera, auf GPS und so weiter. Wir haben außerdem dann gelernt, wie wir eine erste kleine App anlegen können. haben die Struktur besprochen und haben uns mal angesehen, wie wir das auf den verschiedenen Betriebssystemen starten können. Dabei war wichtig, dass wir erkannt haben, dass wir unter Windows für Windows und für Android entwickeln können. Wir können auch für iOS entwickeln. Ich kann das sogar unter Windows starten aber ich brauche später zu paketieren davon auf jeden Fall immer einen Mac. Im einfachsten Fall, wenn ich jetzt selber mit dem Mac\n'slidetext': ''\n'from': 'index'\n'score': 39.998435974121094\n'normalizedScore': 0.39998435974121094\n'beforeDatePenaltyScore': 0.39998435974121094\n\n'documentId': 'a5dcfc84b51456a6b4b27fce'\n'chunk_id': '6878ecf122599b00136894cc'\n'access': 'granted'\n'part_number': 13\n'total_parts': 77\n'contentType': 'TUTORIAL'\n'title': Die Welt der Web Components\n'parentName': Web Components von 0 auf 100\n'language': 'DE'\n'date': '2025-06-05T13:45:07.000Z'\n'abstract': In der ersten Lesson steigen wir in die Welt der Web Components ein. Wir richten unser Setup ein, klären die Ziele des Tutorials – und schreiben unser erstes „Hello World“. Dabei beantworten wir die Grundfrage: Was sind Web Components eigentlich? Wir schauen uns Content-Attribute und DOM-Properties an, ziehen den Vergleich zu Frameworks und klären, wo Web Components glänzen – und wo nicht. Best Practices und erste UI-Beispiele runden den Einstieg ab.\n'parentId': '54cce7e83417cbefa7c0d3f0'\n'parentDescription': Web Components versprechen universelle Frontend-Komponenten, frei von Framework-Fesseln und Dependency-Depression. Das Problem: Web Components sind komplex, manche APIs wirken eigenartig, und das sie umgebende Ökosystem ist unübersichtlich. Was können Web Components leisten – und was nicht? Brauche ich wirklich Shadow DOM oder kann ich darauf verzichten? Vanilla-Komponenten, Lit – oder etwas dazwischen? In diesem Tutorial lernen wir, wie der Komponenten-Eintopf wirklich gemacht wird. Wir orientieren uns im Ökosystem und erhalten einen Überblick über die Fähigkeiten und Grenzen der Standards rund um Web Components. Von den absoluten API-Grundlagen bis zum Einsatz ausgewachsener Komponenten-Frameworks lassen wir keinen Schritt aus. In jedem Abschnitt unserer Reise erfahren wir nicht nur, wie etwas funktioniert, sondern auch, warum. Dieses Tutorial macht uns nicht nur zu Web-Component-Expert:innen, sondern vertieft auch unser Verständnis der Web-Plattform insgesamt.\n'indexBrandName': 'InternationalJavaScriptCon'\n'indexSeriesName': ''\n'author': 'Peter Kröner'\n'chunkSource': 'text'\n'text': wirkliche Änderung, denn das hier ist ja nur eine Methode auf Instanzen von Hello World, also auf Objekten, die wir da im DOM finden, und das ist jetzt erstmal für uns vom UI her nicht wirklich erfahrbar, da sehen wir nichts von. Aber wir können das tatsächlich mit den DevTools inspizieren, nehmen wir uns nämlich jetzt mal hier im Inspector unser Hello World Element anklicken, in dem Moment wo wir im Inspector ein Element anklicken, können wir es in der JavaScript-Konsole referenzieren mit der Variable $0, $0 referenziert das, was wir gerade anklickt haben, und wir sehen es jetzt ja hier, wird auch gehighlightet, unser Hello World Element, das ist jetzt also eine Instanz unserer Klasse, und das bedeutet, dass ich auf diesem Ding tatsächlich die Methode foo verwenden und aufrufen kann, und siehe her, mir wird 42 in die Konsole geschrieben, und das undefined, da rauskommt, ist der Rückgabewert von foo da habe ich jetzt keinen Rückgabewert angegeben, deswegen kommt da undefined raus, das passt schon, und naja, das ist im Wesentlichen das, was wir kriegen, wenn wir Web-Components haben, wir kriegen erstmal einen eigenen HTML-Tag, den wir dann einfach erfinden können, den wir dann in unser HTML reinschreiben können, wir müssen dem Browser bloß mitteilen, dass dieser HTML-Tag dann belegt ist durch unsere Komponente, die Implementierung findet statt über eine Klasse, in dieser Klasse können wir einfach ausprogrammieren, was immer wir wollen, das wäre jetzt in dem Fall diese Methode foo, das kann aber auch alles Mögliche sein, wir können hingehen, und wir können da ein UI drin definieren, Event Handling machen, das kommt alles später noch, das ist also, was wir erstmal so haben, wir kriegen im Prinzip die Klasse und können uns da drin austoben, und was wir auch schon gesehen haben, ist, dass gewisse Basics bereits funktionieren, wir haben gesehen, ich kann hier das Style-Attribut verwenden, um zum Beispiel color.red zu machen, und schon kriege ich roten Text, das Featureset haben wir im Prinzip einfach dadurch geerbt, dass unser Custom-Element eine Instanz von HTML-Elementen ist, und alle HTML-Elemente\n'slidetext': ''\n'from': 'index'\n'score': 37.79056167602539\n'normalizedScore': 0.3779056167602539\n'beforeDatePenaltyScore': 0.3779056167602539\n\n'documentId': 'a5dcfc84b51456a6b4b27fce'\n'chunk_id': '6878ecf122599b00136894cb'\n'access': 'granted'\n'part_number': 12\n'total_parts': 77\n'contentType': 'TUTORIAL'\n'title': Die Welt der Web Components\n'parentName': Web Components von 0 auf 100\n'language': 'DE'\n'date': '2025-06-05T13:45:07.000Z'\n'abstract': In der ersten Lesson steigen wir in die Welt der Web Components ein. Wir richten unser Setup ein, klären die Ziele des Tutorials – und schreiben unser erstes „Hello World“. Dabei beantworten wir die Grundfrage: Was sind Web Components eigentlich? Wir schauen uns Content-Attribute und DOM-Properties an, ziehen den Vergleich zu Frameworks und klären, wo Web Components glänzen – und wo nicht. Best Practices und erste UI-Beispiele runden den Einstieg ab.\n'parentId': '54cce7e83417cbefa7c0d3f0'\n'parentDescription': Web Components versprechen universelle Frontend-Komponenten, frei von Framework-Fesseln und Dependency-Depression. Das Problem: Web Components sind komplex, manche APIs wirken eigenartig, und das sie umgebende Ökosystem ist unübersichtlich. Was können Web Components leisten – und was nicht? Brauche ich wirklich Shadow DOM oder kann ich darauf verzichten? Vanilla-Komponenten, Lit – oder etwas dazwischen? In diesem Tutorial lernen wir, wie der Komponenten-Eintopf wirklich gemacht wird. Wir orientieren uns im Ökosystem und erhalten einen Überblick über die Fähigkeiten und Grenzen der Standards rund um Web Components. Von den absoluten API-Grundlagen bis zum Einsatz ausgewachsener Komponenten-Frameworks lassen wir keinen Schritt aus. In jedem Abschnitt unserer Reise erfahren wir nicht nur, wie etwas funktioniert, sondern auch, warum. Dieses Tutorial macht uns nicht nur zu Web-Component-Expert:innen, sondern vertieft auch unser Verständnis der Web-Plattform insgesamt.\n'indexBrandName': 'InternationalJavaScriptCon'\n'indexSeriesName': ''\n'author': 'Peter Kröner'\n'chunkSource': 'text'\n'text': verwenden, das ist das Ding, was der HTML-Parser sieht. Tags für Custom-Elements, für Web-Components, müssen einen Bindestrich enthalten, da führt kein Weg dran vorbei, die Idee dahinter ist, dass dieser Bindestrich quasi ein Namespace darstellt, alle Elemente, die einen Bindestrich enthalten, das sind die, die wir als Entwickler frei definieren können, und wenn der Browser eines Tages ein neues HTML-Element hinzu erfinden möchte, gibt er sich alle Mühe, dass dieses keinen Bindestrich enthält, und so haben wir quasi getrennt die Welt der nativen Elemente ohne Bindestrich, und die Welt der nicht-nativen Elemente mit dem Bindestrich. Jetzt werden natürlich die Super-Nerds unter euch sagen, es gibt so ein paar Elemente, speziell im SVG-Bereich, die haben einen Bindestrich, aber wisst ihr was, die ignorieren wir einfach, das sind nämlich ein paar sehr sehr seltsame, so was wie Font-Face, und die stehen auf einer Filterliste die dürfen wir also nicht verwenden als HTML-Tag-Namen, aber ganz grundsätzlich, abgesehen von diesen paar Spezialfällen aus SVG und MathML und so, ist das schon okay, ihr wollt ein neues HTML-Element erfinden, könnt euch einen Tag-Name überlegen mit einem Bindestrich, das passt schon, und wenn nicht, kriegt ihr einen Fehler um die Ohren geschmissen, und dann merkt ihr es auch. Das läuft erstmal, und wie wir sehen, sehen wir wie schon erwähnt, eigentlich nix, also die Webseite sieht genauso aus wie vorher, wir haben hier keinerlei interessanten Features am Start, aber, das können wir jetzt natürlich ändern, wir können in unsere Klasse hier ein paar Features einprogrammieren, und diese Features könnten zum Beispiel sowas sein, ganz normale DOM-Methoden also gehe ich mal hin, definiere hier eine Methode namens foo, und mangels Kreativität gehe ich jetzt mal hin, und lasse die einfach irgendwas in die Konsole schreiben, wie wär's? So, wenn ich jetzt speichere, sehen wir natürlich immer noch keine wirkliche Änderung, denn das hier ist ja nur eine Methode auf Instanzen von Hello World, also auf Objekten, die wir da im DOM finden, und das ist jetzt erstmal für uns vom UI her nicht\n'slidetext': ''\n'from': 'index'\n'score': 37.79056167602539\n'normalizedScore': 0.3779056167602539\n'beforeDatePenaltyScore': 0.3779056167602539\n\n'documentId': 'a5dcfc84b51456a6b4b27fce'\n'chunk_id': '6878ecf122599b00136894ca'\n'access': 'granted'\n'part_number': 11\n'total_parts': 77\n'contentType': 'TUTORIAL'\n'title': Die Welt der Web Components\n'parentName': Web Components von 0 auf 100\n'language': 'DE'\n'date': '2025-06-05T13:45:07.000Z'\n'abstract': In der ersten Lesson steigen wir in die Welt der Web Components ein. Wir richten unser Setup ein, klären die Ziele des Tutorials – und schreiben unser erstes „Hello World“. Dabei beantworten wir die Grundfrage: Was sind Web Components eigentlich? Wir schauen uns Content-Attribute und DOM-Properties an, ziehen den Vergleich zu Frameworks und klären, wo Web Components glänzen – und wo nicht. Best Practices und erste UI-Beispiele runden den Einstieg ab.\n'parentId': '54cce7e83417cbefa7c0d3f0'\n'parentDescription': Web Components versprechen universelle Frontend-Komponenten, frei von Framework-Fesseln und Dependency-Depression. Das Problem: Web Components sind komplex, manche APIs wirken eigenartig, und das sie umgebende Ökosystem ist unübersichtlich. Was können Web Components leisten – und was nicht? Brauche ich wirklich Shadow DOM oder kann ich darauf verzichten? Vanilla-Komponenten, Lit – oder etwas dazwischen? In diesem Tutorial lernen wir, wie der Komponenten-Eintopf wirklich gemacht wird. Wir orientieren uns im Ökosystem und erhalten einen Überblick über die Fähigkeiten und Grenzen der Standards rund um Web Components. Von den absoluten API-Grundlagen bis zum Einsatz ausgewachsener Komponenten-Frameworks lassen wir keinen Schritt aus. In jedem Abschnitt unserer Reise erfahren wir nicht nur, wie etwas funktioniert, sondern auch, warum. Dieses Tutorial macht uns nicht nur zu Web-Component-Expert:innen, sondern vertieft auch unser Verständnis der Web-Plattform insgesamt.\n'indexBrandName': 'InternationalJavaScriptCon'\n'indexSeriesName': ''\n'author': 'Peter Kröner'\n'chunkSource': 'text'\n'text': von denen ist Define. Damit können wir, wenig überraschend, eine Definition von einem HTML-Tag hinlegen, und das funktioniert so, dass wir hier einen Tag-Name angeben, das wäre in unserem Fall natürlich Hello-World, und als zweites geben wir einen Constructor, und der Constructor muss tatsächlich eine solche Klasse sein, also da können wir jetzt nicht irgendwie eine Oldschool-Function hernehmen, sondern aus den Gründen der ganzen Mechanik, das zusammenpasst, ist es einfach so, wir brauchen eine Klasse, die muss HTML-Element oder einen anderen Subtyp von HTML-Element extenden und das ist hier der zweite Parameter, also stecken wir hier unser Hello-World hinein, und damit teilen wir den Browser mit, weißt du was, unser Element Hello-World hat jetzt hier die Features, die in dieser Klasse beschrieben werden, was im Moment gar keine Features sind, aber das macht nichts, das können wir ja noch machen, wenn ich jetzt erstmal speichere, werden wir feststellen, jawohl, funktioniert, es hat sich im Prinzip gar nichts geändert, denn wir haben ja noch keine Features hier eingebaut, aber ganz grundsätzlich ist es das, so, jetzt muss ich mal hierzu noch ein paar Takte loswerden, denn da gibt es ein paar Feinheiten, die erste Feinheit habe ich schon erwähnt, das ist eben, dass das zweite Argument hier für Define eine Klasse sein muss, und diese Klasse muss ein Subtyp oder eine Subklasse von HTML-Element sein, das ist soweit nichts Neues, dann gibt es aber noch den ersten Parameter, dieser erste Parameter hier ist dieser String, dieser String ist der Tag-Name, also der HTML-Tag von unserem Custom-Element, Hello-World definiert im Prinzip das JavaScript-Programmier-Interface, was man halt eben so bei der DOM-Programmierung mit dem man konfrontiert ist, wenn man irgendwie was mit React macht, oder wenn man irgendwie Oldschool-JQuery-Style macht, dann redet man mit Instanzen dieser Klasse, das erste ist aber der HTML-Tag, und das ist das, was wir hier in Zeile 12 verwenden, das ist das Ding, was der HTML-Parser sieht. Tags für Custom-Elements, für Web-Components, müssen einen Bindestrich enthalten, da führt kein Weg dran vorbei, die Idee dahinter ist, dass dieser\n'slidetext': ''\n'from': 'index'\n'score': 37.79056167602539\n'normalizedScore': 0.3779056167602539\n'beforeDatePenaltyScore': 0.3779056167602539\n\n'documentId': 'a5dcfc84b51456a6b4b27fce'\n'chunk_id': '6878ecf122599b00136894c9'\n'access': 'granted'\n'part_number': 10\n'total_parts': 77\n'contentType': 'TUTORIAL'\n'title': Die Welt der Web Components\n'parentName': Web Components von 0 auf 100\n'language': 'DE'\n'date': '2025-06-05T13:45:07.000Z'\n'abstract': In der ersten Lesson steigen wir in die Welt der Web Components ein. Wir richten unser Setup ein, klären die Ziele des Tutorials – und schreiben unser erstes „Hello World“. Dabei beantworten wir die Grundfrage: Was sind Web Components eigentlich? Wir schauen uns Content-Attribute und DOM-Properties an, ziehen den Vergleich zu Frameworks und klären, wo Web Components glänzen – und wo nicht. Best Practices und erste UI-Beispiele runden den Einstieg ab.\n'parentId': '54cce7e83417cbefa7c0d3f0'\n'parentDescription': Web Components versprechen universelle Frontend-Komponenten, frei von Framework-Fesseln und Dependency-Depression. Das Problem: Web Components sind komplex, manche APIs wirken eigenartig, und das sie umgebende Ökosystem ist unübersichtlich. Was können Web Components leisten – und was nicht? Brauche ich wirklich Shadow DOM oder kann ich darauf verzichten? Vanilla-Komponenten, Lit – oder etwas dazwischen? In diesem Tutorial lernen wir, wie der Komponenten-Eintopf wirklich gemacht wird. Wir orientieren uns im Ökosystem und erhalten einen Überblick über die Fähigkeiten und Grenzen der Standards rund um Web Components. Von den absoluten API-Grundlagen bis zum Einsatz ausgewachsener Komponenten-Frameworks lassen wir keinen Schritt aus. In jedem Abschnitt unserer Reise erfahren wir nicht nur, wie etwas funktioniert, sondern auch, warum. Dieses Tutorial macht uns nicht nur zu Web-Component-Expert:innen, sondern vertieft auch unser Verständnis der Web-Plattform insgesamt.\n'indexBrandName': 'InternationalJavaScriptCon'\n'indexSeriesName': ''\n'author': 'Peter Kröner'\n'chunkSource': 'text'\n'text': wir hier einen eigenen Scope haben, dass wir Strict Mode haben. Einfach so ein paar Nettigkeiten von der modernen Web-Entwicklung. So, und nun gehen wir hin und möchten dem Browser beibiegen, dass Hello World tatsächlich etwas ist, was existiert. Und die Weise, wie man das macht, mit normalen Web-Component-APIs, ganz ohne irgendwelche extra Software, Frameworks, was auch alles, ist, dass wir eine ganz normale JavaScript-Klasse schreiben. Ich nenne sie mal wenig überraschend, Hello World, und das per se ist jetzt nicht wirklich, was wir brauchen, das bringt uns jetzt nicht voran, das sagt dem Browser noch nicht, dass dieser HTML-Tag existiert. Damit das funktioniert, müssen wir noch zwei weitere Dinge tun. Zum einen ist es ja so, dass unser Element, Hello World, ein Spezialfall ist von dem Standard-HTML-Element, von dem ich gerade schon sprach, dieses unbekannte Ding mit dem Feature-Set, das alle Elemente gemeinsam haben. Und um eine Erweiterung davon zu bauen, muss man natürlich im Sinne von objektorientierter Programmierung genau diese Klasse, einen Subtyp von HTML-Element definieren lassen. Und das geht natürlich über eine Extents-Klausel, Hello World, Extents, HTML-Element. Und jetzt haben wir zumindest schon mal eine Klasse konstruiert, die einen Subtyp definiert von dem, was alle Elemente sind, eine Spezialisierung quasi, was ziemlich genau das ist, was wir brauchen. Das letzte, was jetzt noch fehlt, ist die Assoziation von einem HTML-Tag mit unserer Klasse hier, denn das ist jetzt aus der Perspektive des Browsers erstmal nur eine Klassendefinition, das ist nicht wirklich zu irgendwas gut, da liegt halt eine Klasse rum. Und das hat noch keine Bewandtnis und noch keine Verbindung zu dem HTML-Tag, aber das ist kein Problem, das können wir nämlich einbauen, indem wir sagen, wir nehmen das Window-Objekt, also so das globale Objekt, wo alles drin wohnt, finden da drin die Custom-Elements-API. Und dieses Ding hat diverse Methoden, eine von denen ist Define. Damit können wir, wenig überraschend, eine Definition von einem HTML-Tag hinlegen, und das funktioniert so, dass wir hier einen Tag-Name angeben, das wäre in unserem Fall natürlich\n'slidetext': ''\n'from': 'index'\n'score': 37.79056167602539\n'normalizedScore': 0.3779056167602539\n'beforeDatePenaltyScore': 0.3779056167602539\n\n'documentId': 'a5dcfc84b51456a6b4b27fce'\n'chunk_id': '6878ecf122599b00136894c8'\n'access': 'granted'\n'part_number': 9\n'total_parts': 77\n'contentType': 'TUTORIAL'\n'title': Die Welt der Web Components\n'parentName': Web Components von 0 auf 100\n'language': 'DE'\n'date': '2025-06-05T13:45:07.000Z'\n'abstract': In der ersten Lesson steigen wir in die Welt der Web Components ein. Wir richten unser Setup ein, klären die Ziele des Tutorials – und schreiben unser erstes „Hello World“. Dabei beantworten wir die Grundfrage: Was sind Web Components eigentlich? Wir schauen uns Content-Attribute und DOM-Properties an, ziehen den Vergleich zu Frameworks und klären, wo Web Components glänzen – und wo nicht. Best Practices und erste UI-Beispiele runden den Einstieg ab.\n'parentId': '54cce7e83417cbefa7c0d3f0'\n'parentDescription': Web Components versprechen universelle Frontend-Komponenten, frei von Framework-Fesseln und Dependency-Depression. Das Problem: Web Components sind komplex, manche APIs wirken eigenartig, und das sie umgebende Ökosystem ist unübersichtlich. Was können Web Components leisten – und was nicht? Brauche ich wirklich Shadow DOM oder kann ich darauf verzichten? Vanilla-Komponenten, Lit – oder etwas dazwischen? In diesem Tutorial lernen wir, wie der Komponenten-Eintopf wirklich gemacht wird. Wir orientieren uns im Ökosystem und erhalten einen Überblick über die Fähigkeiten und Grenzen der Standards rund um Web Components. Von den absoluten API-Grundlagen bis zum Einsatz ausgewachsener Komponenten-Frameworks lassen wir keinen Schritt aus. In jedem Abschnitt unserer Reise erfahren wir nicht nur, wie etwas funktioniert, sondern auch, warum. Dieses Tutorial macht uns nicht nur zu Web-Component-Expert:innen, sondern vertieft auch unser Verständnis der Web-Plattform insgesamt.\n'indexBrandName': 'InternationalJavaScriptCon'\n'indexSeriesName': ''\n'author': 'Peter Kröner'\n'chunkSource': 'text'\n'text': für den Umgang mit unbekannten Elementen Logik gibt, die dafür sorgt, dass dieses Ding als ein HTML-Unknown-Element gepasst wird. Das ist sozusagen das Interface, das hier implementiert wird und was das bedeutet ist, dass es von dem Browser ungefähr so behandelt wird, wie ein Span-Element. Es hat keinerlei spannende Attribute, mit denen man irgendwas machen kann. Es hat keine Dome-Schnittstelle, mit der man irgendwas programmieren kann. Basale Features funktionieren durchaus. Also ich könnte jetzt hingehen und könnte jetzt hier zum Beispiel sowas machen, wie ein Class-Attribut reinschreiben und das würde funktionieren. Ich kriege dann die Class-List-API auf dem Element oder wenn ich es einfach mal stylen möchte, kann ich auch sagen, wir nehmen das Teil-Attribut und machen sowas wie colorist-red, sowas hier und wir kriegen roten Text. Das ist aber jetzt nichts, was ein Verdienst von unseren Web-Components wäre, sondern das ist einfach nur, weil alle HTML-Elemente diese Fähigkeit haben. Die können alle ein Style-Attribut haben und die können alle ihren Text-Content so sie einen solchen haben, entsprechend einfärben. Das ist also nichts Besonderes. Was wir jetzt also bisher bekommen haben, ist im Prinzip die eingebaute Fehlerbehandlungslogik vom Browser. Da gibt es noch keine spannenden Features. Aber wir können tatsächlich spannende Features hier einfügen. Wir können dem Browser sagen, weißt du was, Hello World ist kein unbekanntes Element, sondern ein von uns, Entwicklern definiertes Element und wir können es mit entsprechender Logik aufladen. Zu den Zwecken gehen wir hin und erstellen uns einen Script-Tag. Jetzt ist es so, normale Script-Tags sind ein bisschen old school, die sind nicht im Strict Mode, die haben allerlei unangenehme Eigenschaften, deswegen machen wir hier mal ein Type-Module draus. Das hat jetzt erstmal keine weitere Bewandtnis dafür, wie das funktioniert. Wir werden da jetzt nichts importieren oder exportieren, aber einfach nur Type-Module sorgt dafür, dass wir hier einen eigenen Scope haben, dass wir Strict Mode haben. Einfach so ein paar Nettigkeiten von der modernen Web-Entwicklung. So, und nun gehen wir hin und möchten dem Browser beibiegen, dass\n'slidetext': ''\n'from': 'index'\n'score': 37.79056167602539\n'normalizedScore': 0.3779056167602539\n'beforeDatePenaltyScore': 0.3779056167602539\n\n'documentId': 'a5dcfc84b51456a6b4b27fce'\n'chunk_id': '6878ecf122599b00136894c7'\n'access': 'granted'\n'part_number': 8\n'total_parts': 77\n'contentType': 'TUTORIAL'\n'title': Die Welt der Web Components\n'parentName': Web Components von 0 auf 100\n'language': 'DE'\n'date': '2025-06-05T13:45:07.000Z'\n'abstract': In der ersten Lesson steigen wir in die Welt der Web Components ein. Wir richten unser Setup ein, klären die Ziele des Tutorials – und schreiben unser erstes „Hello World“. Dabei beantworten wir die Grundfrage: Was sind Web Components eigentlich? Wir schauen uns Content-Attribute und DOM-Properties an, ziehen den Vergleich zu Frameworks und klären, wo Web Components glänzen – und wo nicht. Best Practices und erste UI-Beispiele runden den Einstieg ab.\n'parentId': '54cce7e83417cbefa7c0d3f0'\n'parentDescription': Web Components versprechen universelle Frontend-Komponenten, frei von Framework-Fesseln und Dependency-Depression. Das Problem: Web Components sind komplex, manche APIs wirken eigenartig, und das sie umgebende Ökosystem ist unübersichtlich. Was können Web Components leisten – und was nicht? Brauche ich wirklich Shadow DOM oder kann ich darauf verzichten? Vanilla-Komponenten, Lit – oder etwas dazwischen? In diesem Tutorial lernen wir, wie der Komponenten-Eintopf wirklich gemacht wird. Wir orientieren uns im Ökosystem und erhalten einen Überblick über die Fähigkeiten und Grenzen der Standards rund um Web Components. Von den absoluten API-Grundlagen bis zum Einsatz ausgewachsener Komponenten-Frameworks lassen wir keinen Schritt aus. In jedem Abschnitt unserer Reise erfahren wir nicht nur, wie etwas funktioniert, sondern auch, warum. Dieses Tutorial macht uns nicht nur zu Web-Component-Expert:innen, sondern vertieft auch unser Verständnis der Web-Plattform insgesamt.\n'indexBrandName': 'InternationalJavaScriptCon'\n'indexSeriesName': ''\n'author': 'Peter Kröner'\n'chunkSource': 'text'\n'text': in meinen Editor und tippe jetzt einfach mal ein Element da rein, von dem ich weiß, dass es nicht existiert, nämlich Hello-World. So kriegt auch einen schließenden Tag und fertig ist die Kiste. Ich könnte jetzt noch zum Spaß da irgendwelchen Content reinschreiben, warum nicht? Äh Hello-World, sowas hier, ja, wenn man es richtig schreibt, macht es gleich viel mehr Spaß. So, das ist doch wunderbar. Das habe ich jetzt noch nicht gespeichert. kann jetzt gleich dieses Dokument speichern, dann lädt die Seite neu und zeigt mir dieses Element an. Tut es das? Weil das Element ist dem Browser ja unbekannt. Es gibt im HTML-Standard das kann ich euch versichern, nichts, was Hallo-Welt heißt. Dieses Element ist also ein Buch mit sieben Siegeln für den Web-Browser. Was passiert jetzt also, wenn ich den Browser damit konfrontiere? Und was wir jetzt sehen, wenn ich speichere, ist, dass es hier anscheinend kein größeres Problem gibt. Der Text Hello-World der also hier zwischen den Texts steht, taucht auf und es gibt nicht irgendwie einen Absturz oder ähnliches. Der Browser ist in der Lage, mit unbekannten HTML-Elementen per se erst mal umzugehen. Das wissen alle von uns, die wir uns schon mal vertippt haben, so wie ich vorhin, eben an einem HTML-Tag. Okay, das klappt also und wenn wir jetzt mal uns hier im Browser anschauen was wir da gebaut haben, indem wir hier den Inspector verwenden, sehen wir auch diese Debug-Ansicht in den Browser-Dev-Tools zeigt uns an, jawohl da existiert etwas, das heißt Hello-World. Das ist also erst mal da. Jetzt ist es so, dieses Teil hat an sich keine für uns relevanten Features. Denn was der Browser jetzt macht, ist dieses Element zu nehmen und es als unbekanntes Element zu interpretieren. Es ist wirklich so dass der HTML-Parser ein absoluter Müllschlucker ist. Der nimmt alles, was er ihm vorsetzt und verarbeitet das auf irgendeine Weise. Es ist sogar so dass es speziell für den Umgang mit unbekannten Elementen Logik gibt, die dafür sorgt, dass dieses Ding als ein HTML-Unknown-Element gepasst wird. Das ist sozusagen das Interface, das hier implementiert wird und was das bedeutet\n'slidetext': ''\n'from': 'index'\n'score': 37.79056167602539\n'normalizedScore': 0.3779056167602539\n'beforeDatePenaltyScore': 0.3779056167602539\n\n'documentId': 'a5dcfc84b51456a6b4b27fce'\n'chunk_id': '6878ecf122599b00136894c6'\n'access': 'granted'\n'part_number': 7\n'total_parts': 77\n'contentType': 'TUTORIAL'\n'title': Die Welt der Web Components\n'parentName': Web Components von 0 auf 100\n'language': 'DE'\n'date': '2025-06-05T13:45:07.000Z'\n'abstract': In der ersten Lesson steigen wir in die Welt der Web Components ein. Wir richten unser Setup ein, klären die Ziele des Tutorials – und schreiben unser erstes „Hello World“. Dabei beantworten wir die Grundfrage: Was sind Web Components eigentlich? Wir schauen uns Content-Attribute und DOM-Properties an, ziehen den Vergleich zu Frameworks und klären, wo Web Components glänzen – und wo nicht. Best Practices und erste UI-Beispiele runden den Einstieg ab.\n'parentId': '54cce7e83417cbefa7c0d3f0'\n'parentDescription': Web Components versprechen universelle Frontend-Komponenten, frei von Framework-Fesseln und Dependency-Depression. Das Problem: Web Components sind komplex, manche APIs wirken eigenartig, und das sie umgebende Ökosystem ist unübersichtlich. Was können Web Components leisten – und was nicht? Brauche ich wirklich Shadow DOM oder kann ich darauf verzichten? Vanilla-Komponenten, Lit – oder etwas dazwischen? In diesem Tutorial lernen wir, wie der Komponenten-Eintopf wirklich gemacht wird. Wir orientieren uns im Ökosystem und erhalten einen Überblick über die Fähigkeiten und Grenzen der Standards rund um Web Components. Von den absoluten API-Grundlagen bis zum Einsatz ausgewachsener Komponenten-Frameworks lassen wir keinen Schritt aus. In jedem Abschnitt unserer Reise erfahren wir nicht nur, wie etwas funktioniert, sondern auch, warum. Dieses Tutorial macht uns nicht nur zu Web-Component-Expert:innen, sondern vertieft auch unser Verständnis der Web-Plattform insgesamt.\n'indexBrandName': 'InternationalJavaScriptCon'\n'indexSeriesName': ''\n'author': 'Peter Kröner'\n'chunkSource': 'text'\n'text': die vielleicht mal kompliziert sein werden. Was wir jetzt machen, ist ne richtige Web-Component bauen. Wir schauen uns an, wie die einzelnen Dinge zusammenspielen und wie das so grob funktionieren kann. Grundsätzlich kann man sagen, dass Web-Components entwicklerdefinierte HTML-Elemente sind. Es gibt DIVs, es gibt Tables und jetzt gibt es als Ergänzung noch das, was wir definieren. Und zu diesen Zwecken habe ich hier mal folgenden Versuchsaufbau hingestellt. Wir sehen links mein Browser, das ist einfach ein ganz normaler Firefox. Jeder andere Browser tut es auch. Web-Components sind eine etablierte Technologie, das läuft überall. Und auf der anderen Seite sehen wir meinen Code-Editor, das ist in dem Fall Visual Studio Code. Auch hier gilt, alles wo man Text rein tippen kann funktioniert, muss nicht dieser sein. Das einzige, was ein bisschen speziell ist, ist, dass ich hier einen Web-Server eingerichtet habe, der dafür sorgt, dass automatisch ein Update passiert, wenn ich irgendwas an dieser Datei speichere. Der Browser lädt automatisch neu, deswegen werdet ihr jetzt nicht sehen, dass ich das manuell mache. Der Web-Server ist nicht nur für diesen Live-Reload-Aspekt ganz praktisch, sondern der ist auch wichtig für den Umgang mit einigen neuen APIs. Viele moderne APIs funktionieren nicht mehr, wenn man einfach doppelt auf eine HTML-Datei draufklickt, die irgendwie auf dem Desktop liegt und das auf dem Weg geöffnet wird, sondern die brauchen halt eben einen ordentlichen Origin. Da muss dann der Browser-Adressleiste irgendwas stehen wie Local-Host oder in meinem Fall hier die IP-Adresse. Es braucht halt eine Domain. Und so ein Web-Server, der da lokal verwendet wird, ist das einfachste, was man da wirklich haben kann. Okay, dann legen wir doch mal los und bauen uns eine Web-Component. Und weil das Ding Hallo-Welt heißt, gehe ich jetzt einfach mal hin und mache so ähnliche bei Test-Driven-Development erstmal was, was nicht funktionieren kann. Ich gehe nämlich in meinen Editor und tippe jetzt einfach mal ein Element da rein, von dem ich weiß, dass es nicht existiert, nämlich Hello-World. So kriegt auch einen schließenden Tag und fertig ist die Kiste. Ich\n'slidetext': ''\n'from': 'index'\n'score': 37.79056167602539\n'normalizedScore': 0.3779056167602539\n'beforeDatePenaltyScore': 0.3779056167602539\n\n'documentId': 'a5dcfc84b51456a6b4b27fce'\n'chunk_id': '6878ecf122599b00136894c4'\n'access': 'granted'\n'part_number': 5\n'total_parts': 77\n'contentType': 'TUTORIAL'\n'title': Die Welt der Web Components\n'parentName': Web Components von 0 auf 100\n'language': 'DE'\n'date': '2025-06-05T13:45:07.000Z'\n'abstract': In der ersten Lesson steigen wir in die Welt der Web Components ein. Wir richten unser Setup ein, klären die Ziele des Tutorials – und schreiben unser erstes „Hello World“. Dabei beantworten wir die Grundfrage: Was sind Web Components eigentlich? Wir schauen uns Content-Attribute und DOM-Properties an, ziehen den Vergleich zu Frameworks und klären, wo Web Components glänzen – und wo nicht. Best Practices und erste UI-Beispiele runden den Einstieg ab.\n'parentId': '54cce7e83417cbefa7c0d3f0'\n'parentDescription': Web Components versprechen universelle Frontend-Komponenten, frei von Framework-Fesseln und Dependency-Depression. Das Problem: Web Components sind komplex, manche APIs wirken eigenartig, und das sie umgebende Ökosystem ist unübersichtlich. Was können Web Components leisten – und was nicht? Brauche ich wirklich Shadow DOM oder kann ich darauf verzichten? Vanilla-Komponenten, Lit – oder etwas dazwischen? In diesem Tutorial lernen wir, wie der Komponenten-Eintopf wirklich gemacht wird. Wir orientieren uns im Ökosystem und erhalten einen Überblick über die Fähigkeiten und Grenzen der Standards rund um Web Components. Von den absoluten API-Grundlagen bis zum Einsatz ausgewachsener Komponenten-Frameworks lassen wir keinen Schritt aus. In jedem Abschnitt unserer Reise erfahren wir nicht nur, wie etwas funktioniert, sondern auch, warum. Dieses Tutorial macht uns nicht nur zu Web-Component-Expert:innen, sondern vertieft auch unser Verständnis der Web-Plattform insgesamt.\n'indexBrandName': 'InternationalJavaScriptCon'\n'indexSeriesName': ''\n'author': 'Peter Kröner'\n'chunkSource': 'text'\n'text': komplett ignorieren, aber dann besprechen werde. Also Bundler und Compiler und Optimizer, wie kann ich irgendwie TypeScript in meinen Web Components benutzen und wie sinnvoll ist das? Das werden wir da alles besprechen, das wird einfach so eine bunte Tool Show werden und das bietet dann so bisschen den Abschluss der Orientierungsphase. Danach seid ihr hoffentlich in der Lage, euch selbst auszusuchen, wie ihr denn operieren möchtet. Wollt ihr Vanilla Web Components schreiben oder wollt ihr ein Framework verwenden oder vielleicht irgendwas dazwischen euch gar, Gott bewahre, was eigenes bauen, das kann man dann nämlich relativ gut machen, das werden wir alles mal durchgekaut haben. Und zum Abschluss bauen wir einmal so eine Web Component wirklich von vorne bis hinten, beginnend bei einer blanken Datei und endend bei einem komplett, ja, alle Features benutzenden Objekte, einem Element. Ich habe mir da so einen Dark Mode Selektor ausgedacht, weil naja, das ist glaube ich, ganz gutes Beispiel. So Dark Mode Selektor ist was, das braucht man ständig, so ziemlich jede Webseite sollte sowas haben, dass man das so troggeln kann auf einer Pro Seitenbasis. Und es ist auch irgendwie was, wo jeder von uns glaube ich, ganz gut umreißen kann, was so die Anforderungen von sowas sind. Dark Mode Selektor kennen wir alle. Aber zum anderen ist es halt eben auch nicht ganz trivial, so ein Ding zu bauen. Da gibt es viele, viele Feinheiten. Es muss irgendwie interaktiv sein, es muss irgendwie einigermaßen zugänglich sein, es muss per Tastatur bedienbar sein, es muss universell sein, anpassbar sein und es muss halt eben auch eine ganze Menge komplizierten Zustand managen. Es muss sich irgendwie initialisieren, entweder irgendwelchen vorherigen State aus dem Storage lesen den wir schon mal eingestellt haben, oder sich initialisieren, abhängig davon, was die Einstellungen sind. Das ist also alles gar nicht mal so trivial, wenn man anfängt, drüber nachzudenken, und wir werden einfach mal das dadurch exerzieren, weil das, glaube ich, eine gute Demonstration ist, wo man dann auch wirklich mal jeden Aspekt von allem, was wir bisher besprochen haben, werden einmal\n'slidetext': ''\n'from': 'index'\n'score': 37.79056167602539\n'normalizedScore': 0.3779056167602539\n'beforeDatePenaltyScore': 0.3779056167602539\n\n'documentId': 'a5dcfc84b51456a6b4b27fce'\n'chunk_id': '6878ecf022599b00136894c2'\n'access': 'granted'\n'part_number': 4\n'total_parts': 77\n'contentType': 'TUTORIAL'\n'title': Die Welt der Web Components\n'parentName': Web Components von 0 auf 100\n'language': 'DE'\n'date': '2025-06-05T13:45:07.000Z'\n'abstract': In der ersten Lesson steigen wir in die Welt der Web Components ein. Wir richten unser Setup ein, klären die Ziele des Tutorials – und schreiben unser erstes „Hello World“. Dabei beantworten wir die Grundfrage: Was sind Web Components eigentlich? Wir schauen uns Content-Attribute und DOM-Properties an, ziehen den Vergleich zu Frameworks und klären, wo Web Components glänzen – und wo nicht. Best Practices und erste UI-Beispiele runden den Einstieg ab.\n'parentId': '54cce7e83417cbefa7c0d3f0'\n'parentDescription': Web Components versprechen universelle Frontend-Komponenten, frei von Framework-Fesseln und Dependency-Depression. Das Problem: Web Components sind komplex, manche APIs wirken eigenartig, und das sie umgebende Ökosystem ist unübersichtlich. Was können Web Components leisten – und was nicht? Brauche ich wirklich Shadow DOM oder kann ich darauf verzichten? Vanilla-Komponenten, Lit – oder etwas dazwischen? In diesem Tutorial lernen wir, wie der Komponenten-Eintopf wirklich gemacht wird. Wir orientieren uns im Ökosystem und erhalten einen Überblick über die Fähigkeiten und Grenzen der Standards rund um Web Components. Von den absoluten API-Grundlagen bis zum Einsatz ausgewachsener Komponenten-Frameworks lassen wir keinen Schritt aus. In jedem Abschnitt unserer Reise erfahren wir nicht nur, wie etwas funktioniert, sondern auch, warum. Dieses Tutorial macht uns nicht nur zu Web-Component-Expert:innen, sondern vertieft auch unser Verständnis der Web-Plattform insgesamt.\n'indexBrandName': 'InternationalJavaScriptCon'\n'indexSeriesName': ''\n'author': 'Peter Kröner'\n'chunkSource': 'text'\n'text': viele Trade-offs zu bedenken, sehr viele Details. ist alles sehr, kompliziert und wie gesagt, Orientierung ist hier mein Ziel und ich glaube, das wird besonders da notwendig sein. Die Web Component selber wird aber ziemlich langweilig, wenn die einfach nur ein User Interface rendert. Die muss noch ein bisschen mehr tun als das und deswegen werden wir in einem dritten Teil über Events und Life Cycle reden. Das sind so zwei Themen, jetzt technisch nicht wirklich zusammenhängen aber ich habe es dann mal zusammengemanst weil sie das gleiche wollen, nämlich Interaktivität und Reaktionen managen. Sprich, wie initialisiere ich meine Web Component, auf welche Events kann die reagieren und wenn in meiner Web Component irgendwas spannendes passiert, Daten werden geladen oder irgendwer klickt was an, dann will man ja auch ein Event auslösen. Und wie das genau geht und was man da bedenken kann, welche Techniken und Patterns man verwenden kann, das werden wir da besprechen. dabei werden wir unter anderem uns auch an der Mottenkiste der Webentwicklung bedienen, also ein paar ganz ganz alte Sachen wieder entstauben, die könnten dann nämlich im Kontext von Web Components wieder relevant werden. Und das deckt so ziemlich den ganzen Basic Aspekt ab, dann werden wir wirklich jedes interessante Detail einmal gesehen haben und viel zu viel darüber gelernt haben, warum die Dinge so funktionieren, wie sie funktionieren. Nachdem man das zur Kenntnis genommen hat, möchte man vielleicht sagen, das ist ja alles nett, ich will das alles nicht wissen, ich möchte lieber ein High Level Tool verwenden, um Web Components zu bauen. Und dann werden wir da mal ein bisschen drüber reden, also was gibt es so für Web Component Frameworks zum Beispiel, so Sachen wie Lit M zum Beispiel, müssten wir da mal durchsprechen, mal eine Demo machen und ein bisschen so die Tradeoffs diskutieren. Und dann gibt es ja noch viele, viele andere Dinge, die so im modernen Web Stack drin sind, die ich bis zu diesem Punkt komplett ignorieren, aber dann besprechen werde. Also Bundler und Compiler und Optimizer, wie kann ich irgendwie TypeScript in meinen Web Components benutzen und wie sinnvoll ist das? Das werden wir da alles besprechen, das\n'slidetext': ''\n'from': 'index'\n'score': 37.79056167602539\n'normalizedScore': 0.3779056167602539\n'beforeDatePenaltyScore': 0.3779056167602539\n\n'documentId': 'a5dcfc84b51456a6b4b27fce'\n'chunk_id': '6878ecf022599b00136894c1'\n'access': 'granted'\n'part_number': 3\n'total_parts': 77\n'contentType': 'TUTORIAL'\n'title': Die Welt der Web Components\n'parentName': Web Components von 0 auf 100\n'language': 'DE'\n'date': '2025-06-05T13:45:07.000Z'\n'abstract': In der ersten Lesson steigen wir in die Welt der Web Components ein. Wir richten unser Setup ein, klären die Ziele des Tutorials – und schreiben unser erstes „Hello World“. Dabei beantworten wir die Grundfrage: Was sind Web Components eigentlich? Wir schauen uns Content-Attribute und DOM-Properties an, ziehen den Vergleich zu Frameworks und klären, wo Web Components glänzen – und wo nicht. Best Practices und erste UI-Beispiele runden den Einstieg ab.\n'parentId': '54cce7e83417cbefa7c0d3f0'\n'parentDescription': Web Components versprechen universelle Frontend-Komponenten, frei von Framework-Fesseln und Dependency-Depression. Das Problem: Web Components sind komplex, manche APIs wirken eigenartig, und das sie umgebende Ökosystem ist unübersichtlich. Was können Web Components leisten – und was nicht? Brauche ich wirklich Shadow DOM oder kann ich darauf verzichten? Vanilla-Komponenten, Lit – oder etwas dazwischen? In diesem Tutorial lernen wir, wie der Komponenten-Eintopf wirklich gemacht wird. Wir orientieren uns im Ökosystem und erhalten einen Überblick über die Fähigkeiten und Grenzen der Standards rund um Web Components. Von den absoluten API-Grundlagen bis zum Einsatz ausgewachsener Komponenten-Frameworks lassen wir keinen Schritt aus. In jedem Abschnitt unserer Reise erfahren wir nicht nur, wie etwas funktioniert, sondern auch, warum. Dieses Tutorial macht uns nicht nur zu Web-Component-Expert:innen, sondern vertieft auch unser Verständnis der Web-Plattform insgesamt.\n'indexBrandName': 'InternationalJavaScriptCon'\n'indexSeriesName': ''\n'author': 'Peter Kröner'\n'chunkSource': 'text'\n'text': Wurst gemacht wird, in die Spezifikationen eintauchen und schauen, warum gewisse Dinge bei Web Components besser funktionieren als bei Frameworks. Und warum es manchmal wirklich unverhältnismäßig viel Aufwand verursachen zu scheint, gewisse Dinge zu lösen. Das ergibt nämlich alles Sinn, wenn man das Big Picture verstanden hat. Wie gesagt, das ist so bisschen mein Ziel. Ich will euch eben genau das bieten, was ihr nicht einfach irgendwo nachlesen könnt, was euch ChetJPT nicht mal eben so sagen kann. Nämlich Orientierung und das Big Picture und die ganzen technischen Details eben auch, damit wir die mal gesehen haben. Um das Ganze zu machen, habe ich mir folgende Agenda überlegt. Wir beginnen mit so einem kleinen Intro, einem Einstieg in die wunderbare Welt der Web Components. Da möchte ich erst mal klären, was jetzt dieses Video ist, was ist so unsere generelle Herangehensweise, was wollen wir erreichen, was müsst ihr drauf haben, um mir hier folgen zu können. Und wir werden einmal kurz eine Web Component gebaut haben, so hallo weltmäßig, und wir werden alles mal benutzt haben. Wir werden also einmal ein Custom Element definiert haben. werden ein paar Attribute gemanagt haben. Wir werden mal ein Shadowroot angelegt haben und das alles wird mehr so auf der Ebene einer Demo sein, dass wir irgendwie mal gesehen haben. Das gibt so funktioniert, dass das so die grundsätzliche Idee und wir werden dann in den folgenden Lessons hier tiefer in die jeweiligen Details einsteigen. Zum Beispiel ist nach dem Intro Block und dem Hallo Welt und dem ganzen Drumherum der zweite Block direkt der, bei dem es ganz genau um Shadow Dom geht. Das ist eins der kompliziertesten Themen im ganzen Reich von Web Components. Wie definiere ich wirklich eigene UIs mit Web Components? Und wir werden darüber reden, wie das funktioniert, warum das so seltsam geht, was es da für Varianten und Spielarten von gibt, ob man das haben möchte oder nicht. Da gibt es sehr viele Trade-offs zu bedenken, sehr viele Details. ist alles sehr, kompliziert und wie gesagt, Orientierung ist hier mein Ziel und ich glaube, das wird besonders da notwendig sein. Die Web Component selber wird\n'slidetext': ''\n'from': 'index'\n'score': 37.79056167602539\n'normalizedScore': 0.3779056167602539\n'beforeDatePenaltyScore': 0.3779056167602539\n\n'documentId': 'a5dcfc84b51456a6b4b27fce'\n'chunk_id': '6878ecf022599b00136894c0'\n'access': 'granted'\n'part_number': 2\n'total_parts': 77\n'contentType': 'TUTORIAL'\n'title': Die Welt der Web Components\n'parentName': Web Components von 0 auf 100\n'language': 'DE'\n'date': '2025-06-05T13:45:07.000Z'\n'abstract': In der ersten Lesson steigen wir in die Welt der Web Components ein. Wir richten unser Setup ein, klären die Ziele des Tutorials – und schreiben unser erstes „Hello World“. Dabei beantworten wir die Grundfrage: Was sind Web Components eigentlich? Wir schauen uns Content-Attribute und DOM-Properties an, ziehen den Vergleich zu Frameworks und klären, wo Web Components glänzen – und wo nicht. Best Practices und erste UI-Beispiele runden den Einstieg ab.\n'parentId': '54cce7e83417cbefa7c0d3f0'\n'parentDescription': Web Components versprechen universelle Frontend-Komponenten, frei von Framework-Fesseln und Dependency-Depression. Das Problem: Web Components sind komplex, manche APIs wirken eigenartig, und das sie umgebende Ökosystem ist unübersichtlich. Was können Web Components leisten – und was nicht? Brauche ich wirklich Shadow DOM oder kann ich darauf verzichten? Vanilla-Komponenten, Lit – oder etwas dazwischen? In diesem Tutorial lernen wir, wie der Komponenten-Eintopf wirklich gemacht wird. Wir orientieren uns im Ökosystem und erhalten einen Überblick über die Fähigkeiten und Grenzen der Standards rund um Web Components. Von den absoluten API-Grundlagen bis zum Einsatz ausgewachsener Komponenten-Frameworks lassen wir keinen Schritt aus. In jedem Abschnitt unserer Reise erfahren wir nicht nur, wie etwas funktioniert, sondern auch, warum. Dieses Tutorial macht uns nicht nur zu Web-Component-Expert:innen, sondern vertieft auch unser Verständnis der Web-Plattform insgesamt.\n'indexBrandName': 'InternationalJavaScriptCon'\n'indexSeriesName': ''\n'author': 'Peter Kröner'\n'chunkSource': 'text'\n'text': aber die Entscheidung zu treffen, man das machen möchte und wenn ja, auf welche Weise, muss man die ganzen Basics verstanden haben. Und das ist so ein bisschen meine Idee mit diesem Videotraining. Ich will euch wirklich zeigen, wie die Wurst wirklich gemacht wird, was Web-Components sind, wie sie ticken, was sie können, was sie nicht können. Und euch dann auch ein bisschen die Toolbox dazu vorstellen, aber wir beginnen wirklich mit den Basics. Und das soll euch dann hoffentlich das Mittel geben, die Wissenslücken stopfen und vor allen Dingen Orientierung bieten. Dass ihr so bisschen eine Idee habt, dieser ganze Web-Components-Zirkus zusammenpasst. Also Shadowdome, was denn das? Brauche ich das oder brauche ich das nicht? Web-Components, was können die? Warum will ich vielleicht ein Framework haben? Warum möchte ich eventuell keins benutzen? Das muss man alles erstmal irgendwie klären. Das Ganze ist nicht wirklich so ein Hochglanzprodukt wie ein React, wo man irgendwie sagen kann, da ist die Dokumentation, lese es, verstehe es, sondern das ist alles so ein Standards durcheinander. Und wie gesagt, Orientierung ist mein Ziel. Das ist so mein Primärziel zumindest. Ich will euch auch die ganzen technischen Details zumindest mal gezeigt haben. Aber sind wir mal ehrlich, ihr hier, ihr seid keine Hohlbratzen oder? Ihr könnt euch selber Sachen drauf schaffen, wenn ihr wisst, wo es steht. Es ist nicht wirklich nötig für mich, euch wirklich jede einzelne Funktion vorzubeten und dafür zu sorgen, dass ihr euch hier einprägt. Entweder könnt ihr googeln oder eure freundliche KI, schreibt euch sowieso die Hälfte des Codes. Ihr müsst wirklich nur wissen, wie hängt alles zusammen, was das Big Picture und vielleicht alles mal gesehen haben. Das ist so die Idee, die ich hier verfolge. Bedeutet aber auch Blut, Schweiß und Tränen, wie schon erwähnt. Wir werden uns wirklich genau anschauen, wie die Wurst gemacht wird, in die Spezifikationen eintauchen und schauen, warum gewisse Dinge bei Web Components besser funktionieren als bei Frameworks. Und warum es manchmal wirklich unverhältnismäßig viel Aufwand verursachen zu\n'slidetext': ''\n'from': 'index'\n'score': 37.79056167602539\n'normalizedScore': 0.3779056167602539\n'beforeDatePenaltyScore': 0.3779056167602539\n\n'documentId': 'a5dcfc84b51456a6b4b27fce'\n'chunk_id': '6878ecf322599b00136894d8'\n'access': 'granted'\n'part_number': 25\n'total_parts': 77\n'contentType': 'TUTORIAL'\n'title': Die Welt der Web Components\n'parentName': Web Components von 0 auf 100\n'language': 'DE'\n'date': '2025-06-05T13:45:07.000Z'\n'abstract': In der ersten Lesson steigen wir in die Welt der Web Components ein. Wir richten unser Setup ein, klären die Ziele des Tutorials – und schreiben unser erstes „Hello World“. Dabei beantworten wir die Grundfrage: Was sind Web Components eigentlich? Wir schauen uns Content-Attribute und DOM-Properties an, ziehen den Vergleich zu Frameworks und klären, wo Web Components glänzen – und wo nicht. Best Practices und erste UI-Beispiele runden den Einstieg ab.\n'parentId': '54cce7e83417cbefa7c0d3f0'\n'parentDescription': Web Components versprechen universelle Frontend-Komponenten, frei von Framework-Fesseln und Dependency-Depression. Das Problem: Web Components sind komplex, manche APIs wirken eigenartig, und das sie umgebende Ökosystem ist unübersichtlich. Was können Web Components leisten – und was nicht? Brauche ich wirklich Shadow DOM oder kann ich darauf verzichten? Vanilla-Komponenten, Lit – oder etwas dazwischen? In diesem Tutorial lernen wir, wie der Komponenten-Eintopf wirklich gemacht wird. Wir orientieren uns im Ökosystem und erhalten einen Überblick über die Fähigkeiten und Grenzen der Standards rund um Web Components. Von den absoluten API-Grundlagen bis zum Einsatz ausgewachsener Komponenten-Frameworks lassen wir keinen Schritt aus. In jedem Abschnitt unserer Reise erfahren wir nicht nur, wie etwas funktioniert, sondern auch, warum. Dieses Tutorial macht uns nicht nur zu Web-Component-Expert:innen, sondern vertieft auch unser Verständnis der Web-Plattform insgesamt.\n'indexBrandName': 'InternationalJavaScriptCon'\n'indexSeriesName': ''\n'author': 'Peter Kröner'\n'chunkSource': 'text'\n'text': keinerlei besondere patterns die zu beachten sind wir schreiben eine ganz normale klasse und machen ganz normale programmierung ich meine wer sich einigermaßen im nativen javascript auskennt der weiß was curry selektor ist und solchen leuten müssen wir nicht erklären dass es jetzt einfach ein neues html tag gibt wir sagen das ist jetzt da das hat diese features und die menschen können los gehen und die können das benutzen und die müssen nichts weiter wissen die wissen was ein event listener macht das können sie mit dem diff machen das können sie genauso gut mit unserem element machen und das ist schon mal sehr sehr fein wir brauchen einfach nichts zu installieren dieses ganze nervige permanente geupdate was mit moderner webentwicklung einhergeht bleibt uns komplett erspart wir gehen einfach hin und tippen drauf los ohne auf irgendwas zu warten ohne irgendwelche sicherheitslücken zu patchen gehirn aus ab dafür funktioniert super aber es gibt noch einen weiteren vorteil der damit einhergeht unser hallo welt element hier ist im prinzip nichts weiter als ein html element es mag ein bisschen seltsam sein weil wir das gebaut haben mit javascript und ist nicht so ein c++ ausfluss aus dem nativen browser ist aber ganz grundsätzlich und technisch gesehen sogar strikt gesprochen steht es auf einer ebene mit den tables und den diffs dieser welt es ist davon nicht wirklich zu unterscheiden und das hat spannende implikationen für die mit diesen ganzen elendigen sachen die die moderne webentwicklung da so beinhaltet ich habe hier mal ein reakt beispiel das ist jetzt nicht das beste reakt beispiel so macht man das nicht wirklich aber ich habe mal das reakt hallo welt von der reakt webseite kopiert und hier eingefügt im hintergrund ein bildprozess gebaut und den ganzen krempel gemacht in moderne webentwicklung halt eben so beinhaltet ich habe nicht wirklich was speziell gegen reakt aber es ist halt eben keine web components also warum würde man das machen wollen naja keine ahnung mag halt nicht meine entscheidungen sein vielleicht arbeite irgendwo wo reakt oder angular oder view oder sonst irgendwas verwendet und aus irgendwelchen gründen bin ich jetzt der meinung web components müssen hier mitspielen das gute ist das ist exakt gar kein problem denn\n'slidetext': ''\n'from': 'index'\n'score': 37.79056167602539\n'normalizedScore': 0.3779056167602539\n'beforeDatePenaltyScore': 0.3779056167602539\n\n'documentId': 'a5dcfc84b51456a6b4b27fce'\n'chunk_id': '6878ecf322599b00136894d7'\n'access': 'granted'\n'part_number': 24\n'total_parts': 77\n'contentType': 'TUTORIAL'\n'title': Die Welt der Web Components\n'parentName': Web Components von 0 auf 100\n'language': 'DE'\n'date': '2025-06-05T13:45:07.000Z'\n'abstract': In der ersten Lesson steigen wir in die Welt der Web Components ein. Wir richten unser Setup ein, klären die Ziele des Tutorials – und schreiben unser erstes „Hello World“. Dabei beantworten wir die Grundfrage: Was sind Web Components eigentlich? Wir schauen uns Content-Attribute und DOM-Properties an, ziehen den Vergleich zu Frameworks und klären, wo Web Components glänzen – und wo nicht. Best Practices und erste UI-Beispiele runden den Einstieg ab.\n'parentId': '54cce7e83417cbefa7c0d3f0'\n'parentDescription': Web Components versprechen universelle Frontend-Komponenten, frei von Framework-Fesseln und Dependency-Depression. Das Problem: Web Components sind komplex, manche APIs wirken eigenartig, und das sie umgebende Ökosystem ist unübersichtlich. Was können Web Components leisten – und was nicht? Brauche ich wirklich Shadow DOM oder kann ich darauf verzichten? Vanilla-Komponenten, Lit – oder etwas dazwischen? In diesem Tutorial lernen wir, wie der Komponenten-Eintopf wirklich gemacht wird. Wir orientieren uns im Ökosystem und erhalten einen Überblick über die Fähigkeiten und Grenzen der Standards rund um Web Components. Von den absoluten API-Grundlagen bis zum Einsatz ausgewachsener Komponenten-Frameworks lassen wir keinen Schritt aus. In jedem Abschnitt unserer Reise erfahren wir nicht nur, wie etwas funktioniert, sondern auch, warum. Dieses Tutorial macht uns nicht nur zu Web-Component-Expert:innen, sondern vertieft auch unser Verständnis der Web-Plattform insgesamt.\n'indexBrandName': 'InternationalJavaScriptCon'\n'indexSeriesName': ''\n'author': 'Peter Kröner'\n'chunkSource': 'text'\n'text': components machen ist ja wenig mehr als uns in diesen mechanismus einzuklingen oder wir gehen ja auch hin und definieren ein programmierinterface indem wir eine javascript klasse schreiben und wenn wir dem browser sagen diese javascript klasse enthält diese und jenen features und wir melden sie mit custom elements dort define beim browser und sagen hey übrigens diese klasse ist mit diesem html tag assoziiert dann hat der browser alle informationen um diesen serialisierungs und deserialisierungs mechanismus umzusetzen wir machen also das gleiche wie die spezifikation sagen hier ist ein html tag hier ist eine klasse die das programmierinterface beschreibt und dann gibt es noch so kram die attribute und so zu denen kommen wir gleich aber das ist wirklich alles was wir brauchen und damit kriegen wir sin dass wir das set von html elementen erweitern um unsere eigenen schönen kleinen ergänzungen das ist also warum das ganze funktioniert und warum wir diesen weg über javascript gehen und nicht irgendein anderen einfach weil es der normale natürliche korrekte weg ist die spannende frage ist aber immer noch warum sollten wir überhaupt aufbrechen und diesen weg beschreiten was haben wir davon wenn wir web components machen brauchen wir das können wir nicht einfach mit reakt arbeiten oder was ähnlichem die antwort darauf ist natürlich ein ganz klares ja wenn ihr mich fragt gibt es im wesentlichen einen guten grund um web components zu benutzen und diese eine gute grund ist web components sind einfach ein bestandteil der ganz normalen nativen webplattform das hat diverse interessante vorteile und eine ganze menge nachteile aber zu denen kommen wir später erst mal zu den vorteilen was sehen wir hier wenn wir noch mal unser hallo welt uns anschauen wir sehen dass wir einfach nur eine ganz normale html seite haben und ein bisschen javascript code und das war es kein framework kein package keine software nicht zu installieren nicht zu updaten alles ist einfach so im browser da wir brauchen nichts zu tun als auf los zu programmieren und es gibt keinerlei besondere patterns die zu beachten sind wir schreiben eine ganz normale klasse und machen ganz normale programmierung ich meine wer sich einigermaßen im nativen javascript auskennt der weiß was curry selektor ist und solchen\n'slidetext': ''\n'from': 'index'\n'score': 37.79056167602539\n'normalizedScore': 0.3779056167602539\n'beforeDatePenaltyScore': 0.3779056167602539\n\n'documentId': 'a5dcfc84b51456a6b4b27fce'\n'chunk_id': '6878ecf222599b00136894d6'\n'access': 'granted'\n'part_number': 23\n'total_parts': 77\n'contentType': 'TUTORIAL'\n'title': Die Welt der Web Components\n'parentName': Web Components von 0 auf 100\n'language': 'DE'\n'date': '2025-06-05T13:45:07.000Z'\n'abstract': In der ersten Lesson steigen wir in die Welt der Web Components ein. Wir richten unser Setup ein, klären die Ziele des Tutorials – und schreiben unser erstes „Hello World“. Dabei beantworten wir die Grundfrage: Was sind Web Components eigentlich? Wir schauen uns Content-Attribute und DOM-Properties an, ziehen den Vergleich zu Frameworks und klären, wo Web Components glänzen – und wo nicht. Best Practices und erste UI-Beispiele runden den Einstieg ab.\n'parentId': '54cce7e83417cbefa7c0d3f0'\n'parentDescription': Web Components versprechen universelle Frontend-Komponenten, frei von Framework-Fesseln und Dependency-Depression. Das Problem: Web Components sind komplex, manche APIs wirken eigenartig, und das sie umgebende Ökosystem ist unübersichtlich. Was können Web Components leisten – und was nicht? Brauche ich wirklich Shadow DOM oder kann ich darauf verzichten? Vanilla-Komponenten, Lit – oder etwas dazwischen? In diesem Tutorial lernen wir, wie der Komponenten-Eintopf wirklich gemacht wird. Wir orientieren uns im Ökosystem und erhalten einen Überblick über die Fähigkeiten und Grenzen der Standards rund um Web Components. Von den absoluten API-Grundlagen bis zum Einsatz ausgewachsener Komponenten-Frameworks lassen wir keinen Schritt aus. In jedem Abschnitt unserer Reise erfahren wir nicht nur, wie etwas funktioniert, sondern auch, warum. Dieses Tutorial macht uns nicht nur zu Web-Component-Expert:innen, sondern vertieft auch unser Verständnis der Web-Plattform insgesamt.\n'indexBrandName': 'InternationalJavaScriptCon'\n'indexSeriesName': ''\n'author': 'Peter Kröner'\n'chunkSource': 'text'\n'text': naja und da sehen wir schon wie diese beiden dinger wirklich zusammenhängen wie dieses diagramm dass ich hier aufgemalt habe tatsächlich einigermaßen ok beschreibt was vor sich geht oder html ist eine repräsentation von html elementen dokumenten und das kann man in eine repräsentation verwandeln ins dom dass die browser verstehen und man kann dieses dom auch zurück verwandeln in html kein eins zu eins aber es passt so einigermaßen gut so die spannende frage ist halt also wenn das so funktioniert dann was ist dieses dom eigentlich naja im wesentlichen ist es eine sehr komplizierte verkettete liste wo elemente wie irgendwelche bodies und html elemente kindelemente haben das sind dann unsere dibs und tables und die haben wiederum kindelemente wie ars und bs und ähnliches und die sind einfach miteinander verknüpft da gibt es eine ganze menge von komplizierten apis auf die ich jetzt nicht im detail eingehen möchte aber im wesentlichen ist es nicht reichische baumstruktur top to bottom mit ganz ganz vielen quer verweisen und eine ganze menge von apis jedes von diesen elementen die wir da sehen also sowohl ein document als auch ein diff als auch ein a als auch ein b als auch eine textnote tatsächlich haben ein programmierinterface haben irgendwas was so ähnlich wie eine javascript klasse beinhaltet welche getter und setter es gibt welche metoden vorhanden sind und naja so kann man das ganze ding programmieren und als nebenwirkung fällt da auch html raus wenn wir halt eben diese attribute und tags und informationen halt eben haben können wir daraus eine serialisierung bauen einfach nur einen string das unterliegt gewissen regeln und ist verlust behaftet wie wir gerade gesehen haben aber das ist wirklich wie die wurst tatsächlich gemacht wird wir definieren das programmierinterface und sagen wie die in memory repräsentation im browser aussieht und leiten dann daraus ab wie html tickt und das ist wirklich wie es funktioniert wie es im modernen browser in den html spezifikation tatsächlich gedacht ist und was wir web components machen ist ja wenig mehr als uns in diesen mechanismus einzuklingen oder wir gehen ja auch hin und definieren ein programmierinterface indem wir eine javascript klasse schreiben und wenn wir dem browser sagen diese\n'slidetext': ''\n'from': 'index'\n'score': 37.79056167602539\n'normalizedScore': 0.3779056167602539\n'beforeDatePenaltyScore': 0.3779056167602539\n\n'documentId': 'a5dcfc84b51456a6b4b27fce'\n'chunk_id': '6878ecf222599b00136894d5'\n'access': 'granted'\n'part_number': 22\n'total_parts': 77\n'contentType': 'TUTORIAL'\n'title': Die Welt der Web Components\n'parentName': Web Components von 0 auf 100\n'language': 'DE'\n'date': '2025-06-05T13:45:07.000Z'\n'abstract': In der ersten Lesson steigen wir in die Welt der Web Components ein. Wir richten unser Setup ein, klären die Ziele des Tutorials – und schreiben unser erstes „Hello World“. Dabei beantworten wir die Grundfrage: Was sind Web Components eigentlich? Wir schauen uns Content-Attribute und DOM-Properties an, ziehen den Vergleich zu Frameworks und klären, wo Web Components glänzen – und wo nicht. Best Practices und erste UI-Beispiele runden den Einstieg ab.\n'parentId': '54cce7e83417cbefa7c0d3f0'\n'parentDescription': Web Components versprechen universelle Frontend-Komponenten, frei von Framework-Fesseln und Dependency-Depression. Das Problem: Web Components sind komplex, manche APIs wirken eigenartig, und das sie umgebende Ökosystem ist unübersichtlich. Was können Web Components leisten – und was nicht? Brauche ich wirklich Shadow DOM oder kann ich darauf verzichten? Vanilla-Komponenten, Lit – oder etwas dazwischen? In diesem Tutorial lernen wir, wie der Komponenten-Eintopf wirklich gemacht wird. Wir orientieren uns im Ökosystem und erhalten einen Überblick über die Fähigkeiten und Grenzen der Standards rund um Web Components. Von den absoluten API-Grundlagen bis zum Einsatz ausgewachsener Komponenten-Frameworks lassen wir keinen Schritt aus. In jedem Abschnitt unserer Reise erfahren wir nicht nur, wie etwas funktioniert, sondern auch, warum. Dieses Tutorial macht uns nicht nur zu Web-Component-Expert:innen, sondern vertieft auch unser Verständnis der Web-Plattform insgesamt.\n'indexBrandName': 'InternationalJavaScriptCon'\n'indexSeriesName': ''\n'author': 'Peter Kröner'\n'chunkSource': 'text'\n'text': auch einfach zurückspulen dann sieht er dass ich recht habe der punkt ist der current time ist ein offizielles feature von diesem programmier interface vom videoelement das gehört da offiziell rein aber wenn ich jetzt hingehe und ich mache noch einmal video dort auto html dann werden wir feststellen dass tatsächlich hier vom current time nichts zu sehen ist in diesem html string obwohl das ding offiziell supportet ist ein ganz legitimes feature von videoelementen ich habe ja hier zufälligerweise die spezifikationen offen ich muss das gar nicht behaupten ich kann es euch zeigen auf geht's videoelement videoelement da ist es und jetzt wird es wahrscheinlich wird sich wahrscheinlich rausstellen dass das ganze sehr komplizierter ist als ich das gedacht habe weil das vermutlich irgendwo anders definiert ist als im videoelement selber wir schauen mal hier im interface nach da steht selber nicht drin aber wie man das hier lesen muss ist das videoelement ist ein subtyp vom html mediaelement und wenn ich zur mediaelement hingehe dann erwarte ich jetzt hier zu sehen dass es hier irgendwo eine current time gibt jawohl da ist sie ha ha wunderbar wir sehen also offizielles feature offiziell supportet teil der spezifikation aber es kommt eben in html nicht vor weil einfach der serialisierungs algoritmus des ganzen nicht vorsieht dass dieses attribut vom current time sich in html wiederfindet das gibt es nur im dom nur in dieser in memory repräsentation in dem gepaarsten tree ist es wirklich vorhanden und anderswo ist es das halt eben nicht und das muss ja auch nicht wirklich ein großes problem sein ich meine will man das wirklich wenn man per html den aktuellen zustand also die zeitmarke setzen können braucht man wahrscheinlich eher selten wahrscheinlich ist dieses feature vor allen dingen dann relevant wenn man irgendwas um ein video player drumherum programmiert sein eigenes interface baut oder sowas in der richtung dann will man natürlich dieses feature haben aber für html ist es zumindest laut meinung der html designer nicht wirklich notwendig naja und da sehen wir schon wie diese beiden dinger wirklich zusammenhängen wie dieses diagramm dass ich hier aufgemalt habe tatsächlich einigermaßen ok beschreibt was vor sich geht oder html ist eine\n'slidetext': ''\n'from': 'index'\n'score': 37.79056167602539\n'normalizedScore': 0.3779056167602539\n'beforeDatePenaltyScore': 0.3779056167602539\n\n'documentId': 'a5dcfc84b51456a6b4b27fce'\n'chunk_id': '6878ecf222599b00136894d4'\n'access': 'granted'\n'part_number': 21\n'total_parts': 77\n'contentType': 'TUTORIAL'\n'title': Die Welt der Web Components\n'parentName': Web Components von 0 auf 100\n'language': 'DE'\n'date': '2025-06-05T13:45:07.000Z'\n'abstract': In der ersten Lesson steigen wir in die Welt der Web Components ein. Wir richten unser Setup ein, klären die Ziele des Tutorials – und schreiben unser erstes „Hello World“. Dabei beantworten wir die Grundfrage: Was sind Web Components eigentlich? Wir schauen uns Content-Attribute und DOM-Properties an, ziehen den Vergleich zu Frameworks und klären, wo Web Components glänzen – und wo nicht. Best Practices und erste UI-Beispiele runden den Einstieg ab.\n'parentId': '54cce7e83417cbefa7c0d3f0'\n'parentDescription': Web Components versprechen universelle Frontend-Komponenten, frei von Framework-Fesseln und Dependency-Depression. Das Problem: Web Components sind komplex, manche APIs wirken eigenartig, und das sie umgebende Ökosystem ist unübersichtlich. Was können Web Components leisten – und was nicht? Brauche ich wirklich Shadow DOM oder kann ich darauf verzichten? Vanilla-Komponenten, Lit – oder etwas dazwischen? In diesem Tutorial lernen wir, wie der Komponenten-Eintopf wirklich gemacht wird. Wir orientieren uns im Ökosystem und erhalten einen Überblick über die Fähigkeiten und Grenzen der Standards rund um Web Components. Von den absoluten API-Grundlagen bis zum Einsatz ausgewachsener Komponenten-Frameworks lassen wir keinen Schritt aus. In jedem Abschnitt unserer Reise erfahren wir nicht nur, wie etwas funktioniert, sondern auch, warum. Dieses Tutorial macht uns nicht nur zu Web-Component-Expert:innen, sondern vertieft auch unser Verständnis der Web-Plattform insgesamt.\n'indexBrandName': 'InternationalJavaScriptCon'\n'indexSeriesName': ''\n'author': 'Peter Kröner'\n'chunkSource': 'text'\n'text': genau wie man es meinen möchte aber wo ist denn jetzt tatsächlich diese lustbehaftete aspekt davon naja ich habe unser videoelement das ist ja ein ganz normales javascript objekt mit offiziell vorhandenen metoden wie dem source attribute und diesen buffer timestamp geschichten das ist alles da aber es ist nur ein ganz normales javascript objekt und weil es ein ganz normales javascript objekt ist kann ich mit dem ding alles machen was ich möchte ich kann da felder drauf stecken die gar nicht vom standard vorgesehen sind ist das sinnvoll kann ich es machen auf jeden fall das ist insofern definitiv ein feature des ganzen weil ist ja bloß ein javascript objekt natürlich kann ich da dinge drauf stecken gar kein problem kann ich machen ist da video dort fu steht jetzt auf 42 und wenn ich mir das ausgeben lasse video dort fu dann ist es da schreibt mit 42 in die konsole alles funktioniert aber weil video dort fu speziell diese fu property kein bestandteil vom offiziellen html ist kann ich jetzt wenn ich dieses videoelement noch mal zurück verwandle in html mit video dort outer html kriegt den gleichen html string wie vorher meine änderung dass da jetzt ein fu fällt drauf wohnt mit dem wert 42 drin wird von der ganzen gesichtgeschichte nicht reflektiert jetzt könnte man natürlich sagen natürlich wird das nicht reflektiert das ist ja auch nichts was offiziell supportet ist das kann da gar nicht drin vorkommen und dann gibt es noch ein weitere sachen die da drin nicht reflektiert werden zum beispiel ist es so dass video und audioelemente ein feature unterstützen namens current damit kann ich setzen wo auf dem zeitstrahl in dem video ich mich gerade befinde da kann ich jetzt irgendwas reinschreiben und das wird dann gesetzt und das ist auch da und das funktioniert und das wird wieder ausgegeben das ist ein offizielles feature kann man so ein bisschen daran erkennen dass es hier in dieser auto completion auswahl von anfang an mit drin war ich meine jetzt ist natürlich da weil ich habe sie reingeschrieben aber vorher war es auch einfach zurückspulen dann sieht er dass ich recht habe der punkt ist der current time ist ein offizielles feature von diesem programmier interface vom videoelement das gehört da offiziell rein aber wenn ich jetzt\n'slidetext': ''\n'from': 'index'\n'score': 37.79056167602539\n'normalizedScore': 0.3779056167602539\n'beforeDatePenaltyScore': 0.3779056167602539\n\n'documentId': 'a5dcfc84b51456a6b4b27fce'\n'chunk_id': '6878ecf222599b00136894d3'\n'access': 'granted'\n'part_number': 20\n'total_parts': 77\n'contentType': 'TUTORIAL'\n'title': Die Welt der Web Components\n'parentName': Web Components von 0 auf 100\n'language': 'DE'\n'date': '2025-06-05T13:45:07.000Z'\n'abstract': In der ersten Lesson steigen wir in die Welt der Web Components ein. Wir richten unser Setup ein, klären die Ziele des Tutorials – und schreiben unser erstes „Hello World“. Dabei beantworten wir die Grundfrage: Was sind Web Components eigentlich? Wir schauen uns Content-Attribute und DOM-Properties an, ziehen den Vergleich zu Frameworks und klären, wo Web Components glänzen – und wo nicht. Best Practices und erste UI-Beispiele runden den Einstieg ab.\n'parentId': '54cce7e83417cbefa7c0d3f0'\n'parentDescription': Web Components versprechen universelle Frontend-Komponenten, frei von Framework-Fesseln und Dependency-Depression. Das Problem: Web Components sind komplex, manche APIs wirken eigenartig, und das sie umgebende Ökosystem ist unübersichtlich. Was können Web Components leisten – und was nicht? Brauche ich wirklich Shadow DOM oder kann ich darauf verzichten? Vanilla-Komponenten, Lit – oder etwas dazwischen? In diesem Tutorial lernen wir, wie der Komponenten-Eintopf wirklich gemacht wird. Wir orientieren uns im Ökosystem und erhalten einen Überblick über die Fähigkeiten und Grenzen der Standards rund um Web Components. Von den absoluten API-Grundlagen bis zum Einsatz ausgewachsener Komponenten-Frameworks lassen wir keinen Schritt aus. In jedem Abschnitt unserer Reise erfahren wir nicht nur, wie etwas funktioniert, sondern auch, warum. Dieses Tutorial macht uns nicht nur zu Web-Component-Expert:innen, sondern vertieft auch unser Verständnis der Web-Plattform insgesamt.\n'indexBrandName': 'InternationalJavaScriptCon'\n'indexSeriesName': ''\n'author': 'Peter Kröner'\n'chunkSource': 'text'\n'text': das grob vorstellen ist eine funktion für diese videoelemente und naja wir sehen halt eben da kommt was raus das eine ganze menge daten enthält und da sieht man schon dass dieses dom eine ganze menge an features beinhaltet die in html so nicht drin sind aber das geht noch ein bisschen weiter ich habe jetzt ja hier mein videoobjekt und kann auf dem jetzt wenn ich möchte operationen durchführen könnte zum beispiel die set attribute mit oder aufrufen man macht die wohl die setzt natürlich ein attribute so ähnlich wie wir es in html gemacht hätten ich gehe also hin und sagt ich habe jetzt hier eine videoquelle und meine videoquelle nenne ich jetzt einfach mal legit movie backup das ist ja das wofür man videoelemente vor allen dingen braucht das werde ich jetzt einfach mal setzen dann wird wahrscheinlich der browser hingehen wird probieren das zu laden und meckert weil es nicht funktioniert spielt aber keine rolle das ding ist halt nur unser videoelement enthält jetzt dieses attribute und das kann ich tatsächlich auch mir ausgeben lassen indem ich sage video get attribute und dann lasse ich mir ausgeben was denn im source attribute wohl drin stecken würde siehe da es ist tatsächlich legit movie backup wunderbar das funktioniert also was wir jetzt gemacht haben ist wir haben dieses videoelement als ein ganz normales javascript objekt behandelt ich habe es erstellt mit dieser factory funktion create element ich habe mit set attribute ein attribute gesetzt mit get attribute habe ich ausgelesen und was man jetzt tatsächlich machen könnte wenn man wollte wäre dieses ding tatsächlich in einer html repräsentation zu überführen ich könnte jetzt dieses videoelement nehmen und ich könnte darauf aufrufen diesen getter outer html was der macht ist das videoelement und verwandelt es in html wenn ich das jetzt mache sehen wir dass daraus kommt tatsächlich ein html string der relativ überzeugend aussieht oder da ist der video tag drin es gibt das source attribute mit unserer angegebenen quelle das funktioniert also alles wie es erwartbar ist oder es funktioniert genau wie man es meinen möchte aber wo ist denn jetzt tatsächlich diese lustbehaftete aspekt davon naja ich habe unser videoelement das ist ja ein ganz normales javascript objekt mit offiziell vorhandenen metoden wie\n'slidetext': ''\n'from': 'index'\n'score': 37.79056167602539\n'normalizedScore': 0.3779056167602539\n'beforeDatePenaltyScore': 0.3779056167602539\n\n'documentId': 'a5dcfc84b51456a6b4b27fce'\n'chunk_id': '6878ecf222599b00136894d2'\n'access': 'granted'\n'part_number': 19\n'total_parts': 77\n'contentType': 'TUTORIAL'\n'title': Die Welt der Web Components\n'parentName': Web Components von 0 auf 100\n'language': 'DE'\n'date': '2025-06-05T13:45:07.000Z'\n'abstract': In der ersten Lesson steigen wir in die Welt der Web Components ein. Wir richten unser Setup ein, klären die Ziele des Tutorials – und schreiben unser erstes „Hello World“. Dabei beantworten wir die Grundfrage: Was sind Web Components eigentlich? Wir schauen uns Content-Attribute und DOM-Properties an, ziehen den Vergleich zu Frameworks und klären, wo Web Components glänzen – und wo nicht. Best Practices und erste UI-Beispiele runden den Einstieg ab.\n'parentId': '54cce7e83417cbefa7c0d3f0'\n'parentDescription': Web Components versprechen universelle Frontend-Komponenten, frei von Framework-Fesseln und Dependency-Depression. Das Problem: Web Components sind komplex, manche APIs wirken eigenartig, und das sie umgebende Ökosystem ist unübersichtlich. Was können Web Components leisten – und was nicht? Brauche ich wirklich Shadow DOM oder kann ich darauf verzichten? Vanilla-Komponenten, Lit – oder etwas dazwischen? In diesem Tutorial lernen wir, wie der Komponenten-Eintopf wirklich gemacht wird. Wir orientieren uns im Ökosystem und erhalten einen Überblick über die Fähigkeiten und Grenzen der Standards rund um Web Components. Von den absoluten API-Grundlagen bis zum Einsatz ausgewachsener Komponenten-Frameworks lassen wir keinen Schritt aus. In jedem Abschnitt unserer Reise erfahren wir nicht nur, wie etwas funktioniert, sondern auch, warum. Dieses Tutorial macht uns nicht nur zu Web-Component-Expert:innen, sondern vertieft auch unser Verständnis der Web-Plattform insgesamt.\n'indexBrandName': 'InternationalJavaScriptCon'\n'indexSeriesName': ''\n'author': 'Peter Kröner'\n'chunkSource': 'text'\n'text': Ich gehe mal hier in die JavaScript-Konsole, wir ignorieren diese ganzen Fehler, die mein Programm hier rausschmeißt und ich gehe mal jetzt einfach hin und tippe ein bisschen JavaScript slash DOM-Code und wir gucken mal, wie das Ganze sich zueinander verhält. Auf geht's! Zur Demonstrationszwecken würde ich sagen, erschaffen wir uns mal ein Video-Element, indem ich hier einfach eine Variable mache, let video gleich und dann, um mit DOM-Mitteln ein Element zu erstellen, mache ich document createElement. ist natürlich etwas umständlich von der API her. Mit jQuery hätte es das nicht gegeben, aber nun wir müssen halt mit dem arbeiten, was wir hier haben. Da sagen wir also wir hätten jetzt gerne ein Video-Element., wunderbar. Dann gehe ich also hin und mache das und was wir da raus bekommen, ist tatsächlich dann ein Video-Element. Wenn ich das jetzt ausführe, wird das Ding erzeugt und wenn ich jetzt auf Video zugreife und ich schreibe das jetzt zum Beispiel mal in die Konsole oder ich führe jetzt einfach diesen Code aus, dann sehen wir es hier, wird das mir hier repräsentiert, als wäre es ein HTML-Element, als wäre es ein Video-Element. Es gibt keine Attribute, ich habe kein Source-Attribut gesetzt und nichts, das ist einfach nur ein Video DOM-Knoten. Und wenn wir jetzt hingehen und wir klappen den auf, dann sehen wir, dass dieses Video-Objekt eine ganze Menge Elemente und Eigenschaften und Attribute und Felder enthält, die meisten davon sind die meisten sind irgendwie ein bisschen seltsam so sachen wie eine klasse list ok das kennen wir irgendwie klasse setzen und so andere sachen wie buffert und diese ranges wo waren sie denn gerade time ranges hier genau sind ein bisschen was besonderes was ist jetzt genau hier passiert naja ich habe im prinzip dem browser gesagt er soll eine instanz des videoobjekts erzeugen ein bisschen so als hätte ich den new video constructor benutzt den es so in der form nicht benutzt gibt aber so kann man sich das grob vorstellen ist eine funktion für diese videoelemente und naja wir sehen halt eben da kommt was raus das eine ganze menge daten enthält und da sieht man schon dass dieses dom eine ganze\n'slidetext': ''\n'from': 'index'\n'score': 37.79056167602539\n'normalizedScore': 0.3779056167602539\n'beforeDatePenaltyScore': 0.3779056167602539\n\n'documentId': 'a5dcfc84b51456a6b4b27fce'\n'chunk_id': '6878ecf222599b00136894d1'\n'access': 'granted'\n'part_number': 18\n'total_parts': 77\n'contentType': 'TUTORIAL'\n'title': Die Welt der Web Components\n'parentName': Web Components von 0 auf 100\n'language': 'DE'\n'date': '2025-06-05T13:45:07.000Z'\n'abstract': In der ersten Lesson steigen wir in die Welt der Web Components ein. Wir richten unser Setup ein, klären die Ziele des Tutorials – und schreiben unser erstes „Hello World“. Dabei beantworten wir die Grundfrage: Was sind Web Components eigentlich? Wir schauen uns Content-Attribute und DOM-Properties an, ziehen den Vergleich zu Frameworks und klären, wo Web Components glänzen – und wo nicht. Best Practices und erste UI-Beispiele runden den Einstieg ab.\n'parentId': '54cce7e83417cbefa7c0d3f0'\n'parentDescription': Web Components versprechen universelle Frontend-Komponenten, frei von Framework-Fesseln und Dependency-Depression. Das Problem: Web Components sind komplex, manche APIs wirken eigenartig, und das sie umgebende Ökosystem ist unübersichtlich. Was können Web Components leisten – und was nicht? Brauche ich wirklich Shadow DOM oder kann ich darauf verzichten? Vanilla-Komponenten, Lit – oder etwas dazwischen? In diesem Tutorial lernen wir, wie der Komponenten-Eintopf wirklich gemacht wird. Wir orientieren uns im Ökosystem und erhalten einen Überblick über die Fähigkeiten und Grenzen der Standards rund um Web Components. Von den absoluten API-Grundlagen bis zum Einsatz ausgewachsener Komponenten-Frameworks lassen wir keinen Schritt aus. In jedem Abschnitt unserer Reise erfahren wir nicht nur, wie etwas funktioniert, sondern auch, warum. Dieses Tutorial macht uns nicht nur zu Web-Component-Expert:innen, sondern vertieft auch unser Verständnis der Web-Plattform insgesamt.\n'indexBrandName': 'InternationalJavaScriptCon'\n'indexSeriesName': ''\n'author': 'Peter Kröner'\n'chunkSource': 'text'\n'text': oder so. Es gibt so ein paar Dinge, die irgendwie nach HTML riechen, wie so Content-Attribute, aber das tatsächlich Zentrale hier ist zum einen dieser Absatz hier der die Semantik beschreibt, also wofür ist dieses Element auf einer inhaltlichen Ebene gut, aber dann ist der eigentliche Kern des ganzen dieses diese graue Box. Das ist das DOM-Interface und das beschreibt wirklich das Datenmodell von dem, was dieses Picture-Element macht. Und ja, man kann es halt eben auch in HTML verwandeln und man kann dann halt irgendwie auf eine definierte Art und Weise Tags und Attribute damit verarbeiten, aber tatsächlich ist das Denkmodell vom Browser immer von der Datenstruktur ausgehend, immer vom Ergebnis des HTML-Parsers ausgehend und das HTML selber ist quasi eine Nebenwirkung des Ganzen. Und es macht auch einigermaßen Sinn. Was nämlich HTML tatsächlich ist, das habe ich glaube ich vorhin schon gesagt, es ist eine verlustbehaftete Serialisierung vom DOM. Das DOM, also die Datenstruktur, diese Baumstruktur, die kann eine ganze Menge Dinge enthalten, die in HTML nicht gehen und HTML hat ein paar Konstrukte und Syntax-Besonderheiten, die in dieser Baumstruktur nicht repräsentierbar sind. Das Ganze ist also nicht eine 1 zu 1 Übersetzung, sondern ist halt so bisschen verlustbehaftet. Man kann sich das wirklich so vorstellen, als hätte man das Feature-Set von HTML und das Feature-Set von DOM und die überschneiden sich zu einem sehr großen Teil und die können ineinander umgewandelt werden. Aus DOM können wir HTML machen, aus HTML können wir mit dem HTML-Parser wiederum DOM machen, aber das ist halt eben nicht ein 1 zu 1 Match. Das Ganze ist verlustbehaftet und das würde ich jetzt mal eben ganz kurz gerne demonstrieren, ganz ohne Web-Components, nur dass wir irgendwie eine Idee davon haben wie die Kiste funktioniert. Ich mache das einfach mal hier in den Dev-Tools meines Browsers mit dieser Instanz dieser Präsentation, die wir da sehen. Ich gehe mal hier in die JavaScript-Konsole, wir ignorieren diese ganzen Fehler, die mein Programm hier rausschmeißt und ich gehe mal jetzt einfach hin und tippe ein bisschen JavaScript slash DOM-Code und wir\n'slidetext': ''\n'from': 'index'\n'score': 37.79056167602539\n'normalizedScore': 0.3779056167602539\n'beforeDatePenaltyScore': 0.3779056167602539\n\n'documentId': 'a5dcfc84b51456a6b4b27fce'\n'chunk_id': '6878ecf222599b00136894d0'\n'access': 'granted'\n'part_number': 17\n'total_parts': 77\n'contentType': 'TUTORIAL'\n'title': Die Welt der Web Components\n'parentName': Web Components von 0 auf 100\n'language': 'DE'\n'date': '2025-06-05T13:45:07.000Z'\n'abstract': In der ersten Lesson steigen wir in die Welt der Web Components ein. Wir richten unser Setup ein, klären die Ziele des Tutorials – und schreiben unser erstes „Hello World“. Dabei beantworten wir die Grundfrage: Was sind Web Components eigentlich? Wir schauen uns Content-Attribute und DOM-Properties an, ziehen den Vergleich zu Frameworks und klären, wo Web Components glänzen – und wo nicht. Best Practices und erste UI-Beispiele runden den Einstieg ab.\n'parentId': '54cce7e83417cbefa7c0d3f0'\n'parentDescription': Web Components versprechen universelle Frontend-Komponenten, frei von Framework-Fesseln und Dependency-Depression. Das Problem: Web Components sind komplex, manche APIs wirken eigenartig, und das sie umgebende Ökosystem ist unübersichtlich. Was können Web Components leisten – und was nicht? Brauche ich wirklich Shadow DOM oder kann ich darauf verzichten? Vanilla-Komponenten, Lit – oder etwas dazwischen? In diesem Tutorial lernen wir, wie der Komponenten-Eintopf wirklich gemacht wird. Wir orientieren uns im Ökosystem und erhalten einen Überblick über die Fähigkeiten und Grenzen der Standards rund um Web Components. Von den absoluten API-Grundlagen bis zum Einsatz ausgewachsener Komponenten-Frameworks lassen wir keinen Schritt aus. In jedem Abschnitt unserer Reise erfahren wir nicht nur, wie etwas funktioniert, sondern auch, warum. Dieses Tutorial macht uns nicht nur zu Web-Component-Expert:innen, sondern vertieft auch unser Verständnis der Web-Plattform insgesamt.\n'indexBrandName': 'InternationalJavaScriptCon'\n'indexSeriesName': ''\n'author': 'Peter Kröner'\n'chunkSource': 'text'\n'text': in einer komplizierten, verschachtelten verlinkten Liste. Das schauen wir uns nachher noch mal genauer an. So eine Baumstruktur ist das tatsächlich eher. Und das ist wirklich, was der HTML-Paser macht. Der nimmt einen Text und macht heraus die Baumstruktur und was dann in dieser Baumstruktur existiert, also an Elementen, an Features, an Attributen, an allem, was im Prinzip wirklich interessant ist, das ist in diesem Dokument definiert. Allerdings in einer Reihenfolge, die zuerst dieses Datenmodell also das Ergebnis des HTML-Pasers beschreibt und dann sagt, ach übrigens, man kann daraus auch HTML machen. Es gibt immer so einen Zwei-Wege-Mechanismus, man kann aus HTML diese Datenstruktur machen oder man kann aus dieser Datenstruktur HTML machen. Und wir können uns das tatsächlich, wenn wir wollen, mal kurz hier anschauen, indem wir mal uns irgendwie ein Element hier aus den Spezifikationen rauspicken. Was nehmen wir denn heute mal? Nehmen wir mal, das Mark-Element ist glaube ich, bisschen zu langweilig. Link ist jetzt auch nicht wahnsinnig spannend Das Picture-Element, nehmen wir doch mal dieses hier. Da haben wir jetzt also hier die Spezifikation von dem Picture-Element. Wenn ihr euch nicht in den HTML-Spezifikationen regelmäßig umtut, ist das völlig okay. Normale Webentwicklerinnen und Entwickler müssen das nicht wirklich machen oder können. Dokumentation bei MDN lesen reicht völlig, aber das ist halt so ein Bonus. Das kann man halt eben auch haben. Irgendwie so, wie wenn man an seinem Auto selbst einen Ölwechsel machen kann. So das ist nett, wenn man das kann, aber das ist nicht wirklich notwendig, weil es möglicherweise sinnvoller und einfacher ist, einfach irgendwen anders das machen zu lassen. Aber wenn wir schon mal hier sind, wir uns mal kurz umschauen. Dieses Picture-Element beschreibt, wie wir hier sehen, in relativ kompakter Form, in keinerlei Stück, einen HTML-Tag. Es gibt hier nichts von Syntax oder so. Es gibt so ein paar Dinge, die irgendwie nach HTML riechen, wie so Content-Attribute, aber das tatsächlich Zentrale hier ist zum einen dieser Absatz hier der die Semantik beschreibt, also\n'slidetext': ''\n'from': 'index'\n'score': 37.79056167602539\n'normalizedScore': 0.3779056167602539\n'beforeDatePenaltyScore': 0.3779056167602539\n\n'documentId': 'a5dcfc84b51456a6b4b27fce'\n'chunk_id': '6878ecf222599b00136894cf'\n'access': 'granted'\n'part_number': 16\n'total_parts': 77\n'contentType': 'TUTORIAL'\n'title': Die Welt der Web Components\n'parentName': Web Components von 0 auf 100\n'language': 'DE'\n'date': '2025-06-05T13:45:07.000Z'\n'abstract': In der ersten Lesson steigen wir in die Welt der Web Components ein. Wir richten unser Setup ein, klären die Ziele des Tutorials – und schreiben unser erstes „Hello World“. Dabei beantworten wir die Grundfrage: Was sind Web Components eigentlich? Wir schauen uns Content-Attribute und DOM-Properties an, ziehen den Vergleich zu Frameworks und klären, wo Web Components glänzen – und wo nicht. Best Practices und erste UI-Beispiele runden den Einstieg ab.\n'parentId': '54cce7e83417cbefa7c0d3f0'\n'parentDescription': Web Components versprechen universelle Frontend-Komponenten, frei von Framework-Fesseln und Dependency-Depression. Das Problem: Web Components sind komplex, manche APIs wirken eigenartig, und das sie umgebende Ökosystem ist unübersichtlich. Was können Web Components leisten – und was nicht? Brauche ich wirklich Shadow DOM oder kann ich darauf verzichten? Vanilla-Komponenten, Lit – oder etwas dazwischen? In diesem Tutorial lernen wir, wie der Komponenten-Eintopf wirklich gemacht wird. Wir orientieren uns im Ökosystem und erhalten einen Überblick über die Fähigkeiten und Grenzen der Standards rund um Web Components. Von den absoluten API-Grundlagen bis zum Einsatz ausgewachsener Komponenten-Frameworks lassen wir keinen Schritt aus. In jedem Abschnitt unserer Reise erfahren wir nicht nur, wie etwas funktioniert, sondern auch, warum. Dieses Tutorial macht uns nicht nur zu Web-Component-Expert:innen, sondern vertieft auch unser Verständnis der Web-Plattform insgesamt.\n'indexBrandName': 'InternationalJavaScriptCon'\n'indexSeriesName': ''\n'author': 'Peter Kröner'\n'chunkSource': 'text'\n'text': Komplikationen mit sich bringt, denn ich sag euch, davon gibt's nicht wenige. Nachdem wir jetzt Hello World hinter uns gebracht haben, dürfen wir uns nun fragen, was haben wir da eigentlich gebaut? Ist das nicht ein bisschen freaky, ein neues HTML-Element zu erschaffen, mit Hilfe von JavaScript, einer ganz anderen Sprache? Tatsächlich ist es so, dass das gar keine so seltsame Idee ist und eigentlich der natürliche Lauf der Dinge ist, also, dass HTML-Elemente sozusagen eine Nebenwirkung von einer anderen Sprache sind. Ich will's mal kurz erklären. Dieses Schaubild hier das zeigt wirklich, was wir gemacht haben. Es gibt das Set von allen HTML-Elementen, da drin wohnen die Nativen, also die DIVs die Tables und so weiter und jetzt können wir mit Web-Components unsere eigenen dazu packen in dieses Set. Dazu benutzen wir JavaScript, damit beschreiben wir, wie die funktionieren. Klasse, Define Element, haben wir ja alles gerade gesehen. Dieser Mechanismus, also HTML-Elemente durch Scripting hinzuzufügen, ist eigentlich so halbwegs der normale Weg, wie es wirklich funktioniert. Wenn wir mal einen Blick in die HTML-Spezifikationen werfen, okay, müssen wir jetzt für einen Moment sehr stark sein. Das ist nämlich ein sehr sehr sehr langes sehr kompliziertes Dokument und das nennt sich und ist überschrieben hier, wie wir ja sehen, als HTML mit irgendwie einem Update-Datum und so weiter. Das schräge am HTML-Standard ist, dass HTML mit das unwichtigste daran ist. Das kann man sich so vorstellen. Die Art und Weise, wie HTML definiert ist, ist im Prinzip als eine Serialisierung aus einem Datenmodell, das im Browser vorliegt. das bedeutet, wenn ihr HTML schreibt, einfach so einen riesigen String in eine Textdatei kloppt und das einem Browser zum Fressen geht, dann geht der Browser hin, nimmt seinen HTML-Paser, der ist in diesem Dokument definiert, und verwandelt diesen String, diese HTML-Text und Attribute und so weiter in Objekte, in einer komplizierten, verschachtelten verlinkten Liste. Das schauen wir uns nachher noch mal genauer an. So eine Baumstruktur ist das tatsächlich eher. Und das ist wirklich, was der HTML-Paser macht. Der\n'slidetext': ''\n'from': 'index'\n'score': 37.79056167602539\n'normalizedScore': 0.3779056167602539\n'beforeDatePenaltyScore': 0.3779056167602539\n\n'documentId': 'a5dcfc84b51456a6b4b27fce'\n'chunk_id': '6878ecf222599b00136894ce'\n'access': 'granted'\n'part_number': 15\n'total_parts': 77\n'contentType': 'TUTORIAL'\n'title': Die Welt der Web Components\n'parentName': Web Components von 0 auf 100\n'language': 'DE'\n'date': '2025-06-05T13:45:07.000Z'\n'abstract': In der ersten Lesson steigen wir in die Welt der Web Components ein. Wir richten unser Setup ein, klären die Ziele des Tutorials – und schreiben unser erstes „Hello World“. Dabei beantworten wir die Grundfrage: Was sind Web Components eigentlich? Wir schauen uns Content-Attribute und DOM-Properties an, ziehen den Vergleich zu Frameworks und klären, wo Web Components glänzen – und wo nicht. Best Practices und erste UI-Beispiele runden den Einstieg ab.\n'parentId': '54cce7e83417cbefa7c0d3f0'\n'parentDescription': Web Components versprechen universelle Frontend-Komponenten, frei von Framework-Fesseln und Dependency-Depression. Das Problem: Web Components sind komplex, manche APIs wirken eigenartig, und das sie umgebende Ökosystem ist unübersichtlich. Was können Web Components leisten – und was nicht? Brauche ich wirklich Shadow DOM oder kann ich darauf verzichten? Vanilla-Komponenten, Lit – oder etwas dazwischen? In diesem Tutorial lernen wir, wie der Komponenten-Eintopf wirklich gemacht wird. Wir orientieren uns im Ökosystem und erhalten einen Überblick über die Fähigkeiten und Grenzen der Standards rund um Web Components. Von den absoluten API-Grundlagen bis zum Einsatz ausgewachsener Komponenten-Frameworks lassen wir keinen Schritt aus. In jedem Abschnitt unserer Reise erfahren wir nicht nur, wie etwas funktioniert, sondern auch, warum. Dieses Tutorial macht uns nicht nur zu Web-Component-Expert:innen, sondern vertieft auch unser Verständnis der Web-Plattform insgesamt.\n'indexBrandName': 'InternationalJavaScriptCon'\n'indexSeriesName': ''\n'author': 'Peter Kröner'\n'chunkSource': 'text'\n'text': das wäre in dem Fall unser Hello World, und weil es ein Hello World ist, müssten wir darauf natürlich auch Foo aufrufen können, wo 42 rauskommt, was in die Konsole geschrieben werden sollte, richtig, schauen wir doch mal, wir laden neu, der Text bleibt rot, und wenn ich draufklicke, kriegen wir 42 in die Konsole geschrieben, jedes Mal, wenn ich es anklicke. Wir sehen also, wir haben ein HTML-Element gebaut, es ist jetzt nicht das spektakulärste, es hat kein nennenswertes User-Interface, abgesehen von dem, was halt zwischen den beiden Texts steht, was es da an Text anzeigt, aber ansonsten kann es alles, was native Elemente schonen können, es kann angeklickt werden, es kann CSS erfahren, es kann selektiert werden, per CSS oder per Query-Selektor, im Prinzip tut das alles ganz wunderbar, das ist also unsere generelle Herangehensweise, um dem Browser neue HTML-Elemente beizubiegen das ist ja erstmal ganz nett aber warum funktioniert das? Also ganz grundsätzlich ist es ja so, dass das Set von HTML-Elementen in den HTML-Spezifikationen definiert ist, riesig langes Dokument, wo alles genau drin steht, wie HTML zu parsen ist, welche Elemente es so gibt und was die alle so können, und wenn es um den durchschnittlichen Browser geht, ist es natürlich so, dass dieser Zoo von HTML-Elementen implementiert ist in der Sprache der Browser, das ist halt meistens C++. Warum können wir jetzt hier plötzlich mit unserem JavaScript da irgendwelche Elemente hinzufügen, auf welche magische Weise funktioniert das? Ist dafür irgendwie Ausführungsreihenfolge relevant, warum geht das, was genau kriegen wir hier und wo genau funktioniert das nicht? Was ist tatsächlich am Ende der Unterschied zwischen einem DIV und unserem Hello World, abgesehen von der Foo-Methode? Na, das ist genau das, was wir uns als nächstes anschauen, das hier war jetzt mal ein bisschen Praxis und nun gucken wir mal, was dieses offensichtlich gut funktionierende unter der Haube tatsächlich für Komplikationen mit sich bringt, denn ich sag euch, davon gibt's nicht wenige. Nachdem wir jetzt Hello World hinter uns gebracht haben, dürfen wir uns nun fragen, was haben wir da eigentlich\n'slidetext': ''\n'from': 'index'\n'score': 37.79056167602539\n'normalizedScore': 0.3779056167602539\n'beforeDatePenaltyScore': 0.3779056167602539\n\n'documentId': 'a5dcfc84b51456a6b4b27fce'\n'chunk_id': '6878ecf122599b00136894cd'\n'access': 'granted'\n'part_number': 14\n'total_parts': 77\n'contentType': 'TUTORIAL'\n'title': Die Welt der Web Components\n'parentName': Web Components von 0 auf 100\n'language': 'DE'\n'date': '2025-06-05T13:45:07.000Z'\n'abstract': In der ersten Lesson steigen wir in die Welt der Web Components ein. Wir richten unser Setup ein, klären die Ziele des Tutorials – und schreiben unser erstes „Hello World“. Dabei beantworten wir die Grundfrage: Was sind Web Components eigentlich? Wir schauen uns Content-Attribute und DOM-Properties an, ziehen den Vergleich zu Frameworks und klären, wo Web Components glänzen – und wo nicht. Best Practices und erste UI-Beispiele runden den Einstieg ab.\n'parentId': '54cce7e83417cbefa7c0d3f0'\n'parentDescription': Web Components versprechen universelle Frontend-Komponenten, frei von Framework-Fesseln und Dependency-Depression. Das Problem: Web Components sind komplex, manche APIs wirken eigenartig, und das sie umgebende Ökosystem ist unübersichtlich. Was können Web Components leisten – und was nicht? Brauche ich wirklich Shadow DOM oder kann ich darauf verzichten? Vanilla-Komponenten, Lit – oder etwas dazwischen? In diesem Tutorial lernen wir, wie der Komponenten-Eintopf wirklich gemacht wird. Wir orientieren uns im Ökosystem und erhalten einen Überblick über die Fähigkeiten und Grenzen der Standards rund um Web Components. Von den absoluten API-Grundlagen bis zum Einsatz ausgewachsener Komponenten-Frameworks lassen wir keinen Schritt aus. In jedem Abschnitt unserer Reise erfahren wir nicht nur, wie etwas funktioniert, sondern auch, warum. Dieses Tutorial macht uns nicht nur zu Web-Component-Expert:innen, sondern vertieft auch unser Verständnis der Web-Plattform insgesamt.\n'indexBrandName': 'InternationalJavaScriptCon'\n'indexSeriesName': ''\n'author': 'Peter Kröner'\n'chunkSource': 'text'\n'text': zum Beispiel color.red zu machen, und schon kriege ich roten Text, das Featureset haben wir im Prinzip einfach dadurch geerbt, dass unser Custom-Element eine Instanz von HTML-Elementen ist, und alle HTML-Elemente können dieses Style-Attribut, das funktioniert, ebenso können wir hingehen und können tatsächlich hier Event Handling betreiben, unser Hello-World-Objekt hier ist wunderbar in der Lage angeklickt zu werden und ganz normales Event Handling zu betreiben, gehen wir doch mal hin und machen uns hier einfach noch einen zweiten Script-Block auf, hier bin ich jetzt mal räudig und mache mal kein Type-Modul draus, weil warum sollte ich, machen einmal document query-selector hello-world, und das sollte tatsächlich funktionieren, der Browser weiß jetzt ja, dass HTML-Elemente mit diesem Tag existieren, und sämtliche Browser-APIs, wie z.B. Query-selector, funktionieren dann auch mit diesem Ding, kann ich jetzt also hingehen und kann sagen, ich mache mal hier einen Console-Log und schreibe das Ergebnis von dem ganzen Spaß in die Konsole, und siehe da, da kriegen wir es ausgegeben, da ist unser Element, query-selector funktioniert also, und nicht nur funktioniert query-selector, sondern auch im Prinzip alles andere, was man so an Features von normalen HTML-Elementen erwarten würde, z.B. addEventListener, also reagiere auf irgendwelche Events, wie wäre es, wenn wir auf Click-Events reagieren, so was hier, und was wollen wir bei einem Click-Event machen, naja, wir schreiben natürlich wieder was in die Konsole, weil ich bin ja nicht besonders kreativ, console.log, und was ich da reinschreiben könnte, wäre ja tatsächlich das, was rauskommt, wenn ich hier unsere Foo-Methode aufrufe, die Foo-Methode schreibt jetzt gerade selber was in die Konsole, deswegen bauen wir die mal kurz um und lassen sie 42 zurückgeben, und dann kann ich hier unten, ja tatsächlich bei einem Event-Handler, evt, das Event-Objekt entgegennehmen, evt.target ist in dem Fall das Objekt, das hier tatsächlich angeklickt wird, das wäre in dem Fall unser Hello World, und weil es ein Hello World ist, müssten wir darauf natürlich auch Foo aufrufen können, wo 42 rauskommt, was in die Konsole geschrieben werden sollte, richtig,\n'slidetext': ''\n'from': 'index'\n'score': 37.79056167602539\n'normalizedScore': 0.3779056167602539\n'beforeDatePenaltyScore': 0.3779056167602539\n\n\nTop Vectors:\n'documentId': '50c03dd02cf9b7c2ff4480f2'\n'chunk_id': '68b55eab33a5bf00132cb688'\n'access': 'granted'\n'part_number': 7\n'total_parts': 47\n'contentType': 'TUTORIAL'\n'title': React-Grundlagen\n'parentName': Modern React: von Null auf Full-Stack\n'language': 'DE'\n'date': '2025-08-27T09:53:51.000Z'\n'abstract': In der ersten Lesson lernst du, was React ist und wie es funktioniert. Anhand einer Beispielanwendung schauen wir uns den Projektaufbau und den Workspace an. Du erfährst, wie Komponenten aufgebaut sind, wie man mit Props, Listen und State arbeitet und wie Interaktionen in React abgebildet werden.\n'parentId': 'b2c71c7c41dfe8eab4593f02'\n'parentDescription': In diesem Videotutorial lernst du React von Grund auf – bis hin zur Full-Stack-Entwicklung mit Next.js. Du baust Single Page Applications, verwaltest State, entwickelst moderne Formulare, arbeitest mit serverseitigen Daten und setzt Routing effizient um. Zum Abschluss bekommst du eine Einführung in React Server Components und Next.js. Benötigte Vorkenntnisse: JavaScript-Grundlagen, TypeScript ist hilfreich, aber nicht zwingend nötig. Nach dem Tutorial bist du bereit, eigene client- und serverseitige Anwendungen mit React umzusetzen.\n'indexBrandName': 'InternationalJavaScriptCon'\n'indexSeriesName': ''\n'author': 'Nils Hartmann'\n'chunkSource': 'text'\n'text': serverseitigen Daten umgehen? Denn diese ganzen Daten, die wir hier sehen, die sind ja alle irgendwo auf dem Server abgelegt. Wir wollen uns angucken, wie kann ich Formulare bauen? Und schlussendlich wollen wir uns angucken, wie kann ich eigentlich mit verschiedenen Routen in meiner Anwendung umgehen? Also sprich, mit verschiedenen Seiten, wenn man so will. Obwohl wir eine Single-Page-Anwendung bauen, wir ja sowas wie mehrere Seiten in dieser Anwendung. Wir haben hier zum Beispiel diese Dashboard-Seite. Wir haben diese Einstiegsseite. Und letzten Endes haben wir ja auch diese Seite zum Anlegen oder Bearbeiten von Rezepten. Also wir haben durchaus mehrere Seiten. Obwohl wir technisch eine Single-Page-Anwendung bauen, haben wir fachlich eine Multi-Page-Anwendung, wenn man so möchte. Bevor wir jetzt gleich in den Code einsteigen, möchte ich euch eine Sache noch zeigen. Und zwar, ist sozusagen die Architektur wenn man so will, von dieser Anwendung auf einer sehr sehr hohen Ebene. Und zwar sieht das bei mir wie folgt aus, damit wir wissen, wovon wir sprechen. Wir haben sozusagen ein Recipe-File-Backend. Wollen wir die Schrift hier ein klein bisschen größer machen und das vorhin nach oben schieben. Und dieses Recipe-File-Backend das stellt uns eine Rest-API zur Verfügung, mit der ich Rezepte lesen und schreiben kann. Rezepte lesen und schreiben. Und ich kann mich damit auch einloggen. Wobei, das werden wir erst im zweiten Schritt machen. Trotz allem kann ich das damit machen. Und man kann da auch Bewertungen abgeben. Und die Idee von diesem Backend ist, das ist fertig. Das gucken wir uns gar nicht an. Wen es technisch interessiert ist eine Spring-Boot-Anwendung. Für uns ist aber eigentlich relevant, dass es hier eine Rest-API gibt, die wir in unserer Anwendung konsumieren. Wir tun mal für dieses Tutorial so, als ob wir eine bestehende Rest-API haben. Vielleicht haben wir irgendeinen Dienst im Internet, den wir anschließen wollen. Und diese API konsumieren wir Die ist schon fertig gemacht für uns. Da beschäftigen wir uns weiter dann nicht mit, außer dass wir sie eben benutzen. So und jetzt haben\n'slidetext': ''\n'from': 'vector'\n'score': 0.8981435298919678\n'normalizedScore': 0.8940202732500347\n'beforeDatePenaltyScore': 0.8981435298919678\n\n'documentId': '283cdcdb068c7c636571eee9'\n'chunk_id': '6908c315eec9d90012dc48ee'\n'access': 'granted'\n'part_number': 1\n'total_parts': 1\n'contentType': 'TUTORIAL'\n'title': Micro Frontends\n'parentName': Moderne Angular-Architekturen\n'language': 'DE'\n'date': '2025-11-17T11:00:00.000Z'\n'abstract': In der zweiten Lesson geht es um den Aufbau skalierbarer Frontend-Architekturen durch Micro Frontends. Wir erklären die Prinzipien von Modul- und Native Federation und zeigen anhand einer Demo, wie einzelne Frontend-Module unabhängig entwickelt, bereitgestellt und integriert werden können, um eine flexible und wartbare Anwendung zu schaffen.\n'parentId': 'ac8c34d42ff419c583c5dd09'\n'parentDescription': Unternehmens-Anwendungen müssen langfristig wartbar und erweiterbar sein. Dafür kombinieren wir aktuelle Features wie Signals, den Signal Store und Native Federation mit etablierten Konzepten wie Strategic Design (DDD), vertikalen Architekturen sowie Monorepos, Modulithen und Micro Frontends. Wir nutzen Nx für inkrementelle Builds und zeigen, wie Du die Wartbarkeit Deiner Anwendung analysieren und verbessern kannst.\n'indexBrandName': 'InternationalJavaScriptCon'\n'indexSeriesName': ''\n'author': 'Manfred Steyer,Michael Egger-Zikes,Rainer Hahnekamp'\n'chunkSource': 'text'\n'text': Micro Frontends In der zweiten Lesson geht es um den Aufbau skalierbarer Frontend-Architekturen durch Micro Frontends. Wir erklären die Prinzipien von Modul- und Native Federation und zeigen anhand einer Demo, wie einzelne Frontend-Module unabhängig entwickelt, bereitgestellt und integriert werden können, um eine flexible und wartbare Anwendung zu schaffen.\n'slidetext': ''\n'from': 'vector'\n'score': 0.8893067240715027\n'normalizedScore': 0.8896791352377889\n'beforeDatePenaltyScore': 0.8893067240715027\n\n'documentId': 'ed6b19fe4c4328050dad69e5'\n'chunk_id': '68c2ee68787074001356ea86'\n'access': 'granted'\n'part_number': 40\n'total_parts': 40\n'contentType': 'TUTORIAL'\n'title': Typsicheres Routing mit TanStack Router\n'parentName': Modern React: von Null auf Full-Stack\n'language': 'DE'\n'date': '2025-08-27T09:53:51.000Z'\n'abstract': In dieser Lesson lernst du, wie du mit dem TanStack Router eine moderne, typsichere Navigation in deine React-App bringst – inklusive Unterstützung für Links, Back-Button und Bookmarks. Wir zeigen dir die File-System-basierte Routenstruktur, dynamische Routen, Layout-Routen sowie die Verwendung von typsicheren Suchparametern. Außerdem: Integration mit TanStack Query und Performanceoptimierungen.\n'parentId': 'b2c71c7c41dfe8eab4593f02'\n'parentDescription': In diesem Videotutorial lernst du React von Grund auf – bis hin zur Full-Stack-Entwicklung mit Next.js. Du baust Single Page Applications, verwaltest State, entwickelst moderne Formulare, arbeitest mit serverseitigen Daten und setzt Routing effizient um. Zum Abschluss bekommst du eine Einführung in React Server Components und Next.js. Benötigte Vorkenntnisse: JavaScript-Grundlagen, TypeScript ist hilfreich, aber nicht zwingend nötig. Nach dem Tutorial bist du bereit, eigene client- und serverseitige Anwendungen mit React umzusetzen.\n'indexBrandName': 'InternationalJavaScriptCon'\n'indexSeriesName': ''\n'author': 'Nils Hartmann'\n'chunkSource': 'text'\n'text': zugreife. Dann kann der Browser eine HTML-Seite runterladen anzeigen und das geht natürlich am allerschnellsten. Für diesen Anwendungsfall, ich habe sowas wie eine Admin-Anwendung, ich habe sowas wie eine Inhouse-Anwendung, finde ich, macht das relativ wenig Sinn. Man könnte sich vielleicht sogar vorstellen, dass diese Anwendung hinter einer Login-Schranke, hinter einem Login-Formular liegt, dann würde ich quasi nur die Login-Seite vielleicht vorrendern. Das muss man so bisschen gucken, ob das Sinn macht. Ich finde, an der Stelle ist es fachlich verträgretbar, genau diesem technischen Ansatz so zu arbeiten. Auf der anderen Seite, wenn ich zum Beispiel eine E-Commerce-Seite habe, dann möchte ich vielleicht bessere Performance haben, noch bessere Performance haben, dann wäre eine Möglichkeit hier dieses Tenstack Start zu verwenden und eine andere Möglichkeit wäre, richtig auf die Server-Seite zu setzen, quasi eine Server-First-React-Anwendung zu bauen. Und wie das geht am Beispiel von Next.js, das gucken wir uns dann in der nächsten Lektion an\n'slidetext': ''\n'from': 'vector'\n'score': 0.8931353092193604\n'normalizedScore': 0.8890120525774273\n'beforeDatePenaltyScore': 0.8931353092193604\n\n'documentId': 'fb34eb7009846674dee32bf6'\n'chunk_id': '68c0399287c67b0014cf549d'\n'access': 'granted'\n'part_number': 1\n'total_parts': 1\n'contentType': 'TUTORIAL'\n'title': Datenabfrage mit TanStack Query\n'parentName': Modern React: von Null auf Full-Stack\n'language': 'EN'\n'date': '2025-08-27T09:53:51.000Z'\n'abstract': In der dritten Lesson lernst du, wie du mit TanStack Query effizient Daten von einem API abrufst und verwaltest – ein zentrales Thema in modernen SPAs. Du erfährst, wie du Daten mit Zod und TypeScript validierst, Typen automatisch aus einer OpenAPI-Beschreibung generierst und den Query-Cache gezielt nutzt. Außerdem klären wir, wie du mit React Suspense die Darstellung priorisieren kannst.\n'parentId': 'b2c71c7c41dfe8eab4593f02'\n'parentDescription': In diesem Videotutorial lernst du React von Grund auf – bis hin zur Full-Stack-Entwicklung mit Next.js. Du baust Single Page Applications, verwaltest State, entwickelst moderne Formulare, arbeitest mit serverseitigen Daten und setzt Routing effizient um. Zum Abschluss bekommst du eine Einführung in React Server Components und Next.js. Benötigte Vorkenntnisse: JavaScript-Grundlagen, TypeScript ist hilfreich, aber nicht zwingend nötig. Nach dem Tutorial bist du bereit, eigene client- und serverseitige Anwendungen mit React umzusetzen.\n'indexBrandName': 'InternationalJavaScriptCon'\n'indexSeriesName': ''\n'author': 'Nils Hartmann'\n'chunkSource': 'text'\n'text': Datenabfrage mit TanStack Query In der dritten Lesson lernst du, wie du mit TanStack Query effizient Daten von einem API abrufst und verwaltest – ein zentrales Thema in modernen SPAs. Du erfährst, wie du Daten mit Zod und TypeScript validierst, Typen automatisch aus einer OpenAPI-Beschreibung generierst und den Query-Cache gezielt nutzt. Außerdem klären wir, wie du mit React Suspense die Darstellung priorisieren kannst.\n'slidetext': ''\n'from': 'vector'\n'score': 0.8910360336303711\n'normalizedScore': 0.8869127769884381\n'beforeDatePenaltyScore': 0.8910360336303711\n\n'documentId': '50c03dd02cf9b7c2ff4480f2'\n'chunk_id': '68b55eab33a5bf00132cb684'\n'access': 'granted'\n'part_number': 3\n'total_parts': 47\n'contentType': 'TUTORIAL'\n'title': React-Grundlagen\n'parentName': Modern React: von Null auf Full-Stack\n'language': 'DE'\n'date': '2025-08-27T09:53:51.000Z'\n'abstract': In der ersten Lesson lernst du, was React ist und wie es funktioniert. Anhand einer Beispielanwendung schauen wir uns den Projektaufbau und den Workspace an. Du erfährst, wie Komponenten aufgebaut sind, wie man mit Props, Listen und State arbeitet und wie Interaktionen in React abgebildet werden.\n'parentId': 'b2c71c7c41dfe8eab4593f02'\n'parentDescription': In diesem Videotutorial lernst du React von Grund auf – bis hin zur Full-Stack-Entwicklung mit Next.js. Du baust Single Page Applications, verwaltest State, entwickelst moderne Formulare, arbeitest mit serverseitigen Daten und setzt Routing effizient um. Zum Abschluss bekommst du eine Einführung in React Server Components und Next.js. Benötigte Vorkenntnisse: JavaScript-Grundlagen, TypeScript ist hilfreich, aber nicht zwingend nötig. Nach dem Tutorial bist du bereit, eigene client- und serverseitige Anwendungen mit React umzusetzen.\n'indexBrandName': 'InternationalJavaScriptCon'\n'indexSeriesName': ''\n'author': 'Nils Hartmann'\n'chunkSource': 'text'\n'text': nicht so gut von existierenden Frameworks abgebildet werden oder wenn man vielleicht sogar sein eigenes Framework bauen will oder wenn du die Grundlagen von React lernen möchtest, dann gibt es auch noch andere Optionen. Dann musst du kein Framework benutzen. Und genau das werden wir im ersten Schritt machen. Wir werden keins dieser Frameworks benutzen und wir werden später auch noch diskutieren, in welchen Fällen aus meiner Sicht ein Framework überhaupt Sinn macht oder nicht. Denn nicht stimmen den Punkten, die hier auf dieser Webseite genannt sind oder die von dem React-Team ins Feld geführt werden, nicht in allen Punkten zu und sehen das ein bisschen differenzierter oder bisschen kritischer vielleicht. Das ist dann wie gesagt, meine Meinung. Aber dazu müssen wir natürlich erst mal wissen, was das eine ist und was überhaupt das andere ist. Und in diesem Kurs möchte ich mit euch eine vollständige React-Anwendung bauen. Am Anfang werden wir da sehr fein granular vorgehen, Schritt für Schritt. Und diese Anwendung besteht im Prinzip aus zwei Teilen, wenn man so möchte. Das eine ist eine Admin-Anwendung. Damit fangen wir gleich an. Damit können wir Daten verwalten. Und das andere habe ich mal Frontend-Anwendung genannt. Das wäre eine Anwendung die quasi öffentlich im Internet steht und die diese Daten anzeigt. Und damit fange ich mal an bzw. Das zeige euch jetzt mal im ersten Schritt hier. Das ist die fertige Anwendung, die nennt sich Recipify. Und die Idee davon ist, dass ich Kochrezepte eingeben kann und diese Kochrezepte anderen Menschen zur Verfügung stellen kann. Das ist jetzt die sogenannte Frontend-Anwendung Die läuft tatsächlich mit Next.js und die gucken wir uns dann später an. Ich möchte jetzt erst mal nur zeigen, wie sie quasi aussieht. Wir haben hier diese Landing-Page. Wir können hier die Seite aufrufen. Dann seht ihr wir haben hier eine Liste von Kochrezepten. Wir können auf ein Kochrezept draufklicken. Wir können dann dieses Kochrezept uns anschauen. Wir haben hier sowas wie Zutaten. Wir haben hier sowas wie Kochinstructions. Also was muss ich eigentlich machen, um dieses Gericht zu kochen? Ich kann hier\n'slidetext': ''\n'from': 'vector'\n'score': 0.889756441116333\n'normalizedScore': 0.8856331844744\n'beforeDatePenaltyScore': 0.889756441116333\n\n'documentId': '50c03dd02cf9b7c2ff4480f2'\n'chunk_id': '68b55eab33a5bf00132cb687'\n'access': 'granted'\n'part_number': 6\n'total_parts': 47\n'contentType': 'TUTORIAL'\n'title': React-Grundlagen\n'parentName': Modern React: von Null auf Full-Stack\n'language': 'DE'\n'date': '2025-08-27T09:53:51.000Z'\n'abstract': In der ersten Lesson lernst du, was React ist und wie es funktioniert. Anhand einer Beispielanwendung schauen wir uns den Projektaufbau und den Workspace an. Du erfährst, wie Komponenten aufgebaut sind, wie man mit Props, Listen und State arbeitet und wie Interaktionen in React abgebildet werden.\n'parentId': 'b2c71c7c41dfe8eab4593f02'\n'parentDescription': In diesem Videotutorial lernst du React von Grund auf – bis hin zur Full-Stack-Entwicklung mit Next.js. Du baust Single Page Applications, verwaltest State, entwickelst moderne Formulare, arbeitest mit serverseitigen Daten und setzt Routing effizient um. Zum Abschluss bekommst du eine Einführung in React Server Components und Next.js. Benötigte Vorkenntnisse: JavaScript-Grundlagen, TypeScript ist hilfreich, aber nicht zwingend nötig. Nach dem Tutorial bist du bereit, eigene client- und serverseitige Anwendungen mit React umzusetzen.\n'indexBrandName': 'InternationalJavaScriptCon'\n'indexSeriesName': ''\n'author': 'Nils Hartmann'\n'chunkSource': 'text'\n'text': so schlau sind, hier in meinen Beispieldaten sei mal dahingestellt. Ehrlich gesagt, die Beispieldaten habe ich mir von Chetjibiti generieren lassen, die nicht so für bare Münze unbedingt nehmen. Dann haben wir hier unten können wir eingeben, welche Zutaten das Rezept braucht, können natürlich auch Zutaten löschen und so weiter. Und wir können dann eingeben, wie man das Rezept eigentlich zubereitet. Und in diesem Formular, wie gesagt, da sind so unterschiedliche Patterns drin, die wir uns angucken werden, wie man die baut, beispielsweise bei diesen Instructions hier. Die kann ich zum Beispiel mit Dreck in Drop umschieben. Wenn ich festgestellt habe, ich habe in der falschen Reihenfolge eingegeben. Ein zweites Pattern ist hier bei diesem Image zum Beispiel, dass ich hier ein neues Bild hochladen kann. Ich habe jetzt nicht so viele Beispielbilder, deswegen nehme ich hier mal eine Nudel und dann nehmen wir die mal hier und dann wird die hochgeladen. Und dann kann ich hier so ein bisschen da noch reinzoomen, wenn ich das möchte. Rauszoomen, wie man das ebenso von modernen Anwendungen kennt, kann hier den Bildausschnitt festlegen. Das Bild ist ein bisschen klein, ich muss wieder bisschen reinzoomen. So hier schön mit den Tomaten und dem Käse. Und dann kann ich das speichern und könnte das jetzt auch diesem Rezept hinzufügen, wenn ich das möchte. Das Rezept könnte ich natürlich jetzt auch noch speichern, das lasse ich mal weil ich jetzt die hier nur so zum Beispiel so ein paar Änderungen gemacht habe, die nicht wirklich sinnvoll sind. Aber wie gesagt, man dieses Formular entwickelt, werde ich euch zeigen. Ich werde euch zeigen, wie man kleinseitig mit verschiedenen Routen arbeitet. Wenn ihr mal hier auf die URL achtet, werdet ihr sehen, dass sich die immer ändert. Wenn ich hier rumklick, relativ lang. Da stehen relativ viele Informationen drin. Aber so verhält sich das ja in modernen Anwendungen. Genau, also das sind sozusagen die Themen, die wir uns angucken wollen. Wir wollen angucken, wie baue ich überhaupt React-Komponenten Was sind die Grundlagen von React? Wie kann ich mit serverseitigen\n'slidetext': ''\n'from': 'vector'\n'score': 0.8885044455528259\n'normalizedScore': 0.8843811889108929\n'beforeDatePenaltyScore': 0.8885044455528259\n\n'documentId': '50c03dd02cf9b7c2ff4480f2'\n'chunk_id': '68b55eab33a5bf00132cb682'\n'access': 'granted'\n'part_number': 1\n'total_parts': 47\n'contentType': 'TUTORIAL'\n'title': React-Grundlagen\n'parentName': Modern React: von Null auf Full-Stack\n'language': 'DE'\n'date': '2025-08-27T09:53:51.000Z'\n'abstract': In der ersten Lesson lernst du, was React ist und wie es funktioniert. Anhand einer Beispielanwendung schauen wir uns den Projektaufbau und den Workspace an. Du erfährst, wie Komponenten aufgebaut sind, wie man mit Props, Listen und State arbeitet und wie Interaktionen in React abgebildet werden.\n'parentId': 'b2c71c7c41dfe8eab4593f02'\n'parentDescription': In diesem Videotutorial lernst du React von Grund auf – bis hin zur Full-Stack-Entwicklung mit Next.js. Du baust Single Page Applications, verwaltest State, entwickelst moderne Formulare, arbeitest mit serverseitigen Daten und setzt Routing effizient um. Zum Abschluss bekommst du eine Einführung in React Server Components und Next.js. Benötigte Vorkenntnisse: JavaScript-Grundlagen, TypeScript ist hilfreich, aber nicht zwingend nötig. Nach dem Tutorial bist du bereit, eigene client- und serverseitige Anwendungen mit React umzusetzen.\n'indexBrandName': 'InternationalJavaScriptCon'\n'indexSeriesName': ''\n'author': 'Nils Hartmann'\n'chunkSource': 'text'\n'text': React-Grundlagen In der ersten Lesson lernst du, was React ist und wie es funktioniert. Anhand einer Beispielanwendung schauen wir uns den Projektaufbau und den Workspace an. Du erfährst, wie Komponenten aufgebaut sind, wie man mit Props, Listen und State arbeitet und wie Interaktionen in React abgebildet werden. Ja, herzlich willkommen zu meinem Videokurs zu React. Mein Name ist Nils Hartmann. Ich beschäftige mich seit einigen Jahren mit der React-Entwicklung, gebe in dem Zusammenhang auch Workshops und mache Vorträge auf Konferenzen. Und in diesem Kurs möchte ich euch die Entwicklung von Web-Anwendungen mit React näherbringen. Dabei fangen wir sozusagen bei Null an. Das heißt ich zeige euch erst mal, was sind eigentlich die Grundlagen von React? Was kann man mit React überhaupt machen? Was ist React überhaupt? Und so weiter und so fort. Und dann entfernen wir uns sozusagen von dem Kern React ein bisschen. Wir gucken uns typische Bibliotheken an die man benutzt, wenn man React-Anwendung baut. Und wir werden auch die Frage besprechen, ob man React-Anwendung eigentlich nur kleinzeitig ausführt oder ob man sie auch auf dem Server ausführen sollte. Das Stichwort wäre hier zum Beispiel Server-Side-Rendering, Full-Stack-React-Anwendung oder auch Frameworks für React. Habt ihr vielleicht schon mal gehört. Das alles möchte ich mit euch besprechen, sodass ihr dann nach dem Tutorial einen guten Eindruck davon habt was React ist, wie React funktioniert und ob React auch vielleicht für euer Projekt, für eure Anwendung eine Option sein könnte. Und falls ja, mit welchem Ansatz sozusagen ihr dann eure React-Anwendung bauen würdet. Also eher so auf dem Client oder auf dem Server oder beides. Das könnt ihr dann nach dem Kurs hoffentlich für euch entscheiden. Bevor wir richtig einsteigen, möchte ich euch noch ein paar Punkte sagen, die wir in diesem Kurs besprechen und die wir auch nicht besprechen. Wir werden, wie gesagt, bei Null anfangen. Das heißt ich zeige euch die Grundlagen von React. Dann werden wir uns Bibliotheken angucken und im letzten Teil werden wir uns dann Frameworks angucken und zwar in erster Linie Next.js, mit dem wir dann React-Anwendungen auch auf dem Server ausführen.\n'slidetext': ''\n'from': 'vector'\n'score': 0.8882331848144531\n'normalizedScore': 0.8841099281725201\n'beforeDatePenaltyScore': 0.8882331848144531\n\n'documentId': 'ed6b19fe4c4328050dad69e5'\n'chunk_id': '68c2ee64787074001356ea57'\n'access': 'granted'\n'part_number': 1\n'total_parts': 40\n'contentType': 'TUTORIAL'\n'title': Typsicheres Routing mit TanStack Router\n'parentName': Modern React: von Null auf Full-Stack\n'language': 'DE'\n'date': '2025-08-27T09:53:51.000Z'\n'abstract': In dieser Lesson lernst du, wie du mit dem TanStack Router eine moderne, typsichere Navigation in deine React-App bringst – inklusive Unterstützung für Links, Back-Button und Bookmarks. Wir zeigen dir die File-System-basierte Routenstruktur, dynamische Routen, Layout-Routen sowie die Verwendung von typsicheren Suchparametern. Außerdem: Integration mit TanStack Query und Performanceoptimierungen.\n'parentId': 'b2c71c7c41dfe8eab4593f02'\n'parentDescription': In diesem Videotutorial lernst du React von Grund auf – bis hin zur Full-Stack-Entwicklung mit Next.js. Du baust Single Page Applications, verwaltest State, entwickelst moderne Formulare, arbeitest mit serverseitigen Daten und setzt Routing effizient um. Zum Abschluss bekommst du eine Einführung in React Server Components und Next.js. Benötigte Vorkenntnisse: JavaScript-Grundlagen, TypeScript ist hilfreich, aber nicht zwingend nötig. Nach dem Tutorial bist du bereit, eigene client- und serverseitige Anwendungen mit React umzusetzen.\n'indexBrandName': 'InternationalJavaScriptCon'\n'indexSeriesName': ''\n'author': 'Nils Hartmann'\n'chunkSource': 'text'\n'text': Typsicheres Routing mit TanStack Router In dieser Lesson lernst du, wie du mit dem TanStack Router eine moderne, typsichere Navigation in deine React-App bringst – inklusive Unterstützung für Links, Back-Button und Bookmarks. Wir zeigen dir die File-System-basierte Routenstruktur, dynamische Routen, Layout-Routen sowie die Verwendung von typsicheren Suchparametern. Außerdem: Integration mit TanStack Query und Performanceoptimierungen. So, haben uns jetzt schon mit einer ganzen Reihe von Themen auseinandergesetzt. Wir haben gesehen, wie React grundsätzlich überhaupt funktioniert. Wir haben gesehen, wie wir mit Daten lesen, schreiben und so weiter klarkommen in unseren Anwendungen. Und wir haben uns damit auseinandergesetzt, wie wir Formulare bauen können. Und das alles haben wir jeweils gemacht anhand von ich sage mal, einzelnen isolierten Komponenten, die wir natürlich zu größeren Komponenten, Strukturen dann zusammengesteckt haben. Aber wir haben nicht so was gebaut wie eine Anwendung, wo man jetzt sagt, ich komme jetzt hier irgendwie rein, irgendwo an und dann klicke ich irgendwo drauf und dann bin ich im anderen Teil und so weiter und so fort. Und genau dieses Teil wollen wir uns jetzt angucken. Also wir bauen jetzt quasi richtig eine Anwendung, die aus mehreren Seiten sozusagen besteht, auch wenn wir technisch natürlich weiterhin eine Single Page Anwendung bauen. Und wenn wir jetzt mehrere Seiten in unserer Anwendung haben wollen, dann müssen wir üblicherweise so was wie einen Router verwenden. Ein Router ist dazu da, quasi URLs oder Fade in unserem Browser auf Komponenten abzubilden, sodass man quasi weiß, ich slash admin zum Beispiel aufgerufen habe, dann soll das Dashboard zum Beispiel erscheinen. Oder wenn ich nur die slash aufgerufen habe, dann soll vielleicht eine Landing Page erscheinen. Oder wenn ich slash user slash drei aufgerufen habe, dann soll die UI zum Bearbeiten des Users mit der ID 3 aufgerufen werden. Solche Geschichten. Dazu benutzt man einen Router und dieser Router ist eben dazu da, einerseits die Komponenten mit der URL zu verknüpfen, so funktioniert, wie wir das von Server-seitigen Anwendungen auch gewohnt sind. Also sprich, dass wir den Backbutton verwenden können, sprich, dass\n'slidetext': ''\n'from': 'vector'\n'score': 0.8878779411315918\n'normalizedScore': 0.8837546844896588\n'beforeDatePenaltyScore': 0.8878779411315918\n\n'documentId': '50c03dd02cf9b7c2ff4480f2'\n'chunk_id': '68b55eab33a5bf00132cb683'\n'access': 'granted'\n'part_number': 2\n'total_parts': 47\n'contentType': 'TUTORIAL'\n'title': React-Grundlagen\n'parentName': Modern React: von Null auf Full-Stack\n'language': 'DE'\n'date': '2025-08-27T09:53:51.000Z'\n'abstract': In der ersten Lesson lernst du, was React ist und wie es funktioniert. Anhand einer Beispielanwendung schauen wir uns den Projektaufbau und den Workspace an. Du erfährst, wie Komponenten aufgebaut sind, wie man mit Props, Listen und State arbeitet und wie Interaktionen in React abgebildet werden.\n'parentId': 'b2c71c7c41dfe8eab4593f02'\n'parentDescription': In diesem Videotutorial lernst du React von Grund auf – bis hin zur Full-Stack-Entwicklung mit Next.js. Du baust Single Page Applications, verwaltest State, entwickelst moderne Formulare, arbeitest mit serverseitigen Daten und setzt Routing effizient um. Zum Abschluss bekommst du eine Einführung in React Server Components und Next.js. Benötigte Vorkenntnisse: JavaScript-Grundlagen, TypeScript ist hilfreich, aber nicht zwingend nötig. Nach dem Tutorial bist du bereit, eigene client- und serverseitige Anwendungen mit React umzusetzen.\n'indexBrandName': 'InternationalJavaScriptCon'\n'indexSeriesName': ''\n'author': 'Nils Hartmann'\n'chunkSource': 'text'\n'text': ausführen. Wir werden uns nicht angucken, Themen zum Beispiel wie Styling, also wie ihr CSS in euren Anwendungen verwendet. Da macht React mehr oder weniger keine Aussage zu. Da könnt ihr alles benutzen, ihr was ihr möchtet. Alles was es an CSS-Optionen gibt, das werde ich hier nicht weiter besprechen. Und für den Kurs ist es hilfreich, wenn du JavaScript und TypeScript-Kenntnisse mitbringst. Du brauchst natürlich keine React-Kenntnisse. Kenntnisse von HTML sind sicherlich hilfreich. Kenntnisse grundsätzlich von Webentwicklungen sind sicherlich hilfreich. Ich glaube aber dass du dem Kurs auch sogar folgen kannst, wenn du keine oder nur wenig JavaScript und TypeScript-Kenntnisse hast. Du wirst wahrscheinlich die Konzepte dann zumindest auch verstehen, selbst wenn die ein oder andere Syntax vielleicht unklar ist. Anfangen werden wir bei Null mit einer klassischen Single-Page-Anwendung mit React. Das ist eigentlich mittlerweile fast ein bisschen umstritten, denn Single-Page-Anwendungen, klassische Single-Page-Anwendungen, die wir jahrelang mit React schon gebaut haben vielleicht oder die wir auch mit Angular oder Swelte bauen, die sind zumindestens was die Aussagen des React-Teams angeht, mittlerweile ein bisschen umstritten, um nicht zu sagen, das React-Team rät eigentlich davon ab, solche Anwendungen zu bauen. Trotz allem finde ich ganz hilfreich, damit anzufangen, weil wir dann nicht so viel Overhead haben, sozusagen, den wir lernen müssen. Ich möchte euch dazu eine Seite auf der React-Homepage zeigen. Da geht es darum, wie man eigentlich eine neue React-Anwendung anfängt. Und da steht relativ deutlich drin, ich übersetze das mal frei, wenn du eine neue Anwendung oder Webseite mit React baust, empfehlen wir zu starten mit einem Framework, also mit einem Framework zu starten. Und dann gibt es hier den Unterpunkt Full-Stack-Frameworks. Und hier stehen einige Full-Stack-Frameworks drauf, Next.js zum Beispiel. Das gucken wir uns dann auch zum Schluss an. Und wenn wir ganz weiter nach unten scrollen hier, dann findet man die Frage oder beziehungsweise die Antwort Start from scratch. Und da heißt es, wenn deine Anwendung Constraints hat, also Einschränkungen hat oder Anforderungen hat, die nicht\n'slidetext': ''\n'from': 'vector'\n'score': 0.8870155811309814\n'normalizedScore': 0.8828923244890484\n'beforeDatePenaltyScore': 0.8870155811309814\n\n'documentId': '50c03dd02cf9b7c2ff4480f2'\n'chunk_id': '68b55eab33a5bf00132cb68a'\n'access': 'granted'\n'part_number': 9\n'total_parts': 47\n'contentType': 'TUTORIAL'\n'title': React-Grundlagen\n'parentName': Modern React: von Null auf Full-Stack\n'language': 'DE'\n'date': '2025-08-27T09:53:51.000Z'\n'abstract': In der ersten Lesson lernst du, was React ist und wie es funktioniert. Anhand einer Beispielanwendung schauen wir uns den Projektaufbau und den Workspace an. Du erfährst, wie Komponenten aufgebaut sind, wie man mit Props, Listen und State arbeitet und wie Interaktionen in React abgebildet werden.\n'parentId': 'b2c71c7c41dfe8eab4593f02'\n'parentDescription': In diesem Videotutorial lernst du React von Grund auf – bis hin zur Full-Stack-Entwicklung mit Next.js. Du baust Single Page Applications, verwaltest State, entwickelst moderne Formulare, arbeitest mit serverseitigen Daten und setzt Routing effizient um. Zum Abschluss bekommst du eine Einführung in React Server Components und Next.js. Benötigte Vorkenntnisse: JavaScript-Grundlagen, TypeScript ist hilfreich, aber nicht zwingend nötig. Nach dem Tutorial bist du bereit, eigene client- und serverseitige Anwendungen mit React umzusetzen.\n'indexBrandName': 'InternationalJavaScriptCon'\n'indexSeriesName': ''\n'author': 'Nils Hartmann'\n'chunkSource': 'text'\n'text': zum Hintergrund schon mal. Ich habe hier ein Projekt angelegt, das basiert auf dem Build-Tool Veed. Das kann man in der Dokumentation von Veed nachlesen, wie man da mit React-Anwendungen anlegen kann. Da gibt es ein kleines Kommando-Zeilen-Tool. Da sagt man im Prinzip npm create Veed. Und dann sagt man noch, dass man da mit React-Anwendungen bauen will. Und dann wird ein kleines Projekt hingelegt. Das habe ich hier alles schon gemacht. Ich habe hier auch schon ein paar Pakete angelegt, die wir im weiteren Verlauf des Kurses benötigen werden. Aber im Grunde genommen sieht das so aus Es gibt eine Konfigurationsdatei von Veed. Da steht im Prinzip eigentlich nur drin, dass wir hier eine React-Anwendung bauen wollen. Dann haben wir eine Index-HTML-Datei. Das ist quasi immer der Einstieg von so einer React-Anwendung, wenn man sie denn mit Veed baut. Diese Index-HTML-Datei, zeigt auf eine Main-TSX-Datei. Und das ist quasi der Startpunkt für unsere React-Anwendung. Dann haben wir hier ein Source-Verzeichnis. Da liegen unsere Sourcen drin. Da ist jetzt nur ein ganz kleines bisschen hier schon mal vorbereitet. Wie gesagt ich habe hier eine Index-CSS-Datei, weil um das Styling kümmern wir uns in diesem Tutorial nicht. Das Styling habe ich hier schon vorbereitet Das sind so Tailwind-Klassen. Ich habe uns ein paar Hilfs-Dateien schon mal angelegt die wir später brauchen. Und dann gibt es hier einen Komponents-Ordner. Und in diesem Komponents-Ordner wollen wir jetzt anfangen, die Komponenten unserer Anwendung zu bauen. Und die allererste Komponente, damit ihr überhaupt mal seht, wie das so in React funktioniert, das soll eine ganz einfache Komponente sein. Es eine Komponente sein, die ein Bild darstellt. Diese Komponente soll Image Preview heißen. Und die Idee ist, ich habe ja diese Liste von Bildern in meinem Formular und aus dem ich dann ein Bild für mein Rezept auswählen kann. Und die Idee ist, dass diese Image Preview Komponente quasi eine Art wiederverwendbare Komponente ist, mit der ich eben ein Bild eines Kochrezepts oder beziehungsweise eines Gerichtes darstellen kann. Und um diese Komponente jetzt anzulegen,\n'slidetext': ''\n'from': 'vector'\n'score': 0.8864817023277283\n'normalizedScore': 0.8823584456857952\n'beforeDatePenaltyScore': 0.8864817023277283\n\n'documentId': 'ed6b19fe4c4328050dad69e5'\n'chunk_id': '68c2ee68787074001356ea83'\n'access': 'granted'\n'part_number': 37\n'total_parts': 40\n'contentType': 'TUTORIAL'\n'title': Typsicheres Routing mit TanStack Router\n'parentName': Modern React: von Null auf Full-Stack\n'language': 'DE'\n'date': '2025-08-27T09:53:51.000Z'\n'abstract': In dieser Lesson lernst du, wie du mit dem TanStack Router eine moderne, typsichere Navigation in deine React-App bringst – inklusive Unterstützung für Links, Back-Button und Bookmarks. Wir zeigen dir die File-System-basierte Routenstruktur, dynamische Routen, Layout-Routen sowie die Verwendung von typsicheren Suchparametern. Außerdem: Integration mit TanStack Query und Performanceoptimierungen.\n'parentId': 'b2c71c7c41dfe8eab4593f02'\n'parentDescription': In diesem Videotutorial lernst du React von Grund auf – bis hin zur Full-Stack-Entwicklung mit Next.js. Du baust Single Page Applications, verwaltest State, entwickelst moderne Formulare, arbeitest mit serverseitigen Daten und setzt Routing effizient um. Zum Abschluss bekommst du eine Einführung in React Server Components und Next.js. Benötigte Vorkenntnisse: JavaScript-Grundlagen, TypeScript ist hilfreich, aber nicht zwingend nötig. Nach dem Tutorial bist du bereit, eigene client- und serverseitige Anwendungen mit React umzusetzen.\n'indexBrandName': 'InternationalJavaScriptCon'\n'indexSeriesName': ''\n'author': 'Nils Hartmann'\n'chunkSource': 'text'\n'text': Weise, wie man Tenstack Query und Tenstack Router miteinander verknüpfen können. So ähnlich, muss man fairer Weise sagen, würde das auch mit dem React Router und Tenstack Query funktionieren. Aber hier ist die Integration natürlich besonders schön auch mit diesen Suchparametern und der Idee, dass ich angebe, wann soll mein Loder eigentlich ausgeführt werden, dann wird er nicht zu häufig und hoffentlich auch nicht zu selten ausgeführt. Damit haben wir das Datenladen jetzt einigermaßen optimiert. Jetzt haben wir unter Umständen noch ein anderes Problem, was auch ein häufiger Kritikpunkt an Single-Page-Anwendung ist. Und zwar, wenn ich meinen Link hier nehme und im Browser aufrufe, dann dauert das natürlich jetzt in dem Fall extrem lange, weil mein Query hier so lange ist. In einer richtigen Anwendung könnte aber auch das Problem bestehen, dass sowieso das erstmal relativ lange dauert, bis der JavaScript-Code für unsere Anwendung in den Browser geladen worden ist. Wir müssen uns ja vergegenwärtigen, wir rufen diese Adresse auf. Der Client macht ein Request zu unserem Server, der unter Umständen ja weit weg von uns steht, uns als Client, lädt den JavaScript-Code runter, muss den JavaScript-Code ausführen und erst dann können die Loader loslaufen, erst dann können die Komponenten gerendert werden. Das heißt da habe ich eine gewisse Latenz zwischen, ich habe die URL hier aufgerufen, die Anwendung ist da und die Anwendung kann loslaufen, um Daten zu laden. Je nachdem, wie groß der JavaScript-Code ist, kann das natürlich ein Momentchen dauern und das ist auf jeden Fall das kann man glaube ich mehr oder weniger pauschal so sagen, langsamer, als wenn ich eine serverseitig gerenderte Anwendung habe. Ob das ein Problem ist sei mal dahingestellt. Üblicherweise sind die Anwendungen ja trotzdem sehr schnell, aber natürlich können wir da eventuell auch noch bisschen Performance rausholen. Eine Kleinigkeit die wir hier machen können, das Thema zumindest ein bisschen besser zu machen, ich breche jetzt mal unseren Bildprozess hier ab, also den Development Server und werde mal einen Bild ausführen. Bild clean. Ich mache jetzt mal ein Produktionsbild von unserer Anwendung in Hoffnung, dass ich hier keine Fehler drin habe.\n'slidetext': ''\n'from': 'vector'\n'score': 0.886326789855957\n'normalizedScore': 0.882203533214024\n'beforeDatePenaltyScore': 0.886326789855957\n\n'documentId': 'a5dcfc84b51456a6b4b27fce'\n'chunk_id': '6878ecf122599b00136894c5'\n'access': 'granted'\n'part_number': 6\n'total_parts': 77\n'contentType': 'TUTORIAL'\n'title': Die Welt der Web Components\n'parentName': Web Components von 0 auf 100\n'language': 'DE'\n'date': '2025-06-05T13:45:07.000Z'\n'abstract': In der ersten Lesson steigen wir in die Welt der Web Components ein. Wir richten unser Setup ein, klären die Ziele des Tutorials – und schreiben unser erstes „Hello World“. Dabei beantworten wir die Grundfrage: Was sind Web Components eigentlich? Wir schauen uns Content-Attribute und DOM-Properties an, ziehen den Vergleich zu Frameworks und klären, wo Web Components glänzen – und wo nicht. Best Practices und erste UI-Beispiele runden den Einstieg ab.\n'parentId': '54cce7e83417cbefa7c0d3f0'\n'parentDescription': Web Components versprechen universelle Frontend-Komponenten, frei von Framework-Fesseln und Dependency-Depression. Das Problem: Web Components sind komplex, manche APIs wirken eigenartig, und das sie umgebende Ökosystem ist unübersichtlich. Was können Web Components leisten – und was nicht? Brauche ich wirklich Shadow DOM oder kann ich darauf verzichten? Vanilla-Komponenten, Lit – oder etwas dazwischen? In diesem Tutorial lernen wir, wie der Komponenten-Eintopf wirklich gemacht wird. Wir orientieren uns im Ökosystem und erhalten einen Überblick über die Fähigkeiten und Grenzen der Standards rund um Web Components. Von den absoluten API-Grundlagen bis zum Einsatz ausgewachsener Komponenten-Frameworks lassen wir keinen Schritt aus. In jedem Abschnitt unserer Reise erfahren wir nicht nur, wie etwas funktioniert, sondern auch, warum. Dieses Tutorial macht uns nicht nur zu Web-Component-Expert:innen, sondern vertieft auch unser Verständnis der Web-Plattform insgesamt.\n'indexBrandName': 'InternationalJavaScriptCon'\n'indexSeriesName': ''\n'author': 'Peter Kröner'\n'chunkSource': 'text'\n'text': wir werden einfach mal das dadurch exerzieren, weil das, glaube ich, eine gute Demonstration ist, wo man dann auch wirklich mal jeden Aspekt von allem, was wir bisher besprochen haben, werden einmal in Aktion sehen kann. Es ist also überschaubar und verständlich und klar abgegrenzt, aber nicht trivial. Das ist so im Wesentlichen mein Plan und die Ziele sind, wie gesagt, vor allen Dingen für mich Orientierung, dass ihr genau wisst, was es alles gibt und wie die Dinge zusammengehören. Dann auch ein bisschen Verständnis dafür, warum die Technologien so sind, wie sie sind, warum es auch nach diesem Videotutorial für euch viel, einfacher sein wird, ne Angular oder ne React-Komponente zu bauen. Die sind nämlich einfacher zu bauen, aber ein bisschen Verständnis dafür, warum das so ist und ne Einsicht in die Trade-offs, sodass man sich dann eventuell entscheiden kann. Ich wirklich mit meinem klassischen Frontend-Framework arbeite oder brauche ich ein Web-Component-Framework oder möglicherweise auch die Kombination aus beidem das gibt es nämlich auch. Dann möchte ich natürlich euch auch in die Lage versetzen, zur Not die ganzen Sachen manuell selber zu schreiben, also nicht nur die Frameworks zu bedienen. wenn wir das alles dann zusammen haben, dann glaube ich seid ihr ganz brauchbare Nerds Sachen Web-Components. Ihr wisst, wie die Wurst gemacht wird und ihr wisst, wann ihr euch wirklich mit diesen Details befassen wollt und wann nicht. Und das ist im Wesentlichen mein Plan für dieses Videotutorial. Und ich würde sagen, jetzt wo wir die ganzen Basics und die Planung und die Agenda aus dem Weg geräumt haben, bleibt nur eins, wir müssen anfangen. Wir müssen anfangen mit dem, womit wir bei solchen Tutorials immer anfangen müssen, nämlich mit Hallo Welt. Und genau das machen wir jetzt. Das war jetzt wirklich genug Gephasel von Dingen die man mal machen könnte, Zielen, die man haben könnte und Dingen, die vielleicht mal kompliziert sein werden. Was wir jetzt machen, ist ne richtige Web-Component bauen. Wir schauen uns an, wie die einzelnen Dinge zusammenspielen und wie das so grob funktionieren kann. Grundsätzlich\n'slidetext': ''\n'from': 'vector'\n'score': 0.8905597925186157\n'normalizedScore': 0.8818973907726746\n'beforeDatePenaltyScore': 0.8905597925186157\n\n'documentId': '50c03dd02cf9b7c2ff4480f2'\n'chunk_id': '68b55eab33a5bf00132cb685'\n'access': 'granted'\n'part_number': 4\n'total_parts': 47\n'contentType': 'TUTORIAL'\n'title': React-Grundlagen\n'parentName': Modern React: von Null auf Full-Stack\n'language': 'DE'\n'date': '2025-08-27T09:53:51.000Z'\n'abstract': In der ersten Lesson lernst du, was React ist und wie es funktioniert. Anhand einer Beispielanwendung schauen wir uns den Projektaufbau und den Workspace an. Du erfährst, wie Komponenten aufgebaut sind, wie man mit Props, Listen und State arbeitet und wie Interaktionen in React abgebildet werden.\n'parentId': 'b2c71c7c41dfe8eab4593f02'\n'parentDescription': In diesem Videotutorial lernst du React von Grund auf – bis hin zur Full-Stack-Entwicklung mit Next.js. Du baust Single Page Applications, verwaltest State, entwickelst moderne Formulare, arbeitest mit serverseitigen Daten und setzt Routing effizient um. Zum Abschluss bekommst du eine Einführung in React Server Components und Next.js. Benötigte Vorkenntnisse: JavaScript-Grundlagen, TypeScript ist hilfreich, aber nicht zwingend nötig. Nach dem Tutorial bist du bereit, eigene client- und serverseitige Anwendungen mit React umzusetzen.\n'indexBrandName': 'InternationalJavaScriptCon'\n'indexSeriesName': ''\n'author': 'Nils Hartmann'\n'chunkSource': 'text'\n'text': hier umrechnen, für wie viele Portionen ich ein Rezept kochen möchte. Also ein bisschen Interaktion haben wir auch dabei. Wir haben Bewertungen zu den Kochrezepten. Wir können eigene Bewertungen abgeben, wenn wir das möchten. Also im Prinzip alles Funktionalitäten, die man zum Beispiel auch von E-Commerce Webseiten kennt oder von Nachrichtenseiten. Also von ich sag mal, mehr oder weniger statischen Seiten, die sehr contentgetrieben sind und von denen wir möchten, dass sie natürlich sehr einfach zugänglich und sehr schnell zugänglich sind für unsere Benutzerinnen und Benutzer. Auf dieser Liste mit den Kochrezepten haben wir auch die typischen sage ich mal, typischen Bedienmuster. Wir können die Listen nach verschiedenen Dingen sortieren und wir können uns hier durch die einzelnen Seiten klicken, so wie man das auch von anderen Anwendungen kennt. Also ich denke mal, selbst wenn deine Domäne jetzt nicht unbedingt Kochrezepte sind, sondern du andere Arten von Anwendungen baust, kennst du wahrscheinlich das Problem, dass du Daten hast, die möchtest du sehr effizient und sehr schnell deinen Benutzerinnen und Benutzer zur Verfügung stellen. Und das ist eben sozusagen die Aufgabe von diesem Frontend. Das ist eine Customer Facing Web Anwendung, wenn man so will. Also wo die Endkundinnen und Kunden draufgehen. Der andere Teil unserer Anwendung. Und wie gesagt, da fangen wir dann auch in der Implementierung an. Das ist das sogenannte Administrationstool dazu. Da sind die Anforderungen vielleicht ein bisschen anders. Dieses Administrationstool, davon ist die Idee, dass ich das benutzen kann, um die Daten in diesem System zu pflegen. Also sprich neue Kochrezepte einzutragen, vielleicht andere zu bearbeiten, Kommentare freizuschalten und so was. Diese Anwendung ist ein bisschen einfacher oder hat weniger Features Ich muss mich hier natürlich anmelden, weil ich jetzt die Daten von diesem System verändere. Das können wir einmal ganz kurz hier machen. jetzt seht ihr schon, ich habe hier nicht ganz so schöne Oberfläche vielleicht. Die ist ein bisschen funktionaler. Wir haben jetzt hier ein sogenanntes Dashboard. Da sehen wir den aktuellen Datenbestand oder Ausschnitte aus diesem Datenbestand. Wir haben\n'slidetext': ''\n'from': 'vector'\n'score': 0.8858668804168701\n'normalizedScore': 0.8817436237749371\n'beforeDatePenaltyScore': 0.8858668804168701\n\n'documentId': 'e041b16a103e515fb3ff7fa7'\n'chunk_id': '6876df647899910dd58c1019'\n'access': 'granted'\n'part_number': 34\n'total_parts': 35\n'contentType': 'TUTORIAL'\n'title': Zugriff auf lokale Datenbanken\n'parentName': Mit .NET MAUI zur erfolgreichen Cross-Platform-App\n'language': 'DE'\n'date': '2025-02-07T10:45:08.000Z'\n'abstract': In dieser Lesson geht es um: -Zugriff auf lokale Datenbanken -Feinschliff -Abschluss\n'parentId': 'dd0d8f751be8d368f2f60eb9'\n'parentDescription': Zusammen mit Microsoft MVP André Krämer lernst du Schritt für Schritt, wie du mit .NET MAUI in C# und .NET native Apps für Android, iOS, macOS und Windows aus einer einzigen Codebasis erstellst. Du gestaltest ansprechende Benutzeroberflächen mit XAML und dem MVVM-Design-Pattern, stellst Daten in Listen übersichtlich dar und navigierst dabei nahtlos zwischen verschiedenen Ansichten. Zudem erfährst du, wie du Dependency Injection effizient einsetzt und native Gerätefunktionen wie die Kamera nutzt. Das praxisorientierte Tutorial ermöglicht dir, moderne Cross-Platform-Apps eigenständig zu entwickeln.\n'indexBrandName': 'BASTA!'\n'indexSeriesName': ''\n'author': 'André Krämer'\n'chunkSource': 'text'\n'text': und ich bin hier auf meinem GitHub-Profil, github.com slash André Kremer. Und hier sind für dich zwei relevante Repositories. zwar, klicke mir auf den Repositories-Tab und dann siehst du im Moment ist es ganz oben, falls das später irgendwann, wenn du hier drauf gehst, nicht mehr ganz oben ist, gar kein Problem. Du kannst hier einfach suchen nach Entwickler und dann siehst du hier das Entwickler.de Tutorial für die Anwendung WhoBorrowedIt. Also für das, was wir hier programmiert haben. Und wenn du dort reinklickst, dann siehst du sofort, das Ganze ist unter GitHub.com André Kremer Entwickler.de Tutorial Who Borrowed It. Und hier ist der komplette Quellcode drin von allem, was wir in diesem Tutorial gemeinsam erstellt haben. Heißt also, im Zweifelsfall klonest du dir das Tutorial oder noch einfach, du lädst dir einfach hier die ZIP-Datei herunter, dann entpackst du die und kannst von dort aus loslegen und die fehlenden Masken programmieren. Ich habe gesagt, hier sind mal Minimum zwei spannende Tutorials für dich drin. Nämlich wenn du hier mal reinschaust, dann siehst du hier direkt auf der Startseite den Sourcecode zu meinem Maui Buch. Natürlich, den verstehst du am besten, wenn du auch das zugehörige Buch dazu ich habe es ja mehrfach im Tutorial hier angemerkt, wenn du das auch noch direkt dazu dir bekaufst. Aber auch ansonsten, selbst wenn du das nicht hast, schau mal, das ist so aufgebaut, du hast hier jeweils die einzelnen Buchkapitel und du dort reinklickst, findest du immer ich nehme vielleicht mal ein anderes Kapitel oder 17er hier, dann findest du immer einen Ordner Don't let me expire, das ist die durchgängige Beispiel-App im Buch, die du hier dann auch verfolgen kannst, wie die sich Kapitel für Kapitel weiterentwickelt und du immer ein technisches Beispiel, hier zum Beispiel Kapitel 17, wie arbeite ich mit Bildern oder auch in Kapitel 19, wie findest du hier eigentlich, ab Kapitel 8 glaube ich ist es, in jedem Kapitel siehst du hier die Beispielanwendung plus ein technisches Beispiel. Also schau dort rein, dort lernst du noch eine ganze ganze Menge mehr\n'slidetext': ''\n'from': 'vector'\n'score': 0.8958971500396729\n'normalizedScore': 0.8807621461882015\n'beforeDatePenaltyScore': 0.8958971500396729\n\n'documentId': '50c03dd02cf9b7c2ff4480f2'\n'chunk_id': '68b55eab33a5bf00132cb689'\n'access': 'granted'\n'part_number': 8\n'total_parts': 47\n'contentType': 'TUTORIAL'\n'title': React-Grundlagen\n'parentName': Modern React: von Null auf Full-Stack\n'language': 'DE'\n'date': '2025-08-27T09:53:51.000Z'\n'abstract': In der ersten Lesson lernst du, was React ist und wie es funktioniert. Anhand einer Beispielanwendung schauen wir uns den Projektaufbau und den Workspace an. Du erfährst, wie Komponenten aufgebaut sind, wie man mit Props, Listen und State arbeitet und wie Interaktionen in React abgebildet werden.\n'parentId': 'b2c71c7c41dfe8eab4593f02'\n'parentDescription': In diesem Videotutorial lernst du React von Grund auf – bis hin zur Full-Stack-Entwicklung mit Next.js. Du baust Single Page Applications, verwaltest State, entwickelst moderne Formulare, arbeitest mit serverseitigen Daten und setzt Routing effizient um. Zum Abschluss bekommst du eine Einführung in React Server Components und Next.js. Benötigte Vorkenntnisse: JavaScript-Grundlagen, TypeScript ist hilfreich, aber nicht zwingend nötig. Nach dem Tutorial bist du bereit, eigene client- und serverseitige Anwendungen mit React umzusetzen.\n'indexBrandName': 'InternationalJavaScriptCon'\n'indexSeriesName': ''\n'author': 'Nils Hartmann'\n'chunkSource': 'text'\n'text': haben wir im ersten Teil, wenn wir uns gleich mit der Single-Page-Anwendung beschäftigen, bauen wir einen Client. Das habe ich genannt, das ReciPy-Admin-Tool. ReciPy ich schreibe es noch mal richtig. ReciPy, so und auch wieder nach oben hier mit der Schrift. Und das ist eben eine React Single-Page-Anwendung, das werden. React SPA. Und die kommuniziert direkt mit unserem Backend hier über HTTP beziehungsweise Restzugriffe. Man kann sicherlich darüber diskutieren, ob das was ich hier zur Verfügung gestellt habe, eine richtige Rest-API ist. Das ist mir aber jetzt ehrlich gesagt für diesen Kurs nicht ganz so wichtig. Wichtig ist, wir haben hier Endpunkte, die wir aufrufen können und dann die Daten bekommen, die unser Frontend benötigt. Im zweiten Schritt, wie gesagt, für diese Frontend-Anwendung Da sieht das Ganze ein bisschen anders aus. Da haben wir dann hier unseren Next.js-Server. Das ist das ReciPy-Frontend, wie ich das genannt habe. Und das ist eine Next.js-Anwendung. Und die Next.js-Anwendung greift natürlich auch auf dieses Backend zu. Der Unterschied ist aber zu der Single-Page-Anwendung hier, dass dieses Ding hier dieses ReciPy-Admin-Frontend, da das eine Single-Page-Anwendung ist, läuft die im Browser. Das heißt, Browser greift direkt auf unser Backend hier hinzu. In dieser Next.js-Anwendung das werden wir dann sehen, da läuft ein Teil im Browser und ein Teil auch im Next.js-Server. Das heißt, ist unsere Anwendung so bisschen aufgeteilt und die Requests sehen dann ungefähr so aus. Der Browser greift auf dieses Next.js-Backend zu und das Next.js-Backend greift dann auf unser richtiges Backend, unser Rest-Backend, unser API-Backend wie auch immer wir das nennen wollen, dann zu. Also da sieht das Deployment und alles dann ein kleines bisschen anders aus. Da beschäftigen wir uns dann aber mit, wenn wir zu diesem Teil gekommen sind. Gut, jetzt wissen wir sozusagen, wo wir hinwollen. Dann ist es Zeit anzufangen. Wie gesagt, wir fangen ganz vorne an, ganz klein. Wir gucken uns erst mal an was React eigentlich ist und wie wir da mit Anwendungen bauen. Und der erste Schritt wird eine ganz, kleine React-Komponente sein. Nur mal kurz zum\n'slidetext': ''\n'from': 'vector'\n'score': 0.8848119974136353\n'normalizedScore': 0.8806887407717022\n'beforeDatePenaltyScore': 0.8848119974136353\n\n'documentId': 'ed6b19fe4c4328050dad69e5'\n'chunk_id': '68c2ee64787074001356ea5a'\n'access': 'granted'\n'part_number': 4\n'total_parts': 40\n'contentType': 'TUTORIAL'\n'title': Typsicheres Routing mit TanStack Router\n'parentName': Modern React: von Null auf Full-Stack\n'language': 'DE'\n'date': '2025-08-27T09:53:51.000Z'\n'abstract': In dieser Lesson lernst du, wie du mit dem TanStack Router eine moderne, typsichere Navigation in deine React-App bringst – inklusive Unterstützung für Links, Back-Button und Bookmarks. Wir zeigen dir die File-System-basierte Routenstruktur, dynamische Routen, Layout-Routen sowie die Verwendung von typsicheren Suchparametern. Außerdem: Integration mit TanStack Query und Performanceoptimierungen.\n'parentId': 'b2c71c7c41dfe8eab4593f02'\n'parentDescription': In diesem Videotutorial lernst du React von Grund auf – bis hin zur Full-Stack-Entwicklung mit Next.js. Du baust Single Page Applications, verwaltest State, entwickelst moderne Formulare, arbeitest mit serverseitigen Daten und setzt Routing effizient um. Zum Abschluss bekommst du eine Einführung in React Server Components und Next.js. Benötigte Vorkenntnisse: JavaScript-Grundlagen, TypeScript ist hilfreich, aber nicht zwingend nötig. Nach dem Tutorial bist du bereit, eigene client- und serverseitige Anwendungen mit React umzusetzen.\n'indexBrandName': 'InternationalJavaScriptCon'\n'indexSeriesName': ''\n'author': 'Nils Hartmann'\n'chunkSource': 'text'\n'text': meinem Browser zugreifen kann. Das ist ganz wichtig, dass da sozusagen wirklich nur die Dateien drin sind, die ich von außen auch aufrufen möchte. Und eine Datei, mit der wir anfangen müssen, ist die sogenannte unterstrich unterstrich root.tsx Datei Die muss so heißen, die muss da liegen. Das ist unverhandelbar. Und was jetzt ganz spannend ist wenn ich diese Datei anlege und die Datei in meinem Editor hier neu lade, dann seht ihr dass da plötzlich Code vorhanden ist. Und das liegt daran, dass im Hintergrund das Bildtool von Veed beziehungsweise das Tenstack-Router-Plugin für Veed festgestellt habe, in dem Roots verzeichnet ist eine neue Datei. Dann läuft der Code-Generator los und generiert hier so ein kleines bisschen Boilerplate-Code für uns, dass wir das nicht schreiben müssen. Das ist ganz praktisch und das werden wir auch noch in weiteren Fällen sehen Damit haben wir sozusagen unsere erste Route angelegt. Das Besondere an dieser Route ist, dass die gerendert wird, in allen Fällen, egal was wir für einen Fahrt aufrufen. Das ist sozusagen so eine Art Basiskomponente, die immer gerendert wird, die wir zum Beispiel benutzen können, um ein ein Layout zu rendern. Wir brauchen sie einfach technisch und üblicherweise verwenden man sie zum Beispiel, um ein Layout zu rendern. Wenn wir jetzt in unsere Anwendung reinspringen, dann sehen wir, dass wir hier Hello-Route sehen und wir sehen, dass wir ein Not Found hier haben. Das liegt daran, dass diese Route-Komponente jetzt defaultmäßig wie gesagt, bei jedem Fahrt aufgerufen wird, egal was wir jetzt im Browser eintippen, localhost 3000, irgendein Fahrt dahinter. Diese Komponente wird ausgeführt. Ihr seht, das ist eine ganz normale React-Komponente hier und liefert ein Diff zurück, in dem Hello-Route steht. Das ist das, was wir hier sehen. Und wir können das vielleicht auch sogar schon mal ein kleines bisschen hier grafisch anpassen, indem wir hier meine eigene CSS-Klasse benutzen, die um die ganze Anwendung rumgelegt werden soll, die auch originellerweise den Namen Route-Komponent trägt. Wenn wir jetzt hier reingehen, sieht es optisch fast genauso\n'slidetext': ''\n'from': 'vector'\n'score': 0.8842200040817261\n'normalizedScore': 0.8800967474391589\n'beforeDatePenaltyScore': 0.8842200040817261\n\n'documentId': 'f84097699062ea49829a9ba7'\n'chunk_id': '6887448a2d7a080012cea4e3'\n'access': 'granted'\n'part_number': 43\n'total_parts': 63\n'contentType': 'TUTORIAL'\n'title': Shadow DOM (Teil 3): Server-Side Rendering\n'parentName': Web Components von 0 auf 100\n'language': 'DE'\n'date': '2025-06-05T13:45:07.000Z'\n'abstract': In dieser Lesson schauen wir uns die Herausforderungen und Möglichkeiten von Server-Side Rendering mit Web Components an. Du erfährst, wie Tools wie Happy DOM funktionieren, warum SSR überhaupt notwendig ist, welche Strategien es für CSS gibt, wie unterschiedliche Architekturansätze aussehen können – und worauf du achten musst, um typische Fallen und fehlende Features zu umgehen.\n'parentId': '54cce7e83417cbefa7c0d3f0'\n'parentDescription': Web Components versprechen universelle Frontend-Komponenten, frei von Framework-Fesseln und Dependency-Depression. Das Problem: Web Components sind komplex, manche APIs wirken eigenartig, und das sie umgebende Ökosystem ist unübersichtlich. Was können Web Components leisten – und was nicht? Brauche ich wirklich Shadow DOM oder kann ich darauf verzichten? Vanilla-Komponenten, Lit – oder etwas dazwischen? In diesem Tutorial lernen wir, wie der Komponenten-Eintopf wirklich gemacht wird. Wir orientieren uns im Ökosystem und erhalten einen Überblick über die Fähigkeiten und Grenzen der Standards rund um Web Components. Von den absoluten API-Grundlagen bis zum Einsatz ausgewachsener Komponenten-Frameworks lassen wir keinen Schritt aus. In jedem Abschnitt unserer Reise erfahren wir nicht nur, wie etwas funktioniert, sondern auch, warum. Dieses Tutorial macht uns nicht nur zu Web-Component-Expert:innen, sondern vertieft auch unser Verständnis der Web-Plattform insgesamt.\n'indexBrandName': 'InternationalJavaScriptCon'\n'indexSeriesName': ''\n'author': 'Peter Kröner'\n'chunkSource': 'text'\n'text': könnte als so. Außerdem kann man ja vielleicht wirklich was an der Developer Experience tun. Nehmen wir mal das Letztere als erstmal unser Starkbeispiel. Theoretisch ist es ja so, dass die wenigsten Menschen jetzt Web-Entwicklung so betreiben, wie ich das hier betreibe. Das hier ist wirklich eine nackte HTML-Seite und jedes Mal, wenn ich abspeichere, ist da wirklich nichts weiter drin als eine IDE-Extension, die den Browser nebenan macht, hier naht mal neu. Ich habe hier in dem Beispiel hier und bei den meisten anderen, die ich gezeigt habe, außer den React-Beispielen, keinen Bildprozess dabei, keinen Optimierer, keinen CSS-Prozessor, kein gar nichts. Ich verlasse mich wirklich darauf, dass mein Browser, also hier ein ganz normaler Firefox, in der Lage ist, mit modernen JavaScript-Modulen umzugehen. Das ist, was ich hier mache. Was ich mache, ist nicht der Normalfall. Der Normalfall ist tatsächlich, dass ihr irgendwas am Start habt, was in der Lage ist, ein bisschen smarter zu sein. Was spezielle Modul-Lade-Mechanismen zum Beispiel beinhaltet und was man dann da machen könnte. In so einem System, rein theoretisch, wäre sowas zu schreiben wie import styles from foo.css. Wenn ihr jetzt eine foo.css am Start habt, könnte natürlich ein Browser hiermit nichts anfangen, weil Browser standardmäßig CSS nicht importieren können. Ja, können sie demnächst vielleicht schon wir kommen da nachher noch zu. Aber normalerweise würde diese Zeile 7, so wie sie hier steht, nicht funktionieren. Aber wenn ihr irgendeine Art von Compiler habt, ein Webpack oder irgendwas in der Richtung, könnte dieses Ding, sich diese Zeile anschauen, könnte feststellen, hm dot CSS, das sollte ich vielleicht nicht als JavaScript-Modul laden, sondern vielleicht einfach als Text. Dass hier also wirklich CSS-Text rauskommt. Und wenn das der Fall wäre, dann könnte man natürlich hingehen und könnte in seiner Komponente einfach sowas hier machen. Styles kommen hier rein. Und schon ist es nicht mehr ganz so schlimm und man hat eine Trennung geschaffen von der JavaScript-Komponente hier und den CSS-Styles irgendwo anders. Weil das ja vielleicht etwas ist, das ihr Wert legt. Und dann\n'slidetext': ''\n'from': 'vector'\n'score': 0.887181282043457\n'normalizedScore': 0.8785188802975159\n'beforeDatePenaltyScore': 0.887181282043457\n\n'documentId': 'a5dcfc84b51456a6b4b27fce'\n'chunk_id': '6878ecf122599b00136894c4'\n'access': 'granted'\n'part_number': 5\n'total_parts': 77\n'contentType': 'TUTORIAL'\n'title': Die Welt der Web Components\n'parentName': Web Components von 0 auf 100\n'language': 'DE'\n'date': '2025-06-05T13:45:07.000Z'\n'abstract': In der ersten Lesson steigen wir in die Welt der Web Components ein. Wir richten unser Setup ein, klären die Ziele des Tutorials – und schreiben unser erstes „Hello World“. Dabei beantworten wir die Grundfrage: Was sind Web Components eigentlich? Wir schauen uns Content-Attribute und DOM-Properties an, ziehen den Vergleich zu Frameworks und klären, wo Web Components glänzen – und wo nicht. Best Practices und erste UI-Beispiele runden den Einstieg ab.\n'parentId': '54cce7e83417cbefa7c0d3f0'\n'parentDescription': Web Components versprechen universelle Frontend-Komponenten, frei von Framework-Fesseln und Dependency-Depression. Das Problem: Web Components sind komplex, manche APIs wirken eigenartig, und das sie umgebende Ökosystem ist unübersichtlich. Was können Web Components leisten – und was nicht? Brauche ich wirklich Shadow DOM oder kann ich darauf verzichten? Vanilla-Komponenten, Lit – oder etwas dazwischen? In diesem Tutorial lernen wir, wie der Komponenten-Eintopf wirklich gemacht wird. Wir orientieren uns im Ökosystem und erhalten einen Überblick über die Fähigkeiten und Grenzen der Standards rund um Web Components. Von den absoluten API-Grundlagen bis zum Einsatz ausgewachsener Komponenten-Frameworks lassen wir keinen Schritt aus. In jedem Abschnitt unserer Reise erfahren wir nicht nur, wie etwas funktioniert, sondern auch, warum. Dieses Tutorial macht uns nicht nur zu Web-Component-Expert:innen, sondern vertieft auch unser Verständnis der Web-Plattform insgesamt.\n'indexBrandName': 'InternationalJavaScriptCon'\n'indexSeriesName': ''\n'author': 'Peter Kröner'\n'chunkSource': 'text'\n'text': komplett ignorieren, aber dann besprechen werde. Also Bundler und Compiler und Optimizer, wie kann ich irgendwie TypeScript in meinen Web Components benutzen und wie sinnvoll ist das? Das werden wir da alles besprechen, das wird einfach so eine bunte Tool Show werden und das bietet dann so bisschen den Abschluss der Orientierungsphase. Danach seid ihr hoffentlich in der Lage, euch selbst auszusuchen, wie ihr denn operieren möchtet. Wollt ihr Vanilla Web Components schreiben oder wollt ihr ein Framework verwenden oder vielleicht irgendwas dazwischen euch gar, Gott bewahre, was eigenes bauen, das kann man dann nämlich relativ gut machen, das werden wir alles mal durchgekaut haben. Und zum Abschluss bauen wir einmal so eine Web Component wirklich von vorne bis hinten, beginnend bei einer blanken Datei und endend bei einem komplett, ja, alle Features benutzenden Objekte, einem Element. Ich habe mir da so einen Dark Mode Selektor ausgedacht, weil naja, das ist glaube ich, ganz gutes Beispiel. So Dark Mode Selektor ist was, das braucht man ständig, so ziemlich jede Webseite sollte sowas haben, dass man das so troggeln kann auf einer Pro Seitenbasis. Und es ist auch irgendwie was, wo jeder von uns glaube ich, ganz gut umreißen kann, was so die Anforderungen von sowas sind. Dark Mode Selektor kennen wir alle. Aber zum anderen ist es halt eben auch nicht ganz trivial, so ein Ding zu bauen. Da gibt es viele, viele Feinheiten. Es muss irgendwie interaktiv sein, es muss irgendwie einigermaßen zugänglich sein, es muss per Tastatur bedienbar sein, es muss universell sein, anpassbar sein und es muss halt eben auch eine ganze Menge komplizierten Zustand managen. Es muss sich irgendwie initialisieren, entweder irgendwelchen vorherigen State aus dem Storage lesen den wir schon mal eingestellt haben, oder sich initialisieren, abhängig davon, was die Einstellungen sind. Das ist also alles gar nicht mal so trivial, wenn man anfängt, drüber nachzudenken, und wir werden einfach mal das dadurch exerzieren, weil das, glaube ich, eine gute Demonstration ist, wo man dann auch wirklich mal jeden Aspekt von allem, was wir bisher besprochen haben, werden einmal\n'slidetext': ''\n'from': 'vector'\n'score': 0.8860228657722473\n'normalizedScore': 0.8773604640263062\n'beforeDatePenaltyScore': 0.8860228657722473\n\n'documentId': 'a5dcfc84b51456a6b4b27fce'\n'chunk_id': '6878ecf322599b00136894d9'\n'access': 'granted'\n'part_number': 26\n'total_parts': 77\n'contentType': 'TUTORIAL'\n'title': Die Welt der Web Components\n'parentName': Web Components von 0 auf 100\n'language': 'DE'\n'date': '2025-06-05T13:45:07.000Z'\n'abstract': In der ersten Lesson steigen wir in die Welt der Web Components ein. Wir richten unser Setup ein, klären die Ziele des Tutorials – und schreiben unser erstes „Hello World“. Dabei beantworten wir die Grundfrage: Was sind Web Components eigentlich? Wir schauen uns Content-Attribute und DOM-Properties an, ziehen den Vergleich zu Frameworks und klären, wo Web Components glänzen – und wo nicht. Best Practices und erste UI-Beispiele runden den Einstieg ab.\n'parentId': '54cce7e83417cbefa7c0d3f0'\n'parentDescription': Web Components versprechen universelle Frontend-Komponenten, frei von Framework-Fesseln und Dependency-Depression. Das Problem: Web Components sind komplex, manche APIs wirken eigenartig, und das sie umgebende Ökosystem ist unübersichtlich. Was können Web Components leisten – und was nicht? Brauche ich wirklich Shadow DOM oder kann ich darauf verzichten? Vanilla-Komponenten, Lit – oder etwas dazwischen? In diesem Tutorial lernen wir, wie der Komponenten-Eintopf wirklich gemacht wird. Wir orientieren uns im Ökosystem und erhalten einen Überblick über die Fähigkeiten und Grenzen der Standards rund um Web Components. Von den absoluten API-Grundlagen bis zum Einsatz ausgewachsener Komponenten-Frameworks lassen wir keinen Schritt aus. In jedem Abschnitt unserer Reise erfahren wir nicht nur, wie etwas funktioniert, sondern auch, warum. Dieses Tutorial macht uns nicht nur zu Web-Component-Expert:innen, sondern vertieft auch unser Verständnis der Web-Plattform insgesamt.\n'indexBrandName': 'InternationalJavaScriptCon'\n'indexSeriesName': ''\n'author': 'Peter Kröner'\n'chunkSource': 'text'\n'text': arbeite irgendwo wo reakt oder angular oder view oder sonst irgendwas verwendet und aus irgendwelchen gründen bin ich jetzt der meinung web components müssen hier mitspielen das gute ist das ist exakt gar kein problem denn was machen denn die modernen web framework was macht das moderne tooling eigentlich naja das macht nichts weiter als abstraktionen zu schaffen über html und css und javascript über das was wir halt eben als die drei grundpfeiler einer webseite einer web applikation haben es gibt nichts anderes als diese drei pfeiler alles was darauf aufsetzt muss auf irgendeine art und weise mit denen interagieren und das kann man tatsächlich hier an diesem reakt hello world ganz gut sehen da ist dieses komische modul dass wir importieren müssen dann gibt es hier dieses zeug dass wir ignorieren können aber dann kommt hier die zeile 13 da wo halt eben wie es der 13 halt eben auch gut steht alles schief geht da verwendet reakt diese jsx syntax hier das sieht ein bisschen aus als wäre es html ist es aber nicht wirklich es ist im prinzip eine alternative aufruf syntax für funktionen und das macht unter der haube im prinzip ein document create element h1 mit sehr vielen zwischenschritten aber das ist was am ende passiert es wird ein h1 element erstellt und am ende mit hilfe der reakt logik in die webseite gerendert und das können wir auch hier in meinem browser sehen da ist nach h1 mit hello world drin das funktioniert also ganz hervorragend ok was man jetzt aber wirklich wissen muss ist dass reakt eigentlich nur sich auf diese h1 draufgesetzt hat es hat die h1 nicht wirklich neu erfunden es hat nicht wirklich dazu irgendwas beigetragen außer halt alles was reakt ausmacht also den rendermechanismus und das statement und hast du nicht gesehen das ist da alles drin aber am ende wenn es halt wirklich darum geht irgendwas in den browser rein zu beamen dann muss es auch wieder zum nativen html greifen und so sachen wie diffs und h1 elemente und ähnliches benutzen und wissen was noch ein html element ist richtig genau unser hello world hier das kann ganz wunderbar in einer reakt application funktionieren wir können wirklich hingehen können buchstäblich diesen code nehmen können den\n'slidetext': ''\n'from': 'vector'\n'score': 0.8856419324874878\n'normalizedScore': 0.8769795307415467\n'beforeDatePenaltyScore': 0.8856419324874878\n\n'documentId': 'f84097699062ea49829a9ba7'\n'chunk_id': '688744872d7a080012cea4c7'\n'access': 'granted'\n'part_number': 15\n'total_parts': 63\n'contentType': 'TUTORIAL'\n'title': Shadow DOM (Teil 3): Server-Side Rendering\n'parentName': Web Components von 0 auf 100\n'language': 'DE'\n'date': '2025-06-05T13:45:07.000Z'\n'abstract': In dieser Lesson schauen wir uns die Herausforderungen und Möglichkeiten von Server-Side Rendering mit Web Components an. Du erfährst, wie Tools wie Happy DOM funktionieren, warum SSR überhaupt notwendig ist, welche Strategien es für CSS gibt, wie unterschiedliche Architekturansätze aussehen können – und worauf du achten musst, um typische Fallen und fehlende Features zu umgehen.\n'parentId': '54cce7e83417cbefa7c0d3f0'\n'parentDescription': Web Components versprechen universelle Frontend-Komponenten, frei von Framework-Fesseln und Dependency-Depression. Das Problem: Web Components sind komplex, manche APIs wirken eigenartig, und das sie umgebende Ökosystem ist unübersichtlich. Was können Web Components leisten – und was nicht? Brauche ich wirklich Shadow DOM oder kann ich darauf verzichten? Vanilla-Komponenten, Lit – oder etwas dazwischen? In diesem Tutorial lernen wir, wie der Komponenten-Eintopf wirklich gemacht wird. Wir orientieren uns im Ökosystem und erhalten einen Überblick über die Fähigkeiten und Grenzen der Standards rund um Web Components. Von den absoluten API-Grundlagen bis zum Einsatz ausgewachsener Komponenten-Frameworks lassen wir keinen Schritt aus. In jedem Abschnitt unserer Reise erfahren wir nicht nur, wie etwas funktioniert, sondern auch, warum. Dieses Tutorial macht uns nicht nur zu Web-Component-Expert:innen, sondern vertieft auch unser Verständnis der Web-Plattform insgesamt.\n'indexBrandName': 'InternationalJavaScriptCon'\n'indexSeriesName': ''\n'author': 'Peter Kröner'\n'chunkSource': 'text'\n'text': serverseitiges Skript schreiben, das HTML frisst und ein anderes HTML ausspuckt, wo dann die entsprechenden Änderungen drin sind und das, was dann ausgespuckt wird, das liefer ich halt aus. Das ist so das Szenario statischer Seitengenerator. Wenn ihr irgendwas anderes habt, ihr werkelt halt da irgendwie mit einem Java CMS rum, ihr habt PHP am Start, dann wird das Ganze ein bisschen kniffliger, dann wird das wirklich auch eine Frage vom Deployment und wie wird das integriert in euren sonstigen Text-Stack und das ist ein Thema, das fasse ich nicht an, weil a habe ich keine Ahnung und b weiß ich nicht, wie euer Stack aussieht. Dazu kann ich halt nichts sagen. Ich will nur einmal kurz zu Demonstrationszwecken jetzt zeigen, wie Server-Site-Rendering in Aktion sein kann, aber ihr seht schon, das hat am Ende nicht wirklich was mit den Komponenten zu tun, die ihr schreibt. Ihr werdet die halt auf irgendeine Art und Weise schreiben müssen, dass das auf irgendeine Weise, mit welchem System auch immer ihr am Start habt, so zusammenspielt, dass Server-Site-Rendering passieren kann, wenn ihr das denn haben wollt. Und jetzt gucken wir uns mal einen Weg an das zu tun. Wie gesagt, in dem Modus Static Site Generation in der primitivsten Form. Ich habe einfach HTML und ich baue da das HTML um. Einfach gesagt. Ist tatsächlich mit den entsprechenden Tools auch gar nicht so schwierig, wenn euer Use-Case halt auch ein gar nicht so schwieriger ist. Aber gut, schauen wir uns mal an, wie das tatsächlich funktionieren würde. Auf geht's. Server-Site, rendern wir uns doch mal was. Ich habe mir dafür ein Tool rausgesucht, das heißt Happydom. Hier sehen wir die GitHub-Seite auf der linken Seite. Einfach nach Happydom suchen, dann findet ihr das. Was das ist ist im Prinzip eine JavaScript-Implementierung eines Browsers ohne User-Interface. Davon gibt es viele, aber das ist die die mit Abstand am einfachsten zu benutzen ist. Was es macht, ist tatsächlich ein Browser sein, so mehr oder minder. Es enthält also Dom und JavaScript und HTML und all das und bietet uns nicht eine Oberfläche mit Sachen zum Anklicken, sondern\n'slidetext': ''\n'from': 'vector'\n'score': 0.8853603601455688\n'normalizedScore': 0.8766979583996277\n'beforeDatePenaltyScore': 0.8853603601455688\n\n\n Dieser Content von  ist in deiner Sprache nicht verfügbar. Zurück zur Antwort"
}