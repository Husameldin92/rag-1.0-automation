{
  "test_id": "test_012_explore_en",
  "query": "How do I enable feature X in the newest Angular if it’s not in your docs?",
  "endpoint": "reader_explore_text",
  "user": {
    "tier": "elevate",
    "language": "en"
  },
  "prompt": "main",
  "actual_response": "arrow_forward_iosDeine Suchergebnisse:  Getting the most out of Angular DevTools Sam VloeberghsInternational JavaScript Conference Munich 2025 Angular Signals: Neue Features für die reak... Felix WunderlichJavaScript Days Berlin und online 2025 Exploring httpResource in Angular 19.2 Manfred SteyerAdvanced Angular: Signals, NgRx & AI Forms Angular Signals: Neue Features für die reak... Felix SchützJavaScript Days München und online 2025 Modern Angular Workshop: Architektur und Fe... Manfred Steyer, Rainer Hahnekamp und weitereBASTA! Spring 2025 Angular 19: Incremental Hydration, Hybrid R... Manfred SteyeriJS Magazin 1.2025 Manfred Steyer on Angular 20: Signals, Dyna... Manfred SteyeriJS Magazine Volume 19 Custom Standalone APIs for Angular Manfred SteyeriJS Magazine Volume 19 Die neue httpResource in Angular 19.2 Manfred SteyeriJS Magazin 2.2025 Fit für die Zukunft: Migration zu Modern An... Manfred SteyerJavaScript Days München und online 2025 Professional Tips for Using Signals in Angu... Manfred SteyeriJS Magazine Volume 17 Wachsen ohne Chaos: Architektur für nachhal... Rainer HahnekampW-JAX 2025 Accessibility in Angular Alexander ThalhammerJavaScript Days Berlin und online 2025 How to architect Angular apps in 2025 Alain ChautardInternational JavaScript New York 2025 Angular’s New Era: Unveiling the Most Excit... Pankaj ParkarInternational JavaScript Conference Singapore 2024 Skalierbare Architekturen in Angular mit Nx Fabian GosebrinkBASTA! Spring 2025 Optimizing Angular Applications - Technique... Sonu KapoorInternational JavaScript New York 2024 Level-up your Angular Codebase with Cutting... Michael Egger-ZikesInternational JavaScript Conference Munich 2024 Built to last: Angular's Lessons in Framewo... Mark ThompsonInternational JavaScript New York 2024 Modern Angular: Renovierung für Ihre Anwend... Manfred SteyerJavaScript Days Berlin und online 2024 Building the Next Generation of Supercharge... Mark ThompsonInternational JavaScript New York 2024 Modern-Angular-Workshop: Architektur und Fe... Manfred Steyer, Rainer Hahnekamp und weitereBASTA! Herbst 2024 Renovate your Angular App! Michael Egger-ZikesInternational JavaScript Conference London 2024 Signal Store und Angular-Architektur – Rege... Manfred SteyerWindows Developer 4.2024 Modern Angular: Renovierung für Ihre Anwend... Daniel MurrmannJavaScript Days Muenchen und online 2024 Build the Next Generation of Web Apps With ... Mark ThompsonInternational JavaScript New York The Latest Innovations in the Angular Envir... Manfred SteyerJavaScript Magazine Issue 9How do I enable feature X in the newest Angular if it’s not in your docs?gpt-4.1-mini keyword: {\n  'phrase_out': 'feature X Angular',\n  'primary_version_array': [],\n  'secondary_version_array': [],\n  'year_array': ['2025','2026'],\n  'issue_array': []\n} \nIf you want to enable a specific feature 'X' in the newest Angular version but it is not explicitly documented in the available materials, here is a practical approach tailored for modern Angular development as of late 2025:\n\nCheck for Standalone APIs and Modular FeaturesAngular has been moving towards standalone components and standalone APIs that reduce reliance on NgModules. Many new features are exposed via provider factories named with the pattern provideXYZ or feature toggles using withABC functions. Even if feature X is not documented, look for such provider factories or configuration patterns in the Angular core or popular libraries like NgRx or Router [1.].\n\nUse Angular CLI and Schematics for Migration and Feature EnablementAngular provides schematics to assist with migration and enabling new features. If feature X relates to a new API or architectural pattern, there might be a schematic to help you migrate or enable it incrementally. This is especially true for standalone migration, control flow syntax, or router improvements [2.].\n\nLeverage Signals and Reactive PrimitivesMany recent Angular innovations revolve around Signals, linkedSignals, and the Resource API for reactive state and data management. If feature X involves reactivity or state management, consider using these primitives, which are designed to integrate smoothly with RxJS and provide better performance and developer experience [3.].\n\nExplore Experimental or Developer Preview FeaturesAngular often ships new features as developer previews or experimental APIs (e.g., httpResource in Angular 19.2). These may not be fully documented yet but can be enabled via imports from @angular/core or related packages. Check the Angular GitHub repo or changelogs for such experimental flags or APIs [4.].\n\nConsult Community and Conference ContentSince official docs may lag behind, look for recent conference talks, workshops, or articles by Angular experts. These often reveal how to enable or use new features before they are fully documented. For example, sessions on modern Angular architecture, standalone components, or advanced routing techniques provide practical guidance on enabling cutting-edge features [5.].\n\nFallback: Implement a Custom Provider or WrapperIf feature X is a new API pattern or configuration not yet integrated into Angular’s core, you can often implement a custom standalone API or provider factory yourself, following patterns used in Angular libraries. This involves creating injectable services, configuration tokens, and environment initializers to extend Angular’s behavior in a modular way [1.].\n\n\nSummaryTo enable an undocumented feature in the newest Angular, start by exploring standalone APIs and provider factories, use Angular CLI schematics for migration, leverage Signals and reactive primitives, and consider experimental APIs. Supplement this with insights from recent expert talks and workshops. If needed, implement custom providers following Angular’s modular design patterns. This approach ensures you stay aligned with Angular’s evolving architecture while preparing your codebase for future updates.\nIf you want, I can help you find specific examples or guides related to your feature X based on its nature or category. Just let me know!\n\nSources\n\nCustom Standalone APIs for Angular - Enterprise Angular This article examines patterns for building custom standalone APIs in Angular, inspired by established libraries like HttpClient, Router, and NgRx. ✅ This content is included with your elevate membership.\n\nLevel-up your Angular Codebase with Cutting-Edge APIs This conference talk examines how new Angular APIs enable modern codebases, focusing on migration strategies and developer experience. ℹ️ This talk of International JavaScript Conference Munich 2024 was part of a past event. Booking is no longer available, but you can discover the current edition right here on the platform.\n\nProfessional Tips for Using Signals in Angular - Enterprise Angular This article provides professional guidance on effectively using Signals in Angular, focusing on best practices for reactive data flow and integration with RxJS. ✅ This content is included with your elevate membership.\n\nDie neue httpResource in Angular 19.2 - Kolumne: Enterprise Angular This article examines the experimental httpResource feature in Angular 19.2 for loading data within reactive flows. ✅ This content is included with your elevate membership.\n\nTag 2:  Erweiterte Angular-Direktiven, Modernes Angular und Erweiterte Angular-Routing-Techniken (Lektion 3, 4 & 5) This seminar lesson focuses on advanced Angular directives, modern Angular features, and sophisticated routing techniques for scalable web applications. ℹ️ This talk of Angular Camp - Deep Dive Camp Intense Februar 2025 | Online was part of a past event. Booking is no longer available, but you can discover the current edition right here on the platform.\n\n\n\nMore on this Topic\n\nThe Latest Innovations in the Angular Environment - Column: Enterprise Angular This article explores Angular’s new standalone features and functional APIs that lighten applications and enhance maintainability by minimizing NgModule dependencies. ✅ This content is included with your elevate membership.\n\nAngular 19: Incremental Hydration, Hybrid Rendering und Signals - Kolumne: Enterprise Angular This article examines Angular 19’s new features, focusing on incremental hydration, hybrid rendering, and enhancements to Signals. ✅ This content is included with your elevate membership.\n\nManfred Steyer on Angular 20: Signals, Dynamic Components, AI, and What’s Next - Exploring selectorless components, signal-based forms, and other features in Angular This article discusses Angular 20’s evolution, focusing on signals, reactivity, dynamic components, and the framework’s future direction. ✅ This content is included with your elevate membership.\n\nSignal Store und Angular-Architektur – Regeländerungen und Fallstricke - Kolumne: Enterprise Angular This article examines how the NgRx Signal Store changes architectural rules and best practices in Angular applications. ✅ This content is included with your elevate membership.\n\nGetting the most out of Angular DevTools This conference talk presents practical techniques for using Angular DevTools to debug, profile, and optimize modern Angular applications. ✅ You still have access to the recordings for this talk of International JavaScript Conference Munich 2025 until 2026-04-27. Unfortunately, recordings are not available for workshops, but you can still access the slides and your certificate. Dive back in anytime!\n\nExploring httpResource in Angular 19.2 This seminar lesson examines how Angular 19.2’s httpResource enables reactive, signal-based data loading in modern applications. ✅ This content is included with your elevate membership.\n\nFit für die Zukunft: Migration zu Modern Angular This conference talk examines how to modernize Angular applications by adopting recent features like Signals, standalone APIs, and functional patterns. ℹ️ This talk of JavaScript Days München und online 2025 was part of a past event. Booking is no longer available, but you can discover the current edition right here on the platform.\n\nWachsen ohne Chaos: Architektur für nachhaltige Angular-Projekte This conference talk presents practical architectural strategies for sustainable Angular projects, covering modularization, state management, and scaling approaches. ✅ You still have access to the recordings for this talk of W-JAX 2025 until 2026-05-05. Unfortunately, recordings are not available for workshops, but you can still access the slides and your certificate. Dive back in anytime!\n\n\nReference:\n{\n  'translated_headers': {\n    'sources': 'Sources',\n    'more_on_this_topic': 'More on this Topic'\n  },\n  'sources': [],\n  'more_on_this_topic': [\n    {\n      'doc_id': '3acbf0544b06e04de42f0a07'\n    },\n    {\n      'doc_id': '1c2d0d1ddbcc6e6469e58943'\n    },\n    {\n      'doc_id': '1fed2c6361980d606789e315'\n    },\n    {\n      'doc_id': 'c8af1d2c9d8e08acaa09599f'\n    },\n    {\n      'doc_id': 'e68608162c5fe79f9ee9d810'\n    },\n    {\n      'doc_id': 'ac8bcbad20150e9773f7400b'\n    },\n    {\n      'doc_id': '43b7900e7154d2f13c41085b'\n    },\n    {\n      'doc_id': 'd74f910ab5ef9854703a97d3'\n    },\n    {\n      'doc_id': 'af6bfaa1ee403d005b7cb22d'\n    },\n    {\n      'doc_id': '9836770500f149a58b7769f9'\n    }\n  ]\n}\n\nChunks:\n'documentId': '3acbf0544b06e04de42f0a07'\n'chunk_id': '687ab4782be886398c2ab477'\n'access': 'granted'\n'part_number': 1\n'total_parts': 4\n'contentType': 'READ'\n'title': The Latest Innovations in the Angular Environment - Column: Enterprise Angular\n'parentName': JavaScript Magazine Issue 9\n'language': 'EN'\n'date': '2023-07-27T00:00:00.000Z'\n'abstract': Angular has recently acquired a few new features that allow the framework to be used in a fresh and lightweight way. This article demonstrates how these new features help to keep our solutions maintainable.\n'parentId': 'fb94d3945241b54be2e79cad'\n'parentDescription': Broaden your knowledge and expand your JavaScript techniques and practices. From Angular, React, and WebAssembly, to the best JavaScript IDEs, open source tools and more, you’ll learn insights on everything JS from seasoned experts in their field. Keep up with JavaScript news, tips, and advice with interviews, tutorials, and in-depth articles.\n'indexBrandName': ''\n'indexSeriesName': ''\n'author': 'Manfred Steyer'\n'chunkSource': 'text'\n'text': The Latest Innovations in the Angular Environment Column: Enterprise Angular Angular has recently acquired a few new features that allow the framework to be used in a fresh and lightweight way. This article demonstrates how these new features help to keep our solutions maintainable. Angular has recently acquired a few new features that allow the framework to be used in a fresh and lightweight way. This article demonstrates how these new features help to keep our solutions maintainable. The examples used are available in [1]. Standalone components The long-awaited standalone components are the first and, arguably, the biggest innovation of the most recent releases. The application is significantly more lightweight because they don't need indirections and don't depend on NgModules. Set the standalone flag in the component decorator to true to notify Angular that the component is a standalone one (listing 1). Listing 1 @Component({ standalone: true, imports: [ NgIf, NgForOf, AsyncPipe, JsonPipe, FormsModule, FlightCardComponent, CityValidator, ], selector: 'flight-search', templateUrl: './flight-search.component.html' }) export class FlightSearchComponent { private store = inject(Store); readonly flights$ = this.store.select(selectFilteredFlights); […] } In addition, the new imports array is also required to provide the compilation context. This context contains all other components as well as directives and pipes that use the template of the standalone component. NgModules that already exist can also be imported. This is required to keep supporting the existing code. So, the Angular team stays away from breaking changes. Moreover, even the building blocks that come with Angular do not yet completely dispense with NgModules. This is somewhat reflected in the example given: while the NgIf, NgFor, AsyncPipe, and JsonPipe components of the CommonModules are currently standalone, this is not yet the case for the FormsModule. Another innovation that makes Angular solutions lighter is demonstrated in the example in listing 1: It is now possible to inject dependencies directly into properties using inject (Box: 'inject and the ECMAScript standard'). Thus, the component does not need to introduce its own constructor for getting services. inject and the ECMAScript standard Another, less visible benefit of using inject is that the injected dependency can provide default values for other properties. In the scenario under consideration, the injected store provides a default value for flights$. In the past, this also worked with dependencies injected via the constructor. However, this approach does not adhere to ECMAScript standards. ECMAScript initially populates the properties with default values before executing the constructor. TypeScript currently adheres to this default. However, Angular developers are unaware of this because the Angular CLI activates the original\n'slidetext': ''\n'from': 'vector'\n'score': 0.9039825201034546\n'normalizedScore': 0.8580866680201212\n'beforeDatePenaltyScore': 0.9039825201034546\n\n'documentId': 'yeDqYHwX2d2dnZvTR'\n'chunk_id': '687b453c2b0a1813a73e5c09'\n'access': 'restricted'\n'part_number': 1\n'total_parts': 18\n'contentType': 'RHEINGOLD'\n'title': Build the Next Generation of Web Apps With Angular\n'parentName': International JavaScript New York\n'language': 'EN'\n'date': '2023-09-28T12:45:00.000Z'\n'abstract': The web is changing and Angular is changing to meet the needs of the modern web developer. But how is Angular changing? What features are available to help you build the next generation of Angular web apps? Come to this session to learn how Angular is evolving to enable developers to build dynamic web applications across the web stack. Whether you are new to Angular or a seasoned Angular developer, what I'm going to share will leave you excited about the future of web development with the platform. You'll find out why there has never been a better time to develop web apps with Angular.\n'parentId': '7xbLG2AYJB4BSzpe9'\n'parentDescription': \n'indexBrandName': 'InternationalJavaScriptCon'\n'indexSeriesName': 'NewYork'\n'author': 'Mark Thompson'\n'chunkSource': 'text'\n'text': Build the Next Generation of Web Apps With Angular The web is changing and Angular is changing to meet the needs of the modern web developer. But how is Angular changing? What features are available to help you build the next generation of Angular web apps? Come to this session to learn how Angular is evolving to enable developers to build dynamic web applications across the web stack. Whether you are new to Angular or a seasoned Angular developer, what I'm going to share will leave you excited about the future of web development with the platform. You'll find out why there has never been a better time to develop web apps with Angular. And the reason I do that is because I just wanna get your bodies moving, you know, get us like engaged. So let me get a double clap. Ready? 1, 2, 3. Are y'all ready for just one more? Gimme a triple clap. Fantastic. All right, friends, my name is Mark Thompson. I work on the Angular team at Google, and I have a confession to make right off the bat. You know, the web is changing and we talked a little bit about this during, during the q and a, but here's what I find to be true. Am I still off the camera? Okay, that's friends at home. I care about you. Don't you worry about it. I'm gonna try to stay in camera. All right, so here's what's changing. APIs are changing. You can do more now than you've ever been able to do with any web technology. Like think about the fact that we can write code in our browsers now because the web is so powerful. There was a time when I was first coming up as an engineer. I couldn't even imagine being able to do Photoshop in the browser. I couldn't imagine being able to create a web app in the browser that was just like magic to me. And now that is not only happening, but that's fully here. And so here's what the side effects of the web changing is that there are two groups that are changing along with it. You know, who else is changing? Your users. Oh, sorry. Expectations are changing because now users and developers are expecting more. What about your users? So your users want more out of your application. If you ever read the comment section on an app, people complain all the time now because they say, well, it, I'll give it five stars if it just did this. You ever seen that review before? Or, uh, I'm giving one star for now because it doesn't connect quite with my smartwatch. I mean, all of these problems\n'slidetext': ''\n'from': 'vector'\n'score': 0.901870846748352\n'normalizedScore': 0.8594561590485803\n'beforeDatePenaltyScore': 0.901870846748352\n\n'documentId': 'HMjgiHgaqRmGAddkF'\n'chunk_id': '687a2e839bbcb45d2a11f727'\n'access': 'restricted'\n'part_number': 1\n'total_parts': 1\n'contentType': 'RHEINGOLD'\n'title': Modern Angular: Renovierung für Ihre Anwendungen\n'parentName': JavaScript Days Muenchen und online 2024\n'language': 'DE'\n'date': '2024-03-21T08:00:00.000Z'\n'abstract': In den letzten Monaten hat Angular zahlreiche neue Features erhalten, die es ermöglichen, das Framework auf moderne und leichtgewichtige Weise zu verwenden. Signals für eine moderne und performante Change Detection, Standalone Components und Standalone APIs, funktionale Guards und Interceptoren, esbuild-Unterstützung sowie und zahlreiche Verbesserungen beim Router sind ein paar Beispiele dafür. In diesem Workshop starten wir mit einer klassischen Angular-Lösungen, die wir nach und nach um die neuen Möglichkeiten erweitern. Somit ergibt sich eine leichtgewichtige und moderne Lösung, die sich einfacher warten lässt und die Vorteile der neuen Features auch nutzen kann. Am Ende wissen Sie, wie sich Ihre Angular-Lösung modernisieren lässt und welche neuen Features sich für Ihre Vorhaben lohnen.\n'parentId': 'PgLz2ZMETKTvgz57u'\n'parentDescription': Das Trainingsevent für JavaScript, Angular, React und HTML & CSS\n'indexBrandName': 'JavaScriptDays'\n'indexSeriesName': 'Munich'\n'author': 'Daniel Murrmann'\n'chunkSource': 'text'\n'text': Modern Angular: Renovierung für Ihre Anwendungen In den letzten Monaten hat Angular zahlreiche neue Features erhalten, die es ermöglichen, das Framework auf moderne und leichtgewichtige Weise zu verwenden. Signals für eine moderne und performante Change Detection, Standalone Components und Standalone APIs, funktionale Guards und Interceptoren, esbuild-Unterstützung sowie und zahlreiche Verbesserungen beim Router sind ein paar Beispiele dafür. In diesem Workshop starten wir mit einer klassischen Angular-Lösungen, die wir nach und nach um die neuen Möglichkeiten erweitern. Somit ergibt sich eine leichtgewichtige und moderne Lösung, die sich einfacher warten lässt und die Vorteile der neuen Features auch nutzen kann. Am Ende wissen Sie, wie sich Ihre Angular-Lösung modernisieren lässt und welche neuen Features sich für Ihre Vorhaben lohnen. [object Object]\n'slidetext': ''\n'from': 'vector'\n'score': 0.8956974148750305\n'normalizedScore': 0.8628609235216566\n'beforeDatePenaltyScore': 0.8956974148750305\n\n'documentId': 'mrkFPBdm5bQQ8Q8nY'\n'chunk_id': '687a3560ca798166d3ba5e2c'\n'access': 'restricted'\n'part_number': 9\n'total_parts': 22\n'contentType': 'RHEINGOLD'\n'title': Renovate your Angular App!\n'parentName': International JavaScript Conference London 2024\n'language': 'EN'\n'date': '2024-04-10T08:30:00.000Z'\n'abstract': The Angular Team is currently pushing the popular enterprise frontend framework into a bright future. New APIs which are prooved as Solid in the JavaScript ecosystem and Qwiker start-up time by introducing more advanced server-side rendering support are combined with the new Control Flow syntax that feels like a perfect joint-venture between Svelte and .NET. The Standalone APIs make NgModules optional as well as RxJS and Zone.js will not be mandatory dependencies in the future anymore. But what does this mean for your current codebase? Which refactoring strategy is the best compromise between good preparation for the future and tight project budgets? The good news - all of this comes with backwards compatibility in mind. It is your own decision which pace to use to refactor your own codebase to the latest framework features. In this practical session, we will discuss those new APIs and discover ways to transform your code into a future-proof application.\n'parentId': 'cKCGY58YaztJ8GQ9k'\n'parentDescription': The JavaScript Fullstack Conference - Angular, Node.js, React and more\n'indexBrandName': 'InternationalJavaScriptCon'\n'indexSeriesName': 'London'\n'author': 'Michael Egger-Zikes'\n'chunkSource': 'text'\n'text': angular dependence injection behind the covers, that's nothing more. And as you can see, we can also pass arguments in EW. We pass features in, like in this case, in this case, that tell the HGB client implementation. Hey, please use not the XML HT P request API of the browser, but instead use the fetch method. The more modern API, this is recommended by the angular team. If you want to have a server side rendering in place, then the fetch method should be used, um, and the fu we can see provide router with the app route. So there seems to be an a root, a root configuration. We can look into that. Um, that's a typically route array that we can use, uh, to configure our route like we did in the past, but this time I do not pass them in into a four root method that instead a pass them in here into such a root array or configured as a rotary and capacity here in the provide router function. And what you can see here is a feature, a feature that tells my angular application, configured the root this way, configured router this way that it supports automatically component input bindings. I will refer to them a little bit later on the slides. Um, it allows you, um, as a spoiler, as a quick spoil, it allows you to connect router data to the inputs of the target component. So if the route says, Hey, I want to load my search component, then with that feature enabled, it would automatically try to find the property, uh, in my router configuration or in the UL and would automatically write this to the input of the component. So it's not needed to use the activated route necessarily anymore to fetch some dynamic IDs or names or whatever you would like to configure through the router. Um, and we can write such provider functions on our own as well. Okay, so this is the bootstrapping part of the standalone a PS how does a, a simple component look like? And for that, we can, for example, look into a UI component, my flight car, tm. So basically to also show this in the running application, we can, give me a second, we can look up something here. And then there is a result set of, uh, flight cards that renders out, uh, for each flight found return per server. We render out a flight card down there, um, to be used. And basically this card component implementation, it's a so-called UI component or dump component. Um, it receives its state by the parent component through such input bindings and can work with them. Again, I have an inline template\n'slidetext': ''\n'from': 'vector'\n'score': 0.8953345417976379\n'normalizedScore': 0.8635950824077343\n'beforeDatePenaltyScore': 0.8953345417976379\n\n'documentId': 'e68608162c5fe79f9ee9d810'\n'chunk_id': '68bef62c5b3acf0013024dfb'\n'access': 'granted'\n'part_number': 6\n'total_parts': 6\n'contentType': 'READ'\n'title': Signal Store und Angular-Architektur – Regeländerungen und Fallstricke - Kolumne: Enterprise Angular\n'parentName': Windows Developer 4.2024\n'language': 'DE'\n'date': '2024-03-11T23:00:00.000Z'\n'abstract': Der NgRx Signal Store ist ein moderner und leichtgewichtiger Store zur Zustandsverwaltung. Auch wenn er einfach zu nutzen ist, sorgt er gleich für mehrere Fragen hinsichtlich unserer Architektur: Wo soll er platziert werden? Wie groß soll ein einzelner Store sein? Darf ein Store auf andere Stores zugreifen? Kann er auch für den globalen Zustand verwendet werden? Kann er zusammen mit oder anstelle des traditionellen Redux-basierten NgRx Store genutzt werden? Dieser Artikel liefert Antworten und zeigt, dass leichtgewichtige Stores einige Regeln aus der Welt von Redux ändern.\n'parentId': '3ad3047d609b8bb3648ccd40'\n'parentDescription': Windows Developer informiert umfassend und herstellerneutral über die neuen Trends und Möglichkeiten der Software- und Systementwicklung rund um Microsoft- und Web-Technologien. Von der klassischen .NET-Entwicklung über .NET Core bis hin zu neuen Technologien wie Windows 10, Microsoft Azure und der ganzen Bandbreite der aktuellen Web-, Phone- und Tabletentwicklung für Android und iOS mit Xamarin und unterschiedlichen JavaScript-Frameworks. Professionelle Entwickler und IT-Entscheider erhalten genau die Informationen, die sie für den erfolgreichen Einsatz von unternehmensorientierten Lösungen benötigen.\n'indexBrandName': ''\n'indexSeriesName': ''\n'author': 'Manfred Steyer'\n'chunkSource': 'text'\n'text': Stattdessen können Sie einen Feature-Service einführen, der die benötigten Stores orchestriert. Links & Literatur [1] https://www.angulararchitects.io/blog/smarter-not-harder-simplifying-your-application-with-NgRx-signal-store-and-custom-features/ [2] Steyer, Manfred: 'Strategic Design mit Sheriff und Standalone'; WD 10.23 [3] https://www.npmjs.com/package/@angular-architects/NgRx-toolkit [4] https://www.angulararchitects.io/en/blog/routing-and-lazy-loading-with-standalone-components/\n'slidetext': ''\n'from': 'vector'\n'score': 0.8973249197006226\n'normalizedScore': 0.8639747297171116\n'beforeDatePenaltyScore': 0.8973249197006226\n\n'documentId': 'N9G6dCb5BArvu6cbr'\n'chunk_id': '687a2d559bbcb45d2a11ead2'\n'access': 'restricted'\n'part_number': 23\n'total_parts': 23\n'contentType': 'RHEINGOLD'\n'title': Renovate your Angular App!\n'parentName': International JavaScript Conference San Diego 2024\n'language': 'EN'\n'date': '2024-05-21T12:30:00.000Z'\n'abstract': The Angular Team is currently pushing the popular enterprise frontend framework into a bright future. New APIs proved to be solid in the JavaScript ecosystem and quicker start-up time introduced more advanced server-side rendering support. Combined with the new Control Flow syntax, it feels like a perfect joint venture between Svelte and .NET. The Standalone APIs make NgModules optional too. RxJS and Zone.js won't be a mandatory dependency in the future anymore. But what does this mean for your current codebase? Which refactoring strategy is the best compromise between good preparation for the future and tight project budgets? The good news is that all of this comes with backward compatibility in mind. It is your decision which pace to use to refactor your codebase to the latest framework features. In a practical session, we'll discuss those new APIs and discover ways to transform your code into a future-proof application.\n'parentId': 'BYZWRge2q657D9ZYR'\n'parentDescription': The Fullstack Conference for JS Development\n'indexBrandName': 'InternationalJavaScriptCon'\n'indexSeriesName': 'SanDiego'\n'author': 'Michael Egger-Zikes'\n'chunkSource': 'text'\n'text': often a little bit something, uh, something that was a little bit hard to implement on your own without flickering and so on. Um, and they merged with an internal Google team called with, um, they have quite a, a lot of know-how in the service at rendering area because they're, they're driving the, the Google search and YouTube. And so really, uh, uh, services that need to, to bootstrap and, and, uh, uh, quite quickly actually. Um, and over the years, the next years, uh, the with, uh, team at Angular team will merge together. And you get, we all get the best of both sides because with, has a, a fantastic service at rendering, uh, concept applied that works in practice in several years. And on the other hand, cool, uh, angular or Angular itself has a, has a quite good developer experience, which is quite worse in this, uh, and not that, uh, good service rendering support, at least in the past. So we get two benefits from both sides and a win-win for us all. Yeah, win-win for, for Google Forward, the Wisdom team, for the Angular team and for us as a angular community. So we will get upcoming partial hydration features means, um, parts of the website can get interactive only if, if you need them. Yeah, that's also quite, quite interesting. Uh, yeah, we have a rich ecosystem like I presented in my previous talk with the NX signals, uh, package as well. That helps us to do the state management part. Fine, yeah, you can find all my material here on the, um, I will push it in a moment. The latest changes to the repository here. Uh, the slides are available on def mi, we'll also tweet about them. So, uh, yeah, feel free to look into that. And if you have any questions, reach out. Thanks. Thank you.\n'slidetext': ''\n'from': 'vector'\n'score': 0.8939515352249146\n'normalizedScore': 0.864467783597568\n'beforeDatePenaltyScore': 0.8939515352249146\n\n'documentId': 'N9G6dCb5BArvu6cbr'\n'chunk_id': '687a2d529bbcb45d2a11eaa3'\n'access': 'restricted'\n'part_number': 1\n'total_parts': 23\n'contentType': 'RHEINGOLD'\n'title': Renovate your Angular App!\n'parentName': International JavaScript Conference San Diego 2024\n'language': 'EN'\n'date': '2024-05-21T12:30:00.000Z'\n'abstract': The Angular Team is currently pushing the popular enterprise frontend framework into a bright future. New APIs proved to be solid in the JavaScript ecosystem and quicker start-up time introduced more advanced server-side rendering support. Combined with the new Control Flow syntax, it feels like a perfect joint venture between Svelte and .NET. The Standalone APIs make NgModules optional too. RxJS and Zone.js won't be a mandatory dependency in the future anymore. But what does this mean for your current codebase? Which refactoring strategy is the best compromise between good preparation for the future and tight project budgets? The good news is that all of this comes with backward compatibility in mind. It is your decision which pace to use to refactor your codebase to the latest framework features. In a practical session, we'll discuss those new APIs and discover ways to transform your code into a future-proof application.\n'parentId': 'BYZWRge2q657D9ZYR'\n'parentDescription': The Fullstack Conference for JS Development\n'indexBrandName': 'InternationalJavaScriptCon'\n'indexSeriesName': 'SanDiego'\n'author': 'Michael Egger-Zikes'\n'chunkSource': 'text'\n'text': Renovate your Angular App! The Angular Team is currently pushing the popular enterprise frontend framework into a bright future. New APIs proved to be solid in the JavaScript ecosystem and quicker start-up time introduced more advanced server-side rendering support. Combined with the new Control Flow syntax, it feels like a perfect joint venture between Svelte and .NET. The Standalone APIs make NgModules optional too. RxJS and Zone.js won't be a mandatory dependency in the future anymore. But what does this mean for your current codebase? Which refactoring strategy is the best compromise between good preparation for the future and tight project budgets? The good news is that all of this comes with backward compatibility in mind. It is your decision which pace to use to refactor your codebase to the latest framework features. In a practical session, we'll discuss those new APIs and discover ways to transform your code into a future-proof application. So then let's get the party Started. Microphone on fine. Then. Um, yeah, I've learned I'm not allowed to move that far, but that should be fine. Okay. Uh, welcome everyone here in the room, in, in San Diego, beautiful San Diego and everyone also, uh, connected online, um, through Deaf meal. Uh, hello everyone. Um, I would like to, um, talk a little bit about, uh, renovating Your Angle applications. That means we have received so many APIs that it's basically a challenge to really figure out what to, uh, refactor immediately, what to refactor later. Um, so quite a lot to do for applications and yeah, let's dive directly into that. Um, as soon as my clicker reacts list, um, we will talk about standalone migration. Um, we can do so with some, uh, schematics, but also manually. Um, we look into the signals, API also how we can, uh, refactor our current components into new ones. Um, and, uh, we will talk about the router integration. There are several features, um, that basically makes it easier for us and it, to be honest, feels better than in the past to work with ENG router. So for example, uh, getting an ID out of the URL, uh, using, uh, quite a bunch of modern features, signal, signal inputs, um, and other features, um, to, to get, uh, access to the routing state and, and use it in your child components there. Um, we will also talk about, uh, provider functions and inject functions. So they are important right now. Um, on one hand, you know them basically, uh, maybe already from the Angular framework itself,\n'slidetext': ''\n'from': 'vector'\n'score': 0.8946701884269714\n'normalizedScore': 0.8651864367996249\n'beforeDatePenaltyScore': 0.8946701884269714\n\n'documentId': 'mrkFPBdm5bQQ8Q8nY'\n'chunk_id': '687a355fca798166d3ba5e20'\n'access': 'restricted'\n'part_number': 3\n'total_parts': 22\n'contentType': 'RHEINGOLD'\n'title': Renovate your Angular App!\n'parentName': International JavaScript Conference London 2024\n'language': 'EN'\n'date': '2024-04-10T08:30:00.000Z'\n'abstract': The Angular Team is currently pushing the popular enterprise frontend framework into a bright future. New APIs which are prooved as Solid in the JavaScript ecosystem and Qwiker start-up time by introducing more advanced server-side rendering support are combined with the new Control Flow syntax that feels like a perfect joint-venture between Svelte and .NET. The Standalone APIs make NgModules optional as well as RxJS and Zone.js will not be mandatory dependencies in the future anymore. But what does this mean for your current codebase? Which refactoring strategy is the best compromise between good preparation for the future and tight project budgets? The good news - all of this comes with backwards compatibility in mind. It is your own decision which pace to use to refactor your own codebase to the latest framework features. In this practical session, we will discuss those new APIs and discover ways to transform your code into a future-proof application.\n'parentId': 'cKCGY58YaztJ8GQ9k'\n'parentDescription': The JavaScript Fullstack Conference - Angular, Node.js, React and more\n'indexBrandName': 'InternationalJavaScriptCon'\n'indexSeriesName': 'London'\n'author': 'Michael Egger-Zikes'\n'chunkSource': 'text'\n'text': uh, JavaScript community, if you normally ask them what's the, the really powerful API that Angular has, uh, where Angular has really was really in innovative and, and, um, implemented a set of features that the other frameworks did not have back then. Um, basically it's dependence injection, so that's a big success story. It makes things far easier, uh, in a lean manner, connecting your, um, your dependencies to components, directives and so on. And the system stayed the same, but we received new APIs on how to work with the dependent injection. Um, also because of the standalone, uh, APIs that were introduced, because if you think back, or maybe it's even currently still in your code base, that's perfectly fine. Um, how did we add roots, for example, with the route the module, uh, for root and with the route the module for a child. Today, we make this differently. We have provider functions. We also do this for state management to connect the new states life into our application. Um, we'll also talk about the control flow. That's another nice feature that was added, uh, with the last nature release. Um, it makes, uh, it transforms your code with a schematic generator that we can use, uh, from NG NG four NG switch to a kind of different template language with an add symbol in front. And it looks more like something erect component. You can also say selt component, or there are also similar notations in.net applications, for example, where we can really have code blocks in the template, or at least it looks like a code block. It's still HTML template, but, um, it's, it's far easier to read and, and therefore also not only for reading, uh, something beneficial, but also for performance because the, the angle application can render all your iterable lists like an array, for example, um, more performant than in the past. And then dot, dot, dot, uh, the spread operator. Right? Um, we have some, some other nice features as well, uh, that, that I will take here at least briefly in an overview slide at end. Um, my name is Mikey. I work at the Angular Architects. Um, so together with Maner Van Amp and some other guys, we try to help our customers and Angola with trainings, consultancies and reviews and sometimes, uh, yeah, and even here at conferences, um, hopefully giving you some, some nice inputs about, uh, current topics that, uh, are relevant for the Angular development. Um, yeah, you can find me also on Twitter. I still see Twitter\n'slidetext': ''\n'from': 'vector'\n'score': 0.8972049355506897\n'normalizedScore': 0.8654654761607861\n'beforeDatePenaltyScore': 0.8972049355506897\n\n'documentId': 'N9G6dCb5BArvu6cbr'\n'chunk_id': '687a2d559bbcb45d2a11ead0'\n'access': 'restricted'\n'part_number': 22\n'total_parts': 23\n'contentType': 'RHEINGOLD'\n'title': Renovate your Angular App!\n'parentName': International JavaScript Conference San Diego 2024\n'language': 'EN'\n'date': '2024-05-21T12:30:00.000Z'\n'abstract': The Angular Team is currently pushing the popular enterprise frontend framework into a bright future. New APIs proved to be solid in the JavaScript ecosystem and quicker start-up time introduced more advanced server-side rendering support. Combined with the new Control Flow syntax, it feels like a perfect joint venture between Svelte and .NET. The Standalone APIs make NgModules optional too. RxJS and Zone.js won't be a mandatory dependency in the future anymore. But what does this mean for your current codebase? Which refactoring strategy is the best compromise between good preparation for the future and tight project budgets? The good news is that all of this comes with backward compatibility in mind. It is your decision which pace to use to refactor your codebase to the latest framework features. In a practical session, we'll discuss those new APIs and discover ways to transform your code into a future-proof application.\n'parentId': 'BYZWRge2q657D9ZYR'\n'parentDescription': The Fullstack Conference for JS Development\n'indexBrandName': 'InternationalJavaScriptCon'\n'indexSeriesName': 'SanDiego'\n'author': 'Michael Egger-Zikes'\n'chunkSource': 'text'\n'text': component, please apply a directive. So a lot of use cases where you normally would need inheritance, for example, you can use instead host directives to add some additional features, um, to your application. Uh, ES build support, new build tool, uh, in some cases, uh, quite easy to migrate. In other cases, a little bit more effort. There's an upgrade guide also, uh, and even an experimental schematics support. Um, you have two options actually. You can migrate the web pack based builder to a, uh, browser builder ES build that has less breaking changes. And you have, uh, the, the application builder, the new one that has, uh, a little bit more breaking changes, but in a lot of code bases it works quite nice. You have much quicker build, you have wheat as a dev server, so that's the new standard for new angular applications for remaining one you can opt in server that rendering, um, angular can now, uh, really do this as part of the Angular framework. So they insourced the, the external universal package into, into the angular names is quite a good thing because then it has another maintenance levered in a community project, um, as it was in the past at least. Um, and it's now part of the application builder. So also the Ang Angular chase setup is it's less to set up actually as configuration in the, in the angular adjacent because it's directly integrated. Um, and the idea is to make this a default feature for everyone in future so that you do not need to think much, whether you want to activate, uh, server set rendering or leave it, um, deactivated, um, it's at the moment and a feature that helps us to, um, basically get, uh, initial few renders, uh, more quickly. So better startup performance, but also it's helpful for server sites, um, uh, for search engine optimizations. Um, so better indexing for the search engines like Google, for example. Uh, and other features were already added. Hydration. That means if something initially runs on the server and it loads some state from, um, from the, uh, backend resource server, for example, it can use that state and directly hand it over to the client, run them. So you do not need to do the initial server course once again. So this is based into the hydration feature. This was often a little bit something, uh, something that was a little bit hard to implement on your own without flickering and so on. Um, and they merged with an internal Google team called with, um, they have quite a, a lot of know-how\n'slidetext': ''\n'from': 'vector'\n'score': 0.8971368074417114\n'normalizedScore': 0.8676530558143649\n'beforeDatePenaltyScore': 0.8971368074417114\n\n'documentId': 'mrkFPBdm5bQQ8Q8nY'\n'chunk_id': '687a355fca798166d3ba5e1c'\n'access': 'restricted'\n'part_number': 1\n'total_parts': 22\n'contentType': 'RHEINGOLD'\n'title': Renovate your Angular App!\n'parentName': International JavaScript Conference London 2024\n'language': 'EN'\n'date': '2024-04-10T08:30:00.000Z'\n'abstract': The Angular Team is currently pushing the popular enterprise frontend framework into a bright future. New APIs which are prooved as Solid in the JavaScript ecosystem and Qwiker start-up time by introducing more advanced server-side rendering support are combined with the new Control Flow syntax that feels like a perfect joint-venture between Svelte and .NET. The Standalone APIs make NgModules optional as well as RxJS and Zone.js will not be mandatory dependencies in the future anymore. But what does this mean for your current codebase? Which refactoring strategy is the best compromise between good preparation for the future and tight project budgets? The good news - all of this comes with backwards compatibility in mind. It is your own decision which pace to use to refactor your own codebase to the latest framework features. In this practical session, we will discuss those new APIs and discover ways to transform your code into a future-proof application.\n'parentId': 'cKCGY58YaztJ8GQ9k'\n'parentDescription': The JavaScript Fullstack Conference - Angular, Node.js, React and more\n'indexBrandName': 'InternationalJavaScriptCon'\n'indexSeriesName': 'London'\n'author': 'Michael Egger-Zikes'\n'chunkSource': 'text'\n'text': Renovate your Angular App! The Angular Team is currently pushing the popular enterprise frontend framework into a bright future. New APIs which are prooved as Solid in the JavaScript ecosystem and Qwiker start-up time by introducing more advanced server-side rendering support are combined with the new Control Flow syntax that feels like a perfect joint-venture between Svelte and .NET. The Standalone APIs make NgModules optional as well as RxJS and Zone.js will not be mandatory dependencies in the future anymore. But what does this mean for your current codebase? Which refactoring strategy is the best compromise between good preparation for the future and tight project budgets? The good news - all of this comes with backwards compatibility in mind. It is your own decision which pace to use to refactor your own codebase to the latest framework features. In this practical session, we will discuss those new APIs and discover ways to transform your code into a future-proof application. All, Now it works. Hi. Hi again to everyone. Uh, we are, um, today talking about the new Angular features. Uh, the talk is called Runway Weight Your Angle app because, um, actually we are now on version 17 and quite a bunch of features were added recently. If you look back in time, the new generation of Angular two plus applications, some even called it Angular three already because we never had a version three in our framework. Um, it's, it, it changes quite that much, um, that we could even argue. Maybe it's a, it's, it's the third generation of the Angola framework, but this time not that way. Like we had the transition, the, to be honest, painful transition from Angular one to Angular two this time. Um, Ola team learned quite a lot from, uh, those days back then and from the feedback of the community that wasn't, that the community wasn't that happy about all the migration projects that still are today a thing for some companies to migrate. The Angular J called base to Angular two plus applications Angular 17, maybe today. Um, and so they found a quite better strategy, a strategy that leads to more effort for them and not more effort for us implementing our Angular applications and will exactly tackle that topic today. That means, um, since Angular 14 at least, um, they had quite a, a high pace implementing new features, offering new features, offering, develop a preview with, uh, the signals, API with the new control flow with, uh, standalone components at the beginning with Angola. 14. Uh, what else did we receive? Uh, typed finally typed forms. So quite a bunch of\n'slidetext': ''\n'from': 'vector'\n'score': 0.8994925022125244\n'normalizedScore': 0.867753042823255\n'beforeDatePenaltyScore': 0.8994925022125244\n\n'documentId': 'vAJzqCurd28Mq4HRk'\n'chunk_id': '687a3236ca798166d3ba4eca'\n'access': 'restricted'\n'part_number': 1\n'total_parts': 1\n'contentType': 'RHEINGOLD'\n'title': Modern-Angular-Workshop: Architektur und Features\n'parentName': BASTA! Herbst 2024\n'language': 'DE'\n'date': '2024-09-20T07:00:00.000Z'\n'abstract': In diesem Workshop tauchen Sie tief in die neuesten Angular-Features ein, um moderne, wartbare Anwendungsarchitekturen zu entwickeln. Lernen Sie, wie Sie Standalone Components nutzen, neue Modularisierungsansätze mit Nx und Sheriff anwenden, und erfahren Sie mehr über die aktualisierten APIs für HttpClient und Router. Entdecken Sie neue Built-in Control Flow Blocks, Signals für verbesserte Change Detection und den Signal Store für effektives State-Management.\n'parentId': 'Hm6SdzajQWSYS6foi'\n'parentDescription': Die Konferenz für .NET, Windows & Open Innovation\n'indexBrandName': 'BASTA!'\n'indexSeriesName': 'Herbst'\n'author': 'Manfred Steyer,Rainer Hahnekamp'\n'chunkSource': 'text'\n'text': Modern-Angular-Workshop: Architektur und Features In diesem Workshop tauchen Sie tief in die neuesten Angular-Features ein, um moderne, wartbare Anwendungsarchitekturen zu entwickeln. Lernen Sie, wie Sie Standalone Components nutzen, neue Modularisierungsansätze mit Nx und Sheriff anwenden, und erfahren Sie mehr über die aktualisierten APIs für HttpClient und Router. Entdecken Sie neue Built-in Control Flow Blocks, Signals für verbesserte Change Detection und den Signal Store für effektives State-Management.\n'slidetext': ''\n'from': 'vector'\n'score': 0.8945451974868774\n'normalizedScore': 0.8717338202887547\n'beforeDatePenaltyScore': 0.8945451974868774\n\n'documentId': '22a125a269ee4ccc064bc5d5'\n'chunk_id': '687a26cd96f7bf47ed452442'\n'access': 'restricted'\n'part_number': 5\n'total_parts': 19\n'contentType': 'RHEINGOLD'\n'title': Building the Next Generation of Supercharged Web Applications Today\n'parentName': International JavaScript New York 2024\n'language': 'EN'\n'date': '2024-10-08T13:00:00.000Z'\n'abstract': Web development is on the cusp of a revolution and you need to be a part of it. Users are starting to expect applications to do things that previously required massive engineering efforts. You can harness the power of LLMs and other AI features to build applications that interact with your users in new ways. Tired of web applications that feel static? In this action-packed session, Mark will show you how to use AI to transform your applications and reimagine the way you interact with users. Prepare to be inspired and empowered to reimagine the possibilities of your apps.\n'parentId': 'xhXxg9ohmYPxSZtL6'\n'parentDescription': The JavaScript Fullstack Conference - Angular, Node.js, React and more\n'indexBrandName': 'InternationalJavaScriptCon'\n'indexSeriesName': 'NewYork'\n'author': 'Mark Thompson'\n'chunkSource': 'text'\n'text': of this stuff. You can still find it where it works for you. How does that feel? Feels good. I like the applause. Let's follow their lead. Come on, you can gimme a round applause. I love it. I need it. Thank you. I love it right there. That's the energy I'm talking about. Yes. I feel even, see I just got supercharged. Alright, let's talk about developer experience. Alright, so here's something that we learned on the Angular team. I'm always talking about lessons because I'm always thinking about things that we learned. Anybody's ever said this to themselves while trying to use angular. Angular is hard to learn. Let me reinforce that. Don't even try to read it. I made it small on purpose. I want you to see the volume of code for a hello world. That's a lot of lines of code to get. Hello world. You see something like this in a tutorial, you are gonna do what? You're gonna go away. You're not even gonna spend time on it, right? And so we heard this feedback over and over again and because developer experience is so important, we said fine, we can do better. What if we got to less code? So then we changed it to this. Now this is an entire angular application right now. Now some of you who work in web frameworks may be saying, oh, what about your configuration files? Those are not listed. Well what about your configuration files? Okay, fine. But this is an entire application. You got a component with the decorator that kind of describes it and then you have your properties for your classes and stuff, okay? But this is an entire application. So if you were to copy and paste this into your, your code editor with angular installed on your computer, you can run it. That's the whole thing. Because we heard this feedback and then that let us know that we needed to make changes because the developer experience is everything. What do you all talk about with your friends, your developer friends? I would say your other friends are like, I don't want to hear about your code life, but your developer friends, when you talk about development, you talk about how nice this API is, how smooth this thing is because developer experience still matters. What about better syntax? Okay, now this is some HTML mixed in with some angular, okay? Now this is an if else, lemme walk you through this. So it says if the user is human, if the user is human display, this component called human profile. Alright? It's, it's, it's kind of legible. Well\n'slidetext': ''\n'from': 'vector'\n'score': 0.8949709534645081\n'normalizedScore': 0.8731595762663853\n'beforeDatePenaltyScore': 0.8949709534645081\n\n'documentId': 'Es9qB3iW8QsKxfKEh'\n'chunk_id': '687a2d569bbcb45d2a11ead8'\n'access': 'restricted'\n'part_number': 1\n'total_parts': 1\n'contentType': 'RHEINGOLD'\n'title': Modern Angular: Renovierung für Ihre Anwendungen\n'parentName': JavaScript Days Berlin und online 2024\n'language': 'DE'\n'date': '2024-10-24T11:30:00.000Z'\n'abstract': In den letzten Monaten hat Angular zahlreiche neue Features erhalten, die es ermöglichen, das Framework auf moderne und leichtgewichtige Weise zu verwenden. Signals für eine moderne und performante Change Detection, Standalone Components und Standalone APIs, funktionale Guards und Interceptoren, esbuild-Unterstützung sowie und zahlreiche Verbesserungen beim Router sind ein paar Beispiele dafür. In diesem Workshop starten wir mit einer klassischen Angular-Lösungen, die wir nach und nach um die neuen Möglichkeiten erweitern. Somit ergibt sich eine leichtgewichtige und moderne Lösung, die sich einfacher warten lässt und die Vorteile der neuen Features auch nutzen kann. Am Ende wissen Sie, wie sich Ihre Angular-Lösung modernisieren lässt und welche neuen Features sich für Ihre Vorhaben lohnen.\n'parentId': 'bAbqTsTMmppKpiENq'\n'parentDescription': 40 Workshops zu JavaScript, Angular, React, Typescript und KI\n'indexBrandName': 'JavaScriptDays'\n'indexSeriesName': 'Berlin'\n'author': 'Manfred Steyer'\n'chunkSource': 'text'\n'text': Modern Angular: Renovierung für Ihre Anwendungen In den letzten Monaten hat Angular zahlreiche neue Features erhalten, die es ermöglichen, das Framework auf moderne und leichtgewichtige Weise zu verwenden. Signals für eine moderne und performante Change Detection, Standalone Components und Standalone APIs, funktionale Guards und Interceptoren, esbuild-Unterstützung sowie und zahlreiche Verbesserungen beim Router sind ein paar Beispiele dafür. In diesem Workshop starten wir mit einer klassischen Angular-Lösungen, die wir nach und nach um die neuen Möglichkeiten erweitern. Somit ergibt sich eine leichtgewichtige und moderne Lösung, die sich einfacher warten lässt und die Vorteile der neuen Features auch nutzen kann. Am Ende wissen Sie, wie sich Ihre Angular-Lösung modernisieren lässt und welche neuen Features sich für Ihre Vorhaben lohnen.\n'slidetext': ''\n'from': 'vector'\n'score': 0.894394040107727\n'normalizedScore': 0.8734559505808371\n'beforeDatePenaltyScore': 0.894394040107727\n\n'documentId': '5ca564ac8c4557f4f949b660'\n'chunk_id': '687a2b82495b49563aa87ad0'\n'access': 'restricted'\n'part_number': 4\n'total_parts': 9\n'contentType': 'RHEINGOLD'\n'title': Level-up your Angular Codebase with Cutting-Edge APIs\n'parentName': International JavaScript Conference Munich 2024\n'language': 'EN'\n'date': '2024-11-13T10:45:00.000Z'\n'abstract': The Angular team is propelling the enterprise frontend framework into a promising future with new, robust APIs. Modern concepts, validated in the JavaScript ecosystem, such as enhanced server-side rendering support, the new Control Flow syntax, Standalone APIs instead of NgModules, and optional RxJS, as well as Zone.js, are paving the way for a brighter future with an easier-to-manage codebase and an excellent developer experience. But how does this impact your current codebase? What refactoring strategy strikes the ideal balance between future-proofing and budget constraints? The reassuring news is that backward compatibility remains paramount. The pace at which you refactor your codebase to leverage the latest framework features is entirely your choice. Join my talk for a practical session where we explore these new APIs and discuss strategies to transform your code into a future-proof application.\n'parentId': 'R8y8tP2vbKi3twHpf'\n'parentDescription': The JavaScript Fullstack Conference - Angular, Node.js, React and more\n'indexBrandName': 'InternationalJavaScriptCon'\n'indexSeriesName': 'Munich'\n'author': 'Michael Egger-Zikes'\n'chunkSource': 'text'\n'text': directly. So turning your, uh, feature based feature modules But this can be done quite easily manually, So whether it is safe to remove the feature module We have here repository So we have normal, uh, ENG modules, um, a boarding, g rooting module here. add angular Core And then here are the questions, right? That's the second step. That's quite un not unusable. because to reach the, the state that much effort as hitting the delete button on your own. Do I need that module anymore? Yes. No, deleting it. But the third one again, is, uh, a helpful one. in your engine module based application, uh, references. Currently this will be converted to an, for standalone adds the providers over there. and just turn your app component into standalone, to convert major parts into standalone Yeah, if you pick the, the first option here, pass here referenced, Yeah, it's only that component. added some imports, uh, right here. and adding the component here to the, to the imports. that is the way of making it compatible that component, use that component in other NG module based Fine. So that's, uh, the part of the schematics here. Sorry, this was the need to pick the, the third one, uh, and then you can see it really deleted our app module. Um, and basically now you have, uh, because of the schematic step, also standalone that you have had back then in the, um, in the, This is a little bit different than generating a new Gimme a moment. So how does a normal that, and it references the app config. It's more aligned with the concept of, of app module, right? It's just called app config. So next thing, uh, control flow, uh, of the structural directives. um, structural directives. So you could have an application where parts are already Nothing to worry here, to have the afin to, RFC phase asked the community, So that proved out to be better. not always, but sometimes really counts and, Sometimes, um, track is now mandatory, so we could use track We needed to reference a function. on when to destroy the dome and when to reuse the dom. through the, through a server, that means each time you and also the ad four are comparing the object references. And then it figures out, okay, that the same data is written into it And this has performance consequences as easy as that. Um, it means if you refactor your application and then just the variable that you use then it uses the flat variable So if the schematics generated for you as it is necessary to the\n'slidetext': ''\n'from': 'vector'\n'score': 0.8948681354522705\n'normalizedScore': 0.8750242240075724\n'beforeDatePenaltyScore': 0.8948681354522705\n\n'documentId': '6883afe7f10bc00f03909bef'\n'chunk_id': '687a370eef5cff79d6f5cf20'\n'access': 'restricted'\n'part_number': 16\n'total_parts': 19\n'contentType': 'RHEINGOLD'\n'title': Built to last: Angular's Lessons in Framework Resilience\n'parentName': International JavaScript New York 2024\n'language': 'EN'\n'date': '2024-10-08T07:15:00.000Z'\n'abstract': In 'Built to Last: Angular's Lessons in Framework Resilience,' we set off on a journey through the evolution of Angular. We'll delve into the pivotal moments, both triumphs and setbacks, that have shaped Angular's remarkable resilience over a decade of constant change.  Discover the key design decisions, community-driven improvements, and adaptive strategies that have enabled Angular to not only survive but thrive in the ever-evolving tech landscape.  Whether you're a seasoned Angular developer or a newcomer to the framework, this talk will offer insights and inspiration for building frameworks, products, and even careers that are built to last.\n'parentId': 'xhXxg9ohmYPxSZtL6'\n'parentDescription': The JavaScript Fullstack Conference - Angular, Node.js, React and more\n'indexBrandName': 'InternationalJavaScriptCon'\n'indexSeriesName': 'NewYork'\n'author': 'Mark Thompson'\n'chunkSource': 'text'\n'text': like, my, I'm changing, I'm clicking the button but nothing's happening. 'cause you're like, oh yeah, you forgot to set state, right? Okay, an angular, that process is automatic. If you change the data, the application updates, that's supposed to be like a roar of applause of uh, being impressed. Okay? But here's what we found out though, even with this idea, which was really great when you first started, but over time as applications grew in complexity grew in scale, it was a limit. And then people were like, why do we have to do it this way? It exposes too many sharp edges. Meaning you have to know too much about angular now when something goes wrong. And that's about the developer experience that I've been talking about is the new, you know, space where frameworks will separate themselves is not about like, you know, who has the newest feature features will be copied. That's, that's easy. Now everything's open source for one. And everybody's very public about what they do. Features are not the new thing. What the really interesting thing is what is the developer experience that's more interesting. I thought he was coming to take me off the stage. I'm like, I'm not done yet. Alright, so our modern reactivity ended up being signals. We added three new framework and we three new primitives. Yeah, signal computed and effect. And the signals just this idea that there's a box that contains the value and if that value changes it can notify any, any interested consumers, right? And we made it really nice that the way we become an interested consumer is that you just reference it. So if you reference it, then you are interested consumer. And so that value will be updated, which is a really nice flow. Here's what we did right this time we made it opt in. Meaning whatever you were working on before, if you were using our old change detection still works. If you didn't want to use signals, nothing changes for you, you could still get all the other stuff. Then we shipped it as a developer preview to signal that it, it wasn't ready for production but we're working on it and we wanna get your feedback much different flow. Think about this for your users at your organizations, for whatever you're working on, how can you do something like this? How can you create developer previews to get feedback? See, these are hard lessons, but it allows us to move at a speed now that we've never been able to move at before because we can release APIs as developer preview, iterate on them, developers can\n'slidetext': ''\n'from': 'vector'\n'score': 0.8975516557693481\n'normalizedScore': 0.8757271507173441\n'beforeDatePenaltyScore': 0.8975516557693481\n\n'documentId': '6883afe7f10bc00f03909bef'\n'chunk_id': '687a370def5cff79d6f5cf11'\n'access': 'restricted'\n'part_number': 16\n'total_parts': 19\n'contentType': 'RHEINGOLD'\n'title': Built to last: Angular's Lessons in Framework Resilience\n'parentName': International JavaScript New York 2024\n'language': 'EN'\n'date': '2024-10-08T07:15:00.000Z'\n'abstract': In 'Built to Last: Angular's Lessons in Framework Resilience,' we set off on a journey through the evolution of Angular. We'll delve into the pivotal moments, both triumphs and setbacks, that have shaped Angular's remarkable resilience over a decade of constant change.  Discover the key design decisions, community-driven improvements, and adaptive strategies that have enabled Angular to not only survive but thrive in the ever-evolving tech landscape.  Whether you're a seasoned Angular developer or a newcomer to the framework, this talk will offer insights and inspiration for building frameworks, products, and even careers that are built to last.\n'parentId': 'xhXxg9ohmYPxSZtL6'\n'parentDescription': The JavaScript Fullstack Conference - Angular, Node.js, React and more\n'indexBrandName': 'InternationalJavaScriptCon'\n'indexSeriesName': 'NewYork'\n'author': 'Mark Thompson'\n'chunkSource': 'text'\n'text': like, my, I'm changing, I'm clicking the button but nothing's happening. 'cause you're like, oh yeah, you forgot to set state, right? Okay, an angular, that process is automatic. If you change the data, the application updates, that's supposed to be like a roar of applause of uh, being impressed. Okay? But here's what we found out though, even with this idea, which was really great when you first started, but over time as applications grew in complexity grew in scale, it was a limit. And then people were like, why do we have to do it this way? It exposes too many sharp edges. Meaning you have to know too much about angular now when something goes wrong. And that's about the developer experience that I've been talking about is the new, you know, space where frameworks will separate themselves is not about like, you know, who has the newest feature features will be copied. That's, that's easy. Now everything's open source for one. And everybody's very public about what they do. Features are not the new thing. What the really interesting thing is what is the developer experience that's more interesting. I thought he was coming to take me off the stage. I'm like, I'm not done yet. Alright, so our modern reactivity ended up being signals. We added three new framework and we three new primitives. Yeah, signal computed and effect. And the signals just this idea that there's a box that contains the value and if that value changes it can notify any, any interested consumers, right? And we made it really nice that the way we become an interested consumer is that you just reference it. So if you reference it, then you are interested consumer. And so that value will be updated, which is a really nice flow. Here's what we did right this time we made it opt in. Meaning whatever you were working on before, if you were using our old change detection still works. If you didn't want to use signals, nothing changes for you, you could still get all the other stuff. Then we shipped it as a developer preview to signal that it, it wasn't ready for production but we're working on it and we wanna get your feedback much different flow. Think about this for your users at your organizations, for whatever you're working on, how can you do something like this? How can you create developer previews to get feedback? See, these are hard lessons, but it allows us to move at a speed now that we've never been able to move at before because we can release APIs as developer preview, iterate on them, developers can\n'slidetext': ''\n'from': 'vector'\n'score': 0.8975516557693481\n'normalizedScore': 0.8757271507179782\n'beforeDatePenaltyScore': 0.8975516557693481\n\n'documentId': '5ca564ac8c4557f4f949b660'\n'chunk_id': '687a2b82495b49563aa87acf'\n'access': 'restricted'\n'part_number': 3\n'total_parts': 9\n'contentType': 'RHEINGOLD'\n'title': Level-up your Angular Codebase with Cutting-Edge APIs\n'parentName': International JavaScript Conference Munich 2024\n'language': 'EN'\n'date': '2024-11-13T10:45:00.000Z'\n'abstract': The Angular team is propelling the enterprise frontend framework into a promising future with new, robust APIs. Modern concepts, validated in the JavaScript ecosystem, such as enhanced server-side rendering support, the new Control Flow syntax, Standalone APIs instead of NgModules, and optional RxJS, as well as Zone.js, are paving the way for a brighter future with an easier-to-manage codebase and an excellent developer experience. But how does this impact your current codebase? What refactoring strategy strikes the ideal balance between future-proofing and budget constraints? The reassuring news is that backward compatibility remains paramount. The pace at which you refactor your codebase to leverage the latest framework features is entirely your choice. Join my talk for a practical session where we explore these new APIs and discuss strategies to transform your code into a future-proof application.\n'parentId': 'R8y8tP2vbKi3twHpf'\n'parentDescription': The JavaScript Fullstack Conference - Angular, Node.js, React and more\n'indexBrandName': 'InternationalJavaScriptCon'\n'indexSeriesName': 'Munich'\n'author': 'Michael Egger-Zikes'\n'chunkSource': 'text'\n'text': 19. You might argue. Now that's not good Um, don't worry about that just add standalone falls to your other, uh, So the, the concept of angular working with the CLI that this is really nothing to worry. NG module, uh, based, uh, implementations uh, standalone APIs. uh, of a smart component. The smart component is engine module based, variables in general is all of them. This was, at the beginning at least, everyone expected components, but it turned out that we have right now, no matter whether or do already require the standalone API, so especially of your ad component decorator. if you want to switch your routing configuration, uh, and not, uh, engine modules anymore, they again, need to be standalone, Um, one day that they will come, clear guidance from the angular team, Uh, so we are, they will ask the community whether, uh, yet, but of course, we can expect one day in future, uh, so many years now. Um, so yes, definitely it will be necessary, um, uh, angular 15. or already, uh, production support for standalone. How can you do so? I will answer this in a moment. Um, Standalone features, uh, from existing engine modules by, uh, using, sorry, to implement new features, that's the point here. Don't, um, uh, use engine modules So try to, to implement new features already where, you know, that's an existing feature, Then consider, uh, turning that into, uh, support of migration? You cannot one So it's really a nice assistance, uh, compared at angular core standalone command. The first step is, um, of your repository you want to change. Yeah. So if you have a repository with several apps to generate the component in or the service in then you will find it's not the It's this time at angular core. Um, so that's also the reason why we typically choose the migration code, right? that would be the equivalent and you just tell the CLI, which package to use for that. And as mentioned, it's not a project like the project flag. to turn the whole repository with all apps or you want to dig deeper that application or only one feature of that application. to turn components, directives, pipes, um, where the module is currently located. And basically that's the thing that the CLI helps you with. uh, for you directly. So turning your, uh, feature based feature modules But this can be done quite easily manually, So whether it is safe to remove the feature module We have here repository So we have normal, uh, ENG modules, um, a boarding, g\n'slidetext': ''\n'from': 'vector'\n'score': 0.8956260681152344\n'normalizedScore': 0.8757821566705363\n'beforeDatePenaltyScore': 0.8956260681152344\n\n'documentId': '5ca564ac8c4557f4f949b660'\n'chunk_id': '687a2b82495b49563aa87acd'\n'access': 'restricted'\n'part_number': 1\n'total_parts': 9\n'contentType': 'RHEINGOLD'\n'title': Level-up your Angular Codebase with Cutting-Edge APIs\n'parentName': International JavaScript Conference Munich 2024\n'language': 'EN'\n'date': '2024-11-13T10:45:00.000Z'\n'abstract': The Angular team is propelling the enterprise frontend framework into a promising future with new, robust APIs. Modern concepts, validated in the JavaScript ecosystem, such as enhanced server-side rendering support, the new Control Flow syntax, Standalone APIs instead of NgModules, and optional RxJS, as well as Zone.js, are paving the way for a brighter future with an easier-to-manage codebase and an excellent developer experience. But how does this impact your current codebase? What refactoring strategy strikes the ideal balance between future-proofing and budget constraints? The reassuring news is that backward compatibility remains paramount. The pace at which you refactor your codebase to leverage the latest framework features is entirely your choice. Join my talk for a practical session where we explore these new APIs and discuss strategies to transform your code into a future-proof application.\n'parentId': 'R8y8tP2vbKi3twHpf'\n'parentDescription': The JavaScript Fullstack Conference - Angular, Node.js, React and more\n'indexBrandName': 'InternationalJavaScriptCon'\n'indexSeriesName': 'Munich'\n'author': 'Michael Egger-Zikes'\n'chunkSource': 'text'\n'text': Level-up your Angular Codebase with Cutting-Edge APIs The Angular team is propelling the enterprise frontend framework into a promising future with new, robust APIs. Modern concepts, validated in the JavaScript ecosystem, such as enhanced server-side rendering support, the new Control Flow syntax, Standalone APIs instead of NgModules, and optional RxJS, as well as Zone.js, are paving the way for a brighter future with an easier-to-manage codebase and an excellent developer experience. But how does this impact your current codebase? What refactoring strategy strikes the ideal balance between future-proofing and budget constraints? The reassuring news is that backward compatibility remains paramount. The pace at which you refactor your codebase to leverage the latest framework features is entirely your choice. Join my talk for a practical session where we explore these new APIs and discuss strategies to transform your code into a future-proof application. Um, I'm giving you a talk today about Angola again, quite nice, and we, the architects mantra already gave him No, we are not talking about shell symbolize a little bit older, tiny, nice, the new wave of features started actually, um, refactoring, uh, the rendering engine Ivy, you know. to make this compatible also internally for Google. It's like a, a surgery on the open heart, right? So they really learned out of the, I would might even say, The whole community was angry about that. to do this completely in a different way, So not the Angular bubble, only and maybe only with Angola. and the React people are thinking the same. So JavaScript experts and how the Angular team is meanwhile, um, trying, Uh, this is actually part of my presentation today. which new feature was added. Uh, people are not sure which APIs they need to implement one of the APIs that we're currently working and of course, questions are always welcomed. then feel free to ask. to the table that we can use right now So with Angular 13, they also did a quite important change, So Angular is a modern framework, As their, uh, support for Internet Explorer dropped out, um, of polyfils, although there was already a possible solution separately compiled. but, um, it, it turned out to be a good one. they introduced Atmos script models for the browser. Uh, if there are Atmos script models The CLI is managing quite a bunch of things for us. Um, and that's basically a thing that that helps us So with, uh, Angola 14, they introduced, um, having a new API that works, again, compatible side by side, in, uh,\n'slidetext': ''\n'from': 'vector'\n'score': 0.8994736671447754\n'normalizedScore': 0.8796297557007114\n'beforeDatePenaltyScore': 0.8994736671447754\n\n'documentId': 'ec8de39dac90e93f9fd00a92'\n'chunk_id': '687a312cca798166d3ba43b5'\n'access': 'restricted'\n'part_number': 11\n'total_parts': 12\n'contentType': 'RHEINGOLD'\n'title': Optimizing Angular Applications - Techniques for Performance Excellence\n'parentName': International JavaScript New York 2024\n'language': 'EN'\n'date': '2024-10-09T14:15:00.000Z'\n'abstract': In today’s fast-paced digital landscape, delivering high-performance applications is crucial for a seamless user experience. This presentation dives deep into proven strategies and best practices for optimizing Angular applications. We will explore advanced techniques such as lazy loading, change detection strategies, signal-based state management, and leveraging NgOptimizedImage for better load times. Attendees will gain insights into optimizing bundle sizes, efficient HTTP communication, tree-shaking, and more. Whether you're dealing with large-scale apps or looking to enhance performance in smaller projects, this session provides actionable takeaways to improve your Angular application's speed and efficiency.\n'parentId': 'xhXxg9ohmYPxSZtL6'\n'parentDescription': The JavaScript Fullstack Conference - Angular, Node.js, React and more\n'indexBrandName': 'InternationalJavaScriptCon'\n'indexSeriesName': 'NewYork'\n'author': 'Sonu Kapoor'\n'chunkSource': 'text'\n'text': significant performance when implemented correctly. So in order to implement this, you need to add the, provide experimental zones, change detection during the application bootstrap rep. You also need to remove zone js from your polyfil and make sure that you're using at least angular version 18. So before you enable zone less in your application, keep in mind that this API is currently experimental, so anything can change at any time. Uh, regardless of that, here is a snippet of how you could try this out and if you run into any issues, I suggest that you open a ticket in the GitHub angular repo so that the Angular team is aware of it. And that's it. I hope these tips were helpful and as always, please connect with me over LinkedIn or Twitter. Um, and again, the repo with all the amazing animations I did, um, are here in the GitHub repo. Any questions? Yeah, go ahead please. I think you refer something incorrect there actually on post, we'll check double three, not just confidence that changes. Okay. Right. So from what I remember, I think it's just the, the component and its ancestors, right? No, it checks the all three, but what does constantly checking, Okay, just When we say okay, check now. Yeah, change on input on observable. Yeah, asy observable and things like that. Yeah. Yes, but it'll select complete not only the company, what's changed that year is the signoffs. With signoffs we can, uh, use our push to as a way to be stable. Um, constant tracking and Okay, I was under the impression that it only checks the component, uh, and not the entire tree because then what's the difference between? Difference Is that it's not automatically changing. Uh, every time you plate changes you on complex, you can use use or push and you decide when all the updates finish. Mm-Hmm. Then you will call the, I don't remember the directive buyer, but force the check You Okay. Will Happen on the complete. Yeah. So you don't, you don't actually have to force it. Um, so if you have on push set up and any of your input references change, then it will automatically trigger the change detection. And also when you have async operations right, then it will also automatically do that. Um, yeah. But thank you. Any other questions? I think you had one. Yeah. Um, lazy loading, first part From the routing. Yeah. Seems so easy to implement. Is there, uh, any reason you wouldn't wanna implement that application? Um, that's a good question. I mean, it should be the default I think, right? Um,\n'slidetext': ''\n'from': 'vector'\n'score': 0.9018042087554932\n'normalizedScore': 0.8800504799598311\n'beforeDatePenaltyScore': 0.9018042087554932\n\n'documentId': 'd74f910ab5ef9854703a97d3'\n'chunk_id': '6876dc4d225e92fc1ac7cc8e'\n'access': 'restricted'\n'part_number': 1\n'total_parts': 1\n'contentType': 'RHEINGOLD'\n'title': Fit für die Zukunft: Migration zu Modern Angular\n'parentName': JavaScript Days München und online 2025\n'language': 'DE'\n'date': '2025-03-20T12:30:00.000Z'\n'abstract': In den letzten Monaten hat Angular zahlreiche neue Features erhalten, die es ermöglichen, das Framework auf moderne und leichtgewichtige Weise zu verwenden. Signals für eine moderne und performante Change Detection, Standalone Components und Standalone APIs, funktionale Guards und Interceptoren, esbuild-Unterstützung sowie und zahlreiche Verbesserungen beim Router sind ein paar Beispiele dafür. In diesem Workshop starten wir mit einer klassischen Angular-Lösungen, die wir nach und nach um die neuen Möglichkeiten erweitern. Somit ergibt sich eine leichtgewichtige und moderne Lösung, die sich einfacher warten lässt und die Vorteile der neuen Features auch nutzen kann. Am Ende wissen Sie, wie sich Ihre Angular-Lösung modernisieren lässt und welche neuen Features sich für Ihre Vorhaben lohnen.\n'parentId': 'efd4ff41c4b9e889b50854b8'\n'parentDescription': 40 Workshops zu JavaScript, Angular, React, HTML & CSS und KI\n'indexBrandName': 'JavaScriptDays'\n'indexSeriesName': 'Munich'\n'author': 'Manfred Steyer'\n'chunkSource': 'text'\n'text': Fit für die Zukunft: Migration zu Modern Angular In den letzten Monaten hat Angular zahlreiche neue Features erhalten, die es ermöglichen, das Framework auf moderne und leichtgewichtige Weise zu verwenden. Signals für eine moderne und performante Change Detection, Standalone Components und Standalone APIs, funktionale Guards und Interceptoren, esbuild-Unterstützung sowie und zahlreiche Verbesserungen beim Router sind ein paar Beispiele dafür. In diesem Workshop starten wir mit einer klassischen Angular-Lösungen, die wir nach und nach um die neuen Möglichkeiten erweitern. Somit ergibt sich eine leichtgewichtige und moderne Lösung, die sich einfacher warten lässt und die Vorteile der neuen Features auch nutzen kann. Am Ende wissen Sie, wie sich Ihre Angular-Lösung modernisieren lässt und welche neuen Features sich für Ihre Vorhaben lohnen.\n'slidetext': ''\n'from': 'vector'\n'score': 0.8933886289596558\n'normalizedScore': 0.8805076170583366\n'beforeDatePenaltyScore': 0.8933886289596558\n\n'documentId': 'cfe389e23ed61a9ae7f11b32'\n'chunk_id': '68ac830f494be90012217e60'\n'access': 'restricted'\n'part_number': 1\n'total_parts': 1\n'contentType': 'RHEINGOLD'\n'title': Modern Angular Workshop: Architektur und Features\n'parentName': BASTA! Spring 2025\n'language': 'DE'\n'date': '2025-03-07T08:00:00.000Z'\n'abstract': Lernen Sie langfristig wartbare Enterprise-Lösungen mit modernem Angular zu entwerfen! In diesem Workshop tauchen Sie tief in die neuesten Angular-Features ein, um moderne, wartbare Anwendungsarchitekturen zu entwickeln. Lernen Sie, wie Sie Standalone Components nutzen, neue Modularisierungsansätze mit Nx und Sheriff anwenden, und erfahren Sie mehr über die aktualisierten APIs für HttpClient und Router. Entdecken Sie neue Built-in Control Flow Blocks, Signals für verbesserte Change Detection und den Signal Store für effektives State-Management.\n'parentId': '577ff41c05af8176bbd0043d'\n'parentDescription': Die Konferenz für .NET, Web & AI Innovation\n'indexBrandName': 'BASTA!'\n'indexSeriesName': 'Spring'\n'author': 'Manfred Steyer,Rainer Hahnekamp'\n'chunkSource': 'text'\n'text': Modern Angular Workshop: Architektur und Features Lernen Sie langfristig wartbare Enterprise-Lösungen mit modernem Angular zu entwerfen! In diesem Workshop tauchen Sie tief in die neuesten Angular-Features ein, um moderne, wartbare Anwendungsarchitekturen zu entwickeln. Lernen Sie, wie Sie Standalone Components nutzen, neue Modularisierungsansätze mit Nx und Sheriff anwenden, und erfahren Sie mehr über die aktualisierten APIs für HttpClient und Router. Entdecken Sie neue Built-in Control Flow Blocks, Signals für verbesserte Change Detection und den Signal Store für effektives State-Management.\n'slidetext': ''\n'from': 'vector'\n'score': 0.8941227197647095\n'normalizedScore': 0.8805191051236643\n'beforeDatePenaltyScore': 0.8941227197647095\n\n'documentId': '01073933df6d62616b01fd1e'\n'chunk_id': '68ac7b53494be90012217afb'\n'access': 'restricted'\n'part_number': 30\n'total_parts': 30\n'contentType': 'RHEINGOLD'\n'title': Skalierbare Architekturen in Angular mit Nx\n'parentName': BASTA! Spring 2025\n'language': 'DE'\n'date': '2025-03-06T11:00:00.000Z'\n'abstract': Je größer deine Angular-Anwendung wird, desto größer werden auch die Herausforderungen, eine skalierbare und wartbare Codebasis zu erhalten. Ohne eine durchdachte Architektur kann die Komplexität schnell außer Kontrolle geraten, was zu schlechten Applikationen und Verzögerungen in der Entwicklung führt. In diesem Vortrag zeigt Fabian Gosebrink, wie man mit Nx skalierbare und modulare Architekturen für Angular-Anwendungen aufbaut. Wir lernen, wie Nx uns hilft, große Codebasen in überschaubare Bibliotheken zu organisieren, den Code aufzuteilen und die Zusammenarbeit in Teams zu verbessern. Wir behandeln Best Practices für das Einrichten von Workspaces, die Nutzung der leistungsstarken Tools von Nx und die Optimierung deines Entwicklungsprozesses. Am Ende dieser Session haben die Entwickler ein klares Verständnis dafür, wie man Angular-Anwendungen mit Nx strukturiert, um langfristige Wartbarkeit, bessere Performance und eine leichtere Zusammenarbeit für kleine und große Teams zu gewährleisten.\n'parentId': '577ff41c05af8176bbd0043d'\n'parentDescription': Die Konferenz für .NET, Web & AI Innovation\n'indexBrandName': 'BASTA!'\n'indexSeriesName': 'Spring'\n'author': 'Fabian Gosebrink'\n'chunkSource': 'text'\n'text': machen. Dann kann man den Branch Merge und wenn alle dann kommen, müssen sie einmal updaten, komplett neue Files, aber das ist nun einmal so. Sie bewerben dieses Nx Migrate Feature, ich habe keine so guten Erfahrungen damit gemacht. Dann gibt es noch eine Kompatibilitätsmatrix, die Version von Nx ist nicht gleich, die ist entkoppelt von der Angular Version, weil Nx eben mehr ist als Angular. Trotzdem gibt es so eine Kompatibilitätsmatrix, da könnt ihr gucken, welche Library oder welche Angular Version mit Nx kompatibel ist. Wenn ihr mehr darüber wissen wollt, gibt es einen Kurs auf Plurisite von einem ziemlich coolen Typen, der das gemacht hat, könnt ihr euch ja mal angucken, da gehe ich nochmal darauf ein. Wie gesagt ihr kriegt die Folien alle, sind sogar schon online. Ansonsten kann ich euch nur empfehlen, jedes Angular Projekt auch mit Nx umzusetzen. Die Vorteile sind einfach da, sehr vorteilhaft sowas zu verwenden. Diese ganzen Features, ich aus der Box bekomme, wirklich, ich möchte sie nicht mehr missen. Wie gesagt, ich mache dann auch noch State Management, so damit wir von solchen Applikationen, von diesem Big Ball of Mod auf solche Applikationen kommen und dann eine Übersicht haben, was bei uns in der Applikation passiert. Vielen Dank an der Stelle, ich wünsche euch einen guten Appetit und die Slides findet ihr hier.\n'slidetext': ''\n'from': 'vector'\n'score': 0.8954849243164062\n'normalizedScore': 0.8818333644698817\n'beforeDatePenaltyScore': 0.8954849243164062\n\n'documentId': '73a55b4bbeecf374b233deaf'\n'chunk_id': '687a299f2491ed518a3f0cf6'\n'access': 'restricted'\n'part_number': 1\n'total_parts': 1\n'contentType': 'RHEINGOLD'\n'title': Angular’s New Era: Unveiling the Most Exciting Features Yet\n'parentName': International JavaScript Conference Singapore 2024\n'language': 'EN'\n'date': '2024-11-27T09:15:00.000Z'\n'abstract': In this session, we'll explore the groundbreaking features of Angular that are transforming the way we build modern web applications. From a simplified developer experience for creating new apps to standalone components that improve modularity, Angular is stepping up its game. We’ll dive into lazy loading for routes and components, optimizing performance and load times, and explore the power of control flow for dynamic, responsive UIs. Discover the magic of deferrable views that help you prioritize critical content, and get an inside look at signals—a new, reactive paradigm for managing state and change detection. We’ll also uncover the potential of zoneless Angular, offering maximum performance by reducing overhead, and take a peek into some of the forthcoming features that promise to shape the future of Angular development. Join us to discover how these game-changing features can take your Angular apps to the next level.\n'parentId': 'gdaJCohaAMyedJZCT'\n'parentDescription': The JavaScript Fullstack Conference - Angular, Node.js, React and more\n'indexBrandName': 'InternationalJavaScriptCon'\n'indexSeriesName': 'Singapore'\n'author': 'Pankaj Parkar'\n'chunkSource': 'text'\n'text': Angular’s New Era: Unveiling the Most Exciting Features Yet In this session, we'll explore the groundbreaking features of Angular that are transforming the way we build modern web applications. From a simplified developer experience for creating new apps to standalone components that improve modularity, Angular is stepping up its game. We’ll dive into lazy loading for routes and components, optimizing performance and load times, and explore the power of control flow for dynamic, responsive UIs. Discover the magic of deferrable views that help you prioritize critical content, and get an inside look at signals—a new, reactive paradigm for managing state and change detection. We’ll also uncover the potential of zoneless Angular, offering maximum performance by reducing overhead, and take a peek into some of the forthcoming features that promise to shape the future of Angular development. Join us to discover how these game-changing features can take your Angular apps to the next level.\n'slidetext': ''\n'from': 'vector'\n'score': 0.9011396169662476\n'normalizedScore': 0.8820594041523206\n'beforeDatePenaltyScore': 0.9011396169662476\n\n'documentId': '0747f0655ef3790a97eba95b'\n'chunk_id': '68f24b683134c10012c3d12f'\n'access': 'restricted'\n'part_number': 4\n'total_parts': 16\n'contentType': 'RHEINGOLD'\n'title': How to architect Angular apps in 2025\n'parentName': International JavaScript New York 2025\n'language': 'EN'\n'date': '2025-10-01T08:15:00.000Z'\n'abstract': In this talk, Alain showcases several architecture concepts he uses to optimize apps for performance, readability, and scalability in 2025 and beyond. We’ll touch on using Signals as state in our services, how to control access to such Signals, using the new resource API, and more!\n'parentId': '9f97d5cdc68d72a05f834df4'\n'parentDescription': The JavaScript Fullstack Conference - Angular, Node.js, React and more\n'indexBrandName': 'InternationalJavaScriptCon'\n'indexSeriesName': 'NewYork'\n'author': 'Alain Chautard'\n'chunkSource': 'text'\n'text': if we compare, you know, a, an simple Hello World app before, so that's Angular 14, you needed at least an app module with an app component and import stuff like browser modules and blah, blah, blah, blah, blah, blah, just to display head world, right? And now if I take Angular 20 while I'm down to just that because I don't have an app module anymore, I'm down to just my app component. Um, and it's, it's a lot easier, right? And the Angular team doesn't want to stop here. This is really very much a work in progress. Um, and there's a lot of changes coming up in the near future, uh, what is called component authoring improvements, which means really trying to remove everything that we don't need or that doesn't bring value to our angular syntax. So for instance, not that long ago, we, we, we needed to have standalone true, but now it's a default. So you don't don't need that anymore. The selector while, you know, 99.9% of the time, I guess you just use the default one, right? So why do we need that if we always use the same thing? So the selector the plan is all that to go away. And so we we're gonna get to a point where all we have in the component decorator would be a template or a template to RL, which is really all we need. So that's, that's what's coming next, really. So going all the way to simplifying as much as possible so that, um, so that, yeah, we remove all of the boilerplate around angular components. So yeah, the, the, the Angular team announced this couple years ago. Uh, and, and I think it's a very good way to summarize the, the mindset of everything that's going on right now. Uh, and our goal is build angular for the next 10 years and ensure that it's still an excellent choice 10 years from now. So basically, you want to regret, but that's the answer. If you start with Angular today, 10 years from now, you should still be happy. That's, that's the idea. And so they also officially said at least a couple times that the goal is to get, well, not get rid of, but at least make optional RXJS and zone Gs. So you don't, you, you could write angular apps without these two, right? So we'll see how that, that works and, and what are the impacts on architecture, because that's what we're here to talk about. So the first big impact on architecture that really drives all of the decisions\n'slidetext': ''\n'from': 'vector'\n'score': 0.8945529460906982\n'normalizedScore': 0.8923471624998814\n'beforeDatePenaltyScore': 0.8945529460906982\n\n'documentId': '3ac2ff4b76a2048bae5607f6'\n'chunk_id': '6903881aa7bbb00013e754e5'\n'access': 'restricted'\n'part_number': 1\n'total_parts': 1\n'contentType': 'RHEINGOLD'\n'title': Accessibility in Angular\n'parentName': JavaScript Days Berlin und online 2025\n'language': 'DE'\n'date': '2025-10-22T07:00:00.000Z'\n'abstract': In diesem neuen Workshop lernen Angular-Entwickler:innen alle Grundlagen und Tools kennen, um das Thema Barrierefreiheit souverän in ihre Angular-Apps zu meistern. Es werden ausgewählte A11y-Tools vorgestellt, die wichtigsten A11y-Features von Angular sowie bewährte Best Practices präsentiert und in praxisnahen Übungsbeispielen demonstriert. Der Workshop richtig sich an alle Angular-Entwickler:innen, A11y-Vorkenntnisse sind nicht erforderlich. Wer am Praxisteil mitmachen möchte, benötigt einen Computer.\n'parentId': 'a233287a238c6e0ce3f91546'\n'parentDescription': 40 Workshops zu JavaScript, Angular, React, Typescript und KI\n'indexBrandName': 'JavaScriptDays'\n'indexSeriesName': 'Berlin'\n'author': 'Alexander Thalhammer'\n'chunkSource': 'text'\n'text': Accessibility in Angular In diesem neuen Workshop lernen Angular-Entwickler:innen alle Grundlagen und Tools kennen, um das Thema Barrierefreiheit souverän in ihre Angular-Apps zu meistern. Es werden ausgewählte A11y-Tools vorgestellt, die wichtigsten A11y-Features von Angular sowie bewährte Best Practices präsentiert und in praxisnahen Übungsbeispielen demonstriert. Der Workshop richtig sich an alle Angular-Entwickler:innen, A11y-Vorkenntnisse sind nicht erforderlich. Wer am Praxisteil mitmachen möchte, benötigt einen Computer.\n'slidetext': ''\n'from': 'index'\n'score': 55.24238204956055\n'normalizedScore': 0.5524238204956055\n'beforeDatePenaltyScore': 0.5524238204956055\n\n'documentId': 'af6bfaa1ee403d005b7cb22d'\n'chunk_id': '690e0ea58c81760014412a9e'\n'access': 'granted'\n'part_number': 1\n'total_parts': 29\n'contentType': 'RHEINGOLD'\n'title': Wachsen ohne Chaos: Architektur für nachhaltige Angular-Projekte\n'parentName': W-JAX 2025\n'language': 'DE'\n'date': '2025-11-06T08:00:00.000Z'\n'abstract': Angular-Anwendungen wachsen oft schneller als geplant – und genau dann zeigt sich, wie gut die Architektur wirklich durchdacht ist. Features verzahnen sich, Strukturen verschwimmen, Refactorings werden riskant. In diesem Vortrag zeige ich Strategien, wie man Angular-Projekte von Anfang an strukturiert – oder bestehende Anwendungen so umbaut, dass sie langfristig wartbar und erweiterbar bleiben. Vom sinnvollen Einsatz von Feature- und Domänenmodulen bis zu Tools wie Sheriff, Signal Store und Native Federation geht es um konkrete Muster für nachhaltiges Wachstum.\n'parentId': '26c78c073b722105116a13de'\n'parentDescription': Die Konferenz für Java, Architektur- und Software-Innovation\n'indexBrandName': 'JAX'\n'indexSeriesName': ''\n'author': 'Rainer Hahnekamp'\n'chunkSource': 'text'\n'text': Wachsen ohne Chaos: Architektur für nachhaltige Angular-Projekte Angular-Anwendungen wachsen oft schneller als geplant – und genau dann zeigt sich, wie gut die Architektur wirklich durchdacht ist. Features verzahnen sich, Strukturen verschwimmen, Refactorings werden riskant. In diesem Vortrag zeige ich Strategien, wie man Angular-Projekte von Anfang an strukturiert – oder bestehende Anwendungen so umbaut, dass sie langfristig wartbar und erweiterbar bleiben. Vom sinnvollen Einsatz von Feature- und Domänenmodulen bis zu Tools wie Sheriff, Signal Store und Native Federation geht es um konkrete Muster für nachhaltiges Wachstum. Dann guten Morgen legen wir los. äh ja, willkommen zum ersten äh zum ersten Vortrag von heute. Ich darf mich kurz vorstellen. ähm Mein Name ist Hanne Kreiner, komme aus Österreich, wie man hört, bin an und für sich bei Engul Architekt dabei, also wir machen sehr sehr viel Richtung Architektur und Engola, passt dann auch ganz gut zum Titel. Und ja, ich versuche auch bei ein paar Open Source Projekte mitzuarbeiten, ein paar kennt man besser, ein paar kennt man vielleicht jetzt nicht ganz so gut. Das populärste ist wahrscheinlich Ner X, Estate Management für Engula, aber mache auch bei ein paar anderen mit. ähm von von der Agenda oder wie ich mir das an und für sich so vorgestellt habe, dass man sagt, man schaut sich einmal an, wie eine Anwendung so wachsen kann, was da für Herausforderungen an und für sich anstehen und äh ja, man kann sagen, es ist eine Art Portepree von verschiedenen Themen. bei der Architektur, die es so gibt, die man eben anwenden kann. Und nachdem natürlich jetzt am Anfang die Probleme nicht so gross sind, würden wir am Anfang das Vortrags eher so, würde ich mal sagen, einfache Ansätze haben, die man eigentlich schon umsetzen kann, das ist jetzt nicht so schwer. Und je nachdem, wie gross dann die Anwendung ist, werden wir uns dann anschauen, welche Probleme dann auftreten und wie man dann dem entgegentreten kann oder welche Lösungsmöglichkeiten es da eben gibt. Gut, ähm ja, dann würde ich sagen, vielleicht ganz am Anfang, wenn man\n'slidetext': ''\n'from': 'index'\n'score': 55.2808837890625\n'normalizedScore': 0.552808837890625\n'beforeDatePenaltyScore': 0.552808837890625\n\n'documentId': 'b8bf349a24030fa6f49599de'\n'chunk_id': '6876da19225e92fc1ac7c15d'\n'access': 'restricted'\n'part_number': 1\n'total_parts': 1\n'contentType': 'CAMP'\n'title': Tag 2: Erweiterte Angular-Direktiven, Modernes Angular und Erweiterte Angular-Routing-Techniken (Lektion 3, 4 & 5)\n'parentName': Angular Camp - Deep Dive Camp Intense Februar 2025 | Online\n'language': 'DE'\n'date': '2025-02-18T08:00:00.000Z'\n'abstract': Erweitern Sie Ihre Angular-Expertise und lernen Sie in diesem spannenden Trainingsabschnitt die vielfältigen Möglichkeiten von Angular-Direktiven, die neuesten Features des modernen Angular und wie Sie komplexe und effiziente Routing-Systeme kreieren. Lektion 3: Erweiterte Angular-Direktiven & Modernes Angular: Attribute, Strukturen, Templates und mehr Die nächste Lektion beschäftigt sich mit den vielfältigen verschiedenen Arten von Angular-Direktiven, die sie für die Erstellung dynamischer und wiederverwendbarer Templates bietet, z.B.: Attribut-, Struktur- und Komponenten-Direktiven. Das erwartet Sie in dieser Lektion: - Attribut-Direktiven für Querschnittsfunktionen - Strukturelle Direktiven - Templates und Container - Microsyntax - Templates zur Laufzeit referenzieren Lektion 4: Angular auf dem neuesten Stand: Standalone Components, Signals und mehr Tauchen Sie in in die Welt des Modern Angular und entdecken die neuesten Features und Techniken für die Entwicklung moderner, performanter und skalierbarer Webanwendungen. Alle wichtigen Themen auf einen Blick: - Architekturen mit Standalone Components - Reaktive Systeme mit Signals - Performance mit Signal Components - Moderne Change Detection mit Signals und Signal Components: Was ändert sich? - Schnellere Builds mit esbuild - Projekt-Strukturen mit Sheriff Lektion 5: Erweiterte Angular-Routing-Techniken: Child-Routes, Aux Routes, Lazy Routes und weitere Fast geschafft. Hier erfahren Sie alles, was Sie wissen müssen, um komplexe und effiziente Routing-Systeme für Ihre Angular-Webanwendungen zu entwickeln. Sie starten mit den Grundlagen des hierarchischen Routings mit Angular, steuern die Zugriffe und werden Profi, um auf Routing-Änderungen reagieren zu können. - Hierarchisches Routing mit Child-Routes - Aux Routes - Lazy Routes - Guards - Resolver - Router Events - Custom Url-Matchers\n'parentId': '06531a7f8e4748acac13fd75'\n'parentDescription': Das Angular Camp für Fortgeschrittene mit Manfred Steyer im 3-tägigen Intensiv-Training im Online-Format\n'indexBrandName': 'AngularCamp'\n'indexSeriesName': 'IntenseDeepDive'\n'author': 'Manfred Steyer'\n'chunkSource': 'text'\n'text': Tag 2: Erweiterte Angular-Direktiven, Modernes Angular und Erweiterte Angular-Routing-Techniken (Lektion 3, 4 & 5) Erweitern Sie Ihre Angular-Expertise und lernen Sie in diesem spannenden Trainingsabschnitt die vielfältigen Möglichkeiten von Angular-Direktiven, die neuesten Features des modernen Angular und wie Sie komplexe und effiziente Routing-Systeme kreieren. Lektion 3: Erweiterte Angular-Direktiven & Modernes Angular: Attribute, Strukturen, Templates und mehr Die nächste Lektion beschäftigt sich mit den vielfältigen verschiedenen Arten von Angular-Direktiven, die sie für die Erstellung dynamischer und wiederverwendbarer Templates bietet, z.B.: Attribut-, Struktur- und Komponenten-Direktiven. Das erwartet Sie in dieser Lektion: - Attribut-Direktiven für Querschnittsfunktionen - Strukturelle Direktiven - Templates und Container - Microsyntax - Templates zur Laufzeit referenzieren Lektion 4: Angular auf dem neuesten Stand: Standalone Components, Signals und mehr Tauchen Sie in in die Welt des Modern Angular und entdecken die neuesten Features und Techniken für die Entwicklung moderner, performanter und skalierbarer Webanwendungen. Alle wichtigen Themen auf einen Blick: - Architekturen mit Standalone Components - Reaktive Systeme mit Signals - Performance mit Signal Components - Moderne Change Detection mit Signals und Signal Components: Was ändert sich? - Schnellere Builds mit esbuild - Projekt-Strukturen mit Sheriff Lektion 5: Erweiterte Angular-Routing-Techniken: Child-Routes, Aux Routes, Lazy Routes und weitere Fast geschafft. Hier erfahren Sie alles, was Sie wissen müssen, um komplexe und effiziente Routing-Systeme für Ihre Angular-Webanwendungen zu entwickeln. Sie starten mit den Grundlagen des hierarchischen Routings mit Angular, steuern die Zugriffe und werden Profi, um auf Routing-Änderungen reagieren zu können. - Hierarchisches Routing mit Child-Routes - Aux Routes - Lazy Routes - Guards - Resolver - Router Events - Custom Url-Matchers\n'slidetext': ''\n'from': 'index'\n'score': 56.56400680541992\n'normalizedScore': 0.5656400680541992\n'beforeDatePenaltyScore': 0.5656400680541992\n\n'documentId': '9836770500f149a58b7769f9'\n'chunk_id': '68ad7e39494be90012217feb'\n'access': 'granted'\n'part_number': 5\n'total_parts': 6\n'contentType': 'READ'\n'title': Professional Tips for Using Signals in Angular - Enterprise Angular\n'parentName': iJS Magazine Volume 17\n'language': 'EN'\n'date': '2025-02-25T23:00:00.000Z'\n'abstract': The new Signals in Angular are a simple reactive building block. However, as is so often the case, the devil is in the detail. In this article, I will give three tips to help you use Signals in a more straightforward way.\n'parentId': '2b07605113b7a8ed6aeea755'\n'parentDescription': Broaden your knowledge and expand your JavaScript techniques and practices. From Angular, React, and WebAssembly, to the best JavaScript IDEs, open source tools and more, you’ll learn insights on everything JS from seasoned experts in their field. Keep up with JavaScript news, tips, and advice with interviews, tutorials, and in-depth articles.\n'indexBrandName': ''\n'indexSeriesName': ''\n'author': 'Manfred Steyer'\n'chunkSource': 'text'\n'text': signal-based components will no longer offer this lifecycle hook. The RFC provides using effects as a replacement. To escape this dilemma, an rxMethod (e.g. offered by a signal store) can be used: constructor() { this.store.rxLoad(this.id); } It should be noted that the constructor transfers the entire signal and not just its current value. The rxMethod subscribes to this Signal and forwards its values to an observable that is used within the rxMethod. If you don’t want to use the signal store, you can instead use the RxJS interop discussed above and convert the signal into an observable with toObservable. If you don't have a reactive method to hand, you might be tempted to define an effect for this task: constructor() { effect(() => { this.store.load(this.id()); }); } Unfortunately, this leads to the exception in Figure 2. Fig. 2: Error message when using effect This problem arises because the entire load method that writes a Signal in the store is executed in the reactive context of the effect. This means that Angular recognizes an effect that writes to a Signal. This has to be prevented by default for the reasons above. It also means that Angular triggers the effect again even if a Signal read in load changes. Both problems can be prevented by using the untracked function (Listing 5). Listing 5 constructor() { // try to avoid this effect(() => { const id = this.id(); untracked(() => { this.store.load(id); }); }); } With this common pattern, untracked ensures that the reactive context does not spill over to the load method. It can write to Signals and the effect doesn’t register for Signals that read load. Angular only triggers the effect again when the Signal id changes, especially since it reads it outside of untracked. Unfortunately, this code is not especially easy to read. It’s a good idea to hide it behind a helper function: constructor() { explicitEffect(this.id, (id) => { this.store.load(id); }); } The created auxiliary function explicitEffect receives a signal and subscribes to it with an effect. The effect triggers the transferred lambda expression using untracked (Listing 6). Listing 6 import { Signal, effect, untracked } from '@angular/core'; export function explicitEffect(source: Signal, action: (value: T) => void) { effect(() => { const s = source(); untracked(() => { action(s) }); }); } Interestingly, the explicit definition of Signals to be obeyed corresponds to the standard behavior of effects in other frameworks, like Solid. The combination of effect and untracked shown is also used in many libraries. Examples include the classic NgRx store, the RxJS interop mentioned above, the rxMethod, or the open source\n'slidetext': ''\n'from': 'index'\n'score': 57.33500289916992\n'normalizedScore': 0.5733500289916992\n'beforeDatePenaltyScore': 0.5733500289916992\n\n'documentId': '9836770500f149a58b7769f9'\n'chunk_id': '68ad7e39494be90012217fec'\n'access': 'granted'\n'part_number': 6\n'total_parts': 6\n'contentType': 'READ'\n'title': Professional Tips for Using Signals in Angular - Enterprise Angular\n'parentName': iJS Magazine Volume 17\n'language': 'EN'\n'date': '2025-02-25T23:00:00.000Z'\n'abstract': The new Signals in Angular are a simple reactive building block. However, as is so often the case, the devil is in the detail. In this article, I will give three tips to help you use Signals in a more straightforward way.\n'parentId': '2b07605113b7a8ed6aeea755'\n'parentDescription': Broaden your knowledge and expand your JavaScript techniques and practices. From Angular, React, and WebAssembly, to the best JavaScript IDEs, open source tools and more, you’ll learn insights on everything JS from seasoned experts in their field. Keep up with JavaScript news, tips, and advice with interviews, tutorials, and in-depth articles.\n'indexBrandName': ''\n'indexSeriesName': ''\n'author': 'Manfred Steyer'\n'chunkSource': 'text'\n'text': source library ngxtension, which offers many extra functions for Signals. To summarize RxJS and Signals harmonize wonderfully together and the RxJS interop from Angular gives us the best of both worlds. Using RxJS is recommended for representing events. For processing asynchronous tasks, RxJS or stores (which can be based on RxJS) are recommended. The synchronous transport of data to the view should be handled by Signals. Together, RxJS, stores, and Signals are the building blocks for establishing a unidirectional data flow. The flattening operators in RxJS can also elegantly avoid race conditions. Alternatively or in addition to this, flags can be used to indicate if a request is currently in progress at the backend. Even if Signals weren’t primarily created to display events, there are cases when you want to react to changes in a Signal. This is the case with framework APIs based on Signals. In addition to the RxJS interop, the rxMethod from the Signal Store can also be used. Another option is the effect/untracked pattern for implementing effects that only react to explicitly named Signals.\n'slidetext': ''\n'from': 'index'\n'score': 56.795475006103516\n'normalizedScore': 0.5679547500610351\n'beforeDatePenaltyScore': 0.5679547500610351\n\n'documentId': 'dcce136001b8cf2cfe8b5498'\n'chunk_id': '6876df207899910dd58c0ea2'\n'access': 'granted'\n'part_number': 7\n'total_parts': 7\n'contentType': 'READ'\n'title': Die neue httpResource in Angular 19.2 - Kolumne: Enterprise Angular\n'parentName': iJS Magazin 2.2025\n'language': 'DE'\n'date': '2025-03-25T23:00:00.000Z'\n'abstract': Angular 19.2 beinhaltet nun die neue httpResource, die es erlaubt, Daten innerhalb des reaktiven Flusses zu laden. Dieser Artikel zeigt, wie sich dieses - derzeit experimentelle - Feature nutzen lässt. Als Beispiel dient eine einfache Anwendung, die durch Levels, im Stil des Spiels „Super Mario“, scrollt. Jedes Level besteht aus Kacheln, die in vier verschiedenen Stilen zur Verfügung stehen: Overworld, Underground, Underwater und Castle. In unserer Implementierung können Benutzer:innen frei zwischen diesen Stilen wechseln. Abbildung 1 zeigt zum Beispiel das erste Level im Stil Overworld an. Abbildung 2 zeigt dasselbe Level im Stil Underground.\n'parentId': '7cb807973ada8ce87de439aa'\n'parentDescription': Kaum ein Softwareprojekt, das nicht in wesentlichen Teilen auf der JavaScript-Technologie basiert. Eine breite Unterstützung sowie, leistungsfähige Programmiersprachen, die Vielzahl moderner Tools, sowie ausgereifte Frameworks wie Angular, React, Vue.js oder Node.js machen den JavaScript-Werkzeugkasten zu einem Alleskönner. Das iJS Magazin informiert aktuell und umfassend über die wichtige und innovative Entwicklungen im JavaScript-Universum und bietet handfeste Praxisinformationen für Softwareentwickler und -architekten.\n'indexBrandName': ''\n'indexSeriesName': ''\n'author': 'Manfred Steyer'\n'chunkSource': 'text'\n'text': console.log(this.levelOverviewResource.headers()?.keys()); Darüber hinaus stellt die httpResource alles zur Verfügung, was auch von gewöhnlichen Resources bekannt ist, darunter ein error-Signal, das über einen eventuell aufgetretenen Fehler informiert sowie die Möglichkeit, den value zu aktualisieren, der als lokale Arbeitskopie vorliegt. Zusammenfassung Die neue httpResource ist ein weiterer Baustein, der Angulars neue Signal-Story ergänzt. Sie ermöglicht das Laden von Daten innerhalb des reaktiven Graphen. Derzeit verwendet sie den HttpClient als Implementierungsdetail, der eventuell zu einem späteren Zeitpunkt durch eine andere Lösung ersetzt wird. Während die HTTP-Resource auch das Abrufen von Daten mit HTTP-Verben jenseits von GET ermöglicht, ist sie nicht für das Zurückschreiben von Daten zum Server ausgelegt. Diese Aufgabe gilt es weiterhin auf herkömmliche Weise zu erledigen. Links & Literatur [1] https://github.com/manfredsteyer/mario.git [2] https://zod.dev/ [3] https://www.spriters-resource.com/nes/supermariobros/sheet/52571\n'slidetext': ''\n'from': 'index'\n'score': 56.52215576171875\n'normalizedScore': 0.5652215576171875\n'beforeDatePenaltyScore': 0.5652215576171875\n\n'documentId': '43b7900e7154d2f13c41085b'\n'chunk_id': '6876d2a2225e92fc1ac797fa'\n'access': 'granted'\n'part_number': 4\n'total_parts': 6\n'contentType': 'COURSE'\n'title': Exploring httpResource in Angular 19.2\n'parentName': Advanced Angular: Signals, NgRx & AI Forms\n'language': 'DE'\n'date': '2025-05-02T10:49:04.000Z'\n'abstract': The introduction of *httpResource* in Angular 19.2 brings a new way to load data seamlessly within the reactive flow. Let's explore how this experimental feature can be leveraged to enhance your applications.\n'parentId': '5e78d57fd77e42835f9996dc'\n'parentDescription': Level up your Angular skills with this advanced course, highlighting the framework’s evolving features. We will cover cutting-edge topics, from mastering state management with the NgRx Signal store and unlocking AI-enhanced forms’ potential, to revisiting the performance benefits of server-side rendering. You will learn how to effectively use Signals through professional tips and real-world insights, and explore emerging features like httpResource in Angular 19.2. Whether you are scaling enterprise apps or upgrading legacy codebases, this course equips you with the practices to build smarter, faster Angular applications and stay ahead in today’s Angular ecosystem.\n'indexBrandName': 'InternationalJavaScriptCon'\n'indexSeriesName': ''\n'author': 'Manfred Steyer'\n'chunkSource': 'text'\n'text': Figure 4: Reactive flow of ngMario The signals levelKey, style, and animation represent the user input. The first two correspond to the drop-down fields at the top of the application. The animation signal contains a Boolean that indicates whether the animation was started by clicking the Toggle Animation button (see screenshots above). The tilesResource is a classic resource that derives the individual tiles for the selected style from the tilemap. To do this, it essentially delegates to a function of the game engine, which is treated as a black box here. The rendering is triggered by an effect, especially since we cannot draw the level directly using data binding. It draws or animates the level on a canvas, which the application retrieves as a signal-based viewChild. Angular then calls the effect whenever the level (provided by the levelResource), the style, the animation flag, or the canvas changes. A tilesMapProgress signal uses the progress information provided by tilesMapResource to indicate how much of the tilesmap has already been downloaded. To load the list of available levels, the example uses a levelOverviewResource that is not directly connected to the reactive graph discussed so far. Listing 6 shows the implementation of this reactive flow in the form of fields of the LevelComponent. Listing 6: export class LevelComponent implements OnDestroy { private tilesMapLoader = inject(TilesMapLoader); private levelLoader = inject(LevelLoader); canvas = viewChild<elementref>('canvas'); levelKey = linkedSignal(() => this.getFirstLevelKey()); style = signal</elementref\n'slidetext': ''\n'from': 'index'\n'score': 57.179046630859375\n'normalizedScore': 0.5717904663085938\n'beforeDatePenaltyScore': 0.5717904663085938\n\n'documentId': 'c8af1d2c9d8e08acaa09599f'\n'chunk_id': '68c26ff80a53cd001394abf5'\n'access': 'granted'\n'part_number': 1\n'total_parts': 4\n'contentType': 'READ'\n'title': Custom Standalone APIs for Angular - Enterprise Angular\n'parentName': iJS Magazine Volume 19\n'language': 'EN'\n'date': '2025-06-24T22:00:00.000Z'\n'abstract': Together with standalone components, the Angular team has introduced the so-called standalone APIs. They provide a simple solution for library setup and do not require Angular modules.\n'parentId': 'a1269c65e87d5b8ebcde4b28'\n'parentDescription': Broaden your knowledge and expand your JavaScript techniques and practices. From Angular, React, and WebAssembly, to the best JavaScript IDEs, open source tools and more, you’ll learn insights on everything JS from seasoned experts in their field. Keep up with JavaScript news, tips, and advice with interviews, tutorials, and in-depth articles.\n'indexBrandName': ''\n'indexSeriesName': ''\n'author': 'Manfred Steyer'\n'chunkSource': 'text'\n'text': Custom Standalone APIs for Angular Enterprise Angular Together with standalone components, the Angular team has introduced the so-called standalone APIs. They provide a simple solution for library setup and do not require Angular modules. Together with standalone components, the Angular team has introduced the so-called standalone APIs. They provide a simple solution for library setup and do not require Angular modules. Popular libraries that already implement this concept include the HttpClient, Router, and NgRx. These libraries are based on several patterns that we find beneficial in our own projects. They also provide our library users with familiar structures and behaviors. In this article, I show three such patterns that I derived from the libraries mentioned. The source code and examples are available here. Example A simple logger library is used here to show the different patterns (Fig. 1). The LogFormatter formats the messages before the Logger publishes them. This is an abstract class that is used as a DI token. The consumers of the logger library can customize the formatting by providing their own implementation. Alternatively, they can settle for a default implementation provided by the library. Fig. 1: Structure of an exemplary Logger library The LogAppender is another replaceable concept that takes care of attaching the message to a log. The default implementation just writes the message to the console. While there can be only one LogFormatter, the library supports multiple LogAppenders. For example, the first LogAppender might write the message to the console, while the second also sends it to the server. To make this possible, each LogAppender is registered via a multiprovider. The injector returns all registered LogAppenders in the form of an array. Since an array cannot be used as a DI token, the example uses an InjectionToken instead: export const LOG_APPENDERS = new InjectionToken('LOG_APPENDERS'); An abstract LoggerConfig, which also acts as a DI token, defines the possible configuration options (Listing 1). Listing 1 export abstract class LoggerConfig { abstract level: LogLevel; abstract formatter: Type; abstract appenders: Type[]; } export const defaultConfig: LoggerConfig = { level: LogLevel.DEBUG, formatter: DefaultLogFormatter, appenders: [DefaultLogAppender], }; The default values for these configuration options are in the defaultConfig constant. The LogLevel in the configuration is a filter for log messages. It is of type enum and has for simplification only the values DEBUG, INFO and ERROR: export enum LogLevel { DEBUG = 0, INFO = 1, ERROR = 2, } The Logger only publishes messages that have the LogLevel specified here or a higher LogLevel. The LoggerService itself receives the LoggerConfig, the LogFormatter and an array with LogAppender via DI and uses them to log the received\n'slidetext': ''\n'from': 'index'\n'score': 56.62080383300781\n'normalizedScore': 0.5662080383300782\n'beforeDatePenaltyScore': 0.5662080383300782\n\n'documentId': 'ffe46902112505d5bdec0031'\n'chunk_id': '6876e1af7899910dd58c1c2c'\n'access': 'restricted'\n'part_number': 1\n'total_parts': 1\n'contentType': 'CAMP'\n'title': Tag 2: Erweiterte Angular-Direktiven, Modernes Angular und Erweiterte Angular-Routing-Techniken (Lektion 3, 4 & 5)\n'parentName': Angular Camp - Deep Dive Camp Intense September 2025 | München\n'language': 'DE'\n'date': '2025-09-16T07:00:00.000Z'\n'abstract': Erweitern Sie Ihre Angular-Expertise und lernen Sie in diesem spannenden Trainingsabschnitt die vielfältigen Möglichkeiten von Angular-Direktiven, die neuesten Features des modernen Angular und wie Sie komplexe und effiziente Routing-Systeme kreieren. Lektion 3: Erweiterte Angular-Direktiven & Modernes Angular: Attribute, Strukturen, Templates und mehr Die nächste Lektion beschäftigt sich mit den vielfältigen verschiedenen Arten von Angular-Direktiven, die sie für die Erstellung dynamischer und wiederverwendbarer Templates bietet, z.B.: Attribut-, Struktur- und Komponenten-Direktiven. Das erwartet Sie in dieser Lektion: - Attribut-Direktiven für Querschnittsfunktionen - Strukturelle Direktiven - Templates und Container - Microsyntax - Templates zur Laufzeit referenzieren Lektion 4: Angular auf dem neuesten Stand: Standalone Components, Signals und mehr Tauchen Sie in in die Welt des Modern Angular und entdecken die neuesten Features und Techniken für die Entwicklung moderner, performanter und skalierbarer Webanwendungen. Alle wichtigen Themen auf einen Blick: - Architekturen mit Standalone Components - Reaktive Systeme mit Signals - Performance mit Signal Components - Moderne Change Detection mit Signals und Signal Components: Was ändert sich? - Schnellere Builds mit esbuild - Projekt-Strukturen mit Sheriff Lektion 5: Erweiterte Angular-Routing-Techniken: Child-Routes, Aux Routes, Lazy Routes und weitere Fast geschafft. Hier erfahren Sie alles, was Sie wissen müssen, um komplexe und effiziente Routing-Systeme für Ihre Angular-Webanwendungen zu entwickeln. Sie starten mit den Grundlagen des hierarchischen Routings mit Angular, steuern die Zugriffe und werden Profi, um auf Routing-Änderungen reagieren zu können. - Hierarchisches Routing mit Child-Routes - Aux Routes - Lazy Routes - Guards - Resolver - Router Events - Custom Url-Matchers\n'parentId': '3791de9cb4cc670970c79310'\n'parentDescription': Das Angular Camp für Fortgeschrittene mit Manfred Steyer im 3-tägigen Intensiv-Training\n'indexBrandName': 'AngularCamp'\n'indexSeriesName': 'IntenseDeepDive'\n'author': 'Manfred Steyer'\n'chunkSource': 'text'\n'text': Tag 2: Erweiterte Angular-Direktiven, Modernes Angular und Erweiterte Angular-Routing-Techniken (Lektion 3, 4 & 5) Erweitern Sie Ihre Angular-Expertise und lernen Sie in diesem spannenden Trainingsabschnitt die vielfältigen Möglichkeiten von Angular-Direktiven, die neuesten Features des modernen Angular und wie Sie komplexe und effiziente Routing-Systeme kreieren. Lektion 3: Erweiterte Angular-Direktiven & Modernes Angular: Attribute, Strukturen, Templates und mehr Die nächste Lektion beschäftigt sich mit den vielfältigen verschiedenen Arten von Angular-Direktiven, die sie für die Erstellung dynamischer und wiederverwendbarer Templates bietet, z.B.: Attribut-, Struktur- und Komponenten-Direktiven. Das erwartet Sie in dieser Lektion: - Attribut-Direktiven für Querschnittsfunktionen - Strukturelle Direktiven - Templates und Container - Microsyntax - Templates zur Laufzeit referenzieren Lektion 4: Angular auf dem neuesten Stand: Standalone Components, Signals und mehr Tauchen Sie in in die Welt des Modern Angular und entdecken die neuesten Features und Techniken für die Entwicklung moderner, performanter und skalierbarer Webanwendungen. Alle wichtigen Themen auf einen Blick: - Architekturen mit Standalone Components - Reaktive Systeme mit Signals - Performance mit Signal Components - Moderne Change Detection mit Signals und Signal Components: Was ändert sich? - Schnellere Builds mit esbuild - Projekt-Strukturen mit Sheriff Lektion 5: Erweiterte Angular-Routing-Techniken: Child-Routes, Aux Routes, Lazy Routes und weitere Fast geschafft. Hier erfahren Sie alles, was Sie wissen müssen, um komplexe und effiziente Routing-Systeme für Ihre Angular-Webanwendungen zu entwickeln. Sie starten mit den Grundlagen des hierarchischen Routings mit Angular, steuern die Zugriffe und werden Profi, um auf Routing-Änderungen reagieren zu können. - Hierarchisches Routing mit Child-Routes - Aux Routes - Lazy Routes - Guards - Resolver - Router Events - Custom Url-Matchers\n'slidetext': ''\n'from': 'index'\n'score': 56.63596725463867\n'normalizedScore': 0.5663596725463867\n'beforeDatePenaltyScore': 0.5663596725463867\n\n'documentId': '8b124d1f8a4b51f23acbc7f1'\n'chunk_id': '690b38892e2492001343de86'\n'access': 'restricted'\n'part_number': 1\n'total_parts': 1\n'contentType': 'CAMP'\n'title': Tag 2: Erweiterte Angular-Direktiven, Modernes Angular und Erweiterte Angular-Routing-Techniken (Lektion 3, 4 & 5)\n'parentName': Angular Camp - Deep Dive Camp Intense Dezember 2025 | Online\n'language': 'DE'\n'date': '2025-12-02T08:30:00.000Z'\n'abstract': Erweitern Sie Ihre Angular-Expertise und lernen Sie in diesem spannenden Trainingsabschnitt die vielfältigen Möglichkeiten von Angular-Direktiven, die neuesten Features des modernen Angular und wie Sie komplexe und effiziente Routing-Systeme kreieren. Lektion 3: Erweiterte Angular-Direktiven & Modernes Angular: Attribute, Strukturen, Templates und mehr Die nächste Lektion beschäftigt sich mit den vielfältigen verschiedenen Arten von Angular-Direktiven, die sie für die Erstellung dynamischer und wiederverwendbarer Templates bietet, z.B.: Attribut-, Struktur- und Komponenten-Direktiven. Das erwartet Sie in dieser Lektion: - Attribut-Direktiven für Querschnittsfunktionen - Strukturelle Direktiven - Templates und Container - Microsyntax - Templates zur Laufzeit referenzieren Lektion 4: Angular auf dem neuesten Stand: Standalone Components, Signals und mehr Tauchen Sie in in die Welt des Modern Angular und entdecken die neuesten Features und Techniken für die Entwicklung moderner, performanter und skalierbarer Webanwendungen. Alle wichtigen Themen auf einen Blick: - Architekturen mit Standalone Components - Reaktive Systeme mit Signals - Performance mit Signal Components - Moderne Change Detection mit Signals und Signal Components: Was ändert sich? - Schnellere Builds mit esbuild - Projekt-Strukturen mit Sheriff Lektion 5: Erweiterte Angular-Routing-Techniken: Child-Routes, Aux Routes, Lazy Routes und weitere Fast geschafft. Hier erfahren Sie alles, was Sie wissen müssen, um komplexe und effiziente Routing-Systeme für Ihre Angular-Webanwendungen zu entwickeln. Sie starten mit den Grundlagen des hierarchischen Routings mit Angular, steuern die Zugriffe und werden Profi, um auf Routing-Änderungen reagieren zu können. - Hierarchisches Routing mit Child-Routes - Aux Routes - Lazy Routes - Guards - Resolver - Router Events - Custom Url-Matchers\n'parentId': '93c77279759adfdb48c0b856'\n'parentDescription': Das Angular Camp für Fortgeschrittene mit Andre Dickenscheidt im 3-tägigen Intensiv-Training\n'indexBrandName': 'AngularCamp'\n'indexSeriesName': 'IntenseDeepDive'\n'author': 'André Wilke'\n'chunkSource': 'text'\n'text': Tag 2: Erweiterte Angular-Direktiven, Modernes Angular und Erweiterte Angular-Routing-Techniken (Lektion 3, 4 & 5) Erweitern Sie Ihre Angular-Expertise und lernen Sie in diesem spannenden Trainingsabschnitt die vielfältigen Möglichkeiten von Angular-Direktiven, die neuesten Features des modernen Angular und wie Sie komplexe und effiziente Routing-Systeme kreieren. Lektion 3: Erweiterte Angular-Direktiven & Modernes Angular: Attribute, Strukturen, Templates und mehr Die nächste Lektion beschäftigt sich mit den vielfältigen verschiedenen Arten von Angular-Direktiven, die sie für die Erstellung dynamischer und wiederverwendbarer Templates bietet, z.B.: Attribut-, Struktur- und Komponenten-Direktiven. Das erwartet Sie in dieser Lektion: - Attribut-Direktiven für Querschnittsfunktionen - Strukturelle Direktiven - Templates und Container - Microsyntax - Templates zur Laufzeit referenzieren Lektion 4: Angular auf dem neuesten Stand: Standalone Components, Signals und mehr Tauchen Sie in in die Welt des Modern Angular und entdecken die neuesten Features und Techniken für die Entwicklung moderner, performanter und skalierbarer Webanwendungen. Alle wichtigen Themen auf einen Blick: - Architekturen mit Standalone Components - Reaktive Systeme mit Signals - Performance mit Signal Components - Moderne Change Detection mit Signals und Signal Components: Was ändert sich? - Schnellere Builds mit esbuild - Projekt-Strukturen mit Sheriff Lektion 5: Erweiterte Angular-Routing-Techniken: Child-Routes, Aux Routes, Lazy Routes und weitere Fast geschafft. Hier erfahren Sie alles, was Sie wissen müssen, um komplexe und effiziente Routing-Systeme für Ihre Angular-Webanwendungen zu entwickeln. Sie starten mit den Grundlagen des hierarchischen Routings mit Angular, steuern die Zugriffe und werden Profi, um auf Routing-Änderungen reagieren zu können. - Hierarchisches Routing mit Child-Routes - Aux Routes - Lazy Routes - Guards - Resolver - Router Events - Custom Url-Matchers\n'slidetext': ''\n'from': 'index'\n'score': 56.63596725463867\n'normalizedScore': 0.5663596725463867\n'beforeDatePenaltyScore': 0.5663596725463867\n\n'documentId': '9836770500f149a58b7769f9'\n'chunk_id': '68ad7e39494be90012217fea'\n'access': 'granted'\n'part_number': 4\n'total_parts': 6\n'contentType': 'READ'\n'title': Professional Tips for Using Signals in Angular - Enterprise Angular\n'parentName': iJS Magazine Volume 17\n'language': 'EN'\n'date': '2025-02-25T23:00:00.000Z'\n'abstract': The new Signals in Angular are a simple reactive building block. However, as is so often the case, the devil is in the detail. In this article, I will give three tips to help you use Signals in a more straightforward way.\n'parentId': '2b07605113b7a8ed6aeea755'\n'parentDescription': Broaden your knowledge and expand your JavaScript techniques and practices. From Angular, React, and WebAssembly, to the best JavaScript IDEs, open source tools and more, you’ll learn insights on everything JS from seasoned experts in their field. Keep up with JavaScript news, tips, and advice with interviews, tutorials, and in-depth articles.\n'indexBrandName': ''\n'indexSeriesName': ''\n'author': 'Manfred Steyer'\n'chunkSource': 'text'\n'text': { patchState(store, { ratings, loading: false }); }, error: (error) => { patchState(store, { loading: false }); toastService.show('Error loading ratings!'); console.error(error); }, }); }, Depending on the flag’s value, the application can display a loading indicator or deactivate the respective button. The latter is counterproductive or even impossible with a highly reactive UI if the application can manage without an explicit button. Tip 3: Signals as triggers As mentioned earlier, Signals are especially suitable for transporting data to the view, like what’s seen on the right in Figure 1. Real events, UI events, or events displayed with RxJS are the better solution for transmitting an intention. There are several reasons why: First, Signals’ glitch-free property can reduce consecutive changes to the last change. Consumers must subscribe to the Signal in order to be able to react to value changes. This requires an effect that triggers the desired action and writes the result to a signal. Effects that write to Signals are not welcome. By default, they are even penalized by Angular with an exception. The Angular team wants to avoid confusing reactive chains - changes that lead to changes, which in turn, lead to further changes. On the other hand, Angular is converting more and more APIs to signals. One example is Signals that can be bound to form fields or Signals that represent passed values (inputs). In most cases, you could argue that instead of listening for the Signal, you can also use the event that led to the Signal change. But in some cases, this is a detour that bypasses the new signal-based APIs. Listing 4 shows an example of a component that receives the ID of a data set to be displayed as an input signal. The router takes this ID from a routing parameter. This is possible with the relatively new feature withComponentInputBinding. Listing 4 @Component({ […] }) export class DessertDetailComponent implements OnChanges { store = inject(DessertDetailStore); dessert = this.store.dessert; loading = this.store.loading; id = input.required({ transform: numberAttribute }); […] } This component’s template lets you scroll between the data records. This logic is deliberately implemented very simply for this example:  Next  When scrolling, the input signal id receives a new value. Now, the question arises as to how to trigger the loading of the respective data set in the event of this kind of change. The classic procedure is using the live cycle hook ngOnChanges: ngOnChanges(): void { const id = this.id(); this.store.load(id); } For the time being, there’s nothing wrong with this. However, the planned signal-based\n'slidetext': ''\n'from': 'index'\n'score': 58.142940521240234\n'normalizedScore': 0.5814294052124024\n'beforeDatePenaltyScore': 0.5814294052124024\n\n'documentId': 'd74f910ab5ef9854703a97d3'\n'chunk_id': '6876dc4d225e92fc1ac7cc8e'\n'access': 'restricted'\n'part_number': 1\n'total_parts': 1\n'contentType': 'RHEINGOLD'\n'title': Fit für die Zukunft: Migration zu Modern Angular\n'parentName': JavaScript Days München und online 2025\n'language': 'DE'\n'date': '2025-03-20T12:30:00.000Z'\n'abstract': In den letzten Monaten hat Angular zahlreiche neue Features erhalten, die es ermöglichen, das Framework auf moderne und leichtgewichtige Weise zu verwenden. Signals für eine moderne und performante Change Detection, Standalone Components und Standalone APIs, funktionale Guards und Interceptoren, esbuild-Unterstützung sowie und zahlreiche Verbesserungen beim Router sind ein paar Beispiele dafür. In diesem Workshop starten wir mit einer klassischen Angular-Lösungen, die wir nach und nach um die neuen Möglichkeiten erweitern. Somit ergibt sich eine leichtgewichtige und moderne Lösung, die sich einfacher warten lässt und die Vorteile der neuen Features auch nutzen kann. Am Ende wissen Sie, wie sich Ihre Angular-Lösung modernisieren lässt und welche neuen Features sich für Ihre Vorhaben lohnen.\n'parentId': 'efd4ff41c4b9e889b50854b8'\n'parentDescription': 40 Workshops zu JavaScript, Angular, React, HTML & CSS und KI\n'indexBrandName': 'JavaScriptDays'\n'indexSeriesName': 'Munich'\n'author': 'Manfred Steyer'\n'chunkSource': 'text'\n'text': Fit für die Zukunft: Migration zu Modern Angular In den letzten Monaten hat Angular zahlreiche neue Features erhalten, die es ermöglichen, das Framework auf moderne und leichtgewichtige Weise zu verwenden. Signals für eine moderne und performante Change Detection, Standalone Components und Standalone APIs, funktionale Guards und Interceptoren, esbuild-Unterstützung sowie und zahlreiche Verbesserungen beim Router sind ein paar Beispiele dafür. In diesem Workshop starten wir mit einer klassischen Angular-Lösungen, die wir nach und nach um die neuen Möglichkeiten erweitern. Somit ergibt sich eine leichtgewichtige und moderne Lösung, die sich einfacher warten lässt und die Vorteile der neuen Features auch nutzen kann. Am Ende wissen Sie, wie sich Ihre Angular-Lösung modernisieren lässt und welche neuen Features sich für Ihre Vorhaben lohnen.\n'slidetext': ''\n'from': 'index'\n'score': 58.076866149902344\n'normalizedScore': 0.5807686614990234\n'beforeDatePenaltyScore': 0.5807686614990234\n\n'documentId': 'dcce136001b8cf2cfe8b5498'\n'chunk_id': '6876df207899910dd58c0e9c'\n'access': 'granted'\n'part_number': 1\n'total_parts': 7\n'contentType': 'READ'\n'title': Die neue httpResource in Angular 19.2 - Kolumne: Enterprise Angular\n'parentName': iJS Magazin 2.2025\n'language': 'DE'\n'date': '2025-03-25T23:00:00.000Z'\n'abstract': Angular 19.2 beinhaltet nun die neue httpResource, die es erlaubt, Daten innerhalb des reaktiven Flusses zu laden. Dieser Artikel zeigt, wie sich dieses - derzeit experimentelle - Feature nutzen lässt. Als Beispiel dient eine einfache Anwendung, die durch Levels, im Stil des Spiels „Super Mario“, scrollt. Jedes Level besteht aus Kacheln, die in vier verschiedenen Stilen zur Verfügung stehen: Overworld, Underground, Underwater und Castle. In unserer Implementierung können Benutzer:innen frei zwischen diesen Stilen wechseln. Abbildung 1 zeigt zum Beispiel das erste Level im Stil Overworld an. Abbildung 2 zeigt dasselbe Level im Stil Underground.\n'parentId': '7cb807973ada8ce87de439aa'\n'parentDescription': Kaum ein Softwareprojekt, das nicht in wesentlichen Teilen auf der JavaScript-Technologie basiert. Eine breite Unterstützung sowie, leistungsfähige Programmiersprachen, die Vielzahl moderner Tools, sowie ausgereifte Frameworks wie Angular, React, Vue.js oder Node.js machen den JavaScript-Werkzeugkasten zu einem Alleskönner. Das iJS Magazin informiert aktuell und umfassend über die wichtige und innovative Entwicklungen im JavaScript-Universum und bietet handfeste Praxisinformationen für Softwareentwickler und -architekten.\n'indexBrandName': ''\n'indexSeriesName': ''\n'author': 'Manfred Steyer'\n'chunkSource': 'text'\n'text': Die neue httpResource in Angular 19.2 Kolumne: Enterprise Angular Angular 19.2 beinhaltet nun die neue httpResource, die es erlaubt, Daten innerhalb des reaktiven Flusses zu laden. Dieser Artikel zeigt, wie sich dieses - derzeit experimentelle - Feature nutzen lässt. Als Beispiel dient eine einfache Anwendung, die durch Levels, im Stil des Spiels „Super Mario“, scrollt. Jedes Level besteht aus Kacheln, die in vier verschiedenen Stilen zur Verfügung stehen: Overworld, Underground, Underwater und Castle. In unserer Implementierung können Benutzer:innen frei zwischen diesen Stilen wechseln. Abbildung 1 zeigt zum Beispiel das erste Level im Stil Overworld an. Abbildung 2 zeigt dasselbe Level im Stil Underground. Angular 19.2 beinhaltet nun die neue httpResource, die es erlaubt, Daten innerhalb des reaktiven Flusses zu laden. Dieser Artikel zeigt, wie sich dieses – derzeit experimentelle – Feature nutzen lässt. Als Beispiel dient eine einfache Anwendung, die durch Levels, im Stil des Spiels „Super Mario“, scrollt. Jedes Level besteht aus Kacheln, die in vier verschiedenen Stilen zur Verfügung stehen: Overworld, Underground, Underwater und Castle. In unserer Implementierung können Benutzer:innen frei zwischen diesen Stilen wechseln. Abbildung 1 zeigt zum Beispiel das erste Level im Stil Overworld an. Abbildung 2 zeigt dasselbe Level im Stil Underground. Abb. 1: Level 1 im Stil Overworld Abb. 2: Level 1 im Stil Underground Eine LevelComponent in der Beispielanwendung [1] kümmert sich um das Laden von Leveldateien (JSON) und Kacheln zum Zeichnen der Level unter Nutzung einer httpResource. Zum Rendern und Animieren der Level stützt sich das Beispiel auf eine sehr einfache Engine, die dem Quellcode beiliegt, hier im Artikel jedoch als Blackbox behandelt wird. HttpClient im Unterbau ermöglicht die Verwendung von Interceptors Im Unterbau verwendet die neue httpResource derzeit den guten alten HttpClient. Daher muss die Anwendung diesen Service bereitstellen, was normalerweise durch Aufruf von provideHttpClient während des Bootstrappings geschieht. Als Konsequenz ergibt sich, dass die httpResource auch automatisch die registrierten HttpInterceptors aufgreift. Der HttpClient ist jedoch lediglich ein Implementierungsdetail, das Angular eventuell irgendwann durch eine andere Implementierung ersetzt. Level-Dateien Die verschiedenen Levels beschreibt unser Beispiel mit JSON-Dateien, die definieren, welche Kacheln an welchen\n'slidetext': ''\n'from': 'index'\n'score': 58.97711944580078\n'normalizedScore': 0.5897711944580079\n'beforeDatePenaltyScore': 0.5897711944580079\n\n'documentId': 'c8af1d2c9d8e08acaa09599f'\n'chunk_id': '68c26ff80a53cd001394abf8'\n'access': 'granted'\n'part_number': 4\n'total_parts': 4\n'contentType': 'READ'\n'title': Custom Standalone APIs for Angular - Enterprise Angular\n'parentName': iJS Magazine Volume 19\n'language': 'EN'\n'date': '2025-06-24T22:00:00.000Z'\n'abstract': Together with standalone components, the Angular team has introduced the so-called standalone APIs. They provide a simple solution for library setup and do not require Angular modules.\n'parentId': 'a1269c65e87d5b8ebcde4b28'\n'parentDescription': Broaden your knowledge and expand your JavaScript techniques and practices. From Angular, React, and WebAssembly, to the best JavaScript IDEs, open source tools and more, you’ll learn insights on everything JS from seasoned experts in their field. Keep up with JavaScript news, tips, and advice with interviews, tutorials, and in-depth articles.\n'indexBrandName': ''\n'indexSeriesName': ''\n'author': 'Manfred Steyer'\n'chunkSource': 'text'\n'text': e.g. to configure preloading or to enable tracing. The HttpClient uses it to provide interceptors, to configure JSONP and to configure/disable XSRF token handling. Pattern: configuration factory Configuration factories extend the behavior of existing services. They can provide additional configuration options, but also additional services. An extended version of our LoggerService will serve as an illustration. It allows to define an additional LogAppender for each log category: @Injectable() export class LoggerService { readonly categories: Record = {}; […] } To configure a LogAppender for a category, we introduce a configuration factory named provideCategory (Listing 8). Listing 8 export function provideCategory( category: string, appender: Type ): EnvironmentProviders { // Internal/ Local token for registering the service // and retrieving the resolved service instance // immediately after. const appenderToken = new InjectionToken('APPENDER_' + category); return makeEnvironmentProviders([ { provide: appenderToken, useClass: appender, }, { provide: ENVIRONMENT_INITIALIZER, multi: true, useValue: () => { const appender = inject(appenderToken); const logger = inject(LoggerService); logger.categories[category] = appender; }, }, ]); } This factory creates a provider for the LogAppender class. The call to inject gives us an instance of it and resolves its dependencies. The ENVIRONMENT_INITIALIZER token points to a function that Angular triggers when initializing the respective environment injector. It registers the LogAppender with the LoggerService (Listing 9). Listing 9 export const FLIGHT_BOOKING_ROUTES: Routes = [ { path: '', component: FlightBookingComponent, providers: [ // Setting up an NgRx // feature slice provideState(bookingFeature), provideEffects([BookingEffects]), // Provide LogAppender for // logger category provideCategory('booking', DefaultLogAppender), ], children: [ { path: 'flight-search', component: FlightSearchComponent, }, [...] ], }, ]; This pattern is found, for example, in NgRx to register feature slices. The feature withDebugTracing offered by the router also uses this pattern to subscribe to the observable events in the router service. Conclusion Standalone APIs allow you to set up libraries without Angular modules. Their use is simple to begin with: consumers simply need to look for a provider factory with the name provideXYZ. Additional features can be enabled, if necessary, with functions that follow the withABC naming scheme. However, the implementation of such APIs is not always trivial. This is exactly where the patterns presented here help. Since they are derived from libraries of the Angular and NgRx teams, they reflect first-hand experience and design decisions.\n'slidetext': ''\n'from': 'index'\n'score': 58.89068603515625\n'normalizedScore': 0.5889068603515625\n'beforeDatePenaltyScore': 0.5889068603515625\n\n'documentId': '1fed2c6361980d606789e315'\n'chunk_id': '68c26fcc0a53cd001394ab96'\n'access': 'granted'\n'part_number': 6\n'total_parts': 8\n'contentType': 'READ'\n'title': Manfred Steyer on Angular 20: Signals, Dynamic Components, AI, and What’s Next - Exploring selectorless components, signal-based forms, and other features in Angular\n'parentName': iJS Magazine Volume 19\n'language': 'EN'\n'date': '2025-06-24T22:00:00.000Z'\n'abstract': In this interview, GDE Manfred Steyer highlights Angular’s journey towards a more reactive future. We discuss the framework’s strengths, challenges, and what’s ahead with the release of Angular 20.\n'parentId': 'a1269c65e87d5b8ebcde4b28'\n'parentDescription': Broaden your knowledge and expand your JavaScript techniques and practices. From Angular, React, and WebAssembly, to the best JavaScript IDEs, open source tools and more, you’ll learn insights on everything JS from seasoned experts in their field. Keep up with JavaScript news, tips, and advice with interviews, tutorials, and in-depth articles.\n'indexBrandName': ''\n'indexSeriesName': ''\n'author': 'Manfred Steyer'\n'chunkSource': 'text'\n'text': you think every developer should know, what would they be? Manfred Steyer: Well, I’d say data binding is a big one. Most people use Angular first and foremost because it gives you data binding. Doing data binding manually can be tedious and often leads to messy, unmanageable code. Lately, I’ve really been enjoying the new Signals feature. It brings a more intuitive approach to reactivity, making it easier to streamline how data flows through the application. I’ve always been a big fan of the Angular Router too and everything that allows us to do HTTP access, as Angular continues to shine in this area. And lastly—maybe not the most exciting, but definitely essential—is form support. Especially in enterprise applications, you deal with a lot of forms, and Angular’s form support is incredibly useful right out of the box. Ines Chargui: I’m curious to know how much you get to experiment with other new frameworks. What do you think about these newer, minimal ones? Do you find them interesting or useful in certain contexts? Manfred Steyer: I think these newer, young frameworks are really important. In the past, they have often been the reason that pushed Angular and other major frameworks to evolve and reinvent themselves. They bring new ideas to the table and show that, with a different mindset, you can sometimes achieve more in certain areas. In that sense, they act as incubators for innovation. That said, I think it’s tough for a new framework to gain real traction. You need a critical mass of users and contributors. Frameworks like Angular or React have already reached that scale, which gives them long-term stability. From a practical standpoint, whether you choose Angular, React, or Vue, they’re all likely to be around for many years. But those smaller frameworks—Qwik is another great example—still play an essential role. They push the big players to reflect, adapt, and reinvent themselves. And so far, we’ve seen that they are capable of rising to the challenge. Ines Chargui: But here’s something I’ve always found interesting—despite Angular’s popularity, all the improvements, and the way it keeps evolving, it never shows up in the top three or even top five in developer surveys when it comes to most used frameworks. How do you explain that? Manfred Steyer: Good point. I think this correlates with what I've told you before. If you are a typical web developer working on web projects or portals, Angular can sometimes feel like too much, and people often prefer more lightweight stuff. However, if you took the same survey among\n'slidetext': ''\n'from': 'index'\n'score': 58.783424377441406\n'normalizedScore': 0.5878342437744141\n'beforeDatePenaltyScore': 0.5878342437744141\n\n'documentId': 'c8af1d2c9d8e08acaa09599f'\n'chunk_id': '68c26ff80a53cd001394abf7'\n'access': 'granted'\n'part_number': 3\n'total_parts': 4\n'contentType': 'READ'\n'title': Custom Standalone APIs for Angular - Enterprise Angular\n'parentName': iJS Magazine Volume 19\n'language': 'EN'\n'date': '2025-06-24T22:00:00.000Z'\n'abstract': Together with standalone components, the Angular team has introduced the so-called standalone APIs. They provide a simple solution for library setup and do not require Angular modules.\n'parentId': 'a1269c65e87d5b8ebcde4b28'\n'parentDescription': Broaden your knowledge and expand your JavaScript techniques and practices. From Angular, React, and WebAssembly, to the best JavaScript IDEs, open source tools and more, you’ll learn insights on everything JS from seasoned experts in their field. Keep up with JavaScript news, tips, and advice with interviews, tutorials, and in-depth articles.\n'indexBrandName': ''\n'indexSeriesName': ''\n'author': 'Manfred Steyer'\n'chunkSource': 'text'\n'text': The optional feature is represented by an object with a providers array. In addition, the object has a kind property that subdivides the feature of a certain category. This categorization enables the validation of the jointly configured features. For example, features can be mutually exclusive. An example of this can be found in the HttpClient: It prohibits the use of a feature for configuring XSRF handling if the consumers have simultaneously activated a feature for disabling it. The logger library used here uses a ColorFeature that allows messages to be output in different colors depending on the LoggerLevel (Fig. 2). Fig. 2: Structure of the ColorFeature An enum is used to categorize features: export enum LoggerFeatureKind { COLOR, OTHER_FEATURE, ADDITIONAL_FEATURE } Another factory is used to provide the ColorFeature (Listing 5). Listing 5 export function withColor(config?: Partial): LoggerFeature { const internal = { ...defaultColorConfig, ...config }; return { kind: LoggerFeatureKind.COLOR, providers: [ { provide: ColorConfig, useValue: internal, }, { provide: ColorService, useClass: DefaultColorService, }, ], }; } The updated provider factory provideLogger takes on several features via an optional second parameter defined as an array for rest parameters (Listing 6). Listing 6 export function provideLogger( config: Partial, ...features: LoggerFeature[] ): EnvironmentProviders { const merged = { ...defaultConfig, ...config }; // Inspecting passed features const colorFeatures = features?.filter((f) => f.kind === LoggerFeatureKind.COLOR)?.length ?? 0; // Validating passed features if (colorFeatures > 1) { throw new Error('Only one color feature allowed for logger!'); } return makeEnvironmentProviders([ { provide: LoggerConfig, useValue: merged, }, { provide: LogFormatter, useClass: merged.formatter, }, merged.appenders.map((a) => ({ provide: LOG_APPENDERS, useClass: a, multi: true, })), // Providing services for the // features features?.map((f) => f.providers), ]); } The provider factory uses the kind property to examine and validate the passed features. If all is well, it includes the feature's providers in the EnvironmentProviders object. The DefaultLogAppender fetches the ColorService provided by the ColorFeature via dependency injection (Listing 7). Listing 7 export class DefaultLogAppender implements LogAppender { colorService = inject(ColorService, { optional: true }); append(level: LogLevel, category: string, msg: string): void { if (this.colorService) { msg = this.colorService.apply(level, msg); } console.log(msg); } } Since features are optional, the DefaultLog appender passes the {optional: true} option to inject. This prevents an exception in cases where the feature, and thus the ColorService, has not been provided. Also, the DefaultLogAppender must check for null values. This pattern occurs in the router, e.g.\n'slidetext': ''\n'from': 'index'\n'score': 58.085575103759766\n'normalizedScore': 0.5808557510375977\n'beforeDatePenaltyScore': 0.5808557510375977\n\n'documentId': '1fed2c6361980d606789e315'\n'chunk_id': '68c26fcc0a53cd001394ab94'\n'access': 'granted'\n'part_number': 4\n'total_parts': 8\n'contentType': 'READ'\n'title': Manfred Steyer on Angular 20: Signals, Dynamic Components, AI, and What’s Next - Exploring selectorless components, signal-based forms, and other features in Angular\n'parentName': iJS Magazine Volume 19\n'language': 'EN'\n'date': '2025-06-24T22:00:00.000Z'\n'abstract': In this interview, GDE Manfred Steyer highlights Angular’s journey towards a more reactive future. We discuss the framework’s strengths, challenges, and what’s ahead with the release of Angular 20.\n'parentId': 'a1269c65e87d5b8ebcde4b28'\n'parentDescription': Broaden your knowledge and expand your JavaScript techniques and practices. From Angular, React, and WebAssembly, to the best JavaScript IDEs, open source tools and more, you’ll learn insights on everything JS from seasoned experts in their field. Keep up with JavaScript news, tips, and advice with interviews, tutorials, and in-depth articles.\n'indexBrandName': ''\n'indexSeriesName': ''\n'author': 'Manfred Steyer'\n'chunkSource': 'text'\n'text': linked signals give us a local working copy. We can bind to that, make changes locally, and then send all the data back to the store or directly to the backend. I’ve also tried out the new hydration story and hybrid rendering, where we can decide on a bare route level whether this route should be rendered on the server side, on the client side, or pre-rendered during the build. Combined with incremental hydration, this offers a major performance boost, as it speeds up the page loading times. When your app is exposed to the internet, faster initial load times are critical, and every millisecond counts. Ines Chargui: That leads me to my next question. What do you think of Angular's current position when it comes to achieving hydration and resumability? Manfred Steyer: I think we are on a really good track here. It's now possible to hydrate a page incrementally, meaning you just load a bunch of static HTML and then different parts of the page are hydrated at different times, depending on their importance and what the user is actually interacting with. For example, if a user hasn’t scrolled to a certain section yet, that part doesn’t need to be hydrated immediately. Sure, server-side rendering was always possible, but to be honest, the developer experience was not exactly great. But now, thanks in part to friendly competition from other frameworks like Qwik, there’s been a shift in the ecosystem. Angular has moved quickly, and we’re starting to see major improvements. The developer experience has got a lot better, and features like incremental hydration are moving significantly closer to the direction of resumability. Ines Chargui: Hydration and resumability have become hot topics, with frameworks like React and Angular taking different approaches. Do you think this is something worth investing in going forward, or do you see it potentially hitting a dead end? Manfred Steyer: I don't think it's the end. There are several approaches to this, and different frameworks handle it in various ways. Even if a framework calls it “hydration,” you need to look closely and check what they actually mean by it. The implementation may differ, but the general direction is always the same: minimizing the amount of JavaScript that needs to be downloaded before the user can start using the page. JavaScript is great for UI/UX, but it can slow down the initial page load. This is why single-page applications have always been a bit critical in the area of public portals for customers because every millisecond counts in those scenarios. However, for internal applications used regularly within a company, it’s not a big deal\n'slidetext': ''\n'from': 'index'\n'score': 57.84555435180664\n'normalizedScore': 0.5784555435180664\n'beforeDatePenaltyScore': 0.5784555435180664\n\n'documentId': '1fed2c6361980d606789e315'\n'chunk_id': '68c26fcc0a53cd001394ab97'\n'access': 'granted'\n'part_number': 7\n'total_parts': 8\n'contentType': 'READ'\n'title': Manfred Steyer on Angular 20: Signals, Dynamic Components, AI, and What’s Next - Exploring selectorless components, signal-based forms, and other features in Angular\n'parentName': iJS Magazine Volume 19\n'language': 'EN'\n'date': '2025-06-24T22:00:00.000Z'\n'abstract': In this interview, GDE Manfred Steyer highlights Angular’s journey towards a more reactive future. We discuss the framework’s strengths, challenges, and what’s ahead with the release of Angular 20.\n'parentId': 'a1269c65e87d5b8ebcde4b28'\n'parentDescription': Broaden your knowledge and expand your JavaScript techniques and practices. From Angular, React, and WebAssembly, to the best JavaScript IDEs, open source tools and more, you’ll learn insights on everything JS from seasoned experts in their field. Keep up with JavaScript news, tips, and advice with interviews, tutorials, and in-depth articles.\n'indexBrandName': ''\n'indexSeriesName': ''\n'author': 'Manfred Steyer'\n'chunkSource': 'text'\n'text': among enterprise developers, I'm pretty sure the results would look very different. In sectors like banking, insurance, or manufacturing, Angular is widely used. I also think that the Angular team is aware of the perception around complexity, and they’ve been making efforts to remove unnecessary weight. Ines Chargui: We touched on your hopes and expectations for the upcoming release of Angular 20. Looking beyond that, what do you envision for the future of Angular? What’s maybe something that’s not currently on the team’s radar, but as a developer, you think would make a big difference? Manfred Steyer: I see three directions: One direction is improvements in the whole incremental rendering story, including incremental hydration and so on. Second, there is the reactivity story, in which we’re still at the early stages, but there is a lot of potential, especially with the introduction of Signals. For example, adjusting the router, forms, and data loading to signals would be a big step. That kind of reactivity could open up a lot of new patterns. Eventually, these two areas—incremental rendering and reactivity—will come together because when we have incremental rendering, sooner or later we also need incremental data fetching. This is where reactivity comes in. Then, there’s the developer experience side. This includes improving the build process, speeding things up, doing more on-demand stuff, or rewriting compilers in native languages. TypeScript is now rewritten in Go, and I would love to see something similar for the Angular compiler. This would speed up the whole build process, which can be a huge issue for large-scale teams. Ines Chargui: AI is such a big topic right now, and everyone is using it in some form. What are your thoughts on integrating AI into JavaScript? More specifically, how do you see AI being used within Angular applications? Manfred Steyer: The Angular team is thinking about using AI in the future to assist with code migrations. This ties in well with their commitment to avoiding breaking existing code. Currently, a lot of migrations are handled through custom scripts, but this is limiting since you can’t automate everything, especially when there is no direct transformation from the old to the new style. It's a bit difficult to do this automatically, so AI could really help. It can look at your current source code and find out which tweaks are needed to adjust the source code to the latest versions of all the libraries. Ines Chargui: This has nothing to do with Angular, but what do you think about these AI libraries like TensorFlow.js or Brain.js? Manfred Steyer: I think web developers will learn\n'slidetext': ''\n'from': 'index'\n'score': 57.832542419433594\n'normalizedScore': 0.578325424194336\n'beforeDatePenaltyScore': 0.578325424194336\n\n'documentId': '1c2d0d1ddbcc6e6469e58943'\n'chunk_id': '68beca605b3acf00130227a6'\n'access': 'granted'\n'part_number': 4\n'total_parts': 9\n'contentType': 'READ'\n'title': Angular 19: Incremental Hydration, Hybrid Rendering und Signals - Kolumne: Enterprise Angular\n'parentName': iJS Magazin 1.2025\n'language': 'DE'\n'date': '2025-01-29T23:00:00.000Z'\n'abstract': Mit Version 19 bringt Angular zwei wichtige Features, die unsere Anwendungen performanter machen: Incremental Hydration und Hybrid Rendering. Daneben erhält das Framework weitere Möglichkeiten rund um Signals.\n'parentId': 'fda1be46c7e3c0a30654c08a'\n'parentDescription': Kaum ein Softwareprojekt, das nicht in wesentlichen Teilen auf der JavaScript-Technologie basiert. Eine breite Unterstützung sowie, leistungsfähige Programmiersprachen, die Vielzahl moderner Tools, sowie ausgereifte Frameworks wie Angular, React, Vue.js oder Node.js machen den JavaScript-Werkzeugkasten zu einem Alleskönner. Das iJS Magazin informiert aktuell und umfassend über die wichtige und innovative Entwicklungen im JavaScript-Universum und bietet handfeste Praxisinformationen für Softwareentwickler und -architekten.\n'indexBrandName': ''\n'indexSeriesName': ''\n'author': 'Manfred Steyer'\n'chunkSource': 'text'\n'text': mit Parametern Da das Prerendering bereits beim Build statische HTML-Dateien erzeugt, müssen die möglichen Werte für Routenparameter bekannt sein. In der Vergangenheit konnte man die zu generierten Routen samt Parameter über eine Textdatei bereitstellen. Ab Angular 19 lässt sich das eleganter durch das Festlegen einer Methode getPrerenderParams in der serverseitigen Routenkonfiguration bewerkstelligen (Listing 6). Listing 6 export const serverRoutes: ServerRoute[] = [ { path: 'desserts/:id', renderMode: RenderMode.Prerender, async getPrerenderParams() { const dessertService = inject(DessertService); const ids = await dessertService.findIdsPromise(); return ids.map((id) => ({ id: String(id) })); }, fallback: PrerenderFallback.Client }, { path: '**', renderMode: RenderMode.Prerender, }, ]; Diese asynchrone Methode liefert ein Array vom Typ Record. Die Records enthalten jeweils eine mögliche Parameterkombination. Für jeden Eintrag in diesem Array generiert die Angular CLI eine statische Datei. Die Einstellung fallback kommt zu tragen, wenn zur Laufzeit eine vorgerenderte Route nicht vorliegt. Beispielsweise könnte ein Hyperlink desserts/17 anfordern, obwohl die ID 17 beim Prerendering gar nicht bekannt war. Je nach Einstellung von fallback ergeben sich nun drei mögliche Verhalten: - PrerenderFallback.Client: Die Anwendung rendert die angeforderte Route clientseitig. - PrerenderFallback.Server: Die Anwendung rendert die angeforderte Route serverseitig, hierbei handelt es sich um die Standardeinstellung. - PrerenderFallback.None: Die Anwendung beantwortet die Anfrage nicht. App Shell mit Prerendering In manchen Fällen reicht es schon aus, wenn das Grundgerüst der Anwendung schnell sichtbar ist. Deswegen unterstützt Angular bereits seit einigen Jahren das aus der PWA-Welt bekannte App-Shell-Muster. Die Idee ist, das Grundgerüst der Anwendung in die index.html der Anwendung zu rendern. Auch diese Option lässt sich mit der neuen API für das Hybrid Rendering nutzen. Dazu ist lediglich der Pfad jener Route, die für die App Shell zu nutzen ist, in der Datei app.config.server.ts an provideServerRoutesConfig zu übergeben: provideServerRoutesConfig(serverRoutes, { appShellRoute: 'shell' }) Dabei kann es sich auch um eine sonst nicht direkt über die Navigation erreichbare Route handeln, die speziell für das Prerendering der App Shell eingerichtet wurde. Resource API Bis jetzt konnte man mit Signals nicht direkt im reaktiven Datenfluss\n'slidetext': ''\n'from': 'index'\n'score': 60.4759407043457\n'normalizedScore': 0.604759407043457\n'beforeDatePenaltyScore': 0.604759407043457\n\n'documentId': '1c2d0d1ddbcc6e6469e58943'\n'chunk_id': '68beca605b3acf00130227a8'\n'access': 'granted'\n'part_number': 6\n'total_parts': 9\n'contentType': 'READ'\n'title': Angular 19: Incremental Hydration, Hybrid Rendering und Signals - Kolumne: Enterprise Angular\n'parentName': iJS Magazin 1.2025\n'language': 'DE'\n'date': '2025-01-29T23:00:00.000Z'\n'abstract': Mit Version 19 bringt Angular zwei wichtige Features, die unsere Anwendungen performanter machen: Incremental Hydration und Hybrid Rendering. Daneben erhält das Framework weitere Möglichkeiten rund um Signals.\n'parentId': 'fda1be46c7e3c0a30654c08a'\n'parentDescription': Kaum ein Softwareprojekt, das nicht in wesentlichen Teilen auf der JavaScript-Technologie basiert. Eine breite Unterstützung sowie, leistungsfähige Programmiersprachen, die Vielzahl moderner Tools, sowie ausgereifte Frameworks wie Angular, React, Vue.js oder Node.js machen den JavaScript-Werkzeugkasten zu einem Alleskönner. Das iJS Magazin informiert aktuell und umfassend über die wichtige und innovative Entwicklungen im JavaScript-Universum und bietet handfeste Praxisinformationen für Softwareentwickler und -architekten.\n'indexBrandName': ''\n'indexSeriesName': ''\n'author': 'Manfred Steyer'\n'chunkSource': 'text'\n'text': mehrfach hintereinander die Suchkriterien ändern. In diesem Fall soll die Anwendung lediglich das zum letzten Suchkriterium passende Ergebnis präsentieren. Kurz aufblitzende Zwischenergebnisse wären hingegen verwirrend. Um ein solches Verhalten zu vermeiden, verwirft das Resource API die erhaltenen Ergebnisse, wenn bereits eine weitere Anfrage läuft. Das Resource API signalisiert einer im Loader aufgerufenen Operation sogar, dass sie nicht mehr benötigt wird und abgebrochen werden kann. Dazu enthält das an den Loader übergebene Parameterobjekt ein AbortSignal. Die aufgerufene Operation kann auf dieses AbortSignal horchen und bei einer Benachrichtigung die Ausführung einstellen. Es liegt am Loader sowie an der aufgerufenen Operation, diese Möglichkeit zu nutzen. Da das Resource API unnötige Ergebnisse ignoriert, dient diese Option lediglich der Performanceoptimierung, die sich besonders bei aufwendigen Aufgaben anbietet. rxResource: Resource für RxJS Wenn die Anwendung bereits Observables nutzt, müssen diese nicht manuell in Promises umgewandelt werden. Stattdessen lässt sich das API rxResource aus @angular/core/rxjs-interop verwenden. Es funktioniert wie resource, allerdings liefert der Loader ein Observable. Listing 8 dessertsResource = rxResource({ request: this.dessertsCriteria, loader: (param) => { return timer(300).pipe( switchMap(() => this.#dessertService.find(param.request))); } }); Der Loader der rxResource bekommt kein AbortSignal, da Observables direkt durch implizites oder explizites Abmelden abgebrochen werden können. Es ist wichtig zu wissen, dass die aktuelle Implementierung von rxResource nur den ersten empfangenen Wert aus dem Observable verwendet. Intern nutzt sie firstValueFrom, um das Observable in ein Promise umzuwandeln. Dieses Promise übergibt sie danach an resource. Während dieses Verhalten für HTTP-Aufrufe in Ordnung ist, führt es zu Überraschungen, wenn mehrere Werte über einen Stream empfangen werden, z. B. beim Einsatz von WebSockets. Im letzteren Fall sollte die Anwendung die Observables auf klassische Weise nutzen. Linked Signals Eine weitere Neuerung, die ab Angular 19 als Developer Preview vorliegt, sind die sogenannten Linked Signals. Auf dem ersten Blick wirken sie wie ein berechnetes Signal. Allerdings sind berechnete Signals read-only. Linked Signals haben jedoch eine veränderbare Arbeitskopie. Deswegen bieten sich Linked Signals an, um berechnete Werte oder read-only Zustände an Template-driven Forms zu binden. Das Beispiel\n'slidetext': ''\n'from': 'index'\n'score': 60.190425872802734\n'normalizedScore': 0.6019042587280273\n'beforeDatePenaltyScore': 0.6019042587280273\n\n'documentId': '1c2d0d1ddbcc6e6469e58943'\n'chunk_id': '68beca605b3acf00130227a7'\n'access': 'granted'\n'part_number': 5\n'total_parts': 9\n'contentType': 'READ'\n'title': Angular 19: Incremental Hydration, Hybrid Rendering und Signals - Kolumne: Enterprise Angular\n'parentName': iJS Magazin 1.2025\n'language': 'DE'\n'date': '2025-01-29T23:00:00.000Z'\n'abstract': Mit Version 19 bringt Angular zwei wichtige Features, die unsere Anwendungen performanter machen: Incremental Hydration und Hybrid Rendering. Daneben erhält das Framework weitere Möglichkeiten rund um Signals.\n'parentId': 'fda1be46c7e3c0a30654c08a'\n'parentDescription': Kaum ein Softwareprojekt, das nicht in wesentlichen Teilen auf der JavaScript-Technologie basiert. Eine breite Unterstützung sowie, leistungsfähige Programmiersprachen, die Vielzahl moderner Tools, sowie ausgereifte Frameworks wie Angular, React, Vue.js oder Node.js machen den JavaScript-Werkzeugkasten zu einem Alleskönner. Das iJS Magazin informiert aktuell und umfassend über die wichtige und innovative Entwicklungen im JavaScript-Universum und bietet handfeste Praxisinformationen für Softwareentwickler und -architekten.\n'indexBrandName': ''\n'indexSeriesName': ''\n'author': 'Manfred Steyer'\n'chunkSource': 'text'\n'text': Datenfluss eine asynchrone Operation anstoßen. Gerade, aber nicht nur, für das Abrufen von Resourcen via HTTP ist diese Aufgabe jedoch essenziell. Das neue, vorerst als experimentell eingestufte Resource API ändert das. Jede damit definierte Resource repräsentiert eine asynchrone Aufgabe, die Daten liefert. Eine Resource hat eine Funktion loader, die ein Promise mit den geladenen Daten zurückgibt. Dieser Loader kommt unmittelbar nach der Initialisierung der Resource zum Einsatz. Zusätzlich kann die Resource ein request-Signal haben, das Parameter (Suchkriterien) für den Loader bereitstellt. Jedes Mal, wenn sich das request-Signal ändert, stößt die Resource den Loader erneut an (Listing 7). Listing 7 import { resource } from '@angular/core'; [...] @Component([...]) export class DessertsComponent { #dessertService = inject(DessertService); [...] // Criteria for search originalName = signal(''); englishName = signal(''); // Combine criteria to computed Signal dessertsCriteria = computed(() => ({ originalName: this.originalName(), englishName: this.englishName(), })); // Define resource with request (=search criteria) and loader // Every time, the request is changing, the loader is triggered dessertsResource = resource({ request: this.dessertsCriteria, loader: (param) => { return this.#dessertService.findPromise(param.request); } }); // Initially, resources are undefined desserts = computed(() => this.dessertsResource.value() ?? []); loading = this.dessertsResource.isLoading; error = this.dessertsResource.error; [...] } In diesem Beispiel verwendet dessertsResource die Werte in den Signals originalName und englishName als Parameter. Das an den Loader übergebene param-Objekt enthält die aktuellen Suchkriterien aus dem request Signal. Das Ergebnis der Resource findet sich in ihrem Signal value. Das berechnete desserts Signal ersetzt den initialen undefined-Wert durch ein leeres Array. Das Signal isLoaded informiert über den Ladezustand und error ist ein Signal mit einem möglichen Fehler, der während des Ladens aufgetreten ist. Trigger und Race Conditions Das Resource API hat zwei wichtige Eigenschaften, die es von der direkten Verwendung eines Effects abhebt: Zum einen verfolgt sie nur das request-Signal. Signals, die im Loader zum Einsatz kommen, triggern keinen erneuten Ladevorgang, wenn sie sich ändern. Somit sieht man auf dem ersten Blick, unter welchen Umständen die Resource ein erneutes Laden anstößt. Daneben verhindert das Resource API Probleme mit überlappenden Anfragen, wie z. B. Race Conditions. Diese können auftreten, wenn Benutzer:innen mehrfach\n'slidetext': ''\n'from': 'index'\n'score': 59.65107345581055\n'normalizedScore': 0.5965107345581054\n'beforeDatePenaltyScore': 0.5965107345581054\n\n'documentId': 'cfe389e23ed61a9ae7f11b32'\n'chunk_id': '68ac830f494be90012217e60'\n'access': 'restricted'\n'part_number': 1\n'total_parts': 1\n'contentType': 'RHEINGOLD'\n'title': Modern Angular Workshop: Architektur und Features\n'parentName': BASTA! Spring 2025\n'language': 'DE'\n'date': '2025-03-07T08:00:00.000Z'\n'abstract': Lernen Sie langfristig wartbare Enterprise-Lösungen mit modernem Angular zu entwerfen! In diesem Workshop tauchen Sie tief in die neuesten Angular-Features ein, um moderne, wartbare Anwendungsarchitekturen zu entwickeln. Lernen Sie, wie Sie Standalone Components nutzen, neue Modularisierungsansätze mit Nx und Sheriff anwenden, und erfahren Sie mehr über die aktualisierten APIs für HttpClient und Router. Entdecken Sie neue Built-in Control Flow Blocks, Signals für verbesserte Change Detection und den Signal Store für effektives State-Management.\n'parentId': '577ff41c05af8176bbd0043d'\n'parentDescription': Die Konferenz für .NET, Web & AI Innovation\n'indexBrandName': 'BASTA!'\n'indexSeriesName': 'Spring'\n'author': 'Manfred Steyer,Rainer Hahnekamp'\n'chunkSource': 'text'\n'text': Modern Angular Workshop: Architektur und Features Lernen Sie langfristig wartbare Enterprise-Lösungen mit modernem Angular zu entwerfen! In diesem Workshop tauchen Sie tief in die neuesten Angular-Features ein, um moderne, wartbare Anwendungsarchitekturen zu entwickeln. Lernen Sie, wie Sie Standalone Components nutzen, neue Modularisierungsansätze mit Nx und Sheriff anwenden, und erfahren Sie mehr über die aktualisierten APIs für HttpClient und Router. Entdecken Sie neue Built-in Control Flow Blocks, Signals für verbesserte Change Detection und den Signal Store für effektives State-Management.\n'slidetext': ''\n'from': 'index'\n'score': 64.29460144042969\n'normalizedScore': 0.6429460144042969\n'beforeDatePenaltyScore': 0.6429460144042969\n\n'documentId': '01a63ca630515849aaa314b1'\n'chunk_id': '6876e25c51ca701363239b74'\n'access': 'restricted'\n'part_number': 1\n'total_parts': 1\n'contentType': 'RHEINGOLD'\n'title': Angular Signals: Neue Features für die reaktive Entwicklung\n'parentName': JavaScript Days München und online 2025\n'language': 'DE'\n'date': '2025-03-19T12:30:00.000Z'\n'abstract': Angular Signals sind seit einiger Zeit ein spannender Bestandteil der reaktiven Entwicklung in Angular. Mit neuen Features wie linkedSignal() und resource() in Angular 19 rücken sie weiter in den Fokus. Doch wie funktionieren Signals und was macht sie so besonders – insbesondere in Bezug auf die Performance? Welche Vorteile bieten sie gegenüber klassischen RxJS-Patterns?Felix Schütz von Thinktecture gibt eine praxisnahe Einführung in Angular Signals und die damit verbundenen neuen Features und zeigt, wie sie die Entwicklung von modernen, reaktiven Anwendungen nachhaltig verändern. Zusätzlich gibt er einen Ausblick auf die geplante Unterstützung von Signal-basierten Formularen.\n'parentId': 'efd4ff41c4b9e889b50854b8'\n'parentDescription': 40 Workshops zu JavaScript, Angular, React, HTML & CSS und KI\n'indexBrandName': 'JavaScriptDays'\n'indexSeriesName': 'Munich'\n'author': 'Felix Schütz'\n'chunkSource': 'text'\n'text': Angular Signals: Neue Features für die reaktive Entwicklung Angular Signals sind seit einiger Zeit ein spannender Bestandteil der reaktiven Entwicklung in Angular. Mit neuen Features wie linkedSignal() und resource() in Angular 19 rücken sie weiter in den Fokus. Doch wie funktionieren Signals und was macht sie so besonders – insbesondere in Bezug auf die Performance? Welche Vorteile bieten sie gegenüber klassischen RxJS-Patterns?Felix Schütz von Thinktecture gibt eine praxisnahe Einführung in Angular Signals und die damit verbundenen neuen Features und zeigt, wie sie die Entwicklung von modernen, reaktiven Anwendungen nachhaltig verändern. Zusätzlich gibt er einen Ausblick auf die geplante Unterstützung von Signal-basierten Formularen.\n'slidetext': ''\n'from': 'index'\n'score': 69.0760498046875\n'normalizedScore': 0.690760498046875\n'beforeDatePenaltyScore': 0.690760498046875\n\n'documentId': '43b7900e7154d2f13c41085b'\n'chunk_id': '6876d2a1225e92fc1ac797f7'\n'access': 'granted'\n'part_number': 1\n'total_parts': 6\n'contentType': 'COURSE'\n'title': Exploring httpResource in Angular 19.2\n'parentName': Advanced Angular: Signals, NgRx & AI Forms\n'language': 'DE'\n'date': '2025-05-02T10:49:04.000Z'\n'abstract': The introduction of *httpResource* in Angular 19.2 brings a new way to load data seamlessly within the reactive flow. Let's explore how this experimental feature can be leveraged to enhance your applications.\n'parentId': '5e78d57fd77e42835f9996dc'\n'parentDescription': Level up your Angular skills with this advanced course, highlighting the framework’s evolving features. We will cover cutting-edge topics, from mastering state management with the NgRx Signal store and unlocking AI-enhanced forms’ potential, to revisiting the performance benefits of server-side rendering. You will learn how to effectively use Signals through professional tips and real-world insights, and explore emerging features like httpResource in Angular 19.2. Whether you are scaling enterprise apps or upgrading legacy codebases, this course equips you with the practices to build smarter, faster Angular applications and stay ahead in today’s Angular ecosystem.\n'indexBrandName': 'InternationalJavaScriptCon'\n'indexSeriesName': ''\n'author': 'Manfred Steyer'\n'chunkSource': 'text'\n'text': Exploring httpResource in Angular 19.2 The introduction of httpResource in Angular 19.2 brings a new way to load data seamlessly within the reactive flow. Let's explore how this experimental feature can be leveraged to enhance your applications. Angular 19.2 introduced the experimental httpResource feature, streamlining HTTP data loading within the reactive flow of applications. By leveraging signals, it simplifies asynchronous data fetching, providing developers with a more streamlined approach to handling HTTP requests. With Angular 20 on the horizon, this feature will evolve further, offering even more power for managing data in reactive applications. Let’s explore how to leverage httpResource to enhance your applications. As an example, we have a simple application that scrolls through levels in the style of the game Super Mario. Each level consists of tiles that are available in four different styles: overworld, underground, underwater, and castle. In our implementation, users can switch freely between these styles. Figure 1 shows the first level in overworld style, while Figure 2 shows the same level in underground style. Figure 1: Level 1 in overworld style Figure 2: Level 1 in the underground style A LevelComponent in the example application takes care of loading level files (JSON) and tiles for drawing the levels using an httpResource. To render and animate the levels, the example relies on a very simple engine that is included with the source code but is treated as a black box here in the article. HttpClient in the substructure enables the use of interceptors At its core, the new httpResource currently uses the good old HttpClient. Therefore, the application has to provide this service, which is usually done by calling provideHttpClient during bootstrapping. As a consequence, the httpResource also automatically picks up the registered HttpInterceptors. However, the HttpClient is just an implementation detail that Angular may eventually replace with a different implementation. Level files The different levels are described by our example JSON files, which define which tiles are to be displayed at which coordinates (Listing 1). Listing 1: { 'levelId': 1, 'backgroundColor': '#9494ff', 'items': [ { 'tileKey': 'floor', 'col': 0, 'row': 13, [...] }, { 'tileKey': 'cloud', 'col': 12, 'row': 1, [...] }, [...] ] } These coordinates define positions within a matrix of blocks measuring 16x16 pixels. An overview.json file is provided with these level files, which provides information about the names of the available levels. A LevelLoader takes care of loading these files. To do this, it uses the new httpResource (Listing 2). Listing 2: @Injectable({ providedIn: 'root' }) export class LevelLoader { getLevelOverviewResource():\n'slidetext': ''\n'from': 'index'\n'score': 60.01118469238281\n'normalizedScore': 0.6001118469238281\n'beforeDatePenaltyScore': 0.6001118469238281\n\n'documentId': '59c6dfa238c69ebd748cc7dc'\n'chunk_id': '69038857a7bbb00013e754e7'\n'access': 'restricted'\n'part_number': 1\n'total_parts': 1\n'contentType': 'RHEINGOLD'\n'title': Angular Signals: Neue Features für die reaktive Entwicklung\n'parentName': JavaScript Days Berlin und online 2025\n'language': 'DE'\n'date': '2025-10-22T11:30:00.000Z'\n'abstract': Angular Signals sind seit einiger Zeit ein spannender Bestandteil der reaktiven Entwicklung in Angular. Mit neuen Features wie linkedSignal() und resource() in Angular 20 rücken sie weiter in den Fokus. Doch wie funktionieren Signals und was macht sie so besonders – insbesondere in Bezug auf die Performance? Welche Vorteile bieten sie gegenüber klassischen RxJS-Patterns? Felix Schütz von Thinktecture gibt eine praxisnahe Einführung in Angular Signals und die damit verbundenen neuen Features und zeigt, wie sie die Entwicklung von modernen, reaktiven Anwendungen nachhaltig verändern. Zusätzlich gibt er einen Ausblick auf die geplante Unterstützung von Signal-basierten Formularen.\n'parentId': 'a233287a238c6e0ce3f91546'\n'parentDescription': 40 Workshops zu JavaScript, Angular, React, Typescript und KI\n'indexBrandName': 'JavaScriptDays'\n'indexSeriesName': 'Berlin'\n'author': 'Felix Wunderlich'\n'chunkSource': 'text'\n'text': Angular Signals: Neue Features für die reaktive Entwicklung Angular Signals sind seit einiger Zeit ein spannender Bestandteil der reaktiven Entwicklung in Angular. Mit neuen Features wie linkedSignal() und resource() in Angular 20 rücken sie weiter in den Fokus. Doch wie funktionieren Signals und was macht sie so besonders – insbesondere in Bezug auf die Performance? Welche Vorteile bieten sie gegenüber klassischen RxJS-Patterns? Felix Schütz von Thinktecture gibt eine praxisnahe Einführung in Angular Signals und die damit verbundenen neuen Features und zeigt, wie sie die Entwicklung von modernen, reaktiven Anwendungen nachhaltig verändern. Zusätzlich gibt er einen Ausblick auf die geplante Unterstützung von Signal-basierten Formularen.\n'slidetext': ''\n'from': 'index'\n'score': 69.1158676147461\n'normalizedScore': 0.691158676147461\n'beforeDatePenaltyScore': 0.691158676147461\n\n'documentId': 'ac8bcbad20150e9773f7400b'\n'chunk_id': '69021a60a5de460012a1af2b'\n'access': 'granted'\n'part_number': 11\n'total_parts': 11\n'contentType': 'RHEINGOLD'\n'title': Getting the most out of Angular DevTools\n'parentName': International JavaScript Conference Munich 2025\n'language': 'EN'\n'date': '2025-10-29T09:15:00.000Z'\n'abstract': In this session, we’ll dive into Angular DevTools and how it can enhance your development experience. From getting started with installation and setup to exploring the interface, you'll learn how to quickly get it running and connected to your Angular app. We’ll cover debugging techniques using the component tree, tracking state changes, and spotting binding issues. You’ll also get hands-on with performance profiling, learn how to identify rendering bottlenecks, and understand what the timeline panel is really telling you. A dedicated section on inspecting injectors will help demystify Angular’s dependency injection. Finally, we’ll wrap up with tips and hidden gems to help you get the most value from DevTools day to day. Whether you're new to Angular or a seasoned developer, this session will give you practical, actionable ways to make Angular DevTools an essential part of your workflow.\n'parentId': 'd9a5c0715a7cff50bbb51e14'\n'parentDescription': \n'indexBrandName': 'InternationalJavaScriptCon'\n'indexSeriesName': 'Munich'\n'author': 'Sam Vloeberghs'\n'chunkSource': 'text'\n'text': the signal graph, yeah. Yeah, so I had to repeat for, for the audience online, the question was if there uh. Is a, uh, if you're using a signal store, will it uh allow, will the angular dev tools allow you to uh click through to the sources of the um of the signal stores signal store directly. Yeah. Any other questions? If you're shy and don't want to ask your question in public, you can always uh ask me privately as well. Um. And uh yeah, please um provide your feedback uh in the uh conference application afterwards. Thank you. There are some Questions from the audience as well. Let me see. There's a question from the audience. Uh, I do not have the router tree tap. Uh, is my angular De Tools an old version? It could be, um, it could be that you're using an older version of your, uh, in your angular application as well. But the uh router tree. Uh, let me see. Is a feature that you need to enable explicitly. So it's not enabled by default. You can use the top level, um, let me. Share my full screen. So the router tree is a feature that you'll need to explicitly enable. All right. Thank you.\n'slidetext': ''\n'from': 'vector'\n'score': 0.9001873731613159\n'normalizedScore': 0.8995181192514986\n'beforeDatePenaltyScore': 0.9001873731613159\n\n\nReferenceChunks:\n'documentId': 'ac8bcbad20150e9773f7400b'\n'chunk_id': '69021a60a5de460012a1af2b'\n'access': 'granted'\n'part_number': 11\n'total_parts': 11\n'poc_summary': 'This conference talk presents practical techniques for using Angular DevTools to debug, profile, and optimize modern Angular applications.'\n'chunk_summary': 'It answers audience questions about signal store integration and router tree availability in Angular DevTools.'\n'access_message': '✅ You still have access to the recordings for this talk of International JavaScript Conference Munich 2025 until 2026-04-27. Unfortunately, recordings are not available for workshops, but you can still access the slides and your certificate. Dive back in anytime!'\n\n'documentId': '59c6dfa238c69ebd748cc7dc'\n'chunk_id': '69038857a7bbb00013e754e7'\n'access': 'restricted'\n'part_number': 1\n'total_parts': 1\n'poc_summary': 'This conference talk introduces Angular Signals and new features for modern reactive application development.'\n'chunk_summary': 'It explains the advantages of Signals over classic RxJS patterns and previews Signal-based forms.'\n'access_message': 'ℹ️ This talk of JavaScript Days Berlin und online 2025 was part of a past event. Booking is no longer available, but you can discover the current edition right here on the platform.'\n\n'documentId': '43b7900e7154d2f13c41085b'\n'chunk_id': '6876d2a1225e92fc1ac797f7'\n'access': 'granted'\n'part_number': 1\n'total_parts': 6\n'poc_summary': 'This seminar lesson examines how Angular 19.2’s httpResource enables reactive, signal-based data loading in modern applications.'\n'chunk_summary': 'It introduces a Super Mario–style example app that loads level data and tiles using httpResource.'\n'access_message': '✅ This content is included with your elevate membership.'\n\n'documentId': '01a63ca630515849aaa314b1'\n'chunk_id': '6876e25c51ca701363239b74'\n'access': 'restricted'\n'part_number': 1\n'total_parts': 1\n'poc_summary': 'This conference talk introduces Angular Signals and their new features for modern reactive application development.'\n'chunk_summary': 'It explains how linkedSignal() and resource() in Angular 19 enhance performance and developer experience.'\n'access_message': 'ℹ️ This talk of JavaScript Days München und online 2025 was part of a past event. Booking is no longer available, but you can discover the current edition right here on the platform.'\n\n'documentId': 'cfe389e23ed61a9ae7f11b32'\n'chunk_id': '68ac830f494be90012217e60'\n'access': 'restricted'\n'part_number': 1\n'total_parts': 1\n'poc_summary': 'This conference talk examines how to design maintainable enterprise solutions using modern Angular architecture and its latest features.'\n'chunk_summary': 'It highlights the use of Standalone Components, Nx, Sheriff, and new APIs for HttpClient and Router.'\n'access_message': 'ℹ️ This talk of BASTA! Spring 2025 was part of a past event. Booking is no longer available, but you can discover the current edition right here on the platform.'\n\n'documentId': '1c2d0d1ddbcc6e6469e58943'\n'chunk_id': '68beca605b3acf00130227a7'\n'access': 'granted'\n'part_number': 5\n'total_parts': 9\n'poc_summary': 'This article examines Angular 19’s new features, focusing on incremental hydration, hybrid rendering, and enhancements to Signals.'\n'chunk_summary': 'It highlights the experimental Resource API, enabling asynchronous data loading with Signals and automatic reloading on parameter changes.'\n'access_message': '✅ This content is included with your elevate membership.'\n\n'documentId': '1fed2c6361980d606789e315'\n'chunk_id': '68c26fcc0a53cd001394ab97'\n'access': 'granted'\n'part_number': 7\n'total_parts': 8\n'poc_summary': 'This article discusses Angular 20’s evolution, focusing on signals, reactivity, dynamic components, and the framework’s future direction.'\n'chunk_summary': 'It examines future directions for Angular, including AI-assisted migrations and compiler improvements for faster builds.'\n'access_message': '✅ This content is included with your elevate membership.'\n\n'documentId': 'c8af1d2c9d8e08acaa09599f'\n'chunk_id': '68c26ff80a53cd001394abf7'\n'access': 'granted'\n'part_number': 3\n'total_parts': 4\n'poc_summary': 'This article examines patterns for building custom standalone APIs in Angular, inspired by established libraries like HttpClient, Router, and NgRx.'\n'chunk_summary': 'It highlights the feature pattern, allowing optional functionality to be added and validated through categorized feature objects.'\n'access_message': '✅ This content is included with your elevate membership.'\n\n'documentId': 'dcce136001b8cf2cfe8b5498'\n'chunk_id': '6876df207899910dd58c0e9c'\n'access': 'granted'\n'part_number': 1\n'total_parts': 7\n'poc_summary': 'This article examines the experimental httpResource feature in Angular 19.2 for loading data within reactive flows.'\n'chunk_summary': 'It introduces a sample application that scrolls through levels styled like Super Mario, using httpResource for data loading.'\n'access_message': '✅ This content is included with your elevate membership.'\n\n'documentId': 'd74f910ab5ef9854703a97d3'\n'chunk_id': '6876dc4d225e92fc1ac7cc8e'\n'access': 'restricted'\n'part_number': 1\n'total_parts': 1\n'poc_summary': 'This conference talk examines how to modernize Angular applications by adopting recent features like Signals, standalone APIs, and functional patterns.'\n'chunk_summary': 'It outlines a step-by-step migration from classic Angular solutions to a lightweight, maintainable modern architecture.'\n'access_message': 'ℹ️ This talk of JavaScript Days München und online 2025 was part of a past event. Booking is no longer available, but you can discover the current edition right here on the platform.'\n\n'documentId': '9836770500f149a58b7769f9'\n'chunk_id': '68ad7e39494be90012217fea'\n'access': 'granted'\n'part_number': 4\n'total_parts': 6\n'poc_summary': 'This article provides professional guidance on effectively using Signals in Angular, focusing on best practices for reactive data flow and integration with RxJS.'\n'chunk_summary': 'It discusses the limitations of using Signals as triggers for events and the importance of using effects or RxJS for intentions.'\n'access_message': '✅ This content is included with your elevate membership.'\n\n'documentId': '8b124d1f8a4b51f23acbc7f1'\n'chunk_id': '690b38892e2492001343de86'\n'access': 'restricted'\n'part_number': 1\n'total_parts': 1\n'poc_summary': 'This seminar lesson focuses on advanced Angular directives, modern Angular features, and sophisticated routing techniques for scalable web applications.'\n'chunk_summary': 'It highlights the use of attribute, structural, and component directives for dynamic, reusable templates in Angular.'\n'access_message': '⚠️ This talk of Angular Camp - Deep Dive Camp Intense Dezember 2025 | Online is a premium add-on. Purchase separately to participate. As an Elevate member, your discount of 10% is applied automatically when booking via your Elevate dashboard here on entwickler.de. An additional 3% applies if you use a prepayment method.'\n\n'documentId': 'ffe46902112505d5bdec0031'\n'chunk_id': '6876e1af7899910dd58c1c2c'\n'access': 'restricted'\n'part_number': 1\n'total_parts': 1\n'poc_summary': 'This seminar lesson deepens advanced Angular skills with directives, modern features, and sophisticated routing techniques.'\n'chunk_summary': 'It explains attribute, structural, and component directives for building dynamic, reusable templates in Angular.'\n'access_message': 'ℹ️ This talk of Angular Camp - Deep Dive Camp Intense September 2025 | München was part of a past event. Booking is no longer available, but you can discover the current edition right here on the platform.'\n\n'documentId': 'b8bf349a24030fa6f49599de'\n'chunk_id': '6876da19225e92fc1ac7c15d'\n'access': 'restricted'\n'part_number': 1\n'total_parts': 1\n'poc_summary': 'This seminar lesson focuses on advanced Angular directives, modern Angular features, and sophisticated routing techniques for scalable web applications.'\n'chunk_summary': 'It highlights attribute, structural, and component directives, as well as runtime template referencing and microsyntax in Angular.'\n'access_message': 'ℹ️ This talk of Angular Camp - Deep Dive Camp Intense Februar 2025 | Online was part of a past event. Booking is no longer available, but you can discover the current edition right here on the platform.'\n\n'documentId': 'af6bfaa1ee403d005b7cb22d'\n'chunk_id': '690e0ea58c81760014412a9e'\n'access': 'granted'\n'part_number': 1\n'total_parts': 29\n'poc_summary': 'This conference talk presents practical architectural strategies for sustainable Angular projects, covering modularization, state management, and scaling approaches.'\n'chunk_summary': 'It introduces the importance of structuring Angular applications early to avoid risky refactoring as projects grow.'\n'access_message': '✅ You still have access to the recordings for this talk of W-JAX 2025 until 2026-05-05. Unfortunately, recordings are not available for workshops, but you can still access the slides and your certificate. Dive back in anytime!'\n\n'documentId': '3ac2ff4b76a2048bae5607f6'\n'chunk_id': '6903881aa7bbb00013e754e5'\n'access': 'restricted'\n'part_number': 1\n'total_parts': 1\n'poc_summary': 'This conference talk introduces key accessibility concepts, tools, and best practices for building accessible Angular applications.'\n'chunk_summary': 'It highlights practical exercises using selected A11y tools and Angular features for hands-on learning.'\n'access_message': 'ℹ️ This talk of JavaScript Days Berlin und online 2025 was part of a past event. Booking is no longer available, but you can discover the current edition right here on the platform.'\n\n'documentId': '0747f0655ef3790a97eba95b'\n'chunk_id': '68f24b683134c10012c3d12f'\n'access': 'restricted'\n'part_number': 4\n'total_parts': 16\n'poc_summary': 'This conference talk examines modern Angular architecture in 2025, focusing on signals, resources, and lazy loading for scalable, maintainable apps.'\n'chunk_summary': 'It outlines upcoming component authoring improvements aimed at reducing boilerplate and making Angular more future-proof.'\n'access_message': 'ℹ️ This talk of International JavaScript New York 2025 was part of a past event. Booking is no longer available, but you can discover the current edition right here on the platform.'\n\n'documentId': '73a55b4bbeecf374b233deaf'\n'chunk_id': '687a299f2491ed518a3f0cf6'\n'access': 'restricted'\n'part_number': 1\n'total_parts': 1\n'poc_summary': 'This conference talk examines Angular’s latest innovations for building modern, high-performance web applications.'\n'chunk_summary': 'It highlights standalone components, lazy loading, control flow, deferrable views, signals, and zoneless Angular.'\n'access_message': 'ℹ️ This talk of International JavaScript Conference Singapore 2024 was part of a past event. Booking is no longer available, but you can discover the current edition right here on the platform.'\n\n'documentId': '01073933df6d62616b01fd1e'\n'chunk_id': '68ac7b53494be90012217afb'\n'access': 'restricted'\n'part_number': 30\n'total_parts': 30\n'poc_summary': 'This conference talk examines how Nx enables scalable, modular architectures for Angular applications, emphasizing workspace organization and maintainability.'\n'chunk_summary': 'It concludes by recommending Nx for all Angular projects and points to further resources for learning.'\n'access_message': 'ℹ️ This talk of BASTA! Spring 2025 was part of a past event. Booking is no longer available, but you can discover the current edition right here on the platform.'\n\n'documentId': 'ec8de39dac90e93f9fd00a92'\n'chunk_id': '687a312cca798166d3ba43b5'\n'access': 'restricted'\n'part_number': 11\n'total_parts': 12\n'poc_summary': 'This conference talk presents advanced strategies and practical techniques for optimizing Angular application performance in modern web development.'\n'chunk_summary': 'It discusses experimental zone-less APIs and clarifies how OnPush change detection works in practice.'\n'access_message': 'ℹ️ This talk of International JavaScript New York 2024 was part of a past event. Booking is no longer available, but you can discover the current edition right here on the platform.'\n\n'documentId': '5ca564ac8c4557f4f949b660'\n'chunk_id': '687a2b82495b49563aa87acd'\n'access': 'restricted'\n'part_number': 1\n'total_parts': 9\n'poc_summary': 'This conference talk examines how new Angular APIs enable modern codebases, focusing on migration strategies and developer experience.'\n'chunk_summary': 'It highlights Angular’s shift to standalone APIs, enhanced server-side rendering, and optional RxJS for easier code management.'\n'access_message': 'ℹ️ This talk of International JavaScript Conference Munich 2024 was part of a past event. Booking is no longer available, but you can discover the current edition right here on the platform.'\n\n'documentId': '6883afe7f10bc00f03909bef'\n'chunk_id': '687a370def5cff79d6f5cf11'\n'access': 'restricted'\n'part_number': 16\n'total_parts': 19\n'poc_summary': 'This conference talk examines Angular’s evolution, highlighting key lessons in resilience, adaptation, and community-driven development over a decade.'\n'chunk_summary': 'It demonstrates the opt-in nature of signals and the use of developer previews for community feedback.'\n'access_message': 'ℹ️ This talk of International JavaScript New York 2024 was part of a past event. Booking is no longer available, but you can discover the current edition right here on the platform.'\n\n'documentId': 'Es9qB3iW8QsKxfKEh'\n'chunk_id': '687a2d569bbcb45d2a11ead8'\n'access': 'restricted'\n'part_number': 1\n'total_parts': 1\n'poc_summary': 'This conference talk examines how to modernize Angular applications using recent features for lighter, more maintainable solutions.'\n'chunk_summary': 'It highlights the integration of Signals, standalone APIs, functional guards, and esbuild support in modern Angular.'\n'access_message': 'ℹ️ This talk of JavaScript Days Berlin und online 2024 was part of a past event. Booking is no longer available, but you can discover the current edition right here on the platform.'\n\n'documentId': '22a125a269ee4ccc064bc5d5'\n'chunk_id': '687a26cd96f7bf47ed452442'\n'access': 'restricted'\n'part_number': 5\n'total_parts': 19\n'poc_summary': 'This conference talk examines how AI and modern Angular features enable developers to build high-performance, user-centric web applications that exceed evolving expectations.'\n'chunk_summary': 'The talk discusses Angular's improvements in developer experience, reducing boilerplate and simplifying syntax.'\n'access_message': 'ℹ️ This talk of International JavaScript New York 2024 was part of a past event. Booking is no longer available, but you can discover the current edition right here on the platform.'\n\n'documentId': 'vAJzqCurd28Mq4HRk'\n'chunk_id': '687a3236ca798166d3ba4eca'\n'access': 'restricted'\n'part_number': 1\n'total_parts': 1\n'poc_summary': 'This conference talk examines modern Angular architectures and features for building maintainable applications.'\n'chunk_summary': 'It highlights the use of Standalone Components, Nx, Sheriff, and updated APIs for HttpClient and Router.'\n'access_message': 'ℹ️ This talk of BASTA! Herbst 2024 was part of a past event. Booking is no longer available, but you can discover the current edition right here on the platform.'\n\n'documentId': 'mrkFPBdm5bQQ8Q8nY'\n'chunk_id': '687a355fca798166d3ba5e1c'\n'access': 'restricted'\n'part_number': 1\n'total_parts': 22\n'poc_summary': 'This conference talk examines Angular’s evolution toward standalone APIs, signals, and modern migration strategies for future-proof applications.'\n'chunk_summary': 'It introduces Angular’s recent features, including advanced server-side rendering and the new control flow syntax.'\n'access_message': 'ℹ️ This talk of International JavaScript Conference London 2024 was part of a past event. Booking is no longer available, but you can discover the current edition right here on the platform.'\n\n'documentId': 'N9G6dCb5BArvu6cbr'\n'chunk_id': '687a2d559bbcb45d2a11ead0'\n'access': 'restricted'\n'part_number': 22\n'total_parts': 23\n'poc_summary': 'This conference talk examines Angular’s latest APIs, migration strategies, and features for modernizing enterprise applications with future-proof architecture.'\n'chunk_summary': 'It highlights server-side rendering improvements, including integrated hydration and collaboration with Google’s internal teams.'\n'access_message': 'ℹ️ This talk of International JavaScript Conference San Diego 2024 was part of a past event. Booking is no longer available, but you can discover the current edition right here on the platform.'\n\n'documentId': 'e68608162c5fe79f9ee9d810'\n'chunk_id': '68bef62c5b3acf0013024dfb'\n'access': 'granted'\n'part_number': 6\n'total_parts': 6\n'poc_summary': 'This article examines how the NgRx Signal Store changes architectural rules and best practices in Angular applications.'\n'chunk_summary': 'It concludes by recommending feature services to coordinate multiple Signal Stores and provides further reading links.'\n'access_message': '✅ This content is included with your elevate membership.'\n\n'documentId': 'HMjgiHgaqRmGAddkF'\n'chunk_id': '687a2e839bbcb45d2a11f727'\n'access': 'restricted'\n'part_number': 1\n'total_parts': 1\n'poc_summary': 'This conference talk examines how to modernize Angular applications using recent features like Signals, standalone APIs, and functional patterns.'\n'chunk_summary': 'It outlines a step-by-step approach to upgrading classic Angular solutions with new framework capabilities.'\n'access_message': 'ℹ️ This talk of JavaScript Days Muenchen und online 2024 was part of a past event. Booking is no longer available, but you can discover the current edition right here on the platform.'\n\n'documentId': 'yeDqYHwX2d2dnZvTR'\n'chunk_id': '687b453c2b0a1813a73e5c09'\n'access': 'restricted'\n'part_number': 1\n'total_parts': 18\n'poc_summary': 'This conference talk explores Angular’s latest evolution—standalone APIs, reactivity with signals, hydration and template enhancements—for developing dynamic next-generation web applications.'\n'chunk_summary': 'It notes modern browsers now support running full applications like Photoshop directly in the browser.'\n'access_message': 'ℹ️ This talk of International JavaScript New York was part of a past event. Booking is no longer available, but you can discover the current edition right here on the platform.'\n\n'documentId': '3acbf0544b06e04de42f0a07'\n'chunk_id': '687ab4782be886398c2ab477'\n'access': 'granted'\n'part_number': 1\n'total_parts': 4\n'poc_summary': 'This article explores Angular’s new standalone features and functional APIs that lighten applications and enhance maintainability by minimizing NgModule dependencies.'\n'chunk_summary': 'It outlines how declaring standalone: true and using the imports array enables components without NgModules.'\n'access_message': '✅ This content is included with your elevate membership.'\n\n\nTop Atlas:\n'documentId': '59c6dfa238c69ebd748cc7dc'\n'chunk_id': '69038857a7bbb00013e754e7'\n'access': 'restricted'\n'part_number': 1\n'total_parts': 1\n'contentType': 'RHEINGOLD'\n'title': Angular Signals: Neue Features für die reaktive Entwicklung\n'parentName': JavaScript Days Berlin und online 2025\n'language': 'DE'\n'date': '2025-10-22T11:30:00.000Z'\n'abstract': Angular Signals sind seit einiger Zeit ein spannender Bestandteil der reaktiven Entwicklung in Angular. Mit neuen Features wie linkedSignal() und resource() in Angular 20 rücken sie weiter in den Fokus. Doch wie funktionieren Signals und was macht sie so besonders – insbesondere in Bezug auf die Performance? Welche Vorteile bieten sie gegenüber klassischen RxJS-Patterns? Felix Schütz von Thinktecture gibt eine praxisnahe Einführung in Angular Signals und die damit verbundenen neuen Features und zeigt, wie sie die Entwicklung von modernen, reaktiven Anwendungen nachhaltig verändern. Zusätzlich gibt er einen Ausblick auf die geplante Unterstützung von Signal-basierten Formularen.\n'parentId': 'a233287a238c6e0ce3f91546'\n'parentDescription': 40 Workshops zu JavaScript, Angular, React, Typescript und KI\n'indexBrandName': 'JavaScriptDays'\n'indexSeriesName': 'Berlin'\n'author': 'Felix Wunderlich'\n'chunkSource': 'text'\n'text': Angular Signals: Neue Features für die reaktive Entwicklung Angular Signals sind seit einiger Zeit ein spannender Bestandteil der reaktiven Entwicklung in Angular. Mit neuen Features wie linkedSignal() und resource() in Angular 20 rücken sie weiter in den Fokus. Doch wie funktionieren Signals und was macht sie so besonders – insbesondere in Bezug auf die Performance? Welche Vorteile bieten sie gegenüber klassischen RxJS-Patterns? Felix Schütz von Thinktecture gibt eine praxisnahe Einführung in Angular Signals und die damit verbundenen neuen Features und zeigt, wie sie die Entwicklung von modernen, reaktiven Anwendungen nachhaltig verändern. Zusätzlich gibt er einen Ausblick auf die geplante Unterstützung von Signal-basierten Formularen.\n'slidetext': ''\n'from': 'index'\n'score': 69.1158676147461\n'normalizedScore': 0.691158676147461\n'beforeDatePenaltyScore': 0.691158676147461\n\n'documentId': '01a63ca630515849aaa314b1'\n'chunk_id': '6876e25c51ca701363239b74'\n'access': 'restricted'\n'part_number': 1\n'total_parts': 1\n'contentType': 'RHEINGOLD'\n'title': Angular Signals: Neue Features für die reaktive Entwicklung\n'parentName': JavaScript Days München und online 2025\n'language': 'DE'\n'date': '2025-03-19T12:30:00.000Z'\n'abstract': Angular Signals sind seit einiger Zeit ein spannender Bestandteil der reaktiven Entwicklung in Angular. Mit neuen Features wie linkedSignal() und resource() in Angular 19 rücken sie weiter in den Fokus. Doch wie funktionieren Signals und was macht sie so besonders – insbesondere in Bezug auf die Performance? Welche Vorteile bieten sie gegenüber klassischen RxJS-Patterns?Felix Schütz von Thinktecture gibt eine praxisnahe Einführung in Angular Signals und die damit verbundenen neuen Features und zeigt, wie sie die Entwicklung von modernen, reaktiven Anwendungen nachhaltig verändern. Zusätzlich gibt er einen Ausblick auf die geplante Unterstützung von Signal-basierten Formularen.\n'parentId': 'efd4ff41c4b9e889b50854b8'\n'parentDescription': 40 Workshops zu JavaScript, Angular, React, HTML & CSS und KI\n'indexBrandName': 'JavaScriptDays'\n'indexSeriesName': 'Munich'\n'author': 'Felix Schütz'\n'chunkSource': 'text'\n'text': Angular Signals: Neue Features für die reaktive Entwicklung Angular Signals sind seit einiger Zeit ein spannender Bestandteil der reaktiven Entwicklung in Angular. Mit neuen Features wie linkedSignal() und resource() in Angular 19 rücken sie weiter in den Fokus. Doch wie funktionieren Signals und was macht sie so besonders – insbesondere in Bezug auf die Performance? Welche Vorteile bieten sie gegenüber klassischen RxJS-Patterns?Felix Schütz von Thinktecture gibt eine praxisnahe Einführung in Angular Signals und die damit verbundenen neuen Features und zeigt, wie sie die Entwicklung von modernen, reaktiven Anwendungen nachhaltig verändern. Zusätzlich gibt er einen Ausblick auf die geplante Unterstützung von Signal-basierten Formularen.\n'slidetext': ''\n'from': 'index'\n'score': 69.0760498046875\n'normalizedScore': 0.690760498046875\n'beforeDatePenaltyScore': 0.690760498046875\n\n'documentId': 'cfe389e23ed61a9ae7f11b32'\n'chunk_id': '68ac830f494be90012217e60'\n'access': 'restricted'\n'part_number': 1\n'total_parts': 1\n'contentType': 'RHEINGOLD'\n'title': Modern Angular Workshop: Architektur und Features\n'parentName': BASTA! Spring 2025\n'language': 'DE'\n'date': '2025-03-07T08:00:00.000Z'\n'abstract': Lernen Sie langfristig wartbare Enterprise-Lösungen mit modernem Angular zu entwerfen! In diesem Workshop tauchen Sie tief in die neuesten Angular-Features ein, um moderne, wartbare Anwendungsarchitekturen zu entwickeln. Lernen Sie, wie Sie Standalone Components nutzen, neue Modularisierungsansätze mit Nx und Sheriff anwenden, und erfahren Sie mehr über die aktualisierten APIs für HttpClient und Router. Entdecken Sie neue Built-in Control Flow Blocks, Signals für verbesserte Change Detection und den Signal Store für effektives State-Management.\n'parentId': '577ff41c05af8176bbd0043d'\n'parentDescription': Die Konferenz für .NET, Web & AI Innovation\n'indexBrandName': 'BASTA!'\n'indexSeriesName': 'Spring'\n'author': 'Manfred Steyer,Rainer Hahnekamp'\n'chunkSource': 'text'\n'text': Modern Angular Workshop: Architektur und Features Lernen Sie langfristig wartbare Enterprise-Lösungen mit modernem Angular zu entwerfen! In diesem Workshop tauchen Sie tief in die neuesten Angular-Features ein, um moderne, wartbare Anwendungsarchitekturen zu entwickeln. Lernen Sie, wie Sie Standalone Components nutzen, neue Modularisierungsansätze mit Nx und Sheriff anwenden, und erfahren Sie mehr über die aktualisierten APIs für HttpClient und Router. Entdecken Sie neue Built-in Control Flow Blocks, Signals für verbesserte Change Detection und den Signal Store für effektives State-Management.\n'slidetext': ''\n'from': 'index'\n'score': 64.29460144042969\n'normalizedScore': 0.6429460144042969\n'beforeDatePenaltyScore': 0.6429460144042969\n\n'documentId': '1c2d0d1ddbcc6e6469e58943'\n'chunk_id': '68beca605b3acf00130227a3'\n'access': 'granted'\n'part_number': 1\n'total_parts': 9\n'contentType': 'READ'\n'title': Angular 19: Incremental Hydration, Hybrid Rendering und Signals - Kolumne: Enterprise Angular\n'parentName': iJS Magazin 1.2025\n'language': 'DE'\n'date': '2025-01-29T23:00:00.000Z'\n'abstract': Mit Version 19 bringt Angular zwei wichtige Features, die unsere Anwendungen performanter machen: Incremental Hydration und Hybrid Rendering. Daneben erhält das Framework weitere Möglichkeiten rund um Signals.\n'parentId': 'fda1be46c7e3c0a30654c08a'\n'parentDescription': Kaum ein Softwareprojekt, das nicht in wesentlichen Teilen auf der JavaScript-Technologie basiert. Eine breite Unterstützung sowie, leistungsfähige Programmiersprachen, die Vielzahl moderner Tools, sowie ausgereifte Frameworks wie Angular, React, Vue.js oder Node.js machen den JavaScript-Werkzeugkasten zu einem Alleskönner. Das iJS Magazin informiert aktuell und umfassend über die wichtige und innovative Entwicklungen im JavaScript-Universum und bietet handfeste Praxisinformationen für Softwareentwickler und -architekten.\n'indexBrandName': ''\n'indexSeriesName': ''\n'author': 'Manfred Steyer'\n'chunkSource': 'text'\n'text': Angular 19: Incremental Hydration, Hybrid Rendering und Signals Kolumne: Enterprise Angular Mit Version 19 bringt Angular zwei wichtige Features, die unsere Anwendungen performanter machen: Incremental Hydration und Hybrid Rendering. Daneben erhält das Framework weitere Möglichkeiten rund um Signals. Mit Version 19 bringt Angular zwei wichtige Features, die unsere Anwendungen performanter machen: Incremental Hydration und Hybrid Rendering. Daneben erhält das Framework weitere Möglichkeiten rund um Signals. In diesem Artikel gehe ich auf diese Neuerungen ein und bespreche zusätzlich ein paar weitere, kleinere Abrundungen. Der für die Beispiele verwendeten Quellcode findet sich unter [1] im Branch 21-ng19. Incremental Hydration Um den Initial Page Load zu beschleunigen, rendern moderne JavaScript-Frameworks die angeforderte Seite zunächst serverseitig. Somit erhält der Browser bereits HTML mit nützlichen Informationen, die er augenblicklich anzeigen kann. Benutzer:innen müssen also nicht warten, bis auch noch die einzelnen JavaScript Bundles geladen sind. Diese Vorgehensweise nennt sich Server-side Rendering (SSR) und ist so weit nichts neues (Kasten: „Standardmäßige Event Replay“). Neu in Angular ist jedoch die sogenannte Incremental Hydration, die die Bundles erst bei Bedarf – so spät wie möglich, idealerweise gar nicht – anfordert. Dadurch werden die wirklich wichtigen Seitenteile schneller geladen und interaktiv. Man sagt auch, sie werden hydriert. Zur Veranschaulichung des Fortschrittes der Hydrierung färbt die hier verwendete Beispielanwendung die noch nicht hydrierten Anwendungsteile grau ein. Die hydrierten Teile stellt sie hingegen in Farbe dar (Abb. 1). Abb. 1: Incremental Hydration Standardmäßige Event Replay Beim Einsatz von SSR kann es vorkommen, dass Benutzer:innen mit Seitenteilen interagieren, bevor das entsprechende Bundle geladen wurde. Damit die Interaktionen nicht ins Leere laufen, integriert Angular in die auf dem Server gerenderte HTML-Seite ein wenig JavaScript-Code, der die einzelnen Events aufzeichnet und später, nach dem Hydrieren, wieder abspielt. Diese mit Angular 18 eingeführte Event Replay ist nun standardmäßig für sämtliche SSR-Anwendungen aktiviert. Incremental Hydration lässt sich bei einer SSR-Anwendung in der app.config.ts mit dem Feature withIncrementalHydration aktivieren (Listing 1). Listing 1 export const appConfig: ApplicationConfig = { providers: [ [...] provideClientHydration( withIncrementalHydration(), ) ], };\n'slidetext': ''\n'from': 'index'\n'score': 63.3150634765625\n'normalizedScore': 0.633150634765625\n'beforeDatePenaltyScore': 0.633150634765625\n\n'documentId': '1c2d0d1ddbcc6e6469e58943'\n'chunk_id': '68beca615b3acf00130227ab'\n'access': 'granted'\n'part_number': 9\n'total_parts': 9\n'contentType': 'READ'\n'title': Angular 19: Incremental Hydration, Hybrid Rendering und Signals - Kolumne: Enterprise Angular\n'parentName': iJS Magazin 1.2025\n'language': 'DE'\n'date': '2025-01-29T23:00:00.000Z'\n'abstract': Mit Version 19 bringt Angular zwei wichtige Features, die unsere Anwendungen performanter machen: Incremental Hydration und Hybrid Rendering. Daneben erhält das Framework weitere Möglichkeiten rund um Signals.\n'parentId': 'fda1be46c7e3c0a30654c08a'\n'parentDescription': Kaum ein Softwareprojekt, das nicht in wesentlichen Teilen auf der JavaScript-Technologie basiert. Eine breite Unterstützung sowie, leistungsfähige Programmiersprachen, die Vielzahl moderner Tools, sowie ausgereifte Frameworks wie Angular, React, Vue.js oder Node.js machen den JavaScript-Werkzeugkasten zu einem Alleskönner. Das iJS Magazin informiert aktuell und umfassend über die wichtige und innovative Entwicklungen im JavaScript-Universum und bietet handfeste Praxisinformationen für Softwareentwickler und -architekten.\n'indexBrandName': ''\n'indexSeriesName': ''\n'author': 'Manfred Steyer'\n'chunkSource': 'text'\n'text': aktuelle Anwendungszustand bleibt erhalten. Durch Setzen einer Umgebungsvariablen bietet ng serve dieses Verhalten auch für Templates: NG_HMR_TEMPLATES=1 ng serve Zusammenfassung Mit Incremental Hydration und Hybrid Rendering greift Angular zwei moderne Features auf, die sich mittlerweile auch in anderen, teils jüngeren Frameworks wiederfinden. Damit beweist Angular ein weiteres Mal, dass es in der Lage ist, sich von innen heraus zu erneuern, um langfristig relevant zu bleiben. Das neue Resource API und Linked Signals sind wichtige Ergänzungen und geben einen guten Vorgeschmack darauf, wie sich künftig reaktives Angular mit Signals anfühlen wird. Links & Literatur [1] https://github.com/manfredsteyer/desserts.git [2] https://angular.dev/guide/incremental-hydration\n'slidetext': ''\n'from': 'index'\n'score': 62.180355072021484\n'normalizedScore': 0.6218035507202149\n'beforeDatePenaltyScore': 0.6218035507202149\n\n'documentId': '1c2d0d1ddbcc6e6469e58943'\n'chunk_id': '68beca615b3acf00130227aa'\n'access': 'granted'\n'part_number': 8\n'total_parts': 9\n'contentType': 'READ'\n'title': Angular 19: Incremental Hydration, Hybrid Rendering und Signals - Kolumne: Enterprise Angular\n'parentName': iJS Magazin 1.2025\n'language': 'DE'\n'date': '2025-01-29T23:00:00.000Z'\n'abstract': Mit Version 19 bringt Angular zwei wichtige Features, die unsere Anwendungen performanter machen: Incremental Hydration und Hybrid Rendering. Daneben erhält das Framework weitere Möglichkeiten rund um Signals.\n'parentId': 'fda1be46c7e3c0a30654c08a'\n'parentDescription': Kaum ein Softwareprojekt, das nicht in wesentlichen Teilen auf der JavaScript-Technologie basiert. Eine breite Unterstützung sowie, leistungsfähige Programmiersprachen, die Vielzahl moderner Tools, sowie ausgereifte Frameworks wie Angular, React, Vue.js oder Node.js machen den JavaScript-Werkzeugkasten zu einem Alleskönner. Das iJS Magazin informiert aktuell und umfassend über die wichtige und innovative Entwicklungen im JavaScript-Universum und bietet handfeste Praxisinformationen für Softwareentwickler und -architekten.\n'indexBrandName': ''\n'indexSeriesName': ''\n'author': 'Manfred Steyer'\n'chunkSource': 'text'\n'text': providers: [ [...], provideAppInitializer(() => { console.log('init application'); // return Promise.resolve(); return of(); }) ], }; Die hinterlegte Funktion liefert entweder void, ein Promise oder ein Observable. In den letzteren beiden Fällen verzögert der Initializer den Anwendungsstart bis das Promise oder das Observable einen Wert liefern. Platform Initializer lassen sich mit providePlatformInitializer auf dieselbe Weise einrichten, wobei sie im Anwendungscode in der Regel nicht zum Einsatz kommen. Auch die Funktion provideEnvironmentInitializer zum Einrichten von Environment Initializer lässt sich analog nutzen. Sie kommt in der Regel in Routingkonfigurationen zum Einsatz, um Provider für eine bestimmte Route und deren Child-Routen festzulegen. Automatische Migrationen Um automatisiert auf die Features der modernen Angular-Versionen zu migrieren, führt Angular 19 einige Schematics ein, die sich wie folgt anstoßen lassen: ng g @angular/core:inject-migration ng g @angular/core:route-lazy-loading ng g @angular/core:signal-input-migration ng g @angular/core:output-migration ng g @angular/core:signal-queries-migration Der erste Schematic überführt Constructor Injection in Property Injection mit der inject-Funktion. Der zweite konfiguriert für Routen, die auf Standalone Components verweisen, Lazy Loading mittels loadComponent. Die restlichen drei Schematics ersetzen @Input, @Output sowie @ContentChild(ren) und @ViewChild(ren) durch ihre modernen Signal-basierten Gegenstücke. Weitere Aktualisierungen Neben den besprochenen größeren Neuerungen kommt Angular 19 auch mit einigen kleineren Abrundungen. Nachfolgend eine Auswahl davon: - Die Eigenschaft standalone bei Komponenten, Direktiven und Pipes ist standardmäßig true. Möchte eine Anwendung diese Building Blocks nach wie vor über Angular-Module bereitstellen, muss sie standalone explizit auf false setzen. Ein Schematic kümmert sich im Rahmen von ng update darum. - Die angularCompilerOptions in der tsconfig.json haben ein Flag strictStandalone. Setzt man es auf true, liefert die CLI beim Einsatz von standalone: false eine Fehlermeldung. - Der Angular Language Service liefert eine Warnung, wenn das imports-Array einer Standalone Component einen Building Block enthält, der im Template nicht zum Einsatz kommt. - @let ist als produktionsreif eingestuft. - Templates unterstützen den Einsatz des JavaScript-Operators typeof. - Hot Module Replacement (HMR) ist standardmäßig für Styles aktiviert. Nach einer Änderung einer Stylesheet-Datei patcht ng serve die Styles im Browser, ohne die Seite neu zu laden. Der aktuelle\n'slidetext': ''\n'from': 'index'\n'score': 61.927032470703125\n'normalizedScore': 0.6192703247070312\n'beforeDatePenaltyScore': 0.6192703247070312\n\n'documentId': '1c2d0d1ddbcc6e6469e58943'\n'chunk_id': '68beca605b3acf00130227a5'\n'access': 'granted'\n'part_number': 3\n'total_parts': 9\n'contentType': 'READ'\n'title': Angular 19: Incremental Hydration, Hybrid Rendering und Signals - Kolumne: Enterprise Angular\n'parentName': iJS Magazin 1.2025\n'language': 'DE'\n'date': '2025-01-29T23:00:00.000Z'\n'abstract': Mit Version 19 bringt Angular zwei wichtige Features, die unsere Anwendungen performanter machen: Incremental Hydration und Hybrid Rendering. Daneben erhält das Framework weitere Möglichkeiten rund um Signals.\n'parentId': 'fda1be46c7e3c0a30654c08a'\n'parentDescription': Kaum ein Softwareprojekt, das nicht in wesentlichen Teilen auf der JavaScript-Technologie basiert. Eine breite Unterstützung sowie, leistungsfähige Programmiersprachen, die Vielzahl moderner Tools, sowie ausgereifte Frameworks wie Angular, React, Vue.js oder Node.js machen den JavaScript-Werkzeugkasten zu einem Alleskönner. Das iJS Magazin informiert aktuell und umfassend über die wichtige und innovative Entwicklungen im JavaScript-Universum und bietet handfeste Praxisinformationen für Softwareentwickler und -architekten.\n'indexBrandName': ''\n'indexSeriesName': ''\n'author': 'Manfred Steyer'\n'chunkSource': 'text'\n'text': lässt sich mit einem Schematic automatisieren. Beim Aktivieren von SSR sowie beim Erzeugen einer neuen Angular-Anwendung ist dazu die Server-Routing-Option zu aktivieren (Abb. 2). Abb. 2: Server Routing (Hybrid Rendering) aktivieren Die serverseitige Routenkonfiguration legt für ausgewählte Pfade einen RenderMode fest (Listing 3). Listing 3 export const serverRoutes: ServerRoute[] = [ { path: 'desserts', renderMode: RenderMode.Server }, { path: 'desserts/:id', renderMode: RenderMode.Server }, { path: '**', renderMode: RenderMode.Prerender } ]; Für alle hier nicht erwähnten Pfade kommt die Einstellung in der Catch-All-Route (path: '**') zu tragen. RenderMode bietet die folgenden drei Einstellungen an: - RenderMode.Server - RenderMode.Prerender - RenderMode.Client Auch hier ist wichtig zu beachten, dass sich die Optionen Server und Prerender nur auf das initiale Rendering auswirken. Danach führt Angular die Anwendung clientseitig aus. Direkt mit HTTP Request und HTTP Response arbeiten Bei Routen, die auf dem Server gerendert werden, kann die Anwendung nun die HTTP Response beeinflussen. Dazu lassen sich in der serverseitigen Routenkonfiguration Kopfzeilen und der gewünschte Statuscode angeben (Listing 4). Listing 4 { path: 'desserts', renderMode: RenderMode.Server, headers: { 'X-Secret': 'Manfred was here!', }, status: 201, statusText: 'CREATED' }, Etwas komfortabler ist das programmatische Interagieren mit HTTP. Die Tokens REQUEST und REQUEST_CONTEXT liefern Informationen über die Anfrage und das Token RESPONSE_INIT erlaubt es, die Antwort zu beeinflussen (Listing 5). Listing 5 @Component({ selector: 'app-root', templateUrl: './app.component.html', styleUrl: './app.component.css', imports: [RouterOutlet, RouterLink, ToastComponent, ToastComponent], }) export class AppComponent { request = inject(REQUEST); requestContext = inject(REQUEST_CONTEXT); responseInit = inject(RESPONSE_INIT); constructor() { if (this.request) { console.log('url', this.request.url); console.log('lang', this.request.headers.get('accept-language')); } if (this.responseInit) { this.responseInit.status = 201; } const headers = this.responseInit?.headers as Headers; if (headers) { headers.append('X-Secret', 'Manfred was here!'); } } } Beim REQUEST_CONTEXT handelt es sich um ein optionales Objekt, mit dem der Server Kontextinformationen, z. B. die aktuelle Benutzersitzung oder Daten über angemeldete Benutzer:innen, liefert. Da diese Objekte lediglich beim Einsatz von SSR zur Verfügung stehen, sollte sich die Anwendung vor dem Zugriff vergewissern, dass sie nicht null sind. Prerendering von Routen mit\n'slidetext': ''\n'from': 'index'\n'score': 60.98884582519531\n'normalizedScore': 0.6098884582519531\n'beforeDatePenaltyScore': 0.6098884582519531\n\n'documentId': '1c2d0d1ddbcc6e6469e58943'\n'chunk_id': '68beca605b3acf00130227a6'\n'access': 'granted'\n'part_number': 4\n'total_parts': 9\n'contentType': 'READ'\n'title': Angular 19: Incremental Hydration, Hybrid Rendering und Signals - Kolumne: Enterprise Angular\n'parentName': iJS Magazin 1.2025\n'language': 'DE'\n'date': '2025-01-29T23:00:00.000Z'\n'abstract': Mit Version 19 bringt Angular zwei wichtige Features, die unsere Anwendungen performanter machen: Incremental Hydration und Hybrid Rendering. Daneben erhält das Framework weitere Möglichkeiten rund um Signals.\n'parentId': 'fda1be46c7e3c0a30654c08a'\n'parentDescription': Kaum ein Softwareprojekt, das nicht in wesentlichen Teilen auf der JavaScript-Technologie basiert. Eine breite Unterstützung sowie, leistungsfähige Programmiersprachen, die Vielzahl moderner Tools, sowie ausgereifte Frameworks wie Angular, React, Vue.js oder Node.js machen den JavaScript-Werkzeugkasten zu einem Alleskönner. Das iJS Magazin informiert aktuell und umfassend über die wichtige und innovative Entwicklungen im JavaScript-Universum und bietet handfeste Praxisinformationen für Softwareentwickler und -architekten.\n'indexBrandName': ''\n'indexSeriesName': ''\n'author': 'Manfred Steyer'\n'chunkSource': 'text'\n'text': mit Parametern Da das Prerendering bereits beim Build statische HTML-Dateien erzeugt, müssen die möglichen Werte für Routenparameter bekannt sein. In der Vergangenheit konnte man die zu generierten Routen samt Parameter über eine Textdatei bereitstellen. Ab Angular 19 lässt sich das eleganter durch das Festlegen einer Methode getPrerenderParams in der serverseitigen Routenkonfiguration bewerkstelligen (Listing 6). Listing 6 export const serverRoutes: ServerRoute[] = [ { path: 'desserts/:id', renderMode: RenderMode.Prerender, async getPrerenderParams() { const dessertService = inject(DessertService); const ids = await dessertService.findIdsPromise(); return ids.map((id) => ({ id: String(id) })); }, fallback: PrerenderFallback.Client }, { path: '**', renderMode: RenderMode.Prerender, }, ]; Diese asynchrone Methode liefert ein Array vom Typ Record. Die Records enthalten jeweils eine mögliche Parameterkombination. Für jeden Eintrag in diesem Array generiert die Angular CLI eine statische Datei. Die Einstellung fallback kommt zu tragen, wenn zur Laufzeit eine vorgerenderte Route nicht vorliegt. Beispielsweise könnte ein Hyperlink desserts/17 anfordern, obwohl die ID 17 beim Prerendering gar nicht bekannt war. Je nach Einstellung von fallback ergeben sich nun drei mögliche Verhalten: - PrerenderFallback.Client: Die Anwendung rendert die angeforderte Route clientseitig. - PrerenderFallback.Server: Die Anwendung rendert die angeforderte Route serverseitig, hierbei handelt es sich um die Standardeinstellung. - PrerenderFallback.None: Die Anwendung beantwortet die Anfrage nicht. App Shell mit Prerendering In manchen Fällen reicht es schon aus, wenn das Grundgerüst der Anwendung schnell sichtbar ist. Deswegen unterstützt Angular bereits seit einigen Jahren das aus der PWA-Welt bekannte App-Shell-Muster. Die Idee ist, das Grundgerüst der Anwendung in die index.html der Anwendung zu rendern. Auch diese Option lässt sich mit der neuen API für das Hybrid Rendering nutzen. Dazu ist lediglich der Pfad jener Route, die für die App Shell zu nutzen ist, in der Datei app.config.server.ts an provideServerRoutesConfig zu übergeben: provideServerRoutesConfig(serverRoutes, { appShellRoute: 'shell' }) Dabei kann es sich auch um eine sonst nicht direkt über die Navigation erreichbare Route handeln, die speziell für das Prerendering der App Shell eingerichtet wurde. Resource API Bis jetzt konnte man mit Signals nicht direkt im reaktiven Datenfluss\n'slidetext': ''\n'from': 'index'\n'score': 60.4759407043457\n'normalizedScore': 0.604759407043457\n'beforeDatePenaltyScore': 0.604759407043457\n\n'documentId': '1c2d0d1ddbcc6e6469e58943'\n'chunk_id': '68beca605b3acf00130227a4'\n'access': 'granted'\n'part_number': 2\n'total_parts': 9\n'contentType': 'READ'\n'title': Angular 19: Incremental Hydration, Hybrid Rendering und Signals - Kolumne: Enterprise Angular\n'parentName': iJS Magazin 1.2025\n'language': 'DE'\n'date': '2025-01-29T23:00:00.000Z'\n'abstract': Mit Version 19 bringt Angular zwei wichtige Features, die unsere Anwendungen performanter machen: Incremental Hydration und Hybrid Rendering. Daneben erhält das Framework weitere Möglichkeiten rund um Signals.\n'parentId': 'fda1be46c7e3c0a30654c08a'\n'parentDescription': Kaum ein Softwareprojekt, das nicht in wesentlichen Teilen auf der JavaScript-Technologie basiert. Eine breite Unterstützung sowie, leistungsfähige Programmiersprachen, die Vielzahl moderner Tools, sowie ausgereifte Frameworks wie Angular, React, Vue.js oder Node.js machen den JavaScript-Werkzeugkasten zu einem Alleskönner. Das iJS Magazin informiert aktuell und umfassend über die wichtige und innovative Entwicklungen im JavaScript-Universum und bietet handfeste Praxisinformationen für Softwareentwickler und -architekten.\n'indexBrandName': ''\n'indexSeriesName': ''\n'author': 'Manfred Steyer'\n'chunkSource': 'text'\n'text': }; Jene Seitenteile, die die Anwendung erst bei Bedarf hydrieren sollen, sind mit einem @defer-Block zu kennzeichnen. Die neue von @defer unterstützte Klausel hydrate legt fest, wann die Hydrierung erfolgen soll (Listing 2). Listing 2 @for (dessert of ratedDesserts(); track dessert.id) { @defer(hydrate on interaction) {  } } Die Einstellung hydrate on interaction legt fest, dass Angular diesen Bereich erst dann zum Leben erweckt, wenn Benutzer:innen mit ihm interagieren – zum Beispiel das Rating verändern. Daneben listet die Angular-Dokumentation [2] noch zahlreiche weitere Optionen, um den Zeitpunkt der Hydrierung festzulegen: - hydrate on idle: Wird ausgelöst, wenn der Browser im Leerlauf ist. - hydrate on viewport: Wird ausgelöst, wenn der angegebene Inhalt in den sichtbaren Bereich (Viewport) gescrollt wird. - hydrate on interaction: Wird ausgelöst, wenn Nutzer:innen mit dem angegebenen Element interagieren. - hydrate on hover: Wird ausgelöst, wenn sich die Maus über dem angegebenen Bereich befindet. - hydrate on immediate: Wird sofort gerendert, Seitenbereiche außerhalb von @defer haben jedoch Vorrang. - hydrate on timer: Wird nach einer festgelegten Zeitspanne ausgelöst (z. B. hydrate on timer(500ms)). - hydrate when [condition]: Wird ausgelöst, wenn die angegebene Bedingung erfüllt ist (z. B. hydrate when userName !=== null). - hydrate never: Es erfolgt keine Hydration, selbst verschachtelte @defer-Blöcke werden nicht hydriert. Vor dem Hydrieren nutzt @defer das serverseitig gerenderte Markup als Platzhalter. Allerdings wirkt sich die Hydrate-Klausel nur auf das initiale Rendering aus. Wechseln Benutzer:innen zum Beispiel auf eine neue Route, rendert Angular diese ausschließlich auf der Clientseite und somit erfolgt keine Incremental Hydration. Hybrid Rendering Mit dem neuen Hydrid Rendering kann man nun pro Route entscheiden, ob SSR, ein Prerendering beim Build oder lediglich clientseitiges Rendering (CSR) zum Einsatz kommen soll. Dazu legt die Anwendung zusätzlich zur klassischen Routenkonfiguration eine serverseitige Konfiguration fest. Letztere ist in der app.config.server.ts an provideServerRoutesConfig zu übergeben: const serverConfig: ApplicationConfig = { providers: [ provideServerRendering(), provideServerRoutesConfig(serverRoutes) ] }; Dieser Schritt lässt\n'slidetext': ''\n'from': 'index'\n'score': 60.4759407043457\n'normalizedScore': 0.604759407043457\n'beforeDatePenaltyScore': 0.604759407043457\n\n'documentId': '1c2d0d1ddbcc6e6469e58943'\n'chunk_id': '68beca605b3acf00130227a8'\n'access': 'granted'\n'part_number': 6\n'total_parts': 9\n'contentType': 'READ'\n'title': Angular 19: Incremental Hydration, Hybrid Rendering und Signals - Kolumne: Enterprise Angular\n'parentName': iJS Magazin 1.2025\n'language': 'DE'\n'date': '2025-01-29T23:00:00.000Z'\n'abstract': Mit Version 19 bringt Angular zwei wichtige Features, die unsere Anwendungen performanter machen: Incremental Hydration und Hybrid Rendering. Daneben erhält das Framework weitere Möglichkeiten rund um Signals.\n'parentId': 'fda1be46c7e3c0a30654c08a'\n'parentDescription': Kaum ein Softwareprojekt, das nicht in wesentlichen Teilen auf der JavaScript-Technologie basiert. Eine breite Unterstützung sowie, leistungsfähige Programmiersprachen, die Vielzahl moderner Tools, sowie ausgereifte Frameworks wie Angular, React, Vue.js oder Node.js machen den JavaScript-Werkzeugkasten zu einem Alleskönner. Das iJS Magazin informiert aktuell und umfassend über die wichtige und innovative Entwicklungen im JavaScript-Universum und bietet handfeste Praxisinformationen für Softwareentwickler und -architekten.\n'indexBrandName': ''\n'indexSeriesName': ''\n'author': 'Manfred Steyer'\n'chunkSource': 'text'\n'text': mehrfach hintereinander die Suchkriterien ändern. In diesem Fall soll die Anwendung lediglich das zum letzten Suchkriterium passende Ergebnis präsentieren. Kurz aufblitzende Zwischenergebnisse wären hingegen verwirrend. Um ein solches Verhalten zu vermeiden, verwirft das Resource API die erhaltenen Ergebnisse, wenn bereits eine weitere Anfrage läuft. Das Resource API signalisiert einer im Loader aufgerufenen Operation sogar, dass sie nicht mehr benötigt wird und abgebrochen werden kann. Dazu enthält das an den Loader übergebene Parameterobjekt ein AbortSignal. Die aufgerufene Operation kann auf dieses AbortSignal horchen und bei einer Benachrichtigung die Ausführung einstellen. Es liegt am Loader sowie an der aufgerufenen Operation, diese Möglichkeit zu nutzen. Da das Resource API unnötige Ergebnisse ignoriert, dient diese Option lediglich der Performanceoptimierung, die sich besonders bei aufwendigen Aufgaben anbietet. rxResource: Resource für RxJS Wenn die Anwendung bereits Observables nutzt, müssen diese nicht manuell in Promises umgewandelt werden. Stattdessen lässt sich das API rxResource aus @angular/core/rxjs-interop verwenden. Es funktioniert wie resource, allerdings liefert der Loader ein Observable. Listing 8 dessertsResource = rxResource({ request: this.dessertsCriteria, loader: (param) => { return timer(300).pipe( switchMap(() => this.#dessertService.find(param.request))); } }); Der Loader der rxResource bekommt kein AbortSignal, da Observables direkt durch implizites oder explizites Abmelden abgebrochen werden können. Es ist wichtig zu wissen, dass die aktuelle Implementierung von rxResource nur den ersten empfangenen Wert aus dem Observable verwendet. Intern nutzt sie firstValueFrom, um das Observable in ein Promise umzuwandeln. Dieses Promise übergibt sie danach an resource. Während dieses Verhalten für HTTP-Aufrufe in Ordnung ist, führt es zu Überraschungen, wenn mehrere Werte über einen Stream empfangen werden, z. B. beim Einsatz von WebSockets. Im letzteren Fall sollte die Anwendung die Observables auf klassische Weise nutzen. Linked Signals Eine weitere Neuerung, die ab Angular 19 als Developer Preview vorliegt, sind die sogenannten Linked Signals. Auf dem ersten Blick wirken sie wie ein berechnetes Signal. Allerdings sind berechnete Signals read-only. Linked Signals haben jedoch eine veränderbare Arbeitskopie. Deswegen bieten sich Linked Signals an, um berechnete Werte oder read-only Zustände an Template-driven Forms zu binden. Das Beispiel\n'slidetext': ''\n'from': 'index'\n'score': 60.190425872802734\n'normalizedScore': 0.6019042587280273\n'beforeDatePenaltyScore': 0.6019042587280273\n\n'documentId': '43b7900e7154d2f13c41085b'\n'chunk_id': '6876d2a1225e92fc1ac797f7'\n'access': 'granted'\n'part_number': 1\n'total_parts': 6\n'contentType': 'COURSE'\n'title': Exploring httpResource in Angular 19.2\n'parentName': Advanced Angular: Signals, NgRx & AI Forms\n'language': 'DE'\n'date': '2025-05-02T10:49:04.000Z'\n'abstract': The introduction of *httpResource* in Angular 19.2 brings a new way to load data seamlessly within the reactive flow. Let's explore how this experimental feature can be leveraged to enhance your applications.\n'parentId': '5e78d57fd77e42835f9996dc'\n'parentDescription': Level up your Angular skills with this advanced course, highlighting the framework’s evolving features. We will cover cutting-edge topics, from mastering state management with the NgRx Signal store and unlocking AI-enhanced forms’ potential, to revisiting the performance benefits of server-side rendering. You will learn how to effectively use Signals through professional tips and real-world insights, and explore emerging features like httpResource in Angular 19.2. Whether you are scaling enterprise apps or upgrading legacy codebases, this course equips you with the practices to build smarter, faster Angular applications and stay ahead in today’s Angular ecosystem.\n'indexBrandName': 'InternationalJavaScriptCon'\n'indexSeriesName': ''\n'author': 'Manfred Steyer'\n'chunkSource': 'text'\n'text': Exploring httpResource in Angular 19.2 The introduction of httpResource in Angular 19.2 brings a new way to load data seamlessly within the reactive flow. Let's explore how this experimental feature can be leveraged to enhance your applications. Angular 19.2 introduced the experimental httpResource feature, streamlining HTTP data loading within the reactive flow of applications. By leveraging signals, it simplifies asynchronous data fetching, providing developers with a more streamlined approach to handling HTTP requests. With Angular 20 on the horizon, this feature will evolve further, offering even more power for managing data in reactive applications. Let’s explore how to leverage httpResource to enhance your applications. As an example, we have a simple application that scrolls through levels in the style of the game Super Mario. Each level consists of tiles that are available in four different styles: overworld, underground, underwater, and castle. In our implementation, users can switch freely between these styles. Figure 1 shows the first level in overworld style, while Figure 2 shows the same level in underground style. Figure 1: Level 1 in overworld style Figure 2: Level 1 in the underground style A LevelComponent in the example application takes care of loading level files (JSON) and tiles for drawing the levels using an httpResource. To render and animate the levels, the example relies on a very simple engine that is included with the source code but is treated as a black box here in the article. HttpClient in the substructure enables the use of interceptors At its core, the new httpResource currently uses the good old HttpClient. Therefore, the application has to provide this service, which is usually done by calling provideHttpClient during bootstrapping. As a consequence, the httpResource also automatically picks up the registered HttpInterceptors. However, the HttpClient is just an implementation detail that Angular may eventually replace with a different implementation. Level files The different levels are described by our example JSON files, which define which tiles are to be displayed at which coordinates (Listing 1). Listing 1: { 'levelId': 1, 'backgroundColor': '#9494ff', 'items': [ { 'tileKey': 'floor', 'col': 0, 'row': 13, [...] }, { 'tileKey': 'cloud', 'col': 12, 'row': 1, [...] }, [...] ] } These coordinates define positions within a matrix of blocks measuring 16x16 pixels. An overview.json file is provided with these level files, which provides information about the names of the available levels. A LevelLoader takes care of loading these files. To do this, it uses the new httpResource (Listing 2). Listing 2: @Injectable({ providedIn: 'root' }) export class LevelLoader { getLevelOverviewResource():\n'slidetext': ''\n'from': 'index'\n'score': 60.01118469238281\n'normalizedScore': 0.6001118469238281\n'beforeDatePenaltyScore': 0.6001118469238281\n\n'documentId': '1c2d0d1ddbcc6e6469e58943'\n'chunk_id': '68beca605b3acf00130227a7'\n'access': 'granted'\n'part_number': 5\n'total_parts': 9\n'contentType': 'READ'\n'title': Angular 19: Incremental Hydration, Hybrid Rendering und Signals - Kolumne: Enterprise Angular\n'parentName': iJS Magazin 1.2025\n'language': 'DE'\n'date': '2025-01-29T23:00:00.000Z'\n'abstract': Mit Version 19 bringt Angular zwei wichtige Features, die unsere Anwendungen performanter machen: Incremental Hydration und Hybrid Rendering. Daneben erhält das Framework weitere Möglichkeiten rund um Signals.\n'parentId': 'fda1be46c7e3c0a30654c08a'\n'parentDescription': Kaum ein Softwareprojekt, das nicht in wesentlichen Teilen auf der JavaScript-Technologie basiert. Eine breite Unterstützung sowie, leistungsfähige Programmiersprachen, die Vielzahl moderner Tools, sowie ausgereifte Frameworks wie Angular, React, Vue.js oder Node.js machen den JavaScript-Werkzeugkasten zu einem Alleskönner. Das iJS Magazin informiert aktuell und umfassend über die wichtige und innovative Entwicklungen im JavaScript-Universum und bietet handfeste Praxisinformationen für Softwareentwickler und -architekten.\n'indexBrandName': ''\n'indexSeriesName': ''\n'author': 'Manfred Steyer'\n'chunkSource': 'text'\n'text': Datenfluss eine asynchrone Operation anstoßen. Gerade, aber nicht nur, für das Abrufen von Resourcen via HTTP ist diese Aufgabe jedoch essenziell. Das neue, vorerst als experimentell eingestufte Resource API ändert das. Jede damit definierte Resource repräsentiert eine asynchrone Aufgabe, die Daten liefert. Eine Resource hat eine Funktion loader, die ein Promise mit den geladenen Daten zurückgibt. Dieser Loader kommt unmittelbar nach der Initialisierung der Resource zum Einsatz. Zusätzlich kann die Resource ein request-Signal haben, das Parameter (Suchkriterien) für den Loader bereitstellt. Jedes Mal, wenn sich das request-Signal ändert, stößt die Resource den Loader erneut an (Listing 7). Listing 7 import { resource } from '@angular/core'; [...] @Component([...]) export class DessertsComponent { #dessertService = inject(DessertService); [...] // Criteria for search originalName = signal(''); englishName = signal(''); // Combine criteria to computed Signal dessertsCriteria = computed(() => ({ originalName: this.originalName(), englishName: this.englishName(), })); // Define resource with request (=search criteria) and loader // Every time, the request is changing, the loader is triggered dessertsResource = resource({ request: this.dessertsCriteria, loader: (param) => { return this.#dessertService.findPromise(param.request); } }); // Initially, resources are undefined desserts = computed(() => this.dessertsResource.value() ?? []); loading = this.dessertsResource.isLoading; error = this.dessertsResource.error; [...] } In diesem Beispiel verwendet dessertsResource die Werte in den Signals originalName und englishName als Parameter. Das an den Loader übergebene param-Objekt enthält die aktuellen Suchkriterien aus dem request Signal. Das Ergebnis der Resource findet sich in ihrem Signal value. Das berechnete desserts Signal ersetzt den initialen undefined-Wert durch ein leeres Array. Das Signal isLoaded informiert über den Ladezustand und error ist ein Signal mit einem möglichen Fehler, der während des Ladens aufgetreten ist. Trigger und Race Conditions Das Resource API hat zwei wichtige Eigenschaften, die es von der direkten Verwendung eines Effects abhebt: Zum einen verfolgt sie nur das request-Signal. Signals, die im Loader zum Einsatz kommen, triggern keinen erneuten Ladevorgang, wenn sie sich ändern. Somit sieht man auf dem ersten Blick, unter welchen Umständen die Resource ein erneutes Laden anstößt. Daneben verhindert das Resource API Probleme mit überlappenden Anfragen, wie z. B. Race Conditions. Diese können auftreten, wenn Benutzer:innen mehrfach\n'slidetext': ''\n'from': 'index'\n'score': 59.65107345581055\n'normalizedScore': 0.5965107345581054\n'beforeDatePenaltyScore': 0.5965107345581054\n\n'documentId': '1c2d0d1ddbcc6e6469e58943'\n'chunk_id': '68beca605b3acf00130227a9'\n'access': 'granted'\n'part_number': 7\n'total_parts': 9\n'contentType': 'READ'\n'title': Angular 19: Incremental Hydration, Hybrid Rendering und Signals - Kolumne: Enterprise Angular\n'parentName': iJS Magazin 1.2025\n'language': 'DE'\n'date': '2025-01-29T23:00:00.000Z'\n'abstract': Mit Version 19 bringt Angular zwei wichtige Features, die unsere Anwendungen performanter machen: Incremental Hydration und Hybrid Rendering. Daneben erhält das Framework weitere Möglichkeiten rund um Signals.\n'parentId': 'fda1be46c7e3c0a30654c08a'\n'parentDescription': Kaum ein Softwareprojekt, das nicht in wesentlichen Teilen auf der JavaScript-Technologie basiert. Eine breite Unterstützung sowie, leistungsfähige Programmiersprachen, die Vielzahl moderner Tools, sowie ausgereifte Frameworks wie Angular, React, Vue.js oder Node.js machen den JavaScript-Werkzeugkasten zu einem Alleskönner. Das iJS Magazin informiert aktuell und umfassend über die wichtige und innovative Entwicklungen im JavaScript-Universum und bietet handfeste Praxisinformationen für Softwareentwickler und -architekten.\n'indexBrandName': ''\n'indexSeriesName': ''\n'author': 'Manfred Steyer'\n'chunkSource': 'text'\n'text': Beispiel veranschaulicht das anhand eines read-only Signals loadedDessert, das von einem Store kommt. dessert = { originalName: linkedSignal(() => this.loadedDessert().originalName), englishName: linkedSignal(() => this.loadedDessert().englishName), kcal: linkedSignal(() => this.loadedDessert().kcal), rating: linkedSignal(() => this.loadedDessert().rating) }; Die hier eingerichteten Linked Signals lassen sich direkt mit ngModel binden:  Die Datenbindung schreibt in die lokale Arbeitskopie zurück, die die Anwendung später – beispielsweise beim Betätigen einer Schaltfläche – zum Store zurücksendet. Ändert sich der Quellwert im Store, überschreibt das Linked Signal die lokale Arbeitskopie damit. Die Anzeige bleibt also aktuell. Neben der einfachen Signatur, die an computed erinnert, bietet linkedSignal auch eine etwas komplexere, die Zugriff auf den vorherigen Wert gewährt: delta = linkedSignal({ source: () => this.loadedDessert().rating, computation: (current, previous) => (previous?.source ?? 0) - current }); Dieses Linked Signal nutzt als Quelle (source) das Rating des aktuellen Desserts. In der Berechnung (computation) berechnet es das Delta zum Rating des zuvor durch loadedDessert repräsentierten Objekts. Da beim ersten Aufruf der Parameter previous den Wert undefined aufweist, greift die Berechnung in diesem Fall auf 0 zurück. Der Parameter previous enthält zwei Eigenschaften: Die im besprochenen Beispiel verwendete Eigenschaft source liefert jenen Wert, den das darüber definierte source Signal zuvor gehabt hat. Die Eigenschaft value (hier nicht gezeigt) liefert hingegen den Wert, den die Berechnung zuletzt ergeben hat. Stabile Signal APIs Mit Angular 19 wurden auch zahlreiche Funktionen rund um Signals, die schon länger vorlagen, als produktionsreif eingestuft. Diese sind: - signal - computed - untracked - input - model - output - outputFromObservable - outputToObservable - viewChild und viewChildren - contentChild und contentChildren - takeUntilDestroy Somit spricht eigentlich nichts mehr gegen einen Einsatz dieser Mechanismen. Nach wie vor in der Developer Preview sind hingegen effect und das darauf basierende toObservable sowie sein Gegenstück toSignal. Weitere Aktualisierungen Für das Einrichten von App Initializer, Environment Initializer und Platform Initializer existieren nun Hilfsfunktionen. Listing 9 zeigt, wie sich damit ein App Initializer in der app.config.ts einrichten lässt. Listing 9 export const appConfig: ApplicationConfig = { providers:\n'slidetext': ''\n'from': 'index'\n'score': 59.605255126953125\n'normalizedScore': 0.5960525512695313\n'beforeDatePenaltyScore': 0.5960525512695313\n\n'documentId': '1fed2c6361980d606789e315'\n'chunk_id': '68c26fcc0a53cd001394ab93'\n'access': 'granted'\n'part_number': 3\n'total_parts': 8\n'contentType': 'READ'\n'title': Manfred Steyer on Angular 20: Signals, Dynamic Components, AI, and What’s Next - Exploring selectorless components, signal-based forms, and other features in Angular\n'parentName': iJS Magazine Volume 19\n'language': 'EN'\n'date': '2025-06-24T22:00:00.000Z'\n'abstract': In this interview, GDE Manfred Steyer highlights Angular’s journey towards a more reactive future. We discuss the framework’s strengths, challenges, and what’s ahead with the release of Angular 20.\n'parentId': 'a1269c65e87d5b8ebcde4b28'\n'parentDescription': Broaden your knowledge and expand your JavaScript techniques and practices. From Angular, React, and WebAssembly, to the best JavaScript IDEs, open source tools and more, you’ll learn insights on everything JS from seasoned experts in their field. Keep up with JavaScript news, tips, and advice with interviews, tutorials, and in-depth articles.\n'indexBrandName': ''\n'indexSeriesName': ''\n'author': 'Manfred Steyer'\n'chunkSource': 'text'\n'text': beta stages. Around that time, I also began consulting companies on adopting Angular 2. Ines Chargui: How would you describe the Angular journey? After everything that the framework went through, is it on the right track? Does it disappoint sometimes? Manfred Steyer: I think it's really on the right track. The Angular team has consistently proven that the underlying philosophy and the whole architecture pay off. It allows Angular to reinvent itself underneath the covers. We don't see a lot of those reinventions, but Angular manages to keep up with all of the innovations out there, at least all the ones important for single-page applications or web applications in general. Just one example: several years ago, they switched out the whole rendering engine for the new Ivy engine. That happened largely behind the scenes, with no major breaking changes, effectively giving us a modernized framework without the usual migration pain. Now, Angular is doing it again. NgModules are optional, zones are becoming optional, and we’re getting a new set of reactivity primitives with Signals. All of this works without breaking changes. Existing code continues to work, which is very important in enterprise environments, where applications are expected to be maintained for years or even decades. Reinvention without disruption is the theme behind Angular, and so far, it’s proven it can deliver on that promise. Ines Chargui: With the upcoming release of Angular 20 on May 28, 2025, what features or improvements are you most excited about exploring? Manfred Steyer: Well, the Signal story will evolve. Many building blocks, such as effects or the RxJS interop will become stable. The Resource API that fetches data within the reactive Signal-based flow will transition to developer preview. The same is the case for Incremental Hydration, Hybrid Routing, and Zone-less Change Detection. Ines Chargui: What do you think about these features in developer preview? Have you experimented with any of these? Manfred Steyer: Absolutely. I was an early adopter of the reactivity features like the Resource API and linked signals. For me, they have always been necessary, even though they were experimental, because they were filling a gap in Angular’s reactivity story. Without them, when working only with Signals, for instance, there is no way to do data fetching as part of the reactive flow. For this, we need resources and a brand new HTTP resource; the linked signal gives us a local working copy. For example, this is necessary when binding read-only data from a store into a template-driven form. Since forms need to update values, and read-only signals can’t be changed directly, linked\n'slidetext': ''\n'from': 'index'\n'score': 59.27711486816406\n'normalizedScore': 0.5927711486816406\n'beforeDatePenaltyScore': 0.5927711486816406\n\n'documentId': '1fed2c6361980d606789e315'\n'chunk_id': '68c26fcc0a53cd001394ab95'\n'access': 'granted'\n'part_number': 5\n'total_parts': 8\n'contentType': 'READ'\n'title': Manfred Steyer on Angular 20: Signals, Dynamic Components, AI, and What’s Next - Exploring selectorless components, signal-based forms, and other features in Angular\n'parentName': iJS Magazine Volume 19\n'language': 'EN'\n'date': '2025-06-24T22:00:00.000Z'\n'abstract': In this interview, GDE Manfred Steyer highlights Angular’s journey towards a more reactive future. We discuss the framework’s strengths, challenges, and what’s ahead with the release of Angular 20.\n'parentId': 'a1269c65e87d5b8ebcde4b28'\n'parentDescription': Broaden your knowledge and expand your JavaScript techniques and practices. From Angular, React, and WebAssembly, to the best JavaScript IDEs, open source tools and more, you’ll learn insights on everything JS from seasoned experts in their field. Keep up with JavaScript news, tips, and advice with interviews, tutorials, and in-depth articles.\n'indexBrandName': ''\n'indexSeriesName': ''\n'author': 'Manfred Steyer'\n'chunkSource': 'text'\n'text': deal because after the first load, the app is cached in the browser. For public websites, speed is very important. I think different frameworks are moving in the right direction by focusing on making it easier to build faster, more efficient public portals. The reactivity models these frameworks use can also help with things like postponing data loading. You don't want to delay the initial rendering, but you may choose to defer loading some data. Ines Chargui: What role does the Angular community play in shaping the framework's direction, and how can developers contribute to Angular’s evolution? Manfred Steyer: Angular is open source, so anyone can open an issue and submit pull requests anytime. The Angular team is also pretty responsive on social media. If you drop them a message, there is a good chance you’ll get a reply directly from someone on the team. Besides that, there is an official RFC process. So, before making big changes, the team writes up their ideas and goals and explains the reasons behind certain approaches. Then, the community can jump in and comment. For instance, the RFC for the new resource API just recently closed after one or two months. That gave people several weeks to share their feedback and suggestions. What I found interesting with that one is how they approached it. They released an experimental version of their vision before opening the RFC, which gave developers something concrete to play around with, making it easier to give useful, thoughtful feedback. I personally tried it out by building a first test application, and it really helped me provide more detailed input. It was a smart move on their part and it made a difference in the quality of the feedback they received. Ines Chargui: With the new EU Accessibility Act coming into effect, what kind of impact does Angular have on accessibility? Does the team take it into account to introduce new tools or improvements that will improve accessibility in Angular applications? Manfred Steyer: I would say Angular as a framework is more or less neutral when it comes to accessibility. It depends on how you use it to build your application and make it accessible. But if you look at Angular Material—the official component library maintained by the Angular team and used within Google—you’ll see that accessibility has always been a core focus. The components are built with proper semantic markup, and they support full keyboard navigation, among other accessibility features. So while Angular as a framework doesn’t enforce accessibility by default, Angular Material goes to great lengths to make its components accessible. Ines Chargui: If you had to pick your top five favourite Angular features, or the ones you\n'slidetext': ''\n'from': 'index'\n'score': 59.187747955322266\n'normalizedScore': 0.5918774795532227\n'beforeDatePenaltyScore': 0.5918774795532227\n\n'documentId': '1fed2c6361980d606789e315'\n'chunk_id': '68c26fcb0a53cd001394ab91'\n'access': 'granted'\n'part_number': 1\n'total_parts': 8\n'contentType': 'READ'\n'title': Manfred Steyer on Angular 20: Signals, Dynamic Components, AI, and What’s Next - Exploring selectorless components, signal-based forms, and other features in Angular\n'parentName': iJS Magazine Volume 19\n'language': 'EN'\n'date': '2025-06-24T22:00:00.000Z'\n'abstract': In this interview, GDE Manfred Steyer highlights Angular’s journey towards a more reactive future. We discuss the framework’s strengths, challenges, and what’s ahead with the release of Angular 20.\n'parentId': 'a1269c65e87d5b8ebcde4b28'\n'parentDescription': Broaden your knowledge and expand your JavaScript techniques and practices. From Angular, React, and WebAssembly, to the best JavaScript IDEs, open source tools and more, you’ll learn insights on everything JS from seasoned experts in their field. Keep up with JavaScript news, tips, and advice with interviews, tutorials, and in-depth articles.\n'indexBrandName': ''\n'indexSeriesName': ''\n'author': 'Manfred Steyer'\n'chunkSource': 'text'\n'text': Manfred Steyer on Angular 20: Signals, Dynamic Components, AI, and What’s Next Exploring selectorless components, signal-based forms, and other features in Angular In this interview, GDE Manfred Steyer highlights Angular’s journey towards a more reactive future. We discuss the framework’s strengths, challenges, and what’s ahead with the release of Angular 20. In this interview, GDE Manfred Steyer highlights Angular’s journey towards a more reactive future. With the release of Angular 20 on May 28, 2025, the framework enters a new stage of evolution, and we take a closer look at its strengths, the challenges it still faces, and the road that lies ahead. Ines Chargui: The release of Angular 20 is set for May 28, 2025. Before we dive into the new features, can you explain Angular's core philosophy and how it differs from other frontend frameworks like React or Vue? Manfred Steyer: I think, technically, you can achieve almost everything with all current frameworks because they are quite similar. However, I’ve always had the impression that Angular has non-technical advantages. For instance, it's implemented and actively used by Google, which gives it a sense of long-term stability. In today’s ecosystem, where many open source frameworks come and go, that kind of backing builds trust, knowing the tool you’re using will endure for a long time and is unlikely to disappear anytime soon. Another aspect where Angular really shines is that it gives you a lot of things out-of-the-box. For example, you get support for components but also for dependency injection testing, HTTP access, reactivity, routing, forms, and more. All of these are designed to work nicely together. This eliminates the guesswork of piecing together various libraries and ensures a cohesive development experience, since everything comes from the same team and is built to integrate smoothly. Ines Chargui: You just highlighted some of Angular’s advantages and why the framework shines. What are the main disadvantages of using Angular, and why would a developer choose to look elsewhere? Manfred Steyer: One thing I’ve seen in the past is that if you’re implementing enterprise-scale applications, Angular really fits well. But if you implement something very lightweight, like enhancing a page generated by a CMS system like WordPress, then Angular might be overkill. In those cases, many companies tend to use React or Vue. That said, the Angular team is aware of this perception and has been actively working to take out unnecessary weight to make it more appealing for lighter use cases. For instance, modules are now optional and generally not used anymore for\n'slidetext': ''\n'from': 'index'\n'score': 59.187747955322266\n'normalizedScore': 0.5918774795532227\n'beforeDatePenaltyScore': 0.5918774795532227\n\n'documentId': 'dcce136001b8cf2cfe8b5498'\n'chunk_id': '6876df207899910dd58c0e9c'\n'access': 'granted'\n'part_number': 1\n'total_parts': 7\n'contentType': 'READ'\n'title': Die neue httpResource in Angular 19.2 - Kolumne: Enterprise Angular\n'parentName': iJS Magazin 2.2025\n'language': 'DE'\n'date': '2025-03-25T23:00:00.000Z'\n'abstract': Angular 19.2 beinhaltet nun die neue httpResource, die es erlaubt, Daten innerhalb des reaktiven Flusses zu laden. Dieser Artikel zeigt, wie sich dieses - derzeit experimentelle - Feature nutzen lässt. Als Beispiel dient eine einfache Anwendung, die durch Levels, im Stil des Spiels „Super Mario“, scrollt. Jedes Level besteht aus Kacheln, die in vier verschiedenen Stilen zur Verfügung stehen: Overworld, Underground, Underwater und Castle. In unserer Implementierung können Benutzer:innen frei zwischen diesen Stilen wechseln. Abbildung 1 zeigt zum Beispiel das erste Level im Stil Overworld an. Abbildung 2 zeigt dasselbe Level im Stil Underground.\n'parentId': '7cb807973ada8ce87de439aa'\n'parentDescription': Kaum ein Softwareprojekt, das nicht in wesentlichen Teilen auf der JavaScript-Technologie basiert. Eine breite Unterstützung sowie, leistungsfähige Programmiersprachen, die Vielzahl moderner Tools, sowie ausgereifte Frameworks wie Angular, React, Vue.js oder Node.js machen den JavaScript-Werkzeugkasten zu einem Alleskönner. Das iJS Magazin informiert aktuell und umfassend über die wichtige und innovative Entwicklungen im JavaScript-Universum und bietet handfeste Praxisinformationen für Softwareentwickler und -architekten.\n'indexBrandName': ''\n'indexSeriesName': ''\n'author': 'Manfred Steyer'\n'chunkSource': 'text'\n'text': Die neue httpResource in Angular 19.2 Kolumne: Enterprise Angular Angular 19.2 beinhaltet nun die neue httpResource, die es erlaubt, Daten innerhalb des reaktiven Flusses zu laden. Dieser Artikel zeigt, wie sich dieses - derzeit experimentelle - Feature nutzen lässt. Als Beispiel dient eine einfache Anwendung, die durch Levels, im Stil des Spiels „Super Mario“, scrollt. Jedes Level besteht aus Kacheln, die in vier verschiedenen Stilen zur Verfügung stehen: Overworld, Underground, Underwater und Castle. In unserer Implementierung können Benutzer:innen frei zwischen diesen Stilen wechseln. Abbildung 1 zeigt zum Beispiel das erste Level im Stil Overworld an. Abbildung 2 zeigt dasselbe Level im Stil Underground. Angular 19.2 beinhaltet nun die neue httpResource, die es erlaubt, Daten innerhalb des reaktiven Flusses zu laden. Dieser Artikel zeigt, wie sich dieses – derzeit experimentelle – Feature nutzen lässt. Als Beispiel dient eine einfache Anwendung, die durch Levels, im Stil des Spiels „Super Mario“, scrollt. Jedes Level besteht aus Kacheln, die in vier verschiedenen Stilen zur Verfügung stehen: Overworld, Underground, Underwater und Castle. In unserer Implementierung können Benutzer:innen frei zwischen diesen Stilen wechseln. Abbildung 1 zeigt zum Beispiel das erste Level im Stil Overworld an. Abbildung 2 zeigt dasselbe Level im Stil Underground. Abb. 1: Level 1 im Stil Overworld Abb. 2: Level 1 im Stil Underground Eine LevelComponent in der Beispielanwendung [1] kümmert sich um das Laden von Leveldateien (JSON) und Kacheln zum Zeichnen der Level unter Nutzung einer httpResource. Zum Rendern und Animieren der Level stützt sich das Beispiel auf eine sehr einfache Engine, die dem Quellcode beiliegt, hier im Artikel jedoch als Blackbox behandelt wird. HttpClient im Unterbau ermöglicht die Verwendung von Interceptors Im Unterbau verwendet die neue httpResource derzeit den guten alten HttpClient. Daher muss die Anwendung diesen Service bereitstellen, was normalerweise durch Aufruf von provideHttpClient während des Bootstrappings geschieht. Als Konsequenz ergibt sich, dass die httpResource auch automatisch die registrierten HttpInterceptors aufgreift. Der HttpClient ist jedoch lediglich ein Implementierungsdetail, das Angular eventuell irgendwann durch eine andere Implementierung ersetzt. Level-Dateien Die verschiedenen Levels beschreibt unser Beispiel mit JSON-Dateien, die definieren, welche Kacheln an welchen\n'slidetext': ''\n'from': 'index'\n'score': 58.97711944580078\n'normalizedScore': 0.5897711944580079\n'beforeDatePenaltyScore': 0.5897711944580079\n\n'documentId': 'c8af1d2c9d8e08acaa09599f'\n'chunk_id': '68c26ff80a53cd001394abf8'\n'access': 'granted'\n'part_number': 4\n'total_parts': 4\n'contentType': 'READ'\n'title': Custom Standalone APIs for Angular - Enterprise Angular\n'parentName': iJS Magazine Volume 19\n'language': 'EN'\n'date': '2025-06-24T22:00:00.000Z'\n'abstract': Together with standalone components, the Angular team has introduced the so-called standalone APIs. They provide a simple solution for library setup and do not require Angular modules.\n'parentId': 'a1269c65e87d5b8ebcde4b28'\n'parentDescription': Broaden your knowledge and expand your JavaScript techniques and practices. From Angular, React, and WebAssembly, to the best JavaScript IDEs, open source tools and more, you’ll learn insights on everything JS from seasoned experts in their field. Keep up with JavaScript news, tips, and advice with interviews, tutorials, and in-depth articles.\n'indexBrandName': ''\n'indexSeriesName': ''\n'author': 'Manfred Steyer'\n'chunkSource': 'text'\n'text': e.g. to configure preloading or to enable tracing. The HttpClient uses it to provide interceptors, to configure JSONP and to configure/disable XSRF token handling. Pattern: configuration factory Configuration factories extend the behavior of existing services. They can provide additional configuration options, but also additional services. An extended version of our LoggerService will serve as an illustration. It allows to define an additional LogAppender for each log category: @Injectable() export class LoggerService { readonly categories: Record = {}; […] } To configure a LogAppender for a category, we introduce a configuration factory named provideCategory (Listing 8). Listing 8 export function provideCategory( category: string, appender: Type ): EnvironmentProviders { // Internal/ Local token for registering the service // and retrieving the resolved service instance // immediately after. const appenderToken = new InjectionToken('APPENDER_' + category); return makeEnvironmentProviders([ { provide: appenderToken, useClass: appender, }, { provide: ENVIRONMENT_INITIALIZER, multi: true, useValue: () => { const appender = inject(appenderToken); const logger = inject(LoggerService); logger.categories[category] = appender; }, }, ]); } This factory creates a provider for the LogAppender class. The call to inject gives us an instance of it and resolves its dependencies. The ENVIRONMENT_INITIALIZER token points to a function that Angular triggers when initializing the respective environment injector. It registers the LogAppender with the LoggerService (Listing 9). Listing 9 export const FLIGHT_BOOKING_ROUTES: Routes = [ { path: '', component: FlightBookingComponent, providers: [ // Setting up an NgRx // feature slice provideState(bookingFeature), provideEffects([BookingEffects]), // Provide LogAppender for // logger category provideCategory('booking', DefaultLogAppender), ], children: [ { path: 'flight-search', component: FlightSearchComponent, }, [...] ], }, ]; This pattern is found, for example, in NgRx to register feature slices. The feature withDebugTracing offered by the router also uses this pattern to subscribe to the observable events in the router service. Conclusion Standalone APIs allow you to set up libraries without Angular modules. Their use is simple to begin with: consumers simply need to look for a provider factory with the name provideXYZ. Additional features can be enabled, if necessary, with functions that follow the withABC naming scheme. However, the implementation of such APIs is not always trivial. This is exactly where the patterns presented here help. Since they are derived from libraries of the Angular and NgRx teams, they reflect first-hand experience and design decisions.\n'slidetext': ''\n'from': 'index'\n'score': 58.89068603515625\n'normalizedScore': 0.5889068603515625\n'beforeDatePenaltyScore': 0.5889068603515625\n\n'documentId': '1fed2c6361980d606789e315'\n'chunk_id': '68c26fcc0a53cd001394ab96'\n'access': 'granted'\n'part_number': 6\n'total_parts': 8\n'contentType': 'READ'\n'title': Manfred Steyer on Angular 20: Signals, Dynamic Components, AI, and What’s Next - Exploring selectorless components, signal-based forms, and other features in Angular\n'parentName': iJS Magazine Volume 19\n'language': 'EN'\n'date': '2025-06-24T22:00:00.000Z'\n'abstract': In this interview, GDE Manfred Steyer highlights Angular’s journey towards a more reactive future. We discuss the framework’s strengths, challenges, and what’s ahead with the release of Angular 20.\n'parentId': 'a1269c65e87d5b8ebcde4b28'\n'parentDescription': Broaden your knowledge and expand your JavaScript techniques and practices. From Angular, React, and WebAssembly, to the best JavaScript IDEs, open source tools and more, you’ll learn insights on everything JS from seasoned experts in their field. Keep up with JavaScript news, tips, and advice with interviews, tutorials, and in-depth articles.\n'indexBrandName': ''\n'indexSeriesName': ''\n'author': 'Manfred Steyer'\n'chunkSource': 'text'\n'text': you think every developer should know, what would they be? Manfred Steyer: Well, I’d say data binding is a big one. Most people use Angular first and foremost because it gives you data binding. Doing data binding manually can be tedious and often leads to messy, unmanageable code. Lately, I’ve really been enjoying the new Signals feature. It brings a more intuitive approach to reactivity, making it easier to streamline how data flows through the application. I’ve always been a big fan of the Angular Router too and everything that allows us to do HTTP access, as Angular continues to shine in this area. And lastly—maybe not the most exciting, but definitely essential—is form support. Especially in enterprise applications, you deal with a lot of forms, and Angular’s form support is incredibly useful right out of the box. Ines Chargui: I’m curious to know how much you get to experiment with other new frameworks. What do you think about these newer, minimal ones? Do you find them interesting or useful in certain contexts? Manfred Steyer: I think these newer, young frameworks are really important. In the past, they have often been the reason that pushed Angular and other major frameworks to evolve and reinvent themselves. They bring new ideas to the table and show that, with a different mindset, you can sometimes achieve more in certain areas. In that sense, they act as incubators for innovation. That said, I think it’s tough for a new framework to gain real traction. You need a critical mass of users and contributors. Frameworks like Angular or React have already reached that scale, which gives them long-term stability. From a practical standpoint, whether you choose Angular, React, or Vue, they’re all likely to be around for many years. But those smaller frameworks—Qwik is another great example—still play an essential role. They push the big players to reflect, adapt, and reinvent themselves. And so far, we’ve seen that they are capable of rising to the challenge. Ines Chargui: But here’s something I’ve always found interesting—despite Angular’s popularity, all the improvements, and the way it keeps evolving, it never shows up in the top three or even top five in developer surveys when it comes to most used frameworks. How do you explain that? Manfred Steyer: Good point. I think this correlates with what I've told you before. If you are a typical web developer working on web projects or portals, Angular can sometimes feel like too much, and people often prefer more lightweight stuff. However, if you took the same survey among\n'slidetext': ''\n'from': 'index'\n'score': 58.783424377441406\n'normalizedScore': 0.5878342437744141\n'beforeDatePenaltyScore': 0.5878342437744141\n\n'documentId': '9836770500f149a58b7769f9'\n'chunk_id': '68ad7e39494be90012217fea'\n'access': 'granted'\n'part_number': 4\n'total_parts': 6\n'contentType': 'READ'\n'title': Professional Tips for Using Signals in Angular - Enterprise Angular\n'parentName': iJS Magazine Volume 17\n'language': 'EN'\n'date': '2025-02-25T23:00:00.000Z'\n'abstract': The new Signals in Angular are a simple reactive building block. However, as is so often the case, the devil is in the detail. In this article, I will give three tips to help you use Signals in a more straightforward way.\n'parentId': '2b07605113b7a8ed6aeea755'\n'parentDescription': Broaden your knowledge and expand your JavaScript techniques and practices. From Angular, React, and WebAssembly, to the best JavaScript IDEs, open source tools and more, you’ll learn insights on everything JS from seasoned experts in their field. Keep up with JavaScript news, tips, and advice with interviews, tutorials, and in-depth articles.\n'indexBrandName': ''\n'indexSeriesName': ''\n'author': 'Manfred Steyer'\n'chunkSource': 'text'\n'text': { patchState(store, { ratings, loading: false }); }, error: (error) => { patchState(store, { loading: false }); toastService.show('Error loading ratings!'); console.error(error); }, }); }, Depending on the flag’s value, the application can display a loading indicator or deactivate the respective button. The latter is counterproductive or even impossible with a highly reactive UI if the application can manage without an explicit button. Tip 3: Signals as triggers As mentioned earlier, Signals are especially suitable for transporting data to the view, like what’s seen on the right in Figure 1. Real events, UI events, or events displayed with RxJS are the better solution for transmitting an intention. There are several reasons why: First, Signals’ glitch-free property can reduce consecutive changes to the last change. Consumers must subscribe to the Signal in order to be able to react to value changes. This requires an effect that triggers the desired action and writes the result to a signal. Effects that write to Signals are not welcome. By default, they are even penalized by Angular with an exception. The Angular team wants to avoid confusing reactive chains - changes that lead to changes, which in turn, lead to further changes. On the other hand, Angular is converting more and more APIs to signals. One example is Signals that can be bound to form fields or Signals that represent passed values (inputs). In most cases, you could argue that instead of listening for the Signal, you can also use the event that led to the Signal change. But in some cases, this is a detour that bypasses the new signal-based APIs. Listing 4 shows an example of a component that receives the ID of a data set to be displayed as an input signal. The router takes this ID from a routing parameter. This is possible with the relatively new feature withComponentInputBinding. Listing 4 @Component({ […] }) export class DessertDetailComponent implements OnChanges { store = inject(DessertDetailStore); dessert = this.store.dessert; loading = this.store.loading; id = input.required({ transform: numberAttribute }); […] } This component’s template lets you scroll between the data records. This logic is deliberately implemented very simply for this example:  Next  When scrolling, the input signal id receives a new value. Now, the question arises as to how to trigger the loading of the respective data set in the event of this kind of change. The classic procedure is using the live cycle hook ngOnChanges: ngOnChanges(): void { const id = this.id(); this.store.load(id); } For the time being, there’s nothing wrong with this. However, the planned signal-based\n'slidetext': ''\n'from': 'index'\n'score': 58.142940521240234\n'normalizedScore': 0.5814294052124024\n'beforeDatePenaltyScore': 0.5814294052124024\n\n'documentId': 'c8af1d2c9d8e08acaa09599f'\n'chunk_id': '68c26ff80a53cd001394abf7'\n'access': 'granted'\n'part_number': 3\n'total_parts': 4\n'contentType': 'READ'\n'title': Custom Standalone APIs for Angular - Enterprise Angular\n'parentName': iJS Magazine Volume 19\n'language': 'EN'\n'date': '2025-06-24T22:00:00.000Z'\n'abstract': Together with standalone components, the Angular team has introduced the so-called standalone APIs. They provide a simple solution for library setup and do not require Angular modules.\n'parentId': 'a1269c65e87d5b8ebcde4b28'\n'parentDescription': Broaden your knowledge and expand your JavaScript techniques and practices. From Angular, React, and WebAssembly, to the best JavaScript IDEs, open source tools and more, you’ll learn insights on everything JS from seasoned experts in their field. Keep up with JavaScript news, tips, and advice with interviews, tutorials, and in-depth articles.\n'indexBrandName': ''\n'indexSeriesName': ''\n'author': 'Manfred Steyer'\n'chunkSource': 'text'\n'text': The optional feature is represented by an object with a providers array. In addition, the object has a kind property that subdivides the feature of a certain category. This categorization enables the validation of the jointly configured features. For example, features can be mutually exclusive. An example of this can be found in the HttpClient: It prohibits the use of a feature for configuring XSRF handling if the consumers have simultaneously activated a feature for disabling it. The logger library used here uses a ColorFeature that allows messages to be output in different colors depending on the LoggerLevel (Fig. 2). Fig. 2: Structure of the ColorFeature An enum is used to categorize features: export enum LoggerFeatureKind { COLOR, OTHER_FEATURE, ADDITIONAL_FEATURE } Another factory is used to provide the ColorFeature (Listing 5). Listing 5 export function withColor(config?: Partial): LoggerFeature { const internal = { ...defaultColorConfig, ...config }; return { kind: LoggerFeatureKind.COLOR, providers: [ { provide: ColorConfig, useValue: internal, }, { provide: ColorService, useClass: DefaultColorService, }, ], }; } The updated provider factory provideLogger takes on several features via an optional second parameter defined as an array for rest parameters (Listing 6). Listing 6 export function provideLogger( config: Partial, ...features: LoggerFeature[] ): EnvironmentProviders { const merged = { ...defaultConfig, ...config }; // Inspecting passed features const colorFeatures = features?.filter((f) => f.kind === LoggerFeatureKind.COLOR)?.length ?? 0; // Validating passed features if (colorFeatures > 1) { throw new Error('Only one color feature allowed for logger!'); } return makeEnvironmentProviders([ { provide: LoggerConfig, useValue: merged, }, { provide: LogFormatter, useClass: merged.formatter, }, merged.appenders.map((a) => ({ provide: LOG_APPENDERS, useClass: a, multi: true, })), // Providing services for the // features features?.map((f) => f.providers), ]); } The provider factory uses the kind property to examine and validate the passed features. If all is well, it includes the feature's providers in the EnvironmentProviders object. The DefaultLogAppender fetches the ColorService provided by the ColorFeature via dependency injection (Listing 7). Listing 7 export class DefaultLogAppender implements LogAppender { colorService = inject(ColorService, { optional: true }); append(level: LogLevel, category: string, msg: string): void { if (this.colorService) { msg = this.colorService.apply(level, msg); } console.log(msg); } } Since features are optional, the DefaultLog appender passes the {optional: true} option to inject. This prevents an exception in cases where the feature, and thus the ColorService, has not been provided. Also, the DefaultLogAppender must check for null values. This pattern occurs in the router, e.g.\n'slidetext': ''\n'from': 'index'\n'score': 58.085575103759766\n'normalizedScore': 0.5808557510375977\n'beforeDatePenaltyScore': 0.5808557510375977\n\n'documentId': 'd74f910ab5ef9854703a97d3'\n'chunk_id': '6876dc4d225e92fc1ac7cc8e'\n'access': 'restricted'\n'part_number': 1\n'total_parts': 1\n'contentType': 'RHEINGOLD'\n'title': Fit für die Zukunft: Migration zu Modern Angular\n'parentName': JavaScript Days München und online 2025\n'language': 'DE'\n'date': '2025-03-20T12:30:00.000Z'\n'abstract': In den letzten Monaten hat Angular zahlreiche neue Features erhalten, die es ermöglichen, das Framework auf moderne und leichtgewichtige Weise zu verwenden. Signals für eine moderne und performante Change Detection, Standalone Components und Standalone APIs, funktionale Guards und Interceptoren, esbuild-Unterstützung sowie und zahlreiche Verbesserungen beim Router sind ein paar Beispiele dafür. In diesem Workshop starten wir mit einer klassischen Angular-Lösungen, die wir nach und nach um die neuen Möglichkeiten erweitern. Somit ergibt sich eine leichtgewichtige und moderne Lösung, die sich einfacher warten lässt und die Vorteile der neuen Features auch nutzen kann. Am Ende wissen Sie, wie sich Ihre Angular-Lösung modernisieren lässt und welche neuen Features sich für Ihre Vorhaben lohnen.\n'parentId': 'efd4ff41c4b9e889b50854b8'\n'parentDescription': 40 Workshops zu JavaScript, Angular, React, HTML & CSS und KI\n'indexBrandName': 'JavaScriptDays'\n'indexSeriesName': 'Munich'\n'author': 'Manfred Steyer'\n'chunkSource': 'text'\n'text': Fit für die Zukunft: Migration zu Modern Angular In den letzten Monaten hat Angular zahlreiche neue Features erhalten, die es ermöglichen, das Framework auf moderne und leichtgewichtige Weise zu verwenden. Signals für eine moderne und performante Change Detection, Standalone Components und Standalone APIs, funktionale Guards und Interceptoren, esbuild-Unterstützung sowie und zahlreiche Verbesserungen beim Router sind ein paar Beispiele dafür. In diesem Workshop starten wir mit einer klassischen Angular-Lösungen, die wir nach und nach um die neuen Möglichkeiten erweitern. Somit ergibt sich eine leichtgewichtige und moderne Lösung, die sich einfacher warten lässt und die Vorteile der neuen Features auch nutzen kann. Am Ende wissen Sie, wie sich Ihre Angular-Lösung modernisieren lässt und welche neuen Features sich für Ihre Vorhaben lohnen.\n'slidetext': ''\n'from': 'index'\n'score': 58.076866149902344\n'normalizedScore': 0.5807686614990234\n'beforeDatePenaltyScore': 0.5807686614990234\n\n'documentId': '1fed2c6361980d606789e315'\n'chunk_id': '68c26fcc0a53cd001394ab94'\n'access': 'granted'\n'part_number': 4\n'total_parts': 8\n'contentType': 'READ'\n'title': Manfred Steyer on Angular 20: Signals, Dynamic Components, AI, and What’s Next - Exploring selectorless components, signal-based forms, and other features in Angular\n'parentName': iJS Magazine Volume 19\n'language': 'EN'\n'date': '2025-06-24T22:00:00.000Z'\n'abstract': In this interview, GDE Manfred Steyer highlights Angular’s journey towards a more reactive future. We discuss the framework’s strengths, challenges, and what’s ahead with the release of Angular 20.\n'parentId': 'a1269c65e87d5b8ebcde4b28'\n'parentDescription': Broaden your knowledge and expand your JavaScript techniques and practices. From Angular, React, and WebAssembly, to the best JavaScript IDEs, open source tools and more, you’ll learn insights on everything JS from seasoned experts in their field. Keep up with JavaScript news, tips, and advice with interviews, tutorials, and in-depth articles.\n'indexBrandName': ''\n'indexSeriesName': ''\n'author': 'Manfred Steyer'\n'chunkSource': 'text'\n'text': linked signals give us a local working copy. We can bind to that, make changes locally, and then send all the data back to the store or directly to the backend. I’ve also tried out the new hydration story and hybrid rendering, where we can decide on a bare route level whether this route should be rendered on the server side, on the client side, or pre-rendered during the build. Combined with incremental hydration, this offers a major performance boost, as it speeds up the page loading times. When your app is exposed to the internet, faster initial load times are critical, and every millisecond counts. Ines Chargui: That leads me to my next question. What do you think of Angular's current position when it comes to achieving hydration and resumability? Manfred Steyer: I think we are on a really good track here. It's now possible to hydrate a page incrementally, meaning you just load a bunch of static HTML and then different parts of the page are hydrated at different times, depending on their importance and what the user is actually interacting with. For example, if a user hasn’t scrolled to a certain section yet, that part doesn’t need to be hydrated immediately. Sure, server-side rendering was always possible, but to be honest, the developer experience was not exactly great. But now, thanks in part to friendly competition from other frameworks like Qwik, there’s been a shift in the ecosystem. Angular has moved quickly, and we’re starting to see major improvements. The developer experience has got a lot better, and features like incremental hydration are moving significantly closer to the direction of resumability. Ines Chargui: Hydration and resumability have become hot topics, with frameworks like React and Angular taking different approaches. Do you think this is something worth investing in going forward, or do you see it potentially hitting a dead end? Manfred Steyer: I don't think it's the end. There are several approaches to this, and different frameworks handle it in various ways. Even if a framework calls it “hydration,” you need to look closely and check what they actually mean by it. The implementation may differ, but the general direction is always the same: minimizing the amount of JavaScript that needs to be downloaded before the user can start using the page. JavaScript is great for UI/UX, but it can slow down the initial page load. This is why single-page applications have always been a bit critical in the area of public portals for customers because every millisecond counts in those scenarios. However, for internal applications used regularly within a company, it’s not a big deal\n'slidetext': ''\n'from': 'index'\n'score': 57.84555435180664\n'normalizedScore': 0.5784555435180664\n'beforeDatePenaltyScore': 0.5784555435180664\n\n'documentId': '1fed2c6361980d606789e315'\n'chunk_id': '68c26fcc0a53cd001394ab97'\n'access': 'granted'\n'part_number': 7\n'total_parts': 8\n'contentType': 'READ'\n'title': Manfred Steyer on Angular 20: Signals, Dynamic Components, AI, and What’s Next - Exploring selectorless components, signal-based forms, and other features in Angular\n'parentName': iJS Magazine Volume 19\n'language': 'EN'\n'date': '2025-06-24T22:00:00.000Z'\n'abstract': In this interview, GDE Manfred Steyer highlights Angular’s journey towards a more reactive future. We discuss the framework’s strengths, challenges, and what’s ahead with the release of Angular 20.\n'parentId': 'a1269c65e87d5b8ebcde4b28'\n'parentDescription': Broaden your knowledge and expand your JavaScript techniques and practices. From Angular, React, and WebAssembly, to the best JavaScript IDEs, open source tools and more, you’ll learn insights on everything JS from seasoned experts in their field. Keep up with JavaScript news, tips, and advice with interviews, tutorials, and in-depth articles.\n'indexBrandName': ''\n'indexSeriesName': ''\n'author': 'Manfred Steyer'\n'chunkSource': 'text'\n'text': among enterprise developers, I'm pretty sure the results would look very different. In sectors like banking, insurance, or manufacturing, Angular is widely used. I also think that the Angular team is aware of the perception around complexity, and they’ve been making efforts to remove unnecessary weight. Ines Chargui: We touched on your hopes and expectations for the upcoming release of Angular 20. Looking beyond that, what do you envision for the future of Angular? What’s maybe something that’s not currently on the team’s radar, but as a developer, you think would make a big difference? Manfred Steyer: I see three directions: One direction is improvements in the whole incremental rendering story, including incremental hydration and so on. Second, there is the reactivity story, in which we’re still at the early stages, but there is a lot of potential, especially with the introduction of Signals. For example, adjusting the router, forms, and data loading to signals would be a big step. That kind of reactivity could open up a lot of new patterns. Eventually, these two areas—incremental rendering and reactivity—will come together because when we have incremental rendering, sooner or later we also need incremental data fetching. This is where reactivity comes in. Then, there’s the developer experience side. This includes improving the build process, speeding things up, doing more on-demand stuff, or rewriting compilers in native languages. TypeScript is now rewritten in Go, and I would love to see something similar for the Angular compiler. This would speed up the whole build process, which can be a huge issue for large-scale teams. Ines Chargui: AI is such a big topic right now, and everyone is using it in some form. What are your thoughts on integrating AI into JavaScript? More specifically, how do you see AI being used within Angular applications? Manfred Steyer: The Angular team is thinking about using AI in the future to assist with code migrations. This ties in well with their commitment to avoiding breaking existing code. Currently, a lot of migrations are handled through custom scripts, but this is limiting since you can’t automate everything, especially when there is no direct transformation from the old to the new style. It's a bit difficult to do this automatically, so AI could really help. It can look at your current source code and find out which tweaks are needed to adjust the source code to the latest versions of all the libraries. Ines Chargui: This has nothing to do with Angular, but what do you think about these AI libraries like TensorFlow.js or Brain.js? Manfred Steyer: I think web developers will learn\n'slidetext': ''\n'from': 'index'\n'score': 57.832542419433594\n'normalizedScore': 0.578325424194336\n'beforeDatePenaltyScore': 0.578325424194336\n\n'documentId': 'c8af1d2c9d8e08acaa09599f'\n'chunk_id': '68c26ff80a53cd001394abf6'\n'access': 'granted'\n'part_number': 2\n'total_parts': 4\n'contentType': 'READ'\n'title': Custom Standalone APIs for Angular - Enterprise Angular\n'parentName': iJS Magazine Volume 19\n'language': 'EN'\n'date': '2025-06-24T22:00:00.000Z'\n'abstract': Together with standalone components, the Angular team has introduced the so-called standalone APIs. They provide a simple solution for library setup and do not require Angular modules.\n'parentId': 'a1269c65e87d5b8ebcde4b28'\n'parentDescription': Broaden your knowledge and expand your JavaScript techniques and practices. From Angular, React, and WebAssembly, to the best JavaScript IDEs, open source tools and more, you’ll learn insights on everything JS from seasoned experts in their field. Keep up with JavaScript news, tips, and advice with interviews, tutorials, and in-depth articles.\n'indexBrandName': ''\n'indexSeriesName': ''\n'author': 'Manfred Steyer'\n'chunkSource': 'text'\n'text': received messages (Listing 2). Listing 2 @Injectable() export class LoggerService { private config = inject(LoggerConfig); private formatter = inject(LogFormatter); private appenders = inject(LOG_APPENDERS); log(level: LogLevel, category: string, msg: string): void { if (level < this.config.level) { return; } const formatted = this.formatter.format(level, category, msg); for (const a of this.appenders) { a.append(level, category, formatted); } } error(category: string, msg: string): void { this.log(LogLevel.ERROR, category, msg); } info(category: string, msg: string): void { this.log(LogLevel.INFO, category, msg); } debug(category: string, msg: string): void { this.log(LogLevel.DEBUG, category, msg); } } The golden rule Before we take a look at the patterns, I want to mention my golden rule for registering services: Use @Injectable({providedIn: 'root'}) whenever possible! Especially in applications, but also in numerous situations in libraries, this approach is perfectly sufficient. It is simple, treeshakable and even works with lazy loading. The latter aspect is less a merit of Angular than of the underlying bundler. Everything that can only be used in a lazy bundle is also accommodated there. Pattern: provider factory A provider factory is a function that returns all services for a reusable library. It can also register configuration objects as services or exchange service implementations. The returned services are in a provider array that wraps the factory with the EnvironmentProviders type. This approach, designed by the Angular team, ensures that an application can register providers only with so-called environment injectors. These are primarily the injector for the root scope and injectors that Angular sets up via the routing configuration. The provider factory in Listing 3 illustrates this. It takes a LoggerConfig and sets up the individual services for the Logger. Listing 3 export function provideLogger( config: Partial ): EnvironmentProviders { // using default values for // missing properties const merged = { ...defaultConfig, ...config }; return makeEnvironmentProviders([ { provide: LoggerConfig, useValue: merged, }, { provide: LogFormatter, useClass: merged.formatter, }, merged.appenders.map((a) => ({ provide: LOG_APPENDERS, useClass: a, multi: true, })), ]); } The factory takes missing configuration values from the default configuration. The makeEnvironmentProviders function provided by Angular wraps the provider array into an instance of EnvironmentProviders. This factory allows consumers to set up the logger similarly to how they set up the HttpClient or router (Listing 4). Listing 4 bootstrapApplication(AppComponent, { providers: [ provideHttpClient(), provideRouter(APP_ROUTES), [...] provideLogger(loggerConfig), ] } Pattern: feature The feature pattern allows optional functionality to be enabled and configured. If this functionality is not used, the build process removes it using treeshaking. The\n'slidetext': ''\n'from': 'index'\n'score': 57.798465728759766\n'normalizedScore': 0.5779846572875976\n'beforeDatePenaltyScore': 0.5779846572875976\n\n'documentId': '1fed2c6361980d606789e315'\n'chunk_id': '68c26fcc0a53cd001394ab92'\n'access': 'granted'\n'part_number': 2\n'total_parts': 8\n'contentType': 'READ'\n'title': Manfred Steyer on Angular 20: Signals, Dynamic Components, AI, and What’s Next - Exploring selectorless components, signal-based forms, and other features in Angular\n'parentName': iJS Magazine Volume 19\n'language': 'EN'\n'date': '2025-06-24T22:00:00.000Z'\n'abstract': In this interview, GDE Manfred Steyer highlights Angular’s journey towards a more reactive future. We discuss the framework’s strengths, challenges, and what’s ahead with the release of Angular 20.\n'parentId': 'a1269c65e87d5b8ebcde4b28'\n'parentDescription': Broaden your knowledge and expand your JavaScript techniques and practices. From Angular, React, and WebAssembly, to the best JavaScript IDEs, open source tools and more, you’ll learn insights on everything JS from seasoned experts in their field. Keep up with JavaScript news, tips, and advice with interviews, tutorials, and in-depth articles.\n'indexBrandName': ''\n'indexSeriesName': ''\n'author': 'Manfred Steyer'\n'chunkSource': 'text'\n'text': for new code, which simplifies the codebase. Additionally, the new lightweight reactivity system trims down unnecessary complexity. With these changes, Angular feels as lightweight as the other frameworks. Ines Chargui: Signals has received so much momentum lately, can you explain what it is and why it is getting so much attention? Manfred Steyer: The idea of Signals is to provide a very simple, reactive building block that holds a value. The value can be changed and tracked, meaning that someone can find out when the value is changing and then they can react accordingly. This someone is first and foremost Angular itself because Angular needs to know when something is changed in order to trigger a rendering, updating your view and your components. But another consumer of this reactivity can be the application itself. The application can recalculate something every time something else changes. Both have advantages. Angular’s ability to detect exactly when and where data changes occur makes it more efficient, as it avoids the need for broad dirty checking across the entire application. It allows us to optimize the whole change detection. For instance, we can easily switch to the change detection strategy.OnPush. Think of it like an Excel sheet: when one value changes, all dependent values update automatically. You no longer need to manually manage updates like “if this changes, then update that.” It just stays in sync. Those are the big two advantages. Some people may argue that this isn’t entirely new, since RxJS and observables have long provided similar capabilities. And that’s true, everything you can currently do with Signals can also be achieved with RxJS. However, the main idea behind Signals is simplicity. They make common use cases easier to implement. They’re not as powerful as observables, but they’re more well-suited for new developers. Of course, if you’re implementing something more difficult and complex, you can still use RxJS. Ines Chargui: What initially drew you to Angular? How did your Angular journey begin? Manfred Steyer: I think it was sometime between 2010 and 2012 when I realized how valuable it is to get a lot of stuff out-of-the-box. Working in the JavaScript ecosystem at the time often meant combining several tools and technologies. Back then, I used Knockout.js for data binding, some jQuery libraries for UI, and had to rely on a completely separate tool set for testing—none of which felt particularly well. Eventually, I switched to AngularJS. Although AngularJS was a different framework from the modern Angular we know today, I soon started exploring Angular 2 while it was still in its early alpha and beta\n'slidetext': ''\n'from': 'index'\n'score': 57.75300216674805\n'normalizedScore': 0.5775300216674805\n'beforeDatePenaltyScore': 0.5775300216674805\n\n'documentId': '9836770500f149a58b7769f9'\n'chunk_id': '68ad7e38494be90012217fe7'\n'access': 'granted'\n'part_number': 1\n'total_parts': 6\n'contentType': 'READ'\n'title': Professional Tips for Using Signals in Angular - Enterprise Angular\n'parentName': iJS Magazine Volume 17\n'language': 'EN'\n'date': '2025-02-25T23:00:00.000Z'\n'abstract': The new Signals in Angular are a simple reactive building block. However, as is so often the case, the devil is in the detail. In this article, I will give three tips to help you use Signals in a more straightforward way.\n'parentId': '2b07605113b7a8ed6aeea755'\n'parentDescription': Broaden your knowledge and expand your JavaScript techniques and practices. From Angular, React, and WebAssembly, to the best JavaScript IDEs, open source tools and more, you’ll learn insights on everything JS from seasoned experts in their field. Keep up with JavaScript news, tips, and advice with interviews, tutorials, and in-depth articles.\n'indexBrandName': ''\n'indexSeriesName': ''\n'author': 'Manfred Steyer'\n'chunkSource': 'text'\n'text': Professional Tips for Using Signals in Angular Enterprise Angular The new Signals in Angular are a simple reactive building block. However, as is so often the case, the devil is in the detail. In this article, I will give three tips to help you use Signals in a more straightforward way. The new Signals in Angular are a simple reactive building block. However, as is so often the case, the devil is in the detail. In this article, I will give three tips to help you use Signals in a more straightforward way. The examples used for this can be found here. Guiding theory: Unidirectional data flow with signals The approach for establishing a unidirectional data flow (Fig. 1) serves as the guiding theory for my three tips. Fig. 1: Unidirectional data flow with a store Handlers for UI events delegate to the store. I use the abstract term “intention”, since this process is different for different stores. With the Redux-based NgRx store, actions are dispatched; whereas with the lightweight NgRx Signal store, the component calls a method offered by the store. The store executes synchronous or asynchronous tasks. These usually lead to a status change, which the application transports to the views of the individual components with signals. As part of this data flow, the state can be projected onto view models using computed, i.e. onto data structures that represent the view of individual use cases on the state. This approach is based on the fact that signals are primarily suitable for informing the view synchronously about data and data changes. They are less suitable for asynchronous tasks and for representing events. For one, they don’t offer a simple way of dealing with overlapping asynchronous requests and the resulting race conditions. Furthermore, they cannot directly represent error states. Second, signals ignore the resulting intermediate states in the case of directly consecutive value changes. This desired property is called “glitch free”. For example, if a signal changes from 1 to 2 and immediately afterwards from 2 to 3, the consumer only receives a notification about the 3. This is also conducive to data binding performance, especially as updating with intermediate results would result in an unnecessary performance overhead. Tip 1: Signals harmonize with RxJS Signals are deliberately kept simple. That's why it offers fewer options than RxJS, which has been established in the Angular world for years. Thanks to the RxJS interop that Angular provides, the best of both worlds can be combined. Listing 1 demonstrates this. It converts the signals from and to into observables and implements a typeahead based on them. To do this, it uses the operators filter, debounceTime and\n'slidetext': ''\n'from': 'index'\n'score': 57.53023910522461\n'normalizedScore': 0.5753023910522461\n'beforeDatePenaltyScore': 0.5753023910522461\n\n'documentId': '9836770500f149a58b7769f9'\n'chunk_id': '68ad7e39494be90012217feb'\n'access': 'granted'\n'part_number': 5\n'total_parts': 6\n'contentType': 'READ'\n'title': Professional Tips for Using Signals in Angular - Enterprise Angular\n'parentName': iJS Magazine Volume 17\n'language': 'EN'\n'date': '2025-02-25T23:00:00.000Z'\n'abstract': The new Signals in Angular are a simple reactive building block. However, as is so often the case, the devil is in the detail. In this article, I will give three tips to help you use Signals in a more straightforward way.\n'parentId': '2b07605113b7a8ed6aeea755'\n'parentDescription': Broaden your knowledge and expand your JavaScript techniques and practices. From Angular, React, and WebAssembly, to the best JavaScript IDEs, open source tools and more, you’ll learn insights on everything JS from seasoned experts in their field. Keep up with JavaScript news, tips, and advice with interviews, tutorials, and in-depth articles.\n'indexBrandName': ''\n'indexSeriesName': ''\n'author': 'Manfred Steyer'\n'chunkSource': 'text'\n'text': signal-based components will no longer offer this lifecycle hook. The RFC provides using effects as a replacement. To escape this dilemma, an rxMethod (e.g. offered by a signal store) can be used: constructor() { this.store.rxLoad(this.id); } It should be noted that the constructor transfers the entire signal and not just its current value. The rxMethod subscribes to this Signal and forwards its values to an observable that is used within the rxMethod. If you don’t want to use the signal store, you can instead use the RxJS interop discussed above and convert the signal into an observable with toObservable. If you don't have a reactive method to hand, you might be tempted to define an effect for this task: constructor() { effect(() => { this.store.load(this.id()); }); } Unfortunately, this leads to the exception in Figure 2. Fig. 2: Error message when using effect This problem arises because the entire load method that writes a Signal in the store is executed in the reactive context of the effect. This means that Angular recognizes an effect that writes to a Signal. This has to be prevented by default for the reasons above. It also means that Angular triggers the effect again even if a Signal read in load changes. Both problems can be prevented by using the untracked function (Listing 5). Listing 5 constructor() { // try to avoid this effect(() => { const id = this.id(); untracked(() => { this.store.load(id); }); }); } With this common pattern, untracked ensures that the reactive context does not spill over to the load method. It can write to Signals and the effect doesn’t register for Signals that read load. Angular only triggers the effect again when the Signal id changes, especially since it reads it outside of untracked. Unfortunately, this code is not especially easy to read. It’s a good idea to hide it behind a helper function: constructor() { explicitEffect(this.id, (id) => { this.store.load(id); }); } The created auxiliary function explicitEffect receives a signal and subscribes to it with an effect. The effect triggers the transferred lambda expression using untracked (Listing 6). Listing 6 import { Signal, effect, untracked } from '@angular/core'; export function explicitEffect(source: Signal, action: (value: T) => void) { effect(() => { const s = source(); untracked(() => { action(s) }); }); } Interestingly, the explicit definition of Signals to be obeyed corresponds to the standard behavior of effects in other frameworks, like Solid. The combination of effect and untracked shown is also used in many libraries. Examples include the classic NgRx store, the RxJS interop mentioned above, the rxMethod, or the open source\n'slidetext': ''\n'from': 'index'\n'score': 57.33500289916992\n'normalizedScore': 0.5733500289916992\n'beforeDatePenaltyScore': 0.5733500289916992\n\n'documentId': '1fed2c6361980d606789e315'\n'chunk_id': '68c26fcc0a53cd001394ab98'\n'access': 'granted'\n'part_number': 8\n'total_parts': 8\n'contentType': 'READ'\n'title': Manfred Steyer on Angular 20: Signals, Dynamic Components, AI, and What’s Next - Exploring selectorless components, signal-based forms, and other features in Angular\n'parentName': iJS Magazine Volume 19\n'language': 'EN'\n'date': '2025-06-24T22:00:00.000Z'\n'abstract': In this interview, GDE Manfred Steyer highlights Angular’s journey towards a more reactive future. We discuss the framework’s strengths, challenges, and what’s ahead with the release of Angular 20.\n'parentId': 'a1269c65e87d5b8ebcde4b28'\n'parentDescription': Broaden your knowledge and expand your JavaScript techniques and practices. From Angular, React, and WebAssembly, to the best JavaScript IDEs, open source tools and more, you’ll learn insights on everything JS from seasoned experts in their field. Keep up with JavaScript news, tips, and advice with interviews, tutorials, and in-depth articles.\n'indexBrandName': ''\n'indexSeriesName': ''\n'author': 'Manfred Steyer'\n'chunkSource': 'text'\n'text': learn to use AI models, whether they’re on the server side or directly in the browser. The idea is to delegate certain tasks to these models to create more value for the user, like automatically filling out forms, inferring values, analysing images—things like that. For instance, when I report my activities for the GDE program, I have to estimate how many people attended my conference talks. I could just upload a photo, have an AI count the people in it, and get a much more accurate number. I think there’s more we can do to improve the overall user experience, especially by removing repetitive tasks for the user. Another area of improvement is developer experience, where tools like GitHub and Copilot are changing how we write code, making it faster and more intuitive. Ines Chargui: This is definitely promising. Is there anything else you'd like to add about Angular? Manfred Steyer: One last thing: it’s now possible to create components on the fly with dynamic components. That wasn’t really possible before because Angular is a compiled language, so generating components at runtime wasn’t officially supported. Of course, if you understand what the compiler is doing at compile time, you can hack together something similar at runtime to get dynamic components—but again, that was never officially supported. Now, we get an official API for it, which is exciting. Ines Chargui: Thank you so much for taking the time to chat!\n'slidetext': ''\n'from': 'index'\n'score': 57.289920806884766\n'normalizedScore': 0.5728992080688476\n'beforeDatePenaltyScore': 0.5728992080688476\n\n'documentId': '43b7900e7154d2f13c41085b'\n'chunk_id': '6876d2a2225e92fc1ac797fa'\n'access': 'granted'\n'part_number': 4\n'total_parts': 6\n'contentType': 'COURSE'\n'title': Exploring httpResource in Angular 19.2\n'parentName': Advanced Angular: Signals, NgRx & AI Forms\n'language': 'DE'\n'date': '2025-05-02T10:49:04.000Z'\n'abstract': The introduction of *httpResource* in Angular 19.2 brings a new way to load data seamlessly within the reactive flow. Let's explore how this experimental feature can be leveraged to enhance your applications.\n'parentId': '5e78d57fd77e42835f9996dc'\n'parentDescription': Level up your Angular skills with this advanced course, highlighting the framework’s evolving features. We will cover cutting-edge topics, from mastering state management with the NgRx Signal store and unlocking AI-enhanced forms’ potential, to revisiting the performance benefits of server-side rendering. You will learn how to effectively use Signals through professional tips and real-world insights, and explore emerging features like httpResource in Angular 19.2. Whether you are scaling enterprise apps or upgrading legacy codebases, this course equips you with the practices to build smarter, faster Angular applications and stay ahead in today’s Angular ecosystem.\n'indexBrandName': 'InternationalJavaScriptCon'\n'indexSeriesName': ''\n'author': 'Manfred Steyer'\n'chunkSource': 'text'\n'text': Figure 4: Reactive flow of ngMario The signals levelKey, style, and animation represent the user input. The first two correspond to the drop-down fields at the top of the application. The animation signal contains a Boolean that indicates whether the animation was started by clicking the Toggle Animation button (see screenshots above). The tilesResource is a classic resource that derives the individual tiles for the selected style from the tilemap. To do this, it essentially delegates to a function of the game engine, which is treated as a black box here. The rendering is triggered by an effect, especially since we cannot draw the level directly using data binding. It draws or animates the level on a canvas, which the application retrieves as a signal-based viewChild. Angular then calls the effect whenever the level (provided by the levelResource), the style, the animation flag, or the canvas changes. A tilesMapProgress signal uses the progress information provided by tilesMapResource to indicate how much of the tilesmap has already been downloaded. To load the list of available levels, the example uses a levelOverviewResource that is not directly connected to the reactive graph discussed so far. Listing 6 shows the implementation of this reactive flow in the form of fields of the LevelComponent. Listing 6: export class LevelComponent implements OnDestroy { private tilesMapLoader = inject(TilesMapLoader); private levelLoader = inject(LevelLoader); canvas = viewChild<elementref>('canvas'); levelKey = linkedSignal(() => this.getFirstLevelKey()); style = signal</elementref\n'slidetext': ''\n'from': 'index'\n'score': 57.179046630859375\n'normalizedScore': 0.5717904663085938\n'beforeDatePenaltyScore': 0.5717904663085938\n\n'documentId': '9836770500f149a58b7769f9'\n'chunk_id': '68ad7e39494be90012217fec'\n'access': 'granted'\n'part_number': 6\n'total_parts': 6\n'contentType': 'READ'\n'title': Professional Tips for Using Signals in Angular - Enterprise Angular\n'parentName': iJS Magazine Volume 17\n'language': 'EN'\n'date': '2025-02-25T23:00:00.000Z'\n'abstract': The new Signals in Angular are a simple reactive building block. However, as is so often the case, the devil is in the detail. In this article, I will give three tips to help you use Signals in a more straightforward way.\n'parentId': '2b07605113b7a8ed6aeea755'\n'parentDescription': Broaden your knowledge and expand your JavaScript techniques and practices. From Angular, React, and WebAssembly, to the best JavaScript IDEs, open source tools and more, you’ll learn insights on everything JS from seasoned experts in their field. Keep up with JavaScript news, tips, and advice with interviews, tutorials, and in-depth articles.\n'indexBrandName': ''\n'indexSeriesName': ''\n'author': 'Manfred Steyer'\n'chunkSource': 'text'\n'text': source library ngxtension, which offers many extra functions for Signals. To summarize RxJS and Signals harmonize wonderfully together and the RxJS interop from Angular gives us the best of both worlds. Using RxJS is recommended for representing events. For processing asynchronous tasks, RxJS or stores (which can be based on RxJS) are recommended. The synchronous transport of data to the view should be handled by Signals. Together, RxJS, stores, and Signals are the building blocks for establishing a unidirectional data flow. The flattening operators in RxJS can also elegantly avoid race conditions. Alternatively or in addition to this, flags can be used to indicate if a request is currently in progress at the backend. Even if Signals weren’t primarily created to display events, there are cases when you want to react to changes in a Signal. This is the case with framework APIs based on Signals. In addition to the RxJS interop, the rxMethod from the Signal Store can also be used. Another option is the effect/untracked pattern for implementing effects that only react to explicitly named Signals.\n'slidetext': ''\n'from': 'index'\n'score': 56.795475006103516\n'normalizedScore': 0.5679547500610351\n'beforeDatePenaltyScore': 0.5679547500610351\n\n'documentId': '8b124d1f8a4b51f23acbc7f1'\n'chunk_id': '690b38892e2492001343de86'\n'access': 'restricted'\n'part_number': 1\n'total_parts': 1\n'contentType': 'CAMP'\n'title': Tag 2: Erweiterte Angular-Direktiven, Modernes Angular und Erweiterte Angular-Routing-Techniken (Lektion 3, 4 & 5)\n'parentName': Angular Camp - Deep Dive Camp Intense Dezember 2025 | Online\n'language': 'DE'\n'date': '2025-12-02T08:30:00.000Z'\n'abstract': Erweitern Sie Ihre Angular-Expertise und lernen Sie in diesem spannenden Trainingsabschnitt die vielfältigen Möglichkeiten von Angular-Direktiven, die neuesten Features des modernen Angular und wie Sie komplexe und effiziente Routing-Systeme kreieren. Lektion 3: Erweiterte Angular-Direktiven & Modernes Angular: Attribute, Strukturen, Templates und mehr Die nächste Lektion beschäftigt sich mit den vielfältigen verschiedenen Arten von Angular-Direktiven, die sie für die Erstellung dynamischer und wiederverwendbarer Templates bietet, z.B.: Attribut-, Struktur- und Komponenten-Direktiven. Das erwartet Sie in dieser Lektion: - Attribut-Direktiven für Querschnittsfunktionen - Strukturelle Direktiven - Templates und Container - Microsyntax - Templates zur Laufzeit referenzieren Lektion 4: Angular auf dem neuesten Stand: Standalone Components, Signals und mehr Tauchen Sie in in die Welt des Modern Angular und entdecken die neuesten Features und Techniken für die Entwicklung moderner, performanter und skalierbarer Webanwendungen. Alle wichtigen Themen auf einen Blick: - Architekturen mit Standalone Components - Reaktive Systeme mit Signals - Performance mit Signal Components - Moderne Change Detection mit Signals und Signal Components: Was ändert sich? - Schnellere Builds mit esbuild - Projekt-Strukturen mit Sheriff Lektion 5: Erweiterte Angular-Routing-Techniken: Child-Routes, Aux Routes, Lazy Routes und weitere Fast geschafft. Hier erfahren Sie alles, was Sie wissen müssen, um komplexe und effiziente Routing-Systeme für Ihre Angular-Webanwendungen zu entwickeln. Sie starten mit den Grundlagen des hierarchischen Routings mit Angular, steuern die Zugriffe und werden Profi, um auf Routing-Änderungen reagieren zu können. - Hierarchisches Routing mit Child-Routes - Aux Routes - Lazy Routes - Guards - Resolver - Router Events - Custom Url-Matchers\n'parentId': '93c77279759adfdb48c0b856'\n'parentDescription': Das Angular Camp für Fortgeschrittene mit Andre Dickenscheidt im 3-tägigen Intensiv-Training\n'indexBrandName': 'AngularCamp'\n'indexSeriesName': 'IntenseDeepDive'\n'author': 'André Wilke'\n'chunkSource': 'text'\n'text': Tag 2: Erweiterte Angular-Direktiven, Modernes Angular und Erweiterte Angular-Routing-Techniken (Lektion 3, 4 & 5) Erweitern Sie Ihre Angular-Expertise und lernen Sie in diesem spannenden Trainingsabschnitt die vielfältigen Möglichkeiten von Angular-Direktiven, die neuesten Features des modernen Angular und wie Sie komplexe und effiziente Routing-Systeme kreieren. Lektion 3: Erweiterte Angular-Direktiven & Modernes Angular: Attribute, Strukturen, Templates und mehr Die nächste Lektion beschäftigt sich mit den vielfältigen verschiedenen Arten von Angular-Direktiven, die sie für die Erstellung dynamischer und wiederverwendbarer Templates bietet, z.B.: Attribut-, Struktur- und Komponenten-Direktiven. Das erwartet Sie in dieser Lektion: - Attribut-Direktiven für Querschnittsfunktionen - Strukturelle Direktiven - Templates und Container - Microsyntax - Templates zur Laufzeit referenzieren Lektion 4: Angular auf dem neuesten Stand: Standalone Components, Signals und mehr Tauchen Sie in in die Welt des Modern Angular und entdecken die neuesten Features und Techniken für die Entwicklung moderner, performanter und skalierbarer Webanwendungen. Alle wichtigen Themen auf einen Blick: - Architekturen mit Standalone Components - Reaktive Systeme mit Signals - Performance mit Signal Components - Moderne Change Detection mit Signals und Signal Components: Was ändert sich? - Schnellere Builds mit esbuild - Projekt-Strukturen mit Sheriff Lektion 5: Erweiterte Angular-Routing-Techniken: Child-Routes, Aux Routes, Lazy Routes und weitere Fast geschafft. Hier erfahren Sie alles, was Sie wissen müssen, um komplexe und effiziente Routing-Systeme für Ihre Angular-Webanwendungen zu entwickeln. Sie starten mit den Grundlagen des hierarchischen Routings mit Angular, steuern die Zugriffe und werden Profi, um auf Routing-Änderungen reagieren zu können. - Hierarchisches Routing mit Child-Routes - Aux Routes - Lazy Routes - Guards - Resolver - Router Events - Custom Url-Matchers\n'slidetext': ''\n'from': 'index'\n'score': 56.63596725463867\n'normalizedScore': 0.5663596725463867\n'beforeDatePenaltyScore': 0.5663596725463867\n\n'documentId': 'ffe46902112505d5bdec0031'\n'chunk_id': '6876e1af7899910dd58c1c2c'\n'access': 'restricted'\n'part_number': 1\n'total_parts': 1\n'contentType': 'CAMP'\n'title': Tag 2: Erweiterte Angular-Direktiven, Modernes Angular und Erweiterte Angular-Routing-Techniken (Lektion 3, 4 & 5)\n'parentName': Angular Camp - Deep Dive Camp Intense September 2025 | München\n'language': 'DE'\n'date': '2025-09-16T07:00:00.000Z'\n'abstract': Erweitern Sie Ihre Angular-Expertise und lernen Sie in diesem spannenden Trainingsabschnitt die vielfältigen Möglichkeiten von Angular-Direktiven, die neuesten Features des modernen Angular und wie Sie komplexe und effiziente Routing-Systeme kreieren. Lektion 3: Erweiterte Angular-Direktiven & Modernes Angular: Attribute, Strukturen, Templates und mehr Die nächste Lektion beschäftigt sich mit den vielfältigen verschiedenen Arten von Angular-Direktiven, die sie für die Erstellung dynamischer und wiederverwendbarer Templates bietet, z.B.: Attribut-, Struktur- und Komponenten-Direktiven. Das erwartet Sie in dieser Lektion: - Attribut-Direktiven für Querschnittsfunktionen - Strukturelle Direktiven - Templates und Container - Microsyntax - Templates zur Laufzeit referenzieren Lektion 4: Angular auf dem neuesten Stand: Standalone Components, Signals und mehr Tauchen Sie in in die Welt des Modern Angular und entdecken die neuesten Features und Techniken für die Entwicklung moderner, performanter und skalierbarer Webanwendungen. Alle wichtigen Themen auf einen Blick: - Architekturen mit Standalone Components - Reaktive Systeme mit Signals - Performance mit Signal Components - Moderne Change Detection mit Signals und Signal Components: Was ändert sich? - Schnellere Builds mit esbuild - Projekt-Strukturen mit Sheriff Lektion 5: Erweiterte Angular-Routing-Techniken: Child-Routes, Aux Routes, Lazy Routes und weitere Fast geschafft. Hier erfahren Sie alles, was Sie wissen müssen, um komplexe und effiziente Routing-Systeme für Ihre Angular-Webanwendungen zu entwickeln. Sie starten mit den Grundlagen des hierarchischen Routings mit Angular, steuern die Zugriffe und werden Profi, um auf Routing-Änderungen reagieren zu können. - Hierarchisches Routing mit Child-Routes - Aux Routes - Lazy Routes - Guards - Resolver - Router Events - Custom Url-Matchers\n'parentId': '3791de9cb4cc670970c79310'\n'parentDescription': Das Angular Camp für Fortgeschrittene mit Manfred Steyer im 3-tägigen Intensiv-Training\n'indexBrandName': 'AngularCamp'\n'indexSeriesName': 'IntenseDeepDive'\n'author': 'Manfred Steyer'\n'chunkSource': 'text'\n'text': Tag 2: Erweiterte Angular-Direktiven, Modernes Angular und Erweiterte Angular-Routing-Techniken (Lektion 3, 4 & 5) Erweitern Sie Ihre Angular-Expertise und lernen Sie in diesem spannenden Trainingsabschnitt die vielfältigen Möglichkeiten von Angular-Direktiven, die neuesten Features des modernen Angular und wie Sie komplexe und effiziente Routing-Systeme kreieren. Lektion 3: Erweiterte Angular-Direktiven & Modernes Angular: Attribute, Strukturen, Templates und mehr Die nächste Lektion beschäftigt sich mit den vielfältigen verschiedenen Arten von Angular-Direktiven, die sie für die Erstellung dynamischer und wiederverwendbarer Templates bietet, z.B.: Attribut-, Struktur- und Komponenten-Direktiven. Das erwartet Sie in dieser Lektion: - Attribut-Direktiven für Querschnittsfunktionen - Strukturelle Direktiven - Templates und Container - Microsyntax - Templates zur Laufzeit referenzieren Lektion 4: Angular auf dem neuesten Stand: Standalone Components, Signals und mehr Tauchen Sie in in die Welt des Modern Angular und entdecken die neuesten Features und Techniken für die Entwicklung moderner, performanter und skalierbarer Webanwendungen. Alle wichtigen Themen auf einen Blick: - Architekturen mit Standalone Components - Reaktive Systeme mit Signals - Performance mit Signal Components - Moderne Change Detection mit Signals und Signal Components: Was ändert sich? - Schnellere Builds mit esbuild - Projekt-Strukturen mit Sheriff Lektion 5: Erweiterte Angular-Routing-Techniken: Child-Routes, Aux Routes, Lazy Routes und weitere Fast geschafft. Hier erfahren Sie alles, was Sie wissen müssen, um komplexe und effiziente Routing-Systeme für Ihre Angular-Webanwendungen zu entwickeln. Sie starten mit den Grundlagen des hierarchischen Routings mit Angular, steuern die Zugriffe und werden Profi, um auf Routing-Änderungen reagieren zu können. - Hierarchisches Routing mit Child-Routes - Aux Routes - Lazy Routes - Guards - Resolver - Router Events - Custom Url-Matchers\n'slidetext': ''\n'from': 'index'\n'score': 56.63596725463867\n'normalizedScore': 0.5663596725463867\n'beforeDatePenaltyScore': 0.5663596725463867\n\n'documentId': 'c8af1d2c9d8e08acaa09599f'\n'chunk_id': '68c26ff80a53cd001394abf5'\n'access': 'granted'\n'part_number': 1\n'total_parts': 4\n'contentType': 'READ'\n'title': Custom Standalone APIs for Angular - Enterprise Angular\n'parentName': iJS Magazine Volume 19\n'language': 'EN'\n'date': '2025-06-24T22:00:00.000Z'\n'abstract': Together with standalone components, the Angular team has introduced the so-called standalone APIs. They provide a simple solution for library setup and do not require Angular modules.\n'parentId': 'a1269c65e87d5b8ebcde4b28'\n'parentDescription': Broaden your knowledge and expand your JavaScript techniques and practices. From Angular, React, and WebAssembly, to the best JavaScript IDEs, open source tools and more, you’ll learn insights on everything JS from seasoned experts in their field. Keep up with JavaScript news, tips, and advice with interviews, tutorials, and in-depth articles.\n'indexBrandName': ''\n'indexSeriesName': ''\n'author': 'Manfred Steyer'\n'chunkSource': 'text'\n'text': Custom Standalone APIs for Angular Enterprise Angular Together with standalone components, the Angular team has introduced the so-called standalone APIs. They provide a simple solution for library setup and do not require Angular modules. Together with standalone components, the Angular team has introduced the so-called standalone APIs. They provide a simple solution for library setup and do not require Angular modules. Popular libraries that already implement this concept include the HttpClient, Router, and NgRx. These libraries are based on several patterns that we find beneficial in our own projects. They also provide our library users with familiar structures and behaviors. In this article, I show three such patterns that I derived from the libraries mentioned. The source code and examples are available here. Example A simple logger library is used here to show the different patterns (Fig. 1). The LogFormatter formats the messages before the Logger publishes them. This is an abstract class that is used as a DI token. The consumers of the logger library can customize the formatting by providing their own implementation. Alternatively, they can settle for a default implementation provided by the library. Fig. 1: Structure of an exemplary Logger library The LogAppender is another replaceable concept that takes care of attaching the message to a log. The default implementation just writes the message to the console. While there can be only one LogFormatter, the library supports multiple LogAppenders. For example, the first LogAppender might write the message to the console, while the second also sends it to the server. To make this possible, each LogAppender is registered via a multiprovider. The injector returns all registered LogAppenders in the form of an array. Since an array cannot be used as a DI token, the example uses an InjectionToken instead: export const LOG_APPENDERS = new InjectionToken('LOG_APPENDERS'); An abstract LoggerConfig, which also acts as a DI token, defines the possible configuration options (Listing 1). Listing 1 export abstract class LoggerConfig { abstract level: LogLevel; abstract formatter: Type; abstract appenders: Type[]; } export const defaultConfig: LoggerConfig = { level: LogLevel.DEBUG, formatter: DefaultLogFormatter, appenders: [DefaultLogAppender], }; The default values for these configuration options are in the defaultConfig constant. The LogLevel in the configuration is a filter for log messages. It is of type enum and has for simplification only the values DEBUG, INFO and ERROR: export enum LogLevel { DEBUG = 0, INFO = 1, ERROR = 2, } The Logger only publishes messages that have the LogLevel specified here or a higher LogLevel. The LoggerService itself receives the LoggerConfig, the LogFormatter and an array with LogAppender via DI and uses them to log the received\n'slidetext': ''\n'from': 'index'\n'score': 56.62080383300781\n'normalizedScore': 0.5662080383300782\n'beforeDatePenaltyScore': 0.5662080383300782\n\n'documentId': 'b8bf349a24030fa6f49599de'\n'chunk_id': '6876da19225e92fc1ac7c15d'\n'access': 'restricted'\n'part_number': 1\n'total_parts': 1\n'contentType': 'CAMP'\n'title': Tag 2: Erweiterte Angular-Direktiven, Modernes Angular und Erweiterte Angular-Routing-Techniken (Lektion 3, 4 & 5)\n'parentName': Angular Camp - Deep Dive Camp Intense Februar 2025 | Online\n'language': 'DE'\n'date': '2025-02-18T08:00:00.000Z'\n'abstract': Erweitern Sie Ihre Angular-Expertise und lernen Sie in diesem spannenden Trainingsabschnitt die vielfältigen Möglichkeiten von Angular-Direktiven, die neuesten Features des modernen Angular und wie Sie komplexe und effiziente Routing-Systeme kreieren. Lektion 3: Erweiterte Angular-Direktiven & Modernes Angular: Attribute, Strukturen, Templates und mehr Die nächste Lektion beschäftigt sich mit den vielfältigen verschiedenen Arten von Angular-Direktiven, die sie für die Erstellung dynamischer und wiederverwendbarer Templates bietet, z.B.: Attribut-, Struktur- und Komponenten-Direktiven. Das erwartet Sie in dieser Lektion: - Attribut-Direktiven für Querschnittsfunktionen - Strukturelle Direktiven - Templates und Container - Microsyntax - Templates zur Laufzeit referenzieren Lektion 4: Angular auf dem neuesten Stand: Standalone Components, Signals und mehr Tauchen Sie in in die Welt des Modern Angular und entdecken die neuesten Features und Techniken für die Entwicklung moderner, performanter und skalierbarer Webanwendungen. Alle wichtigen Themen auf einen Blick: - Architekturen mit Standalone Components - Reaktive Systeme mit Signals - Performance mit Signal Components - Moderne Change Detection mit Signals und Signal Components: Was ändert sich? - Schnellere Builds mit esbuild - Projekt-Strukturen mit Sheriff Lektion 5: Erweiterte Angular-Routing-Techniken: Child-Routes, Aux Routes, Lazy Routes und weitere Fast geschafft. Hier erfahren Sie alles, was Sie wissen müssen, um komplexe und effiziente Routing-Systeme für Ihre Angular-Webanwendungen zu entwickeln. Sie starten mit den Grundlagen des hierarchischen Routings mit Angular, steuern die Zugriffe und werden Profi, um auf Routing-Änderungen reagieren zu können. - Hierarchisches Routing mit Child-Routes - Aux Routes - Lazy Routes - Guards - Resolver - Router Events - Custom Url-Matchers\n'parentId': '06531a7f8e4748acac13fd75'\n'parentDescription': Das Angular Camp für Fortgeschrittene mit Manfred Steyer im 3-tägigen Intensiv-Training im Online-Format\n'indexBrandName': 'AngularCamp'\n'indexSeriesName': 'IntenseDeepDive'\n'author': 'Manfred Steyer'\n'chunkSource': 'text'\n'text': Tag 2: Erweiterte Angular-Direktiven, Modernes Angular und Erweiterte Angular-Routing-Techniken (Lektion 3, 4 & 5) Erweitern Sie Ihre Angular-Expertise und lernen Sie in diesem spannenden Trainingsabschnitt die vielfältigen Möglichkeiten von Angular-Direktiven, die neuesten Features des modernen Angular und wie Sie komplexe und effiziente Routing-Systeme kreieren. Lektion 3: Erweiterte Angular-Direktiven & Modernes Angular: Attribute, Strukturen, Templates und mehr Die nächste Lektion beschäftigt sich mit den vielfältigen verschiedenen Arten von Angular-Direktiven, die sie für die Erstellung dynamischer und wiederverwendbarer Templates bietet, z.B.: Attribut-, Struktur- und Komponenten-Direktiven. Das erwartet Sie in dieser Lektion: - Attribut-Direktiven für Querschnittsfunktionen - Strukturelle Direktiven - Templates und Container - Microsyntax - Templates zur Laufzeit referenzieren Lektion 4: Angular auf dem neuesten Stand: Standalone Components, Signals und mehr Tauchen Sie in in die Welt des Modern Angular und entdecken die neuesten Features und Techniken für die Entwicklung moderner, performanter und skalierbarer Webanwendungen. Alle wichtigen Themen auf einen Blick: - Architekturen mit Standalone Components - Reaktive Systeme mit Signals - Performance mit Signal Components - Moderne Change Detection mit Signals und Signal Components: Was ändert sich? - Schnellere Builds mit esbuild - Projekt-Strukturen mit Sheriff Lektion 5: Erweiterte Angular-Routing-Techniken: Child-Routes, Aux Routes, Lazy Routes und weitere Fast geschafft. Hier erfahren Sie alles, was Sie wissen müssen, um komplexe und effiziente Routing-Systeme für Ihre Angular-Webanwendungen zu entwickeln. Sie starten mit den Grundlagen des hierarchischen Routings mit Angular, steuern die Zugriffe und werden Profi, um auf Routing-Änderungen reagieren zu können. - Hierarchisches Routing mit Child-Routes - Aux Routes - Lazy Routes - Guards - Resolver - Router Events - Custom Url-Matchers\n'slidetext': ''\n'from': 'index'\n'score': 56.56400680541992\n'normalizedScore': 0.5656400680541992\n'beforeDatePenaltyScore': 0.5656400680541992\n\n'documentId': 'dcce136001b8cf2cfe8b5498'\n'chunk_id': '6876df207899910dd58c0ea2'\n'access': 'granted'\n'part_number': 7\n'total_parts': 7\n'contentType': 'READ'\n'title': Die neue httpResource in Angular 19.2 - Kolumne: Enterprise Angular\n'parentName': iJS Magazin 2.2025\n'language': 'DE'\n'date': '2025-03-25T23:00:00.000Z'\n'abstract': Angular 19.2 beinhaltet nun die neue httpResource, die es erlaubt, Daten innerhalb des reaktiven Flusses zu laden. Dieser Artikel zeigt, wie sich dieses - derzeit experimentelle - Feature nutzen lässt. Als Beispiel dient eine einfache Anwendung, die durch Levels, im Stil des Spiels „Super Mario“, scrollt. Jedes Level besteht aus Kacheln, die in vier verschiedenen Stilen zur Verfügung stehen: Overworld, Underground, Underwater und Castle. In unserer Implementierung können Benutzer:innen frei zwischen diesen Stilen wechseln. Abbildung 1 zeigt zum Beispiel das erste Level im Stil Overworld an. Abbildung 2 zeigt dasselbe Level im Stil Underground.\n'parentId': '7cb807973ada8ce87de439aa'\n'parentDescription': Kaum ein Softwareprojekt, das nicht in wesentlichen Teilen auf der JavaScript-Technologie basiert. Eine breite Unterstützung sowie, leistungsfähige Programmiersprachen, die Vielzahl moderner Tools, sowie ausgereifte Frameworks wie Angular, React, Vue.js oder Node.js machen den JavaScript-Werkzeugkasten zu einem Alleskönner. Das iJS Magazin informiert aktuell und umfassend über die wichtige und innovative Entwicklungen im JavaScript-Universum und bietet handfeste Praxisinformationen für Softwareentwickler und -architekten.\n'indexBrandName': ''\n'indexSeriesName': ''\n'author': 'Manfred Steyer'\n'chunkSource': 'text'\n'text': console.log(this.levelOverviewResource.headers()?.keys()); Darüber hinaus stellt die httpResource alles zur Verfügung, was auch von gewöhnlichen Resources bekannt ist, darunter ein error-Signal, das über einen eventuell aufgetretenen Fehler informiert sowie die Möglichkeit, den value zu aktualisieren, der als lokale Arbeitskopie vorliegt. Zusammenfassung Die neue httpResource ist ein weiterer Baustein, der Angulars neue Signal-Story ergänzt. Sie ermöglicht das Laden von Daten innerhalb des reaktiven Graphen. Derzeit verwendet sie den HttpClient als Implementierungsdetail, der eventuell zu einem späteren Zeitpunkt durch eine andere Lösung ersetzt wird. Während die HTTP-Resource auch das Abrufen von Daten mit HTTP-Verben jenseits von GET ermöglicht, ist sie nicht für das Zurückschreiben von Daten zum Server ausgelegt. Diese Aufgabe gilt es weiterhin auf herkömmliche Weise zu erledigen. Links & Literatur [1] https://github.com/manfredsteyer/mario.git [2] https://zod.dev/ [3] https://www.spriters-resource.com/nes/supermariobros/sheet/52571\n'slidetext': ''\n'from': 'index'\n'score': 56.52215576171875\n'normalizedScore': 0.5652215576171875\n'beforeDatePenaltyScore': 0.5652215576171875\n\n'documentId': 'dcce136001b8cf2cfe8b5498'\n'chunk_id': '6876df207899910dd58c0e9f'\n'access': 'granted'\n'part_number': 4\n'total_parts': 7\n'contentType': 'READ'\n'title': Die neue httpResource in Angular 19.2 - Kolumne: Enterprise Angular\n'parentName': iJS Magazin 2.2025\n'language': 'DE'\n'date': '2025-03-25T23:00:00.000Z'\n'abstract': Angular 19.2 beinhaltet nun die neue httpResource, die es erlaubt, Daten innerhalb des reaktiven Flusses zu laden. Dieser Artikel zeigt, wie sich dieses - derzeit experimentelle - Feature nutzen lässt. Als Beispiel dient eine einfache Anwendung, die durch Levels, im Stil des Spiels „Super Mario“, scrollt. Jedes Level besteht aus Kacheln, die in vier verschiedenen Stilen zur Verfügung stehen: Overworld, Underground, Underwater und Castle. In unserer Implementierung können Benutzer:innen frei zwischen diesen Stilen wechseln. Abbildung 1 zeigt zum Beispiel das erste Level im Stil Overworld an. Abbildung 2 zeigt dasselbe Level im Stil Underground.\n'parentId': '7cb807973ada8ce87de439aa'\n'parentDescription': Kaum ein Softwareprojekt, das nicht in wesentlichen Teilen auf der JavaScript-Technologie basiert. Eine breite Unterstützung sowie, leistungsfähige Programmiersprachen, die Vielzahl moderner Tools, sowie ausgereifte Frameworks wie Angular, React, Vue.js oder Node.js machen den JavaScript-Werkzeugkasten zu einem Alleskönner. Das iJS Magazin informiert aktuell und umfassend über die wichtige und innovative Entwicklungen im JavaScript-Universum und bietet handfeste Praxisinformationen für Softwareentwickler und -architekten.\n'indexBrandName': ''\n'indexSeriesName': ''\n'author': 'Manfred Steyer'\n'chunkSource': 'text'\n'text': Funktion toLevel verwendet. Daneben erlaubt map auch das Einbinden von Bibliotheken wie Zod [2], die eine Schemavalidierung durchführen. Laden von Daten jenseits von JSON Die httpResource erwartet standardmäßig ein JSON-Dokument, das sie in ein JavaScript-Objekt konvertiert. Daneben bietet sie weitere Methoden, die andere Darstellungsformen liefern: - httpResource.text gibt Text zurück - httpResource.blob gibt die abgerufenen Daten als Blob zurück - httpResource.arrayBuffer gibt die abgerufenen Daten als ArrayBuffer zurück Um den Einsatz dieser Möglichkeiten zu demonstrieren, fordert das hier besprochene Beispiel ein Bild mit allen möglichen Kacheln als Blob an. Aus diesem Blob leitet es die benötigten Kacheln für den gewählten Level-Stil ab. Abbildung 3 zeigt einen Ausschnitt dieser von [3] übernommenen Tilemap und verdeutlicht, dass die Anwendung durch die Wahl eines horizontalen bzw. vertikalen Offsets zwischen den einzelnen Stilen wechseln kann. Abb. 3: Ausschnitt der im Beispiel verwendeten Tilemap Zum Laden der Tilemap delegiert ein TilesMapLoader an httpResource.blob (Listing 5). Listing 5 @Injectable({ providedIn: 'root' }) export class TilesMapLoader { getTilesMapResource(): HttpResourceRef { return httpResource.blob({ url: '/tiles.png', reportProgress: true, }); } } Diese Resource fordert auch Fortschrittsinformationen an und greift das Beispiel auf, um die Fortschrittsinformationen links neben den Dropdown-Feldern anzuzeigen. Alles zusammen: reaktiver Fluss Die in den letzten Abschnitten beschriebenen httpResources lassen sich nun zum reaktiven Graphen der Anwendung zusammenfügen (Abb. 4). Abb. 4: Reaktiver Fluss von ngMario Die Signale levelKey, style und animation repräsentieren die Benutzereingaben. Die ersten beiden entsprechen den Dropdown-Feldern im oberen Bereich der Anwendung. Das Signal animation enthält einen Boolean, der angibt, ob die Animation per Klick auf die Schaltfläche Toggle Animation gestartet wurde (siehe Screenshots oben). Die tilesResource ist eine klassische Resource, die die einzelnen Kacheln für den gewählten Stil aus der Tilemap ableitet. Dazu delegiert sie im Wesentlichen an eine Funktion der hier als Blackbox behandelten Game Engine. Das Rendering wird durch einen Effect angestoßen, zumal wir das Level nicht direkt mittels Datenbindung zeichnen können. Er zeichnet oder animiert das Level auf einem Canvas, den die Anwendung als Signal-basiertes viewChild abruft. Angular\n'slidetext': ''\n'from': 'index'\n'score': 56.35037612915039\n'normalizedScore': 0.5635037612915039\n'beforeDatePenaltyScore': 0.5635037612915039\n\n'documentId': 'dcce136001b8cf2cfe8b5498'\n'chunk_id': '6876df207899910dd58c0e9d'\n'access': 'granted'\n'part_number': 2\n'total_parts': 7\n'contentType': 'READ'\n'title': Die neue httpResource in Angular 19.2 - Kolumne: Enterprise Angular\n'parentName': iJS Magazin 2.2025\n'language': 'DE'\n'date': '2025-03-25T23:00:00.000Z'\n'abstract': Angular 19.2 beinhaltet nun die neue httpResource, die es erlaubt, Daten innerhalb des reaktiven Flusses zu laden. Dieser Artikel zeigt, wie sich dieses - derzeit experimentelle - Feature nutzen lässt. Als Beispiel dient eine einfache Anwendung, die durch Levels, im Stil des Spiels „Super Mario“, scrollt. Jedes Level besteht aus Kacheln, die in vier verschiedenen Stilen zur Verfügung stehen: Overworld, Underground, Underwater und Castle. In unserer Implementierung können Benutzer:innen frei zwischen diesen Stilen wechseln. Abbildung 1 zeigt zum Beispiel das erste Level im Stil Overworld an. Abbildung 2 zeigt dasselbe Level im Stil Underground.\n'parentId': '7cb807973ada8ce87de439aa'\n'parentDescription': Kaum ein Softwareprojekt, das nicht in wesentlichen Teilen auf der JavaScript-Technologie basiert. Eine breite Unterstützung sowie, leistungsfähige Programmiersprachen, die Vielzahl moderner Tools, sowie ausgereifte Frameworks wie Angular, React, Vue.js oder Node.js machen den JavaScript-Werkzeugkasten zu einem Alleskönner. Das iJS Magazin informiert aktuell und umfassend über die wichtige und innovative Entwicklungen im JavaScript-Universum und bietet handfeste Praxisinformationen für Softwareentwickler und -architekten.\n'indexBrandName': ''\n'indexSeriesName': ''\n'author': 'Manfred Steyer'\n'chunkSource': 'text'\n'text': ist jedoch lediglich ein Implementierungsdetail, das Angular eventuell irgendwann durch eine andere Implementierung ersetzt. Level-Dateien Die verschiedenen Levels beschreibt unser Beispiel mit JSON-Dateien, die definieren, welche Kacheln an welchen Koordinaten darzustellen sind (Listing 1). Listing 1 { 'levelId': 1, 'backgroundColor': '#9494ff', 'items': [ { 'tileKey': 'floor', 'col': 0, 'row': 13, [...] }, { 'tileKey': 'cloud', 'col': 12, 'row': 1, [...] }, [...] ] } Diese Koordinaten definieren Positionen innerhalb einer Matrix von Blöcken mit 16x16 Pixeln. Neben diesen Leveldateien liegt eine overview.json vor, die über die Namen der verfügbaren Level informiert. Ein LevelLoader kümmert sich um das Laden dieser Dateien. Dazu nutzt er die neue httpResource (Listing 2). Listing 2 @Injectable({ providedIn: 'root' }) export class LevelLoader { getLevelOverviewResource(): HttpResourceRef { return httpResource('/levels/overview.json', { defaultValue: initLevelOverview, }); } getLevelResource(levelKey: () => string | undefined): HttpResourceRef { return httpResource(() => !levelKey() ? undefined : `/levels/${levelKey()}.json`, { defaultValue: initLevel, }); } [...] } Der erste an httpResource übergebene Parameter repräsentiert die jeweilige URL; der zweite optionale Parameter nimmt ein Objekt mit weiteren Optionen auf. Dieses Objekt erlaubt unter anderem die Definition eines Standardwerts, der zum Einsatz kommt, bevor die Resource geladen wurde. Die Methode getLevelResource erwartet ein Signal mit einem levelKey, aus dem der Service den Namen der gewünschten Level-Datei ableitet. Dieses schreibgeschützte Signal liegt als Abstraktion vom Typ () => string | undefined vor. Die von getLevelResource an httpResource übergebene URL ist ein Lambda-Ausdruck, den die Resource automatisch neu auswertet, wenn sich das levelKey-Signal ändert. Im Hintergrund erzeugt httpResource daraus ein berechnetes Signal, das als Auslöser fungiert: Jedes Mal, wenn sich dieser Auslöser ändert, lädt die Resource die URL. Um das Auslösen der httpResource zu verhindern, muss dieser Lambda-Ausdruck den Wert undefined liefern. Auf diese Weise lässt sich das Laden hinauszögern, bis der levelKey zur Verfügung steht. Weitere Optionen mit HttpResourceRequest Um mehr Kontrolle über die ausgehende HTTP-Anfrage zu erhalten, kann der Aufrufer anstelle einer URL einen HttpResourceRequest übergeben (Listing 3). Listing 3 getLevelResource(levelKey: () =>\n'slidetext': ''\n'from': 'index'\n'score': 56.35037612915039\n'normalizedScore': 0.5635037612915039\n'beforeDatePenaltyScore': 0.5635037612915039\n\n'documentId': 'dcce136001b8cf2cfe8b5498'\n'chunk_id': '6876df207899910dd58c0ea0'\n'access': 'granted'\n'part_number': 5\n'total_parts': 7\n'contentType': 'READ'\n'title': Die neue httpResource in Angular 19.2 - Kolumne: Enterprise Angular\n'parentName': iJS Magazin 2.2025\n'language': 'DE'\n'date': '2025-03-25T23:00:00.000Z'\n'abstract': Angular 19.2 beinhaltet nun die neue httpResource, die es erlaubt, Daten innerhalb des reaktiven Flusses zu laden. Dieser Artikel zeigt, wie sich dieses - derzeit experimentelle - Feature nutzen lässt. Als Beispiel dient eine einfache Anwendung, die durch Levels, im Stil des Spiels „Super Mario“, scrollt. Jedes Level besteht aus Kacheln, die in vier verschiedenen Stilen zur Verfügung stehen: Overworld, Underground, Underwater und Castle. In unserer Implementierung können Benutzer:innen frei zwischen diesen Stilen wechseln. Abbildung 1 zeigt zum Beispiel das erste Level im Stil Overworld an. Abbildung 2 zeigt dasselbe Level im Stil Underground.\n'parentId': '7cb807973ada8ce87de439aa'\n'parentDescription': Kaum ein Softwareprojekt, das nicht in wesentlichen Teilen auf der JavaScript-Technologie basiert. Eine breite Unterstützung sowie, leistungsfähige Programmiersprachen, die Vielzahl moderner Tools, sowie ausgereifte Frameworks wie Angular, React, Vue.js oder Node.js machen den JavaScript-Werkzeugkasten zu einem Alleskönner. Das iJS Magazin informiert aktuell und umfassend über die wichtige und innovative Entwicklungen im JavaScript-Universum und bietet handfeste Praxisinformationen für Softwareentwickler und -architekten.\n'indexBrandName': ''\n'indexSeriesName': ''\n'author': 'Manfred Steyer'\n'chunkSource': 'text'\n'text': Das Rendering wird durch einen Effect angestoßen, zumal wir das Level nicht direkt mittels Datenbindung zeichnen können. Er zeichnet oder animiert das Level auf einem Canvas, den die Anwendung als Signal-basiertes viewChild abruft. Angular ruft den Effect immer dann auf, wenn sich das Level (bereitgestellt durch die levelResource), der Stil, das Flag animation oder der Canvas ändert. Ein tilesMapProgress-Signal verwendet die von tilesMapResource bereitgestellten Fortschrittsinformationen, um anzugeben, wie viel von der Tilesmap bereits heruntergeladen wurde. Zum Laden der Liste mit den verfügbaren Levels verwendet das Beispiel eine levelOverviewResource, die nicht direkt mit dem bisher besprochenen reaktiven Graphen verbunden ist. Listing 6 zeigt die Implementierung dieses reaktiven Flusses in Form von Feldern der LevelComponent. Listing 6 export class LevelComponent implements OnDestroy { private tilesMapLoader = inject(TilesMapLoader); private levelLoader = inject(LevelLoader); canvas = viewChild<elementref>('canvas'); levelKey = linkedSignal(() => this.getFirstLevelKey()); style = signal</elementref\n'slidetext': ''\n'from': 'index'\n'score': 56.30455780029297\n'normalizedScore': 0.5630455780029296\n'beforeDatePenaltyScore': 0.5630455780029296\n\n'documentId': '43b7900e7154d2f13c41085b'\n'chunk_id': '6876d2a2225e92fc1ac797fc'\n'access': 'granted'\n'part_number': 6\n'total_parts': 6\n'contentType': 'COURSE'\n'title': Exploring httpResource in Angular 19.2\n'parentName': Advanced Angular: Signals, NgRx & AI Forms\n'language': 'DE'\n'date': '2025-05-02T10:49:04.000Z'\n'abstract': The introduction of *httpResource* in Angular 19.2 brings a new way to load data seamlessly within the reactive flow. Let's explore how this experimental feature can be leveraged to enhance your applications.\n'parentId': '5e78d57fd77e42835f9996dc'\n'parentDescription': Level up your Angular skills with this advanced course, highlighting the framework’s evolving features. We will cover cutting-edge topics, from mastering state management with the NgRx Signal store and unlocking AI-enhanced forms’ potential, to revisiting the performance benefits of server-side rendering. You will learn how to effectively use Signals through professional tips and real-world insights, and explore emerging features like httpResource in Angular 19.2. Whether you are scaling enterprise apps or upgrading legacy codebases, this course equips you with the practices to build smarter, faster Angular applications and stay ahead in today’s Angular ecosystem.\n'indexBrandName': 'InternationalJavaScriptCon'\n'indexSeriesName': ''\n'author': 'Manfred Steyer'\n'chunkSource': 'text'\n'text': any errors that may have occurred, as well as the option to update the value that is available as a local working copy. Conclusion The new httpResource is another building block that complements Angular's new signal story. It allows data to be loaded within the reactive graph. Currently, it uses the HttpClient as an implementation detail, which may eventually be replaced by another solution at a later date. While the HTTP resource also allows data to be retrieved using HTTP verbs other than GET, it is not designed to write data back to the server. This task still needs to be done in the conventional way.\n'slidetext': ''\n'from': 'index'\n'score': 55.865135192871094\n'normalizedScore': 0.558651351928711\n'beforeDatePenaltyScore': 0.558651351928711\n\n'documentId': '43b7900e7154d2f13c41085b'\n'chunk_id': '6876d2a2225e92fc1ac797fb'\n'access': 'granted'\n'part_number': 5\n'total_parts': 6\n'contentType': 'COURSE'\n'title': Exploring httpResource in Angular 19.2\n'parentName': Advanced Angular: Signals, NgRx & AI Forms\n'language': 'DE'\n'date': '2025-05-02T10:49:04.000Z'\n'abstract': The introduction of *httpResource* in Angular 19.2 brings a new way to load data seamlessly within the reactive flow. Let's explore how this experimental feature can be leveraged to enhance your applications.\n'parentId': '5e78d57fd77e42835f9996dc'\n'parentDescription': Level up your Angular skills with this advanced course, highlighting the framework’s evolving features. We will cover cutting-edge topics, from mastering state management with the NgRx Signal store and unlocking AI-enhanced forms’ potential, to revisiting the performance benefits of server-side rendering. You will learn how to effectively use Signals through professional tips and real-world insights, and explore emerging features like httpResource in Angular 19.2. Whether you are scaling enterprise apps or upgrading legacy codebases, this course equips you with the practices to build smarter, faster Angular applications and stay ahead in today’s Angular ecosystem.\n'indexBrandName': 'InternationalJavaScriptCon'\n'indexSeriesName': ''\n'author': 'Manfred Steyer'\n'chunkSource': 'text'\n'text': = this.canvas()?.nativeElement; const animation = this.animation(); if (!tiles || !canvas) { return; } if (animation) { animateLevel({ canvas, level, tiles, }); } else { renderLevel({ canvas, level, tiles, }); } } Resources and missing parameters The tilesResource shown in the diagram discussed is simply delegated to the asynchronous extractTiles function, which the engine also provides (Listing 8). Listing 8: function createTilesResource( tilesMapResource: HttpResourceRef, style: () => Style ) { const tilesMap = tilesMapResource.value(); // undefined prevents the resource from beeing triggered const request = computed(() => !tilesMap ? undefined : { tilesMap: tilesMap, style: style(), } ); return resource({ request, loader: (params) => { const { tilesMap, style } = params.request!; return extractTiles(tilesMap, style); }, }); } This simple resource contains an interesting detail: before the tilemap is loaded, the tilesMapResource has the value undefined. However, we cannot call extractTiles without a tilesMap. The request signal takes this into account: it returns undefined if no tilesMap is available yet, so the resource does not trigger its loader. Displaying Progress The tilesMapResource was configured above to provide information about the download progress via its progress signal. A calculated signal in the LevelComponent projects it into a string for display (Listing 9). Listing 9: function calcProgress(progress: HttpProgressEvent | undefined): string { if (!progress) { return '-'; } if (progress.total) { const percent = Math.round((progress.loaded / progress.total) * 100); return percent + '%'; } const kb = Math.round(progress.loaded / 1024); return kb + ' KB'; } If the server reports the file size, this function calculates a percentage for the portion already downloaded. Otherwise, it just returns the number of kilobytes already downloaded. There is no progress information before the download starts. In this case, only a hyphen is used. To test this function, it makes sense to throttle the browser's network connection in the developer console and press the reload button in the application to instruct the resources to reload the data. Status, header, error, and more In case the application needs the status code or the headers of the HTTP response, the httpResource provides the corresponding signals: console.log(this.levelOverviewResource.status()); console.log(this.levelOverviewResource.statusCode()); console.log(this.levelOverviewResource.headers()?.keys()); In addition, the httpResource provides everything that is also known from ordinary resources, including an error signal that provides information about any errors that may have occurred, as well as the option to update the value that is available as a local working copy. Conclusion The new httpResource is another building block that complements Angular's new signal story. It allows data to be loaded within the\n'slidetext': ''\n'from': 'index'\n'score': 55.865135192871094\n'normalizedScore': 0.558651351928711\n'beforeDatePenaltyScore': 0.558651351928711\n\n'documentId': '43b7900e7154d2f13c41085b'\n'chunk_id': '6876d2a2225e92fc1ac797f9'\n'access': 'granted'\n'part_number': 3\n'total_parts': 6\n'contentType': 'COURSE'\n'title': Exploring httpResource in Angular 19.2\n'parentName': Advanced Angular: Signals, NgRx & AI Forms\n'language': 'DE'\n'date': '2025-05-02T10:49:04.000Z'\n'abstract': The introduction of *httpResource* in Angular 19.2 brings a new way to load data seamlessly within the reactive flow. Let's explore how this experimental feature can be leveraged to enhance your applications.\n'parentId': '5e78d57fd77e42835f9996dc'\n'parentDescription': Level up your Angular skills with this advanced course, highlighting the framework’s evolving features. We will cover cutting-edge topics, from mastering state management with the NgRx Signal store and unlocking AI-enhanced forms’ potential, to revisiting the performance benefits of server-side rendering. You will learn how to effectively use Signals through professional tips and real-world insights, and explore emerging features like httpResource in Angular 19.2. Whether you are scaling enterprise apps or upgrading legacy codebases, this course equips you with the practices to build smarter, faster Angular applications and stay ahead in today’s Angular ecosystem.\n'indexBrandName': 'InternationalJavaScriptCon'\n'indexSeriesName': ''\n'author': 'Manfred Steyer'\n'chunkSource': 'text'\n'text': With the reportProgress option, the caller can request information about the progress of the current operation. This is useful when downloading large files. I will discuss this in more detail below. Analyzing and validating the received data By default, the httpResource expects data in the form of JSON that matches the specified type parameter. In addition, a type assertion is used to ensure that TypeScript assumes the presence of correct types. However, it is possible to intervene in this process to provide custom logic for validating the received raw value and converting it to the desired type. To do this, the caller defines a function using the map property in the options object (Listing 4). Listing 4: getLevelResourceAlternative(levelKey: () => string) { return httpResource(() => `/levels/${levelKey()}.json`, { defaultValue: initLevel, map: (raw) => { return toLevel(raw); }, }); } The httpResource converts the received JSON into an object of type unknown and passes it to map. In our example, a simple self-written function toLevel is used. In addition, map also allows the integration of libraries such as Zod, which performs schema validation. Loading data other than JSON By default, httpResource expects a JSON document, which it converts into a JavaScript object. However, it also offers other methods that provide other forms of representation: - httpResource.text returns text - httpResource.blob returns the retrieved data as a blob - httpResource.arrayBuffer returns the retrieved data as an ArrayBuffer To demonstrate the use of these possibilities, the example discussed here requests an image with all possible tiles as a blob. From this blob, it derives the tiles required for the selected level style. Figure 3 shows a section of this tilemap and illustrates that the application can switch between the individual styles by choosing a horizontal or vertical offset. Figure 3: Section of the tilemap used in the example (Source) A TilesMapLoader delegates to httpResource.blob to load the tilemap (Listing 5). Listing 5: @Injectable({ providedIn: 'root' }) export class TilesMapLoader { getTilesMapResource(): HttpResourceRef { return httpResource.blob({ url: '/tiles.png', reportProgress: true, }); } } This resource also requests progress information and uses the example to display the progress information to the left of the drop-down fields. Putting it all together: reactive flow The httpResources described in the last sections can now be combined into the reactive graph of the application (Figure 4). Figure 4: Reactive flow of ngMario The signals levelKey, style, and animation represent the user input. The first two correspond to the drop-down fields at the top of the application. The animation signal contains a Boolean that indicates whether the animation was started\n'slidetext': ''\n'from': 'index'\n'score': 55.865135192871094\n'normalizedScore': 0.558651351928711\n'beforeDatePenaltyScore': 0.558651351928711\n\n'documentId': '43b7900e7154d2f13c41085b'\n'chunk_id': '6876d2a1225e92fc1ac797f8'\n'access': 'granted'\n'part_number': 2\n'total_parts': 6\n'contentType': 'COURSE'\n'title': Exploring httpResource in Angular 19.2\n'parentName': Advanced Angular: Signals, NgRx & AI Forms\n'language': 'DE'\n'date': '2025-05-02T10:49:04.000Z'\n'abstract': The introduction of *httpResource* in Angular 19.2 brings a new way to load data seamlessly within the reactive flow. Let's explore how this experimental feature can be leveraged to enhance your applications.\n'parentId': '5e78d57fd77e42835f9996dc'\n'parentDescription': Level up your Angular skills with this advanced course, highlighting the framework’s evolving features. We will cover cutting-edge topics, from mastering state management with the NgRx Signal store and unlocking AI-enhanced forms’ potential, to revisiting the performance benefits of server-side rendering. You will learn how to effectively use Signals through professional tips and real-world insights, and explore emerging features like httpResource in Angular 19.2. Whether you are scaling enterprise apps or upgrading legacy codebases, this course equips you with the practices to build smarter, faster Angular applications and stay ahead in today’s Angular ecosystem.\n'indexBrandName': 'InternationalJavaScriptCon'\n'indexSeriesName': ''\n'author': 'Manfred Steyer'\n'chunkSource': 'text'\n'text': which provides information about the names of the available levels. A LevelLoader takes care of loading these files. To do this, it uses the new httpResource (Listing 2). Listing 2: @Injectable({ providedIn: 'root' }) export class LevelLoader { getLevelOverviewResource(): HttpResourceRef { return httpResource('/levels/overview.json', { defaultValue: initLevelOverview, }); } getLevelResource(levelKey: () => string | undefined): HttpResourceRef { return httpResource(() => !levelKey() ? undefined : `/levels/${levelKey()}.json`, { defaultValue: initLevel, }); } [...] } The first parameter passed to httpResource represents the respective URL. The second optional parameter accepts an object with further options. This object allows the definition of a default value that is used before the resource has been loaded. The getLevelResource method expects a signal with a levelKey, from which the service derives the name of the desired level file. This read-only signal is an abstraction of the type () => string | undefined. The URL passed from getLevelResource to httpResource is a lambda expression that the resource automatically reevaluates when the levelKey signal changes. In the background, httpResource uses it to generate a calculated signal that acts as a trigger: every time this trigger changes, the resource loads the URL. To prevent the httpResource from being triggered, this lambda expression must return the value undefined. This way, the loading can be delayed until the levelKey is available. Further options with HttpResourceRequest To get more control over the outgoing HTTP request, the caller can pass an HttpResourceRequest instead of a URL (Listing 3). Listing 3: getLevelResource(levelKey: () => string) { return httpResource( () => ({ url: `/levels/${levelKey()}.json`, method: 'GET', headers: { accept: 'application/json', }, params: { levelId: levelKey(), }, reportProgress: false, body: null, transferCache: false, withCredentials: false, }), { defaultValue: initLevel } ); } This HttpResourceRequest can also be represented by a lambda expression, which the httpResource uses to construct a calculated signal internally. It is important to note that although the httpResource offers the option to specify HTTP methods (HTTP verbs) beyond GET and a body that is transferred as a payload, it is only intended for retrieving data. These options allow you to integrate web APIs that do not adhere to the semantics of HTTP verbs. By default, the httpResource converts the passed body to JSON. With the reportProgress option, the caller can request information about the progress of the current operation. This is useful when downloading large files. I will discuss this in more detail below. Analyzing and validating the received data By default, the httpResource expects\n'slidetext': ''\n'from': 'index'\n'score': 55.865135192871094\n'normalizedScore': 0.558651351928711\n'beforeDatePenaltyScore': 0.558651351928711\n\n'documentId': 'af6bfaa1ee403d005b7cb22d'\n'chunk_id': '690e0ea58c81760014412a9e'\n'access': 'granted'\n'part_number': 1\n'total_parts': 29\n'contentType': 'RHEINGOLD'\n'title': Wachsen ohne Chaos: Architektur für nachhaltige Angular-Projekte\n'parentName': W-JAX 2025\n'language': 'DE'\n'date': '2025-11-06T08:00:00.000Z'\n'abstract': Angular-Anwendungen wachsen oft schneller als geplant – und genau dann zeigt sich, wie gut die Architektur wirklich durchdacht ist. Features verzahnen sich, Strukturen verschwimmen, Refactorings werden riskant. In diesem Vortrag zeige ich Strategien, wie man Angular-Projekte von Anfang an strukturiert – oder bestehende Anwendungen so umbaut, dass sie langfristig wartbar und erweiterbar bleiben. Vom sinnvollen Einsatz von Feature- und Domänenmodulen bis zu Tools wie Sheriff, Signal Store und Native Federation geht es um konkrete Muster für nachhaltiges Wachstum.\n'parentId': '26c78c073b722105116a13de'\n'parentDescription': Die Konferenz für Java, Architektur- und Software-Innovation\n'indexBrandName': 'JAX'\n'indexSeriesName': ''\n'author': 'Rainer Hahnekamp'\n'chunkSource': 'text'\n'text': Wachsen ohne Chaos: Architektur für nachhaltige Angular-Projekte Angular-Anwendungen wachsen oft schneller als geplant – und genau dann zeigt sich, wie gut die Architektur wirklich durchdacht ist. Features verzahnen sich, Strukturen verschwimmen, Refactorings werden riskant. In diesem Vortrag zeige ich Strategien, wie man Angular-Projekte von Anfang an strukturiert – oder bestehende Anwendungen so umbaut, dass sie langfristig wartbar und erweiterbar bleiben. Vom sinnvollen Einsatz von Feature- und Domänenmodulen bis zu Tools wie Sheriff, Signal Store und Native Federation geht es um konkrete Muster für nachhaltiges Wachstum. Dann guten Morgen legen wir los. äh ja, willkommen zum ersten äh zum ersten Vortrag von heute. Ich darf mich kurz vorstellen. ähm Mein Name ist Hanne Kreiner, komme aus Österreich, wie man hört, bin an und für sich bei Engul Architekt dabei, also wir machen sehr sehr viel Richtung Architektur und Engola, passt dann auch ganz gut zum Titel. Und ja, ich versuche auch bei ein paar Open Source Projekte mitzuarbeiten, ein paar kennt man besser, ein paar kennt man vielleicht jetzt nicht ganz so gut. Das populärste ist wahrscheinlich Ner X, Estate Management für Engula, aber mache auch bei ein paar anderen mit. ähm von von der Agenda oder wie ich mir das an und für sich so vorgestellt habe, dass man sagt, man schaut sich einmal an, wie eine Anwendung so wachsen kann, was da für Herausforderungen an und für sich anstehen und äh ja, man kann sagen, es ist eine Art Portepree von verschiedenen Themen. bei der Architektur, die es so gibt, die man eben anwenden kann. Und nachdem natürlich jetzt am Anfang die Probleme nicht so gross sind, würden wir am Anfang das Vortrags eher so, würde ich mal sagen, einfache Ansätze haben, die man eigentlich schon umsetzen kann, das ist jetzt nicht so schwer. Und je nachdem, wie gross dann die Anwendung ist, werden wir uns dann anschauen, welche Probleme dann auftreten und wie man dann dem entgegentreten kann oder welche Lösungsmöglichkeiten es da eben gibt. Gut, ähm ja, dann würde ich sagen, vielleicht ganz am Anfang, wenn man\n'slidetext': ''\n'from': 'index'\n'score': 55.2808837890625\n'normalizedScore': 0.552808837890625\n'beforeDatePenaltyScore': 0.552808837890625\n\n'documentId': '3ac2ff4b76a2048bae5607f6'\n'chunk_id': '6903881aa7bbb00013e754e5'\n'access': 'restricted'\n'part_number': 1\n'total_parts': 1\n'contentType': 'RHEINGOLD'\n'title': Accessibility in Angular\n'parentName': JavaScript Days Berlin und online 2025\n'language': 'DE'\n'date': '2025-10-22T07:00:00.000Z'\n'abstract': In diesem neuen Workshop lernen Angular-Entwickler:innen alle Grundlagen und Tools kennen, um das Thema Barrierefreiheit souverän in ihre Angular-Apps zu meistern. Es werden ausgewählte A11y-Tools vorgestellt, die wichtigsten A11y-Features von Angular sowie bewährte Best Practices präsentiert und in praxisnahen Übungsbeispielen demonstriert. Der Workshop richtig sich an alle Angular-Entwickler:innen, A11y-Vorkenntnisse sind nicht erforderlich. Wer am Praxisteil mitmachen möchte, benötigt einen Computer.\n'parentId': 'a233287a238c6e0ce3f91546'\n'parentDescription': 40 Workshops zu JavaScript, Angular, React, Typescript und KI\n'indexBrandName': 'JavaScriptDays'\n'indexSeriesName': 'Berlin'\n'author': 'Alexander Thalhammer'\n'chunkSource': 'text'\n'text': Accessibility in Angular In diesem neuen Workshop lernen Angular-Entwickler:innen alle Grundlagen und Tools kennen, um das Thema Barrierefreiheit souverän in ihre Angular-Apps zu meistern. Es werden ausgewählte A11y-Tools vorgestellt, die wichtigsten A11y-Features von Angular sowie bewährte Best Practices präsentiert und in praxisnahen Übungsbeispielen demonstriert. Der Workshop richtig sich an alle Angular-Entwickler:innen, A11y-Vorkenntnisse sind nicht erforderlich. Wer am Praxisteil mitmachen möchte, benötigt einen Computer.\n'slidetext': ''\n'from': 'index'\n'score': 55.24238204956055\n'normalizedScore': 0.5524238204956055\n'beforeDatePenaltyScore': 0.5524238204956055\n\n'documentId': '9836770500f149a58b7769f9'\n'chunk_id': '68ad7e39494be90012217fe9'\n'access': 'granted'\n'part_number': 3\n'total_parts': 6\n'contentType': 'READ'\n'title': Professional Tips for Using Signals in Angular - Enterprise Angular\n'parentName': iJS Magazine Volume 17\n'language': 'EN'\n'date': '2025-02-25T23:00:00.000Z'\n'abstract': The new Signals in Angular are a simple reactive building block. However, as is so often the case, the devil is in the detail. In this article, I will give three tips to help you use Signals in a more straightforward way.\n'parentId': '2b07605113b7a8ed6aeea755'\n'parentDescription': Broaden your knowledge and expand your JavaScript techniques and practices. From Angular, React, and WebAssembly, to the best JavaScript IDEs, open source tools and more, you’ll learn insights on everything JS from seasoned experts in their field. Keep up with JavaScript news, tips, and advice with interviews, tutorials, and in-depth articles.\n'indexBrandName': ''\n'indexSeriesName': ''\n'author': 'Manfred Steyer'\n'chunkSource': 'text'\n'text': { loading: true })), switchMap((f) => dessertService.find(f).pipe( tapResponse({ next: (desserts) => { patchState(store, { desserts, loading: false }); }, error: (error) => { toastService.show('Error loading desserts!'); console.error(error); patchState(store, { loading: false }); }, }), ), ), ), ), }), ), withHooks({ onInit(store) { const filter = store.filter; store.loadDessertsByFilter(filter); }, }), ); This example sets up a reactive method loadDessertsByFilter in the store. As it is defined with rxMethod, it receives an observable. The values of this observable pass through the defined pipe. As rxMethod automatically logs on to this observable, the application code must receive the result of the data flow using tap or tabResponse. The latter is an operator from the @ngrx/operators package that combines the functionality of tap, catchError and finalize. The consumer of a reactive method can pass a corresponding observable as well as a signal or a specific value. The onInit hook shown passes the filter signal. This means all values that the signal gradually picks up pass through the pipe in loadDessertsByFilter. This is where the glitch-free property comes into play. It is interesting to note that rxMethod can also be used outside the signal store by design. For example, a component could use it to set up a reactive method. Tip 2: Avoiding race conditions Overlapping, asynchronous operations usually lead to undesirable race conditions. If users search for two different desserts in quick succession, both results are displayed one after the other. One of the two only flashes briefly before the other replaces it. Due to the asynchronous nature, the order of the search queries doesn’t have to match each of the results obtained. To prevent this confusing behavior, RxJS offers a few flattening operators: - switchMap - mergeMap - concatMap - exhaustMap These operators differ in how they deal with overlapping requests. The switchMap only deals with the last search request. It cancels any queries that are already running when a new query arrives. This behavior corresponds to what users intuitively expect when working with search filters. The mergeMap and concatMap operators execute all requests: the former in parallel and the latter sequentially. The exhaustMap operator ignores further requests as long as one is running. These options are another reason for using RxJS and for the RxJS interop and rxMethod. Another strategy often used in addition or as an alternative is a flag that indicates if the application is currently communicating with the backend. Listing 3 loadRatings(): void { patchState(store, { loading: true }); ratingService.loadExpertRatings().subscribe({ next: (ratings) => {\n'slidetext': ''\n'from': 'index'\n'score': 54.99837875366211\n'normalizedScore': 0.5499837875366211\n'beforeDatePenaltyScore': 0.5499837875366211\n\n'documentId': '9836770500f149a58b7769f9'\n'chunk_id': '68ad7e38494be90012217fe8'\n'access': 'granted'\n'part_number': 2\n'total_parts': 6\n'contentType': 'READ'\n'title': Professional Tips for Using Signals in Angular - Enterprise Angular\n'parentName': iJS Magazine Volume 17\n'language': 'EN'\n'date': '2025-02-25T23:00:00.000Z'\n'abstract': The new Signals in Angular are a simple reactive building block. However, as is so often the case, the devil is in the detail. In this article, I will give three tips to help you use Signals in a more straightforward way.\n'parentId': '2b07605113b7a8ed6aeea755'\n'parentDescription': Broaden your knowledge and expand your JavaScript techniques and practices. From Angular, React, and WebAssembly, to the best JavaScript IDEs, open source tools and more, you’ll learn insights on everything JS from seasoned experts in their field. Keep up with JavaScript news, tips, and advice with interviews, tutorials, and in-depth articles.\n'indexBrandName': ''\n'indexSeriesName': ''\n'author': 'Manfred Steyer'\n'chunkSource': 'text'\n'text': and switchMap provided by RxJS. The latter prevents race conditions for overlapping requests by only using the most recent request. SwitchMap aborts requests that have already been started, unless they have already been completed. Listing 1 @Component({ selector: 'app-desserts', standalone: true, imports: [DessertCardComponent, FormsModule, JsonPipe], templateUrl: './desserts.component.html', styleUrl: './desserts.component.css', changeDetection: ChangeDetectionStrategy.OnPush, }) export class DessertsComponent { #dessertService = inject(DessertService); #ratingService = inject(RatingService); #toastService = inject(ToastService); originalName = signal(''); englishName = signal('Cake'); loading = signal(false); ratings = signal({}); ratedDesserts = computed(() => this.toRated(this.desserts(), this.ratings())); originalName$ = toObservable(this.originalName); englishName$ = toObservable(this.englishName); desserts$ = combineLatest({ originalName: this.originalName$, englishName: this.englishName$, }).pipe( filter((c) => c.originalName.length >= 3 || c.englishName.length >= 3), debounceTime(300), tap(() => this.loading.set(true)), switchMap((c) => this.#dessertService.find(c).pipe( catchError((error) => { this.#toastService.show('Error loading desserts!'); console.error(error); return of([]); }), ), ), tap(() => this.loading.set(false)), ); desserts = toSignal(this.desserts$, { initialValue: [], }); […] } At the end, the resulting observable is converted into a signal so that the application can continue with the new Signals API. For performance reasons, the application should not switch between the two worlds too frequently. In contrast to Figure 1, no store is used. Both the intention and the asynchronous action take place in the reactive data flow. If the data flow were outsourced to a service and the loaded data were shared with the shareReplay operator, this service could be regarded as a simple store. However, in line with Figure 1, the component already hands over the execution of asynchronous tasks in the expansion stage shown and receives signals at the end. RxJS in Stores RxJS is also frequently used in stores, like in NgRx in combination with Effects. Instead, the NgRx Signal Store offers its own reactive methods that can be defined with rxMethod (Listing 2). Listing 2 export const DessertStore = signalStore( { providedIn: 'root' }, withState({ filter: { originalName: '', englishName: 'Cake', }, loading: false, ratings: {} as DessertIdToRatingMap, desserts: [] as Dessert[], }), […] withMethods( ( store, dessertService = inject(DessertService), toastService = inject(ToastService), ) => ({ […] loadDessertsByFilter: rxMethod( pipe( filter( (f) => f.originalName.length >= 3 || f.englishName.length >= 3, ), debounceTime(300), tap(() => patchState(store, {\n'slidetext': ''\n'from': 'index'\n'score': 54.99837875366211\n'normalizedScore': 0.5499837875366211\n'beforeDatePenaltyScore': 0.5499837875366211\n\n'documentId': 'dcce136001b8cf2cfe8b5498'\n'chunk_id': '6876df207899910dd58c0e9e'\n'access': 'granted'\n'part_number': 3\n'total_parts': 7\n'contentType': 'READ'\n'title': Die neue httpResource in Angular 19.2 - Kolumne: Enterprise Angular\n'parentName': iJS Magazin 2.2025\n'language': 'DE'\n'date': '2025-03-25T23:00:00.000Z'\n'abstract': Angular 19.2 beinhaltet nun die neue httpResource, die es erlaubt, Daten innerhalb des reaktiven Flusses zu laden. Dieser Artikel zeigt, wie sich dieses - derzeit experimentelle - Feature nutzen lässt. Als Beispiel dient eine einfache Anwendung, die durch Levels, im Stil des Spiels „Super Mario“, scrollt. Jedes Level besteht aus Kacheln, die in vier verschiedenen Stilen zur Verfügung stehen: Overworld, Underground, Underwater und Castle. In unserer Implementierung können Benutzer:innen frei zwischen diesen Stilen wechseln. Abbildung 1 zeigt zum Beispiel das erste Level im Stil Overworld an. Abbildung 2 zeigt dasselbe Level im Stil Underground.\n'parentId': '7cb807973ada8ce87de439aa'\n'parentDescription': Kaum ein Softwareprojekt, das nicht in wesentlichen Teilen auf der JavaScript-Technologie basiert. Eine breite Unterstützung sowie, leistungsfähige Programmiersprachen, die Vielzahl moderner Tools, sowie ausgereifte Frameworks wie Angular, React, Vue.js oder Node.js machen den JavaScript-Werkzeugkasten zu einem Alleskönner. Das iJS Magazin informiert aktuell und umfassend über die wichtige und innovative Entwicklungen im JavaScript-Universum und bietet handfeste Praxisinformationen für Softwareentwickler und -architekten.\n'indexBrandName': ''\n'indexSeriesName': ''\n'author': 'Manfred Steyer'\n'chunkSource': 'text'\n'text': Verfügung steht. Weitere Optionen mit HttpResourceRequest Um mehr Kontrolle über die ausgehende HTTP-Anfrage zu erhalten, kann der Aufrufer anstelle einer URL einen HttpResourceRequest übergeben (Listing 3). Listing 3 getLevelResource(levelKey: () => string) { return httpResource( () => ({ url: `/levels/${levelKey()}.json`, method: 'GET', headers: { accept: 'application/json', }, params: { levelId: levelKey(), }, reportProgress: false, body: null, transferCache: false, withCredentials: false, }), { defaultValue: initLevel } ); } Auch dieser HttpResourceRequest lässt sich durch einen Lambda-Ausdruck, mit dem die httpResource intern ein berechnetes Signal konstruiert, repräsentieren. Es ist wichtig zu beachten, dass httpResource nur zum Abrufen von Daten gedacht ist, obwohl es auch die Möglichkeit bietet, HTTP-Methoden (HTTP-Verben) jenseits von GET sowie einen body, der als Payload übertragen wird, festzulegen. Diese Optionen ermöglichen das Anbinden von Web APIs, die sich nicht an die Semantiken der HTTP-Verben halten. Standardmäßig konvertet die httpResource den übergebene body nach JSON. Mit der Option reportProgress kann der Aufrufer Informationen zum Fortschritt der aktuellen Operation anfordern. Dies ist beim Herunterladen größerer Dateien nützlich. Ich gehe weiter unten darauf ein. Analysieren und Validieren der empfangenen Daten Standardmäßig erwartet die httpResource Daten in Form von JSON, die zum angegebenen Typparameter passen. Zusätzlich kommt eine Type Assertion zum Einsatz, damit TypeScript das Vorliegen korrekter Typen annimmt. Es ist jedoch möglich, sich in diesen Prozess einzuklinken, um eine benutzerdefinierte Logik für die Validierung des empfangenen Rohwerts und dessen Konvertierung in den gewünschten Typ bereitzustellen. Dazu definiert der Aufrufer eine Funktion über die Eigenschaft map im Optionsobjekt (Listing 4). Listing 4 getLevelResourceAlternative(levelKey: () => string) { return httpResource(() => `/levels/${levelKey()}.json`, { defaultValue: initLevel, map: (raw) => { return toLevel(raw); }, }); } Die httpResource konvertiert das empfangene JSON in ein Objekt vom Typ unknown und übergibt es an map. In unserem Beispiel wird eine einfache selbstgeschriebene Funktion toLevel verwendet. Daneben erlaubt map auch das Einbinden von Bibliotheken wie Zod [2], die eine Schemavalidierung durchführen. Laden von Daten jenseits von JSON Die httpResource erwartet standardmäßig ein\n'slidetext': ''\n'from': 'index'\n'score': 54.947731018066406\n'normalizedScore': 0.549477310180664\n'beforeDatePenaltyScore': 0.549477310180664\n\n'documentId': 'dcce136001b8cf2cfe8b5498'\n'chunk_id': '6876df207899910dd58c0ea1'\n'access': 'granted'\n'part_number': 6\n'total_parts': 7\n'contentType': 'READ'\n'title': Die neue httpResource in Angular 19.2 - Kolumne: Enterprise Angular\n'parentName': iJS Magazin 2.2025\n'language': 'DE'\n'date': '2025-03-25T23:00:00.000Z'\n'abstract': Angular 19.2 beinhaltet nun die neue httpResource, die es erlaubt, Daten innerhalb des reaktiven Flusses zu laden. Dieser Artikel zeigt, wie sich dieses - derzeit experimentelle - Feature nutzen lässt. Als Beispiel dient eine einfache Anwendung, die durch Levels, im Stil des Spiels „Super Mario“, scrollt. Jedes Level besteht aus Kacheln, die in vier verschiedenen Stilen zur Verfügung stehen: Overworld, Underground, Underwater und Castle. In unserer Implementierung können Benutzer:innen frei zwischen diesen Stilen wechseln. Abbildung 1 zeigt zum Beispiel das erste Level im Stil Overworld an. Abbildung 2 zeigt dasselbe Level im Stil Underground.\n'parentId': '7cb807973ada8ce87de439aa'\n'parentDescription': Kaum ein Softwareprojekt, das nicht in wesentlichen Teilen auf der JavaScript-Technologie basiert. Eine breite Unterstützung sowie, leistungsfähige Programmiersprachen, die Vielzahl moderner Tools, sowie ausgereifte Frameworks wie Angular, React, Vue.js oder Node.js machen den JavaScript-Werkzeugkasten zu einem Alleskönner. Das iJS Magazin informiert aktuell und umfassend über die wichtige und innovative Entwicklungen im JavaScript-Universum und bietet handfeste Praxisinformationen für Softwareentwickler und -architekten.\n'indexBrandName': ''\n'indexSeriesName': ''\n'author': 'Manfred Steyer'\n'chunkSource': 'text'\n'text': delegiert lediglich an die asynchrone Funktion extractTiles, die die Engine ebenfalls bereitstellt (Listing 8). Listing 8 function createTilesResource( tilesMapResource: HttpResourceRef, style: () => Style ) { const tilesMap = tilesMapResource.value(); // undefined prevents the resource from beeing triggered const request = computed(() => !tilesMap ? undefined : { tilesMap: tilesMap, style: style(), } ); return resource({ request, loader: (params) => { const { tilesMap, style } = params.request!; return extractTiles(tilesMap, style); }, }); } Diese einfache Resource enthält ein interessantes Detail: Vor dem Laden der Tilemap hat die tilesMapResource den Wert undefined. Ohne eine tilesMap können wir jedoch extractTiles nicht aufrufen. Genau das berücksichtigt das Signal request: Es liefert undefined, wenn noch keine tilesMap vorliegt, sodass die Resource ihren Loader nicht anstößt. Anzeige des Fortschritts Oben wurde die tilesMapResource so konfiguriert, dass sie über ihr progress-Signal Informationen über den Downloadfortschritt liefert. Ein berechnetes Signal in der LevelComponent projiziert es in einen String für die Anzeige (Listing 9). Listing 9 function calcProgress(progress: HttpProgressEvent | undefined): string { if (!progress) { return '-'; } if (progress.total) { const percent = Math.round((progress.loaded / progress.total) * 100); return percent + '%'; } const kb = Math.round(progress.loaded / 1024); return kb + ' KB'; } Wenn der Server über die Dateigröße informiert, berechnet diese Funktion einen Prozentwert für den bereits heruntergeladenen Anteil. Andernfalls liefert sie nur die Anzahl der bereits heruntergeladenen Kilobyte zurück. Vor dem Start des Downloads gibt es keine Fortschrittsinformationen. In diesem Fall kommt lediglich ein Bindestrich zum Einsatz. Um diese Funktion zu testen, bietet es sich an, die Netzwerkverbindung des Browsers in der Entwickler-Konsole zu drosseln sowie die Schaltfläche Reload in der Anwendung zu drücken, um die Resources anzuweisen, die Daten erneut zu laden. Status, Header, Error und mehr Für den Fall, dass die Anwendung den Statuscode oder die Header der HTTP-Antwort benötigt, stellt die httpResource entsprechende Signals bereit: console.log(this.levelOverviewResource.status()); console.log(this.levelOverviewResource.statusCode()); console.log(this.levelOverviewResource.headers()?.keys()); Darüber hinaus stellt die httpResource alles zur Verfügung, was auch von gewöhnlichen Resources bekannt ist, darunter ein error-Signal, das über einen eventuell aufgetretenen Fehler informiert sowie die Möglichkeit, den value\n'slidetext': ''\n'from': 'index'\n'score': 54.947731018066406\n'normalizedScore': 0.549477310180664\n'beforeDatePenaltyScore': 0.549477310180664\n\n'documentId': 'f6deca20792c128a44f8b33f'\n'chunk_id': '68c270060a53cd001394ac02'\n'access': 'restricted'\n'part_number': 1\n'total_parts': 5\n'contentType': 'READ'\n'title': Exploring httpResource in Angular 19.2 - A new way to load data seamlessly\n'parentName': iJS Magazine Volume 19\n'language': 'EN'\n'date': '2025-06-24T22:00:00.000Z'\n'abstract': The introduction of *httpResource* in Angular 19.2 brings a new way to load data seamlessly within the reactive flow. Let's explore how this experimental feature can be leveraged to enhance your applications.\n'parentId': 'a1269c65e87d5b8ebcde4b28'\n'parentDescription': Broaden your knowledge and expand your JavaScript techniques and practices. From Angular, React, and WebAssembly, to the best JavaScript IDEs, open source tools and more, you’ll learn insights on everything JS from seasoned experts in their field. Keep up with JavaScript news, tips, and advice with interviews, tutorials, and in-depth articles.\n'indexBrandName': ''\n'indexSeriesName': ''\n'author': 'Manfred Steyer'\n'chunkSource': 'text'\n'text': Exploring httpResource in Angular 19.2 A new way to load data seamlessly The introduction of *httpResource* in Angular 19.2 brings a new way to load data seamlessly within the reactive flow. Let's explore how this experimental feature can be leveraged to enhance your applications. Angular 19.2 introduced the experimental httpResource feature, streamlining HTTP data loading within the reactive flow of applications. By leveraging signals, it simplifies asynchronous data fetching, providing developers with a more streamlined approach to handling HTTP requests. With Angular 20 on the horizon, this feature will evolve further, offering even more power for managing data in reactive applications. Let’s explore how to leverage httpResource to enhance your applications. As an example, we have a simple application that scrolls through levels in the style of the game Super Mario. Each level consists of tiles that are available in four different styles: overworld, underground, underwater, and castle. In our implementation, users can switch freely between these styles. Figure 1 shows the first level in overworld style, while Figure 2 shows the same level in underground style. Figure 1: Level 1 in overworld style Figure 2: Level 1 in the underground style A LevelComponent in the example application takes care of loading level files (JSON) and tiles for drawing the levels using an httpResource. To render and animate the levels, the example relies on a very simple engine that is included with the source code but is treated as a black box here in the article. HttpClient in the substructure enables the use of interceptors At its core, the new httpResource currently uses the good old HttpClient. Therefore, the application has to provide this service, which is usually done by calling provideHttpClient during bootstrapping. As a consequence, the httpResource also automatically picks up the registered HttpInterceptors. However, the HttpClient is just an implementation detail that Angular may eventually replace with a different implementation. Level files The different levels are described by our example JSON files, which define which tiles are to be displayed at which coordinates (Listing 1). Listing 1: { 'levelId': 1, 'backgroundColor': '#9494ff', 'items': [ { 'tileKey': 'floor', 'col': 0, 'row': 13, [...] }, { 'tileKey': 'cloud', 'col': 12, 'row': 1, [...] }, [...] ] } These coordinates define positions within a matrix of blocks measuring 16x16 pixels. An overview.json file is provided with these level files, which provides information about the names of the available levels. A LevelLoader takes care of loading these files. To do this, it uses the new httpResource (Listing 2). Listing 2: @Injectable({ providedIn: 'root' }) export class\n'slidetext': ''\n'from': 'index'\n'score': 54.542808532714844\n'normalizedScore': 0.5454280853271485\n'beforeDatePenaltyScore': 0.5454280853271485\n\n'documentId': 'af6bfaa1ee403d005b7cb22d'\n'chunk_id': '690e0ea68c81760014412ab3'\n'access': 'granted'\n'part_number': 22\n'total_parts': 29\n'contentType': 'RHEINGOLD'\n'title': Wachsen ohne Chaos: Architektur für nachhaltige Angular-Projekte\n'parentName': W-JAX 2025\n'language': 'DE'\n'date': '2025-11-06T08:00:00.000Z'\n'abstract': Angular-Anwendungen wachsen oft schneller als geplant – und genau dann zeigt sich, wie gut die Architektur wirklich durchdacht ist. Features verzahnen sich, Strukturen verschwimmen, Refactorings werden riskant. In diesem Vortrag zeige ich Strategien, wie man Angular-Projekte von Anfang an strukturiert – oder bestehende Anwendungen so umbaut, dass sie langfristig wartbar und erweiterbar bleiben. Vom sinnvollen Einsatz von Feature- und Domänenmodulen bis zu Tools wie Sheriff, Signal Store und Native Federation geht es um konkrete Muster für nachhaltiges Wachstum.\n'parentId': '26c78c073b722105116a13de'\n'parentDescription': Die Konferenz für Java, Architektur- und Software-Innovation\n'indexBrandName': 'JAX'\n'indexSeriesName': ''\n'author': 'Rainer Hahnekamp'\n'chunkSource': 'text'\n'text': einfach, dass das funktioniert. Das Problem ist allerdings, das kann man am Anfang so machen, es wird allerdings nicht skalieren. Wieso nicht? Weil jedes Feature, was ihr dazu bringt, wird einfach eine neue Logik dazugeben, die für sich individuell ist. Das heisst, ihr wäre jetzt bei den Data Services alle Modelle haben müssen, bereitstellen müssen, die eben irgendeines von diesen Features benötigt und einfach, auch wenn sie den grossen globalen Ninja X dort dann verwendet, das ist einfach zu viel. Das skaliert nicht. Also wenn ich da jetzt 56 verschiedene Features habe, dann schaut das Data einfach zu gross aus und das geht dann nicht mehr. Das heisst. Man könnte dann an und für sich diesen Ansatz verfolgen, dass man sagt, OK, jedes Feature für sich, das heisst, wir haben eben Data für Holidays, für Quiz, wir haben für Holidays und für Quiz, das funktioniert auch. Aber was auf jeden Fall noch dazukommen muss, sind dann diese generischen Services, die jetzt bei Holidays an und für sich für alle Features da sind. Weil diese Features werden ja auf irgendwas aufbauen, auf irgendein Holiday Datenmodell eben aufbauen müssen. Und was man dann eben sehr häufig verwenden kann, und das hat sich meiner Meinung nach ganz ganz gut bewährt, dass man sagt, man hat innerhalb von der Domäne, man kann das auch Shared Domäne nennen oder halt eben Cor. Da befinden sich dann grundlegenden Services drinnen, die in dem Fall eben jetzt sagen, ja, ich biete dir an, eben Holidays abzurufen. Ich bitte die an jetzt irgendwelche generischen Inhalte eben anzu darzustellen oder wie auch immer. Alle Features können sich aus diesem Pool bedienen. Aber die Features, die jetzt wieder features spezifisch sind, also das Laden eines Quiz zum Beispiel, das macht auf gar keinen Fall der Chor vom Holidays, das macht sich dann das Quiz selber aus. Das ist die Grundidee. Damit kann ich dann an und für sich jetzt doch auch wieder sehr, sehr gut skalieren. Und eben, wie gesagt, der Platz ist da. Ich habe bei Features diese Möglichkeit. UI Data und das alles eben zu haben. Dann gibt's noch diese\n'slidetext': ''\n'from': 'index'\n'score': 54.282981872558594\n'normalizedScore': 0.5428298187255859\n'beforeDatePenaltyScore': 0.5428298187255859\n\n'documentId': '62f599587e3fd28de76c2756'\n'chunk_id': '68becab35b3acf001302282c'\n'access': 'restricted'\n'part_number': 1\n'total_parts': 8\n'contentType': 'READ'\n'title': Signals werden erwachsen – das neue Resource API in Angular 19 - Kolumne: Enterprise Angular\n'parentName': iJS Magazin 1.2025\n'language': 'DE'\n'date': '2025-01-29T23:00:00.000Z'\n'abstract': Das in Angular 19 zunächst experimentell eingeführte Resource API ermöglicht das asynchrone Laden von Daten in der Welt von Signals. Das gibt uns endlich die Möglichkeit, HTTP-Zugriffe in den reaktiven Fluss zu integrieren. In diesem Artikel zeige ich, wie man damit ein typisches CRUD-Szenario erstellt. Das verwendete Codebeispiel findet sich unter [1] im Branch 02e-resource.\n'parentId': 'fda1be46c7e3c0a30654c08a'\n'parentDescription': Kaum ein Softwareprojekt, das nicht in wesentlichen Teilen auf der JavaScript-Technologie basiert. Eine breite Unterstützung sowie, leistungsfähige Programmiersprachen, die Vielzahl moderner Tools, sowie ausgereifte Frameworks wie Angular, React, Vue.js oder Node.js machen den JavaScript-Werkzeugkasten zu einem Alleskönner. Das iJS Magazin informiert aktuell und umfassend über die wichtige und innovative Entwicklungen im JavaScript-Universum und bietet handfeste Praxisinformationen für Softwareentwickler und -architekten.\n'indexBrandName': ''\n'indexSeriesName': ''\n'author': 'Manfred Steyer'\n'chunkSource': 'text'\n'text': Signals werden erwachsen – das neue Resource API in Angular 19 Kolumne: Enterprise Angular Das in Angular 19 zunächst experimentell eingeführte Resource API ermöglicht das asynchrone Laden von Daten in der Welt von Signals. Das gibt uns endlich die Möglichkeit, HTTP-Zugriffe in den reaktiven Fluss zu integrieren. In diesem Artikel zeige ich, wie man damit ein typisches CRUD-Szenario erstellt. Das verwendete Codebeispiel findet sich unter [1] im Branch 02e-resource. Das in Angular 19 zunächst experimentell eingeführte Resource API ermöglicht das asynchrone Laden von Daten in der Welt von Signals. Das gibt uns endlich die Möglichkeit, HTTP-Zugriffe in den reaktiven Fluss zu integrieren. In diesem Artikel zeige ich, wie man damit ein typisches CRUD-Szenario erstellt. Das verwendete Codebeispiel findet sich unter [1] im Branch 02e-resource. Beispielanwendung Zur Demonstration der einzelnen Features nutze ich die bereits aus früheren Artikeln bekannte Demoanwendung Austrian Desserts (Abb. 1). Abb. 1: Beispielanwendung: Austrian Desserts In dieser Anwendung kann man nach Desserts der Alpenrepublik anhand des originalen österreichischen Namens oder der jeweiligen englischen Übersetzung suchen. Die einzelnen Desserts lassen sich bewerten. Als Alternative können Benutzer:innen auch die Bewertungen eines anerkannten Experten auf diesem Gebiet – es handelt sich dabei um meine Wenigkeit – laden. Außerdem gibt es eine Detailansicht zum Bearbeiten von Desserts (Abb. 2). Abb. 2: Detailansicht in Beispielanwendung Erste Schritte mit dem Resource API Jede mit dem Resource API definierte Resource hat eine Funktion loader, die ein Promise mit den geladenen Daten zurückgibt. Dieser Loader kommt unmittelbar nach der Initialisierung der Resource zum Einsatz. Zusätzlich kann die Resource ein request Signal haben, das Parameter (Suchkriterien) für den Loader bereitstellt. Jedes Mal, wenn sich das request Signal ändert, stößt die Resource den Loader erneut an (Listing 1). Listing 1 import { resource } from '@angular/core'; […] @Component([...]) export class DessertsComponent { #dessertService = inject(DessertService); [...] // Criteria for search originalName = signal(''); englishName = signal(''); // Combine criteria to computed Signal dessertsCriteria = computed(() => ({ originalName: this.originalName(), englishName: this.englishName(), })); // Define resource with request (=search criteria) and loader // Every time, the request is changing, the loader is triggered\n'slidetext': ''\n'from': 'index'\n'score': 54.103271484375\n'normalizedScore': 0.54103271484375\n'beforeDatePenaltyScore': 0.54103271484375\n\n'documentId': 'a527c16f5bc7b4da1bc88ab0'\n'chunk_id': '68f251653134c10012c3d1fb'\n'access': 'restricted'\n'part_number': 2\n'total_parts': 15\n'contentType': 'RHEINGOLD'\n'title': Angular Resources: Everything you need to know\n'parentName': International JavaScript New York 2025\n'language': 'EN'\n'date': '2025-10-01T12:45:00.000Z'\n'abstract': Discover how game changing Angular Resources will be for your Angular applications. We'll dive into what Angular Resources are, why they matter, and how they can replace most RxJs code in your Angular applications. We’ll see how to use resources for cleaner, more concise code. A perfect talk for those looking to level up their Angular skills and stay ahead with the latest features.\n'parentId': '9f97d5cdc68d72a05f834df4'\n'parentDescription': The JavaScript Fullstack Conference - Angular, Node.js, React and more\n'indexBrandName': 'InternationalJavaScriptCon'\n'indexSeriesName': 'NewYork'\n'author': 'Alain Chautard'\n'chunkSource': 'text'\n'text': so just a little bit later, and it's still experimental right now. So these are the, the three main features, functions, resource, RX resource, and HDDP resource. Um, so everything is still experimental, but very likely to become stable very soon. And interestingly enough, because I'm an old Angular GS guy, I can go back to the Angular GS documentation. Back in the day, there was a dollar resource, which was a little bit different from the resource we have in Angular right now, but the idea was very much the same. It was to give us an API around how to interact with a server, right? And back then there was no observer. It was all about promises. So it was basically this dollar resource function that you would pass a URL and some parameters, and then you would be able to do things and, and interact with the backend through simple functions. So the idea of what's, uh, what angular resources do now in Angular 20 is a little bit similar and also a little bit different. So we'll, we'll see that. So the first way that it's different is that it's all about signals. Um, so Angular is evolving from its default change detection, where basically anything would get angular to detect changes and, and try to render its components. So any click, any timeout, any HDP request that happens would just say, Hey, check, check your stuff, right? Um, we had a small optimization, we still have it, yes, on push to make things, uh, smarter about change detection and, and the fact that Angular would now have a little bit more insight that, oh, you change an input here, so I'm gonna check that component. But if a component inputs doesn't change and that component is un push, then angular just gonna assume, oh, the inputs haven't changed, so I'm not gonna refresh that component. And now we have signals where with the signal, angular knows exactly what changes and where, what are the consequences of that change, which is true for components, but also true for other signals, right? Um, the idea is when you use a signal, angular knows about what anything, any code that depends on it, right? It, it builds a dependency graph on, on those signals and knows exactly what depends on, um, on these signals. So when you change the value, everything that needs to change as a result is just known. And so it can happen quickly. And so along with signal scheme, a whole bunch of new functions, features like components, inputs, outputs, can all be signal based. Now, models, um, content\n'slidetext': ''\n'from': 'index'\n'score': 54.02888870239258\n'normalizedScore': 0.5402888870239257\n'beforeDatePenaltyScore': 0.5402888870239257\n\n'documentId': 'af6bfaa1ee403d005b7cb22d'\n'chunk_id': '690e0ea68c81760014412ab0'\n'access': 'granted'\n'part_number': 19\n'total_parts': 29\n'contentType': 'RHEINGOLD'\n'title': Wachsen ohne Chaos: Architektur für nachhaltige Angular-Projekte\n'parentName': W-JAX 2025\n'language': 'DE'\n'date': '2025-11-06T08:00:00.000Z'\n'abstract': Angular-Anwendungen wachsen oft schneller als geplant – und genau dann zeigt sich, wie gut die Architektur wirklich durchdacht ist. Features verzahnen sich, Strukturen verschwimmen, Refactorings werden riskant. In diesem Vortrag zeige ich Strategien, wie man Angular-Projekte von Anfang an strukturiert – oder bestehende Anwendungen so umbaut, dass sie langfristig wartbar und erweiterbar bleiben. Vom sinnvollen Einsatz von Feature- und Domänenmodulen bis zu Tools wie Sheriff, Signal Store und Native Federation geht es um konkrete Muster für nachhaltiges Wachstum.\n'parentId': '26c78c073b722105116a13de'\n'parentDescription': Die Konferenz für Java, Architektur- und Software-Innovation\n'indexBrandName': 'JAX'\n'indexSeriesName': ''\n'author': 'Rainer Hahnekamp'\n'chunkSource': 'text'\n'text': diesem Modell äh das Problem, wenn man in den Domänen UI-Komponenten hat, dann dürfen die UI-Komponenten natürlich ja nicht auf diese Services zugreifen. Und bei dem Domain haben wir jetzt leider Services und die Modelle dabei, womit wir jetzt ein Problem von der Abhängigkeit bekommen würden. Und deswegen ist eben in dieser Darstellung, das ist ein wenig komple komplizierter, Aber wir haben eben hier auf der Ebene, auf der zweiten Ebene Data und UI nebeneinander liegen, damit eben diese UI-Komponenten, die wir auch in den Domänen oder in den Features haben, jetzt nicht auf die Services zugreifen dürfen. Das ist an und für sich eine klassische logische Fortführung von dem, was wir da an und für sich haben. Also jetzt kein Widerspruch oder so etwas, sondern einfach jetzt nur auf unterschiedlichen Entwicklungsstufen gesehen. Ja. ähm Was natürlich dann sehr häufig kommt, wenn man diese Features hat, ich habe es ja vorher schon gesagt, es wäre ideal, wenn diese Features voneinander unabhängig wären die ganze Zeit. Und nachdem ich sage, es wäre ideal, heisst das auch eben, dass das nicht immer so ist. äh Wir haben dann sehr häufig auch die Notwendigkeit, dass hier gewisse Abhängigkeiten zwischen Features bestehen. Wenn ich jetzt zum Beispiel sage, ich habe das Quiz Feature und ich habe dann vielleicht auch so ein User Feature oder so ein Booking feature dann kann es ja sein, dass das Quiz Feature vielleicht wissen möchte, hat der aktuelle Benutzer, haben die jetzt irgendwie äh vielleicht schon bei uns etwas gebucht? Haben die jetzt äh keine Ahnung, äh gerade für diesen, geht es um Ferien, äh für für für diese für diesen Ort äh quasi jetzt ähm einen Urlaub gebucht? Weil das könnte ich ja dann vielleicht irgendwie anzeigen. direkt im Quiz, nicht so nach dem Motto, ja, ich weiss, du fliegst nach keine Ahnung, äh Süditalien und äh das ist jetzt gerade ein Quiz über Süditalien und ich, da kannst du gleich einmal bestellen oder so etwas, nicht? Also solche eben ähm Funktionalitäten, wo ich halt dann, wo die Features miteinander anfangen müssen zu sprechen. Was man dann machen kann, ist,\n'slidetext': ''\n'from': 'index'\n'score': 53.839935302734375\n'normalizedScore': 0.5383993530273438\n'beforeDatePenaltyScore': 0.5383993530273438\n\n'documentId': 'd72da3105a5a3f08b7a603fc'\n'chunk_id': '68becadb5b3acf0013022885'\n'access': 'restricted'\n'part_number': 1\n'total_parts': 5\n'contentType': 'READ'\n'title': Angular Effects – Anwendungsfälle, Risiken und Alternativen - Kolumne: Enterprise Angular\n'parentName': iJS Magazin 1.2025\n'language': 'DE'\n'date': '2025-01-29T23:00:00.000Z'\n'abstract': Effects sollten nur selten benötigt werden. Diese Information aus der Angular-Dokumentation führt leider immer wieder zu Verwirrung, denn eigentlich soll ein reaktives System doch auf Zustandsänderungen reagieren.\n'parentId': 'fda1be46c7e3c0a30654c08a'\n'parentDescription': Kaum ein Softwareprojekt, das nicht in wesentlichen Teilen auf der JavaScript-Technologie basiert. Eine breite Unterstützung sowie, leistungsfähige Programmiersprachen, die Vielzahl moderner Tools, sowie ausgereifte Frameworks wie Angular, React, Vue.js oder Node.js machen den JavaScript-Werkzeugkasten zu einem Alleskönner. Das iJS Magazin informiert aktuell und umfassend über die wichtige und innovative Entwicklungen im JavaScript-Universum und bietet handfeste Praxisinformationen für Softwareentwickler und -architekten.\n'indexBrandName': ''\n'indexSeriesName': ''\n'author': 'Manfred Steyer'\n'chunkSource': 'text'\n'text': Angular Effects – Anwendungsfälle, Risiken und Alternativen Kolumne: Enterprise Angular Effects sollten nur selten benötigt werden. Diese Information aus der Angular-Dokumentation führt leider immer wieder zu Verwirrung, denn eigentlich soll ein reaktives System doch auf Zustandsänderungen reagieren. Angular Effects – Anwendungsfälle, Risiken und Alternativen Effects sollten nur selten benötigt werden. Diese Information aus der Angular-Dokumentation führt leider immer wieder zu Verwirrung, denn eigentlich soll ein reaktives System doch auf Zustandsänderungen reagieren. In diesem Artikel beschreibe ich, wofür Effects in Angular eigentlich gedacht sind, wann man sie nutzen sollte und welche Gefahren sie bergen. Daneben zeige ich Möglichkeiten für das Reagieren auf Änderungen jenseits von Effects auf. Die verwendeten Beispiele finden sich in den einzelnen Branches unter [1]. Der Hauptanwendungsfall für Effects Effects sind in erster Linie für Rendering-Aufgaben gedacht, die sich nicht mit der Datenbindung bewerkstelligen lassen: - Logging - Zeichnen auf einem Canvas - Imperative APIs, die das DOM verändern Ein Beispiel für Letzteres ist das Einblenden einer Nachricht mit einem imperativen API, wie man es in zahlreichen Komponentenbibliotheken findet. Die hierzu vorgesehene Methode kann von einem Effect angestoßen werden: effect(() => { this.#toastService.show(this.desserts().length + ' desserts loaded!'); }); In Fällen, in denen es möglich ist, sollte die Anwendung jedoch auf die Datenbindung zurückgreifen. Da diese Fälle deutlich in der Mehrheit sind, erklärt sich auch, warum die Dokumentation die Notwendigkeit für Effects nur in seltenen Fällen sieht. Auto-Tracking: Fluch und Segen zugleich Beim Einsatz von Effects muss man auch im Hinterkopf behalten, dass Angular implizites Tracking, auch Auto-Tracking genannt, verwendet. Im folgenden Beispiel verfolgt der Effect z. B. die Signals originalName und englishName, obwohl sie nicht direkt im Effect, sondern in der darin aufgerufenen Methode logFilter gelesen werden. Listing 1 constructor() { effect(() => { this.logFilter(); }); } […] private logFilter() { console.log('originalName', this.originalName()); console.log('englishName', this.englishName()); } Dies unterstreicht auch, dass die aktuelle Effects-Implementierung von Angular in erster Linie für das Rendering gedacht ist. Der Effect verfolgt alle Signals, die während des Renderings zum Einsatz kommen. Ändern\n'slidetext': ''\n'from': 'index'\n'score': 53.82465362548828\n'normalizedScore': 0.5382465362548828\n'beforeDatePenaltyScore': 0.5382465362548828\n\n'documentId': 'da5da0f144a0a23494623c94'\n'chunk_id': '6876deea7899910dd58c0d65'\n'access': 'restricted'\n'part_number': 1\n'total_parts': 31\n'contentType': 'RHEINGOLD'\n'title': SSR in Angular: Was, warum und wann?\n'parentName': JAX 2025\n'language': 'DE'\n'date': '2025-05-08T08:30:00.000Z'\n'abstract': Google hat 2024 angekündigt, das bewährte Wiz-Framework, das Anwendungen wie Gmail und die Google-Suche antreibt, in Angular einzubringen. Dadurch kommen die stabilen und performanten Features von Wiz auch Angular zugute. Der Fortschritt ist bereits sichtbar: Dank Incremental Hydration hat sich Angular im Bereich SSR (Server-side Rendering) von den hinteren Startreihen auf die vorderen Plätze katapultiert. In diesem Vortrag zeige ich, wann SSR sinnvoll ist, wie es implementiert wird und welche typischen Fehler und Probleme dabei auftreten können.\n'parentId': 'a616c2e6791c60d80ec68ec7'\n'parentDescription': Die Konferenz für Java, Architektur- und Software-Innovation\n'indexBrandName': 'JAX'\n'indexSeriesName': 'JAX'\n'author': 'Rainer Hahnekamp'\n'chunkSource': 'text'\n'text': SSR in Angular: Was, warum und wann? Google hat 2024 angekündigt, das bewährte Wiz-Framework, das Anwendungen wie Gmail und die Google-Suche antreibt, in Angular einzubringen. Dadurch kommen die stabilen und performanten Features von Wiz auch Angular zugute. Der Fortschritt ist bereits sichtbar: Dank Incremental Hydration hat sich Angular im Bereich SSR (Server-side Rendering) von den hinteren Startreihen auf die vorderen Plätze katapultiert. In diesem Vortrag zeige ich, wann SSR sinnvoll ist, wie es implementiert wird und welche typischen Fehler und Probleme dabei auftreten können. Passt. Dann legen wir los. Willkommen und guten Morgen. Vielleicht kann man noch sagen zu meinem Vortrag. Freut mich, dass dementsprechend das Interesse vorhanden ist. Ich darf mich vielleicht ganz kurz vorstellen. Mein Name ist Hane Campreiner, komme aus Österreich, wie man hört. Bin bei Angular Architects tätig, mache dementsprechend auch sehr viel im Angular Bereich natürlich, wenn es schon vom Namen her so heißt. Neben Vorträgen und Workshops, auch in der Open Source Community ein wenig tätig also für die von euch, die Angular verwenden. Ich werde vielleicht den Begriff Angerics etwas sagen. Ich bin jetzt seit Sommer in diesem Team dabei und versuche halt da ein wenig eben auch mitzuentwickeln. Gut, um State Management wird es hier allerdings überhaupt nicht gehen. Das Thema ist ja an und für sich Server-side rendering. Vor allem, dass ihr versteht, was es ist, was für mich noch viel wichtiger ist, dass ihr auch versteht, was da die Herausforderungen sind und ich glaube, dann ergibt sich an und für sich die Frage, wann man es jetzt braucht und ob es sich das für euch jetzt wirklich rentiert, eher von selber, wenn ihr mal versteht, was da alles dafür notwendig ist, um das zu erreichen, allerdings eben auch was man dafür dann auch bekommt. Von der Agenda her schaut es aus, wir fangen grundsätzlich mit den Grundlagen an, also ich erkläre ganz kurz, Server-side rendering ist, das werden wir schnell durchhaben, dann werden wir uns auf die sogenannte incrementelle Hydration stürzen, die ist eine gewisse Besonderheit, weil die gibt es so eigentlich nur in\n'slidetext': ''\n'from': 'index'\n'score': 53.7769775390625\n'normalizedScore': 0.537769775390625\n'beforeDatePenaltyScore': 0.537769775390625\n\n'documentId': 'a527c16f5bc7b4da1bc88ab0'\n'chunk_id': '68f251653134c10012c3d1fa'\n'access': 'restricted'\n'part_number': 1\n'total_parts': 15\n'contentType': 'RHEINGOLD'\n'title': Angular Resources: Everything you need to know\n'parentName': International JavaScript New York 2025\n'language': 'EN'\n'date': '2025-10-01T12:45:00.000Z'\n'abstract': Discover how game changing Angular Resources will be for your Angular applications. We'll dive into what Angular Resources are, why they matter, and how they can replace most RxJs code in your Angular applications. We’ll see how to use resources for cleaner, more concise code. A perfect talk for those looking to level up their Angular skills and stay ahead with the latest features.\n'parentId': '9f97d5cdc68d72a05f834df4'\n'parentDescription': The JavaScript Fullstack Conference - Angular, Node.js, React and more\n'indexBrandName': 'InternationalJavaScriptCon'\n'indexSeriesName': 'NewYork'\n'author': 'Alain Chautard'\n'chunkSource': 'text'\n'text': Angular Resources: Everything you need to know Discover how game changing Angular Resources will be for your Angular applications. We'll dive into what Angular Resources are, why they matter, and how they can replace most RxJs code in your Angular applications. We’ll see how to use resources for cleaner, more concise code. A perfect talk for those looking to level up their Angular skills and stay ahead with the latest features. He's finally coming on board, hopefully like, Okay, 45, I'm going to get started. So, welcome everyone. I think most of you were here this morning already, and I'm sorry, it's gonna be a little bit of overlap, because the thing is, when you apply to speak at the conference, you, you, you submit multiple different talks, ideas, and you don't know which ones are gonna be selected, so well, and typically they don't select multiple talks either. It's just one. So, uh, so I got, uh, I got, uh, I got these too, and there was a little bit of similarities between them, but we'll go deeper in the, in the resource side of things. So yeah, angular resources, everything you need to know. So my name is Alan Oral. I'm a Google developer expert in Angular and Google Maps, which means that Google trusts me to do talk cyclists at conferences, typically, uh, and, and publish content and, and that kind of thing. Uh, been working with Angular GS since the very, very beginning of the framework, uh, back in 2011. And, uh, yeah, this got me to be an Angular developer first and then becoming more of a trainer consultant. And these days, my goal really is to help people get started with angular or scale with Angular. Sometimes companies come to me, they have, you know, a React app or something else that they want to move to Angular, or they're using Angular, but they're kind of lost and don't know where to go. And, uh, yeah, I'll have them figure, figure things out. That's, that's really the idea. Uh, I speak at conferences and I've been pretty much everywhere to do talks on angular or web developments in general, because I also do react JavaScript type script and even Cypress on the testing side of things. So that's me. Now, our topic for today is, uh, angular resources. So resources were added not that long ago in Angular, even though if we look at, um, so if, if I look at Angular, can I use and go to resource? You can see that it's experimental since Angular 19. And HDP resource was added in Angular 19.2, so\n'slidetext': ''\n'from': 'index'\n'score': 53.74883270263672\n'normalizedScore': 0.5374883270263672\n'beforeDatePenaltyScore': 0.5374883270263672\n\n'documentId': 'af6bfaa1ee403d005b7cb22d'\n'chunk_id': '690e0ea68c81760014412ab1'\n'access': 'granted'\n'part_number': 20\n'total_parts': 29\n'contentType': 'RHEINGOLD'\n'title': Wachsen ohne Chaos: Architektur für nachhaltige Angular-Projekte\n'parentName': W-JAX 2025\n'language': 'DE'\n'date': '2025-11-06T08:00:00.000Z'\n'abstract': Angular-Anwendungen wachsen oft schneller als geplant – und genau dann zeigt sich, wie gut die Architektur wirklich durchdacht ist. Features verzahnen sich, Strukturen verschwimmen, Refactorings werden riskant. In diesem Vortrag zeige ich Strategien, wie man Angular-Projekte von Anfang an strukturiert – oder bestehende Anwendungen so umbaut, dass sie langfristig wartbar und erweiterbar bleiben. Vom sinnvollen Einsatz von Feature- und Domänenmodulen bis zu Tools wie Sheriff, Signal Store und Native Federation geht es um konkrete Muster für nachhaltiges Wachstum.\n'parentId': '26c78c073b722105116a13de'\n'parentDescription': Die Konferenz für Java, Architektur- und Software-Innovation\n'indexBrandName': 'JAX'\n'indexSeriesName': ''\n'author': 'Rainer Hahnekamp'\n'chunkSource': 'text'\n'text': ist, ähm vielleicht zeige ich es noch ganz kurz her. Es geht nämlich mit dem Code wesentlich einfacher als über die Folien. Man muss dann immer wieder diese API-module einführen. Und das ist dann nicht ganz so ohne. Deswegen sagt man immer, ihr müsst halt schon aufpassen, dass ihr diese ganze API Sachen nicht übertreibt. Primär nicht deswegen, damit die Sheriff-Konfiguration so gross wird, sondern wirklich ihr wollt ja eine gewisse Struktur haben, ihr wollt, dass alles mit allem zusammenhängt. Das heisst in dem Fall, ähm das ist dann wachsen, das ist Punkt Nummer vier sind wir schon bei den sogenannten Feature Groups. Da haben wir eben wir hier schon ein bisschen mehr, das ist ja schon auch ein bisschen gewachsen, das ganze System. Und äh da haben wir dann eben hier bei Customers auf einmal so eine Art API, das ist eben dann der fünfte Modultyp und da ist es jetzt so, dass dieses Customer Modul sagt, ich stelle für Features von ausserhalb ein Service bereit, das jetzt nur einen ähm 111 ganz eine minimale Funktionalität von meinem Feature bereitstellt. In dem Fall können an und für sich andere Features abfragen, ob gerade irgendwie im System ein selektierter Kunde ähm herumschwirrt. Und dann kann ich dann diese Information verwenden, um halt jetzt wieder irgendwas anderes zu machen. Das heisst, wir haben eben hier mit Customers and Features, wo es sich wirklich um eine komplette Kundenverwaltung handelt. Da kann ich natürlich viel, viel mehr machen, wenn ich in Customers bin. Aber ausserhalb, sagen wir, nein, ausserhalb, wenn irgend jetzt Holidays oder so etwas Daten haben möchten, die dürfen nur wissen, ob gerade quasi gerade ein Kunde selektiert worden ist, aber sicherlich nicht mehr. Die dürfen jetzt nicht anfangen, Kunden anzulegen oder Kunden zu suchen oder so etwas, das ist verboten. Und da muss man dann eben dieses API Modul einführen und wie ich eben vorher gesagt habe, das ist halt dann von der Sheriff-Konfiguration dann auch nicht mehr ganz so ohne, weil man auch sehr häufig dann hergehen muss und sagt, naja, ich habe jetzt\n'slidetext': ''\n'from': 'index'\n'score': 53.29279708862305\n'normalizedScore': 0.5329279708862305\n'beforeDatePenaltyScore': 0.5329279708862305\n\n'documentId': '62f599587e3fd28de76c2756'\n'chunk_id': '68becab35b3acf0013022830'\n'access': 'restricted'\n'part_number': 5\n'total_parts': 8\n'contentType': 'READ'\n'title': Signals werden erwachsen – das neue Resource API in Angular 19 - Kolumne: Enterprise Angular\n'parentName': iJS Magazin 1.2025\n'language': 'DE'\n'date': '2025-01-29T23:00:00.000Z'\n'abstract': Das in Angular 19 zunächst experimentell eingeführte Resource API ermöglicht das asynchrone Laden von Daten in der Welt von Signals. Das gibt uns endlich die Möglichkeit, HTTP-Zugriffe in den reaktiven Fluss zu integrieren. In diesem Artikel zeige ich, wie man damit ein typisches CRUD-Szenario erstellt. Das verwendete Codebeispiel findet sich unter [1] im Branch 02e-resource.\n'parentId': 'fda1be46c7e3c0a30654c08a'\n'parentDescription': Kaum ein Softwareprojekt, das nicht in wesentlichen Teilen auf der JavaScript-Technologie basiert. Eine breite Unterstützung sowie, leistungsfähige Programmiersprachen, die Vielzahl moderner Tools, sowie ausgereifte Frameworks wie Angular, React, Vue.js oder Node.js machen den JavaScript-Werkzeugkasten zu einem Alleskönner. Das iJS Magazin informiert aktuell und umfassend über die wichtige und innovative Entwicklungen im JavaScript-Universum und bietet handfeste Praxisinformationen für Softwareentwickler und -architekten.\n'indexBrandName': ''\n'indexSeriesName': ''\n'author': 'Manfred Steyer'\n'chunkSource': 'text'\n'text': ein Ladevorgang in Ausführung ist. Mit Begriffen aus RxJS kann das als exhaustMap-Semantik beschrieben werden. Aber auch ohne Deaktivieren des automatischen Ladens kann reload nützlich sein. In diesem Fall lässt sich damit eine bereits durchführte Ladeaktion wiederholen. Intermezzo 1: linkedSignal für Updates Da der value einer Resource initial undefined ist, kommt im gezeigten Beispiel ein berechnetes Signal zum Einsatz, dass undefined durch ein leeres Objekt ersetzt: ratings = computed(() => this.ratingsResource.value() ?? {}); Allerdings sind berechnete Signals von Natur aus read-only. Um die Ratings dennoch editierbar zu gestalten, kommt die Funktion linkedSignal zum Einsatz, die das Angular-Team ebenfalls mit Angular 19 vorerst als experimentell einführt. Sie liefert ein berechnetes Signal, dessen Wert als veränderbare Arbeitskopie vorliegt. ratings = linkedSignal(() => this.ratingsResource.value() ?? {}); Stößt Angular die Berechnung erneut an, wird die Arbeitskopie des linkedSignal mit dem neuen Ergebnis überschrieben. Durch diese Eigenschaft ist linkedSignal prädestiniert für Formulare: Beim Editieren ändert die Datenbindung die lokale Arbeitskopie und der Speichervorgang sendet diese später an den Server zurück. Fehlerbehandlung Auch die Fehlerbehandlung ist in das Resource API integriert. Wenn der Loader über das zurückgegebene Promise einen Fehler meldet, wechselt die Resource in den Zustand Error. In diesem Zustand informiert das error Signal über den vorliegenden Fehler. Die Resource funktioniert jedoch auch nach dem Auftreten eines Fehlers: Wenn jemand die reload-Methode aufruft oder wenn sich das request Signal ändert, kommt der Loader erneut zur Ausführung. War der Loader erfolgreich, setzt die Ressource das error Signal zurück und wechselt in den Zustand resolved. Das ist vergleichbar mit dem heutigen Standardverhalten von Effects in NgRx, wo ein wenig Zusatzlogik unter der Motorhaube verhindert, dass die verwendete RxJS-Pipe im Fehlerfall anhält. RxJS-Interop mit rxResource Wenn die Anwendung bereits Observables nutzt, müssen diese nicht manuell in Promises umgewandelt werden. Stattdessen lässt sich das API rxResource aus @angular/core/rxjs-interop verwenden. Es funktioniert wie resource, allerdings liefert der Loader ein Observable. Listing 5 import { rxResource } from '@angular/core/rxjs-interop'; […] dessertsResource = rxResource({ request: this.dessertsCriteria, loader: (param) => { return\n'slidetext': ''\n'from': 'index'\n'score': 53.19266891479492\n'normalizedScore': 0.5319266891479493\n'beforeDatePenaltyScore': 0.5319266891479493\n\n'documentId': 'af6bfaa1ee403d005b7cb22d'\n'chunk_id': '690e0ea68c81760014412ab2'\n'access': 'granted'\n'part_number': 21\n'total_parts': 29\n'contentType': 'RHEINGOLD'\n'title': Wachsen ohne Chaos: Architektur für nachhaltige Angular-Projekte\n'parentName': W-JAX 2025\n'language': 'DE'\n'date': '2025-11-06T08:00:00.000Z'\n'abstract': Angular-Anwendungen wachsen oft schneller als geplant – und genau dann zeigt sich, wie gut die Architektur wirklich durchdacht ist. Features verzahnen sich, Strukturen verschwimmen, Refactorings werden riskant. In diesem Vortrag zeige ich Strategien, wie man Angular-Projekte von Anfang an strukturiert – oder bestehende Anwendungen so umbaut, dass sie langfristig wartbar und erweiterbar bleiben. Vom sinnvollen Einsatz von Feature- und Domänenmodulen bis zu Tools wie Sheriff, Signal Store und Native Federation geht es um konkrete Muster für nachhaltiges Wachstum.\n'parentId': '26c78c073b722105116a13de'\n'parentDescription': Die Konferenz für Java, Architektur- und Software-Innovation\n'indexBrandName': 'JAX'\n'indexSeriesName': ''\n'author': 'Rainer Hahnekamp'\n'chunkSource': 'text'\n'text': jetzt zwar eine API, aber ich will jetzt auch nicht unbedingt, dass jetzt jeder auf diese API zugreifen darf, sondern ich sage jetzt, vielleicht jetzt nur das Buchungsmodul darf auf diese Customers API zugreifen, aber nicht die anderen. Und da fängt es halt dann an eben sehr, sehr kompliziert, sehr sehr schnell zu werden. deswegen eben vermeiden, aber wenn man es braucht, geht's natürlich dann schon. Was man hier auch noch sieht, da muss ich jetzt wieder in die Folien zurückgehen, sind diese Ausprägungen, diese Riesenfeatures, wenn man so sagen möchte. äh was man eben hier, was hier unter dem Namen Feature Groups definiert worden ist. Also wenn Sie sich jetzt vorstellt, so wie es eben da dargestellt wird, wir haben so eine Art Domäne, die heisst Holidays. Da haben wir am Anfang das Quiz drinnen gehabt und im Laufe der Zeit sind dann eben in diesen in dieser Domäne weitere Features hinzugekommen. Also jetzt nicht nur das Quiz, sondern da ist dann vielleicht auch noch ein Shop dazugekommen, eine Übersicht oder halt irgendwas anderes. Das Problem ist jetzt, wenn ich jetzt sage, ich habe jetzt diese diese diese Riesen Domäne, diesen Riesenordner, der eben Holidays heisst und ich packe da jetzt die ganzen Features hinein. dann stellt sich sehr bald die Frage, ähm haben wir da jetzt nicht eine zusätzliche Ebene? Weil im Endeffekt hat ja das das Quiz ein gewisses Model, da greift es vielleicht auf Holidays zu, es hat vielleicht gewisse Services. Und wie ist das jetzt, wenn jetzt eben ein gewisses Service ist, wie zum Beispiel jetzt für das Holidays holen allgemein, wenn es jetzt von mehreren von diesen Features gebraucht wird. Das kann es ja auch geben. Und da sehen wir eben hier eben, würde ich jetzt einmal sagen, diesen ersten Ansatz, wie man das Ganze lösen kann. Das heisst, wir sagen, wir haben eine mittlere Schicht, da befinden sich diese grundlegenden Services drinnen, das ist eben das Data. Alle Features können auf dieses Data zugreifen. Wir stellen auch gewisse UI-Komponenten bereit, die auch auf alle Features zugreifen können und dann hoffen wir einfach,\n'slidetext': ''\n'from': 'index'\n'score': 53.12217330932617\n'normalizedScore': 0.5312217330932617\n'beforeDatePenaltyScore': 0.5312217330932617\n\n\nTop Vectors:\n'documentId': 'ac8bcbad20150e9773f7400b'\n'chunk_id': '69021a60a5de460012a1af2b'\n'access': 'granted'\n'part_number': 11\n'total_parts': 11\n'contentType': 'RHEINGOLD'\n'title': Getting the most out of Angular DevTools\n'parentName': International JavaScript Conference Munich 2025\n'language': 'EN'\n'date': '2025-10-29T09:15:00.000Z'\n'abstract': In this session, we’ll dive into Angular DevTools and how it can enhance your development experience. From getting started with installation and setup to exploring the interface, you'll learn how to quickly get it running and connected to your Angular app. We’ll cover debugging techniques using the component tree, tracking state changes, and spotting binding issues. You’ll also get hands-on with performance profiling, learn how to identify rendering bottlenecks, and understand what the timeline panel is really telling you. A dedicated section on inspecting injectors will help demystify Angular’s dependency injection. Finally, we’ll wrap up with tips and hidden gems to help you get the most value from DevTools day to day. Whether you're new to Angular or a seasoned developer, this session will give you practical, actionable ways to make Angular DevTools an essential part of your workflow.\n'parentId': 'd9a5c0715a7cff50bbb51e14'\n'parentDescription': \n'indexBrandName': 'InternationalJavaScriptCon'\n'indexSeriesName': 'Munich'\n'author': 'Sam Vloeberghs'\n'chunkSource': 'text'\n'text': the signal graph, yeah. Yeah, so I had to repeat for, for the audience online, the question was if there uh. Is a, uh, if you're using a signal store, will it uh allow, will the angular dev tools allow you to uh click through to the sources of the um of the signal stores signal store directly. Yeah. Any other questions? If you're shy and don't want to ask your question in public, you can always uh ask me privately as well. Um. And uh yeah, please um provide your feedback uh in the uh conference application afterwards. Thank you. There are some Questions from the audience as well. Let me see. There's a question from the audience. Uh, I do not have the router tree tap. Uh, is my angular De Tools an old version? It could be, um, it could be that you're using an older version of your, uh, in your angular application as well. But the uh router tree. Uh, let me see. Is a feature that you need to enable explicitly. So it's not enabled by default. You can use the top level, um, let me. Share my full screen. So the router tree is a feature that you'll need to explicitly enable. All right. Thank you.\n'slidetext': ''\n'from': 'vector'\n'score': 0.9001873731613159\n'normalizedScore': 0.8995181192514986\n'beforeDatePenaltyScore': 0.9001873731613159\n\n'documentId': '0747f0655ef3790a97eba95b'\n'chunk_id': '68f24b683134c10012c3d12f'\n'access': 'restricted'\n'part_number': 4\n'total_parts': 16\n'contentType': 'RHEINGOLD'\n'title': How to architect Angular apps in 2025\n'parentName': International JavaScript New York 2025\n'language': 'EN'\n'date': '2025-10-01T08:15:00.000Z'\n'abstract': In this talk, Alain showcases several architecture concepts he uses to optimize apps for performance, readability, and scalability in 2025 and beyond. We’ll touch on using Signals as state in our services, how to control access to such Signals, using the new resource API, and more!\n'parentId': '9f97d5cdc68d72a05f834df4'\n'parentDescription': The JavaScript Fullstack Conference - Angular, Node.js, React and more\n'indexBrandName': 'InternationalJavaScriptCon'\n'indexSeriesName': 'NewYork'\n'author': 'Alain Chautard'\n'chunkSource': 'text'\n'text': if we compare, you know, a, an simple Hello World app before, so that's Angular 14, you needed at least an app module with an app component and import stuff like browser modules and blah, blah, blah, blah, blah, blah, just to display head world, right? And now if I take Angular 20 while I'm down to just that because I don't have an app module anymore, I'm down to just my app component. Um, and it's, it's a lot easier, right? And the Angular team doesn't want to stop here. This is really very much a work in progress. Um, and there's a lot of changes coming up in the near future, uh, what is called component authoring improvements, which means really trying to remove everything that we don't need or that doesn't bring value to our angular syntax. So for instance, not that long ago, we, we, we needed to have standalone true, but now it's a default. So you don't don't need that anymore. The selector while, you know, 99.9% of the time, I guess you just use the default one, right? So why do we need that if we always use the same thing? So the selector the plan is all that to go away. And so we we're gonna get to a point where all we have in the component decorator would be a template or a template to RL, which is really all we need. So that's, that's what's coming next, really. So going all the way to simplifying as much as possible so that, um, so that, yeah, we remove all of the boilerplate around angular components. So yeah, the, the, the Angular team announced this couple years ago. Uh, and, and I think it's a very good way to summarize the, the mindset of everything that's going on right now. Uh, and our goal is build angular for the next 10 years and ensure that it's still an excellent choice 10 years from now. So basically, you want to regret, but that's the answer. If you start with Angular today, 10 years from now, you should still be happy. That's, that's the idea. And so they also officially said at least a couple times that the goal is to get, well, not get rid of, but at least make optional RXJS and zone Gs. So you don't, you, you could write angular apps without these two, right? So we'll see how that, that works and, and what are the impacts on architecture, because that's what we're here to talk about. So the first big impact on architecture that really drives all of the decisions\n'slidetext': ''\n'from': 'vector'\n'score': 0.8945529460906982\n'normalizedScore': 0.8923471624998814\n'beforeDatePenaltyScore': 0.8945529460906982\n\n'documentId': '73a55b4bbeecf374b233deaf'\n'chunk_id': '687a299f2491ed518a3f0cf6'\n'access': 'restricted'\n'part_number': 1\n'total_parts': 1\n'contentType': 'RHEINGOLD'\n'title': Angular’s New Era: Unveiling the Most Exciting Features Yet\n'parentName': International JavaScript Conference Singapore 2024\n'language': 'EN'\n'date': '2024-11-27T09:15:00.000Z'\n'abstract': In this session, we'll explore the groundbreaking features of Angular that are transforming the way we build modern web applications. From a simplified developer experience for creating new apps to standalone components that improve modularity, Angular is stepping up its game. We’ll dive into lazy loading for routes and components, optimizing performance and load times, and explore the power of control flow for dynamic, responsive UIs. Discover the magic of deferrable views that help you prioritize critical content, and get an inside look at signals—a new, reactive paradigm for managing state and change detection. We’ll also uncover the potential of zoneless Angular, offering maximum performance by reducing overhead, and take a peek into some of the forthcoming features that promise to shape the future of Angular development. Join us to discover how these game-changing features can take your Angular apps to the next level.\n'parentId': 'gdaJCohaAMyedJZCT'\n'parentDescription': The JavaScript Fullstack Conference - Angular, Node.js, React and more\n'indexBrandName': 'InternationalJavaScriptCon'\n'indexSeriesName': 'Singapore'\n'author': 'Pankaj Parkar'\n'chunkSource': 'text'\n'text': Angular’s New Era: Unveiling the Most Exciting Features Yet In this session, we'll explore the groundbreaking features of Angular that are transforming the way we build modern web applications. From a simplified developer experience for creating new apps to standalone components that improve modularity, Angular is stepping up its game. We’ll dive into lazy loading for routes and components, optimizing performance and load times, and explore the power of control flow for dynamic, responsive UIs. Discover the magic of deferrable views that help you prioritize critical content, and get an inside look at signals—a new, reactive paradigm for managing state and change detection. We’ll also uncover the potential of zoneless Angular, offering maximum performance by reducing overhead, and take a peek into some of the forthcoming features that promise to shape the future of Angular development. Join us to discover how these game-changing features can take your Angular apps to the next level.\n'slidetext': ''\n'from': 'vector'\n'score': 0.9011396169662476\n'normalizedScore': 0.8820594041523206\n'beforeDatePenaltyScore': 0.9011396169662476\n\n'documentId': '01073933df6d62616b01fd1e'\n'chunk_id': '68ac7b53494be90012217afb'\n'access': 'restricted'\n'part_number': 30\n'total_parts': 30\n'contentType': 'RHEINGOLD'\n'title': Skalierbare Architekturen in Angular mit Nx\n'parentName': BASTA! Spring 2025\n'language': 'DE'\n'date': '2025-03-06T11:00:00.000Z'\n'abstract': Je größer deine Angular-Anwendung wird, desto größer werden auch die Herausforderungen, eine skalierbare und wartbare Codebasis zu erhalten. Ohne eine durchdachte Architektur kann die Komplexität schnell außer Kontrolle geraten, was zu schlechten Applikationen und Verzögerungen in der Entwicklung führt. In diesem Vortrag zeigt Fabian Gosebrink, wie man mit Nx skalierbare und modulare Architekturen für Angular-Anwendungen aufbaut. Wir lernen, wie Nx uns hilft, große Codebasen in überschaubare Bibliotheken zu organisieren, den Code aufzuteilen und die Zusammenarbeit in Teams zu verbessern. Wir behandeln Best Practices für das Einrichten von Workspaces, die Nutzung der leistungsstarken Tools von Nx und die Optimierung deines Entwicklungsprozesses. Am Ende dieser Session haben die Entwickler ein klares Verständnis dafür, wie man Angular-Anwendungen mit Nx strukturiert, um langfristige Wartbarkeit, bessere Performance und eine leichtere Zusammenarbeit für kleine und große Teams zu gewährleisten.\n'parentId': '577ff41c05af8176bbd0043d'\n'parentDescription': Die Konferenz für .NET, Web & AI Innovation\n'indexBrandName': 'BASTA!'\n'indexSeriesName': 'Spring'\n'author': 'Fabian Gosebrink'\n'chunkSource': 'text'\n'text': machen. Dann kann man den Branch Merge und wenn alle dann kommen, müssen sie einmal updaten, komplett neue Files, aber das ist nun einmal so. Sie bewerben dieses Nx Migrate Feature, ich habe keine so guten Erfahrungen damit gemacht. Dann gibt es noch eine Kompatibilitätsmatrix, die Version von Nx ist nicht gleich, die ist entkoppelt von der Angular Version, weil Nx eben mehr ist als Angular. Trotzdem gibt es so eine Kompatibilitätsmatrix, da könnt ihr gucken, welche Library oder welche Angular Version mit Nx kompatibel ist. Wenn ihr mehr darüber wissen wollt, gibt es einen Kurs auf Plurisite von einem ziemlich coolen Typen, der das gemacht hat, könnt ihr euch ja mal angucken, da gehe ich nochmal darauf ein. Wie gesagt ihr kriegt die Folien alle, sind sogar schon online. Ansonsten kann ich euch nur empfehlen, jedes Angular Projekt auch mit Nx umzusetzen. Die Vorteile sind einfach da, sehr vorteilhaft sowas zu verwenden. Diese ganzen Features, ich aus der Box bekomme, wirklich, ich möchte sie nicht mehr missen. Wie gesagt, ich mache dann auch noch State Management, so damit wir von solchen Applikationen, von diesem Big Ball of Mod auf solche Applikationen kommen und dann eine Übersicht haben, was bei uns in der Applikation passiert. Vielen Dank an der Stelle, ich wünsche euch einen guten Appetit und die Slides findet ihr hier.\n'slidetext': ''\n'from': 'vector'\n'score': 0.8954849243164062\n'normalizedScore': 0.8818333644698817\n'beforeDatePenaltyScore': 0.8954849243164062\n\n'documentId': 'cfe389e23ed61a9ae7f11b32'\n'chunk_id': '68ac830f494be90012217e60'\n'access': 'restricted'\n'part_number': 1\n'total_parts': 1\n'contentType': 'RHEINGOLD'\n'title': Modern Angular Workshop: Architektur und Features\n'parentName': BASTA! Spring 2025\n'language': 'DE'\n'date': '2025-03-07T08:00:00.000Z'\n'abstract': Lernen Sie langfristig wartbare Enterprise-Lösungen mit modernem Angular zu entwerfen! In diesem Workshop tauchen Sie tief in die neuesten Angular-Features ein, um moderne, wartbare Anwendungsarchitekturen zu entwickeln. Lernen Sie, wie Sie Standalone Components nutzen, neue Modularisierungsansätze mit Nx und Sheriff anwenden, und erfahren Sie mehr über die aktualisierten APIs für HttpClient und Router. Entdecken Sie neue Built-in Control Flow Blocks, Signals für verbesserte Change Detection und den Signal Store für effektives State-Management.\n'parentId': '577ff41c05af8176bbd0043d'\n'parentDescription': Die Konferenz für .NET, Web & AI Innovation\n'indexBrandName': 'BASTA!'\n'indexSeriesName': 'Spring'\n'author': 'Manfred Steyer,Rainer Hahnekamp'\n'chunkSource': 'text'\n'text': Modern Angular Workshop: Architektur und Features Lernen Sie langfristig wartbare Enterprise-Lösungen mit modernem Angular zu entwerfen! In diesem Workshop tauchen Sie tief in die neuesten Angular-Features ein, um moderne, wartbare Anwendungsarchitekturen zu entwickeln. Lernen Sie, wie Sie Standalone Components nutzen, neue Modularisierungsansätze mit Nx und Sheriff anwenden, und erfahren Sie mehr über die aktualisierten APIs für HttpClient und Router. Entdecken Sie neue Built-in Control Flow Blocks, Signals für verbesserte Change Detection und den Signal Store für effektives State-Management.\n'slidetext': ''\n'from': 'vector'\n'score': 0.8941227197647095\n'normalizedScore': 0.8805191051236643\n'beforeDatePenaltyScore': 0.8941227197647095\n\n'documentId': 'd74f910ab5ef9854703a97d3'\n'chunk_id': '6876dc4d225e92fc1ac7cc8e'\n'access': 'restricted'\n'part_number': 1\n'total_parts': 1\n'contentType': 'RHEINGOLD'\n'title': Fit für die Zukunft: Migration zu Modern Angular\n'parentName': JavaScript Days München und online 2025\n'language': 'DE'\n'date': '2025-03-20T12:30:00.000Z'\n'abstract': In den letzten Monaten hat Angular zahlreiche neue Features erhalten, die es ermöglichen, das Framework auf moderne und leichtgewichtige Weise zu verwenden. Signals für eine moderne und performante Change Detection, Standalone Components und Standalone APIs, funktionale Guards und Interceptoren, esbuild-Unterstützung sowie und zahlreiche Verbesserungen beim Router sind ein paar Beispiele dafür. In diesem Workshop starten wir mit einer klassischen Angular-Lösungen, die wir nach und nach um die neuen Möglichkeiten erweitern. Somit ergibt sich eine leichtgewichtige und moderne Lösung, die sich einfacher warten lässt und die Vorteile der neuen Features auch nutzen kann. Am Ende wissen Sie, wie sich Ihre Angular-Lösung modernisieren lässt und welche neuen Features sich für Ihre Vorhaben lohnen.\n'parentId': 'efd4ff41c4b9e889b50854b8'\n'parentDescription': 40 Workshops zu JavaScript, Angular, React, HTML & CSS und KI\n'indexBrandName': 'JavaScriptDays'\n'indexSeriesName': 'Munich'\n'author': 'Manfred Steyer'\n'chunkSource': 'text'\n'text': Fit für die Zukunft: Migration zu Modern Angular In den letzten Monaten hat Angular zahlreiche neue Features erhalten, die es ermöglichen, das Framework auf moderne und leichtgewichtige Weise zu verwenden. Signals für eine moderne und performante Change Detection, Standalone Components und Standalone APIs, funktionale Guards und Interceptoren, esbuild-Unterstützung sowie und zahlreiche Verbesserungen beim Router sind ein paar Beispiele dafür. In diesem Workshop starten wir mit einer klassischen Angular-Lösungen, die wir nach und nach um die neuen Möglichkeiten erweitern. Somit ergibt sich eine leichtgewichtige und moderne Lösung, die sich einfacher warten lässt und die Vorteile der neuen Features auch nutzen kann. Am Ende wissen Sie, wie sich Ihre Angular-Lösung modernisieren lässt und welche neuen Features sich für Ihre Vorhaben lohnen.\n'slidetext': ''\n'from': 'vector'\n'score': 0.8933886289596558\n'normalizedScore': 0.8805076170583366\n'beforeDatePenaltyScore': 0.8933886289596558\n\n'documentId': 'ec8de39dac90e93f9fd00a92'\n'chunk_id': '687a312cca798166d3ba43b5'\n'access': 'restricted'\n'part_number': 11\n'total_parts': 12\n'contentType': 'RHEINGOLD'\n'title': Optimizing Angular Applications - Techniques for Performance Excellence\n'parentName': International JavaScript New York 2024\n'language': 'EN'\n'date': '2024-10-09T14:15:00.000Z'\n'abstract': In today’s fast-paced digital landscape, delivering high-performance applications is crucial for a seamless user experience. This presentation dives deep into proven strategies and best practices for optimizing Angular applications. We will explore advanced techniques such as lazy loading, change detection strategies, signal-based state management, and leveraging NgOptimizedImage for better load times. Attendees will gain insights into optimizing bundle sizes, efficient HTTP communication, tree-shaking, and more. Whether you're dealing with large-scale apps or looking to enhance performance in smaller projects, this session provides actionable takeaways to improve your Angular application's speed and efficiency.\n'parentId': 'xhXxg9ohmYPxSZtL6'\n'parentDescription': The JavaScript Fullstack Conference - Angular, Node.js, React and more\n'indexBrandName': 'InternationalJavaScriptCon'\n'indexSeriesName': 'NewYork'\n'author': 'Sonu Kapoor'\n'chunkSource': 'text'\n'text': significant performance when implemented correctly. So in order to implement this, you need to add the, provide experimental zones, change detection during the application bootstrap rep. You also need to remove zone js from your polyfil and make sure that you're using at least angular version 18. So before you enable zone less in your application, keep in mind that this API is currently experimental, so anything can change at any time. Uh, regardless of that, here is a snippet of how you could try this out and if you run into any issues, I suggest that you open a ticket in the GitHub angular repo so that the Angular team is aware of it. And that's it. I hope these tips were helpful and as always, please connect with me over LinkedIn or Twitter. Um, and again, the repo with all the amazing animations I did, um, are here in the GitHub repo. Any questions? Yeah, go ahead please. I think you refer something incorrect there actually on post, we'll check double three, not just confidence that changes. Okay. Right. So from what I remember, I think it's just the, the component and its ancestors, right? No, it checks the all three, but what does constantly checking, Okay, just When we say okay, check now. Yeah, change on input on observable. Yeah, asy observable and things like that. Yeah. Yes, but it'll select complete not only the company, what's changed that year is the signoffs. With signoffs we can, uh, use our push to as a way to be stable. Um, constant tracking and Okay, I was under the impression that it only checks the component, uh, and not the entire tree because then what's the difference between? Difference Is that it's not automatically changing. Uh, every time you plate changes you on complex, you can use use or push and you decide when all the updates finish. Mm-Hmm. Then you will call the, I don't remember the directive buyer, but force the check You Okay. Will Happen on the complete. Yeah. So you don't, you don't actually have to force it. Um, so if you have on push set up and any of your input references change, then it will automatically trigger the change detection. And also when you have async operations right, then it will also automatically do that. Um, yeah. But thank you. Any other questions? I think you had one. Yeah. Um, lazy loading, first part From the routing. Yeah. Seems so easy to implement. Is there, uh, any reason you wouldn't wanna implement that application? Um, that's a good question. I mean, it should be the default I think, right? Um,\n'slidetext': ''\n'from': 'vector'\n'score': 0.9018042087554932\n'normalizedScore': 0.8800504799598311\n'beforeDatePenaltyScore': 0.9018042087554932\n\n'documentId': '5ca564ac8c4557f4f949b660'\n'chunk_id': '687a2b82495b49563aa87acd'\n'access': 'restricted'\n'part_number': 1\n'total_parts': 9\n'contentType': 'RHEINGOLD'\n'title': Level-up your Angular Codebase with Cutting-Edge APIs\n'parentName': International JavaScript Conference Munich 2024\n'language': 'EN'\n'date': '2024-11-13T10:45:00.000Z'\n'abstract': The Angular team is propelling the enterprise frontend framework into a promising future with new, robust APIs. Modern concepts, validated in the JavaScript ecosystem, such as enhanced server-side rendering support, the new Control Flow syntax, Standalone APIs instead of NgModules, and optional RxJS, as well as Zone.js, are paving the way for a brighter future with an easier-to-manage codebase and an excellent developer experience. But how does this impact your current codebase? What refactoring strategy strikes the ideal balance between future-proofing and budget constraints? The reassuring news is that backward compatibility remains paramount. The pace at which you refactor your codebase to leverage the latest framework features is entirely your choice. Join my talk for a practical session where we explore these new APIs and discuss strategies to transform your code into a future-proof application.\n'parentId': 'R8y8tP2vbKi3twHpf'\n'parentDescription': The JavaScript Fullstack Conference - Angular, Node.js, React and more\n'indexBrandName': 'InternationalJavaScriptCon'\n'indexSeriesName': 'Munich'\n'author': 'Michael Egger-Zikes'\n'chunkSource': 'text'\n'text': Level-up your Angular Codebase with Cutting-Edge APIs The Angular team is propelling the enterprise frontend framework into a promising future with new, robust APIs. Modern concepts, validated in the JavaScript ecosystem, such as enhanced server-side rendering support, the new Control Flow syntax, Standalone APIs instead of NgModules, and optional RxJS, as well as Zone.js, are paving the way for a brighter future with an easier-to-manage codebase and an excellent developer experience. But how does this impact your current codebase? What refactoring strategy strikes the ideal balance between future-proofing and budget constraints? The reassuring news is that backward compatibility remains paramount. The pace at which you refactor your codebase to leverage the latest framework features is entirely your choice. Join my talk for a practical session where we explore these new APIs and discuss strategies to transform your code into a future-proof application. Um, I'm giving you a talk today about Angola again, quite nice, and we, the architects mantra already gave him No, we are not talking about shell symbolize a little bit older, tiny, nice, the new wave of features started actually, um, refactoring, uh, the rendering engine Ivy, you know. to make this compatible also internally for Google. It's like a, a surgery on the open heart, right? So they really learned out of the, I would might even say, The whole community was angry about that. to do this completely in a different way, So not the Angular bubble, only and maybe only with Angola. and the React people are thinking the same. So JavaScript experts and how the Angular team is meanwhile, um, trying, Uh, this is actually part of my presentation today. which new feature was added. Uh, people are not sure which APIs they need to implement one of the APIs that we're currently working and of course, questions are always welcomed. then feel free to ask. to the table that we can use right now So with Angular 13, they also did a quite important change, So Angular is a modern framework, As their, uh, support for Internet Explorer dropped out, um, of polyfils, although there was already a possible solution separately compiled. but, um, it, it turned out to be a good one. they introduced Atmos script models for the browser. Uh, if there are Atmos script models The CLI is managing quite a bunch of things for us. Um, and that's basically a thing that that helps us So with, uh, Angola 14, they introduced, um, having a new API that works, again, compatible side by side, in, uh,\n'slidetext': ''\n'from': 'vector'\n'score': 0.8994736671447754\n'normalizedScore': 0.8796297557007114\n'beforeDatePenaltyScore': 0.8994736671447754\n\n'documentId': '5ca564ac8c4557f4f949b660'\n'chunk_id': '687a2b82495b49563aa87acf'\n'access': 'restricted'\n'part_number': 3\n'total_parts': 9\n'contentType': 'RHEINGOLD'\n'title': Level-up your Angular Codebase with Cutting-Edge APIs\n'parentName': International JavaScript Conference Munich 2024\n'language': 'EN'\n'date': '2024-11-13T10:45:00.000Z'\n'abstract': The Angular team is propelling the enterprise frontend framework into a promising future with new, robust APIs. Modern concepts, validated in the JavaScript ecosystem, such as enhanced server-side rendering support, the new Control Flow syntax, Standalone APIs instead of NgModules, and optional RxJS, as well as Zone.js, are paving the way for a brighter future with an easier-to-manage codebase and an excellent developer experience. But how does this impact your current codebase? What refactoring strategy strikes the ideal balance between future-proofing and budget constraints? The reassuring news is that backward compatibility remains paramount. The pace at which you refactor your codebase to leverage the latest framework features is entirely your choice. Join my talk for a practical session where we explore these new APIs and discuss strategies to transform your code into a future-proof application.\n'parentId': 'R8y8tP2vbKi3twHpf'\n'parentDescription': The JavaScript Fullstack Conference - Angular, Node.js, React and more\n'indexBrandName': 'InternationalJavaScriptCon'\n'indexSeriesName': 'Munich'\n'author': 'Michael Egger-Zikes'\n'chunkSource': 'text'\n'text': 19. You might argue. Now that's not good Um, don't worry about that just add standalone falls to your other, uh, So the, the concept of angular working with the CLI that this is really nothing to worry. NG module, uh, based, uh, implementations uh, standalone APIs. uh, of a smart component. The smart component is engine module based, variables in general is all of them. This was, at the beginning at least, everyone expected components, but it turned out that we have right now, no matter whether or do already require the standalone API, so especially of your ad component decorator. if you want to switch your routing configuration, uh, and not, uh, engine modules anymore, they again, need to be standalone, Um, one day that they will come, clear guidance from the angular team, Uh, so we are, they will ask the community whether, uh, yet, but of course, we can expect one day in future, uh, so many years now. Um, so yes, definitely it will be necessary, um, uh, angular 15. or already, uh, production support for standalone. How can you do so? I will answer this in a moment. Um, Standalone features, uh, from existing engine modules by, uh, using, sorry, to implement new features, that's the point here. Don't, um, uh, use engine modules So try to, to implement new features already where, you know, that's an existing feature, Then consider, uh, turning that into, uh, support of migration? You cannot one So it's really a nice assistance, uh, compared at angular core standalone command. The first step is, um, of your repository you want to change. Yeah. So if you have a repository with several apps to generate the component in or the service in then you will find it's not the It's this time at angular core. Um, so that's also the reason why we typically choose the migration code, right? that would be the equivalent and you just tell the CLI, which package to use for that. And as mentioned, it's not a project like the project flag. to turn the whole repository with all apps or you want to dig deeper that application or only one feature of that application. to turn components, directives, pipes, um, where the module is currently located. And basically that's the thing that the CLI helps you with. uh, for you directly. So turning your, uh, feature based feature modules But this can be done quite easily manually, So whether it is safe to remove the feature module We have here repository So we have normal, uh, ENG modules, um, a boarding, g\n'slidetext': ''\n'from': 'vector'\n'score': 0.8956260681152344\n'normalizedScore': 0.8757821566705363\n'beforeDatePenaltyScore': 0.8956260681152344\n\n'documentId': '6883afe7f10bc00f03909bef'\n'chunk_id': '687a370def5cff79d6f5cf11'\n'access': 'restricted'\n'part_number': 16\n'total_parts': 19\n'contentType': 'RHEINGOLD'\n'title': Built to last: Angular's Lessons in Framework Resilience\n'parentName': International JavaScript New York 2024\n'language': 'EN'\n'date': '2024-10-08T07:15:00.000Z'\n'abstract': In 'Built to Last: Angular's Lessons in Framework Resilience,' we set off on a journey through the evolution of Angular. We'll delve into the pivotal moments, both triumphs and setbacks, that have shaped Angular's remarkable resilience over a decade of constant change.  Discover the key design decisions, community-driven improvements, and adaptive strategies that have enabled Angular to not only survive but thrive in the ever-evolving tech landscape.  Whether you're a seasoned Angular developer or a newcomer to the framework, this talk will offer insights and inspiration for building frameworks, products, and even careers that are built to last.\n'parentId': 'xhXxg9ohmYPxSZtL6'\n'parentDescription': The JavaScript Fullstack Conference - Angular, Node.js, React and more\n'indexBrandName': 'InternationalJavaScriptCon'\n'indexSeriesName': 'NewYork'\n'author': 'Mark Thompson'\n'chunkSource': 'text'\n'text': like, my, I'm changing, I'm clicking the button but nothing's happening. 'cause you're like, oh yeah, you forgot to set state, right? Okay, an angular, that process is automatic. If you change the data, the application updates, that's supposed to be like a roar of applause of uh, being impressed. Okay? But here's what we found out though, even with this idea, which was really great when you first started, but over time as applications grew in complexity grew in scale, it was a limit. And then people were like, why do we have to do it this way? It exposes too many sharp edges. Meaning you have to know too much about angular now when something goes wrong. And that's about the developer experience that I've been talking about is the new, you know, space where frameworks will separate themselves is not about like, you know, who has the newest feature features will be copied. That's, that's easy. Now everything's open source for one. And everybody's very public about what they do. Features are not the new thing. What the really interesting thing is what is the developer experience that's more interesting. I thought he was coming to take me off the stage. I'm like, I'm not done yet. Alright, so our modern reactivity ended up being signals. We added three new framework and we three new primitives. Yeah, signal computed and effect. And the signals just this idea that there's a box that contains the value and if that value changes it can notify any, any interested consumers, right? And we made it really nice that the way we become an interested consumer is that you just reference it. So if you reference it, then you are interested consumer. And so that value will be updated, which is a really nice flow. Here's what we did right this time we made it opt in. Meaning whatever you were working on before, if you were using our old change detection still works. If you didn't want to use signals, nothing changes for you, you could still get all the other stuff. Then we shipped it as a developer preview to signal that it, it wasn't ready for production but we're working on it and we wanna get your feedback much different flow. Think about this for your users at your organizations, for whatever you're working on, how can you do something like this? How can you create developer previews to get feedback? See, these are hard lessons, but it allows us to move at a speed now that we've never been able to move at before because we can release APIs as developer preview, iterate on them, developers can\n'slidetext': ''\n'from': 'vector'\n'score': 0.8975516557693481\n'normalizedScore': 0.8757271507179782\n'beforeDatePenaltyScore': 0.8975516557693481\n\n'documentId': '6883afe7f10bc00f03909bef'\n'chunk_id': '687a370eef5cff79d6f5cf20'\n'access': 'restricted'\n'part_number': 16\n'total_parts': 19\n'contentType': 'RHEINGOLD'\n'title': Built to last: Angular's Lessons in Framework Resilience\n'parentName': International JavaScript New York 2024\n'language': 'EN'\n'date': '2024-10-08T07:15:00.000Z'\n'abstract': In 'Built to Last: Angular's Lessons in Framework Resilience,' we set off on a journey through the evolution of Angular. We'll delve into the pivotal moments, both triumphs and setbacks, that have shaped Angular's remarkable resilience over a decade of constant change.  Discover the key design decisions, community-driven improvements, and adaptive strategies that have enabled Angular to not only survive but thrive in the ever-evolving tech landscape.  Whether you're a seasoned Angular developer or a newcomer to the framework, this talk will offer insights and inspiration for building frameworks, products, and even careers that are built to last.\n'parentId': 'xhXxg9ohmYPxSZtL6'\n'parentDescription': The JavaScript Fullstack Conference - Angular, Node.js, React and more\n'indexBrandName': 'InternationalJavaScriptCon'\n'indexSeriesName': 'NewYork'\n'author': 'Mark Thompson'\n'chunkSource': 'text'\n'text': like, my, I'm changing, I'm clicking the button but nothing's happening. 'cause you're like, oh yeah, you forgot to set state, right? Okay, an angular, that process is automatic. If you change the data, the application updates, that's supposed to be like a roar of applause of uh, being impressed. Okay? But here's what we found out though, even with this idea, which was really great when you first started, but over time as applications grew in complexity grew in scale, it was a limit. And then people were like, why do we have to do it this way? It exposes too many sharp edges. Meaning you have to know too much about angular now when something goes wrong. And that's about the developer experience that I've been talking about is the new, you know, space where frameworks will separate themselves is not about like, you know, who has the newest feature features will be copied. That's, that's easy. Now everything's open source for one. And everybody's very public about what they do. Features are not the new thing. What the really interesting thing is what is the developer experience that's more interesting. I thought he was coming to take me off the stage. I'm like, I'm not done yet. Alright, so our modern reactivity ended up being signals. We added three new framework and we three new primitives. Yeah, signal computed and effect. And the signals just this idea that there's a box that contains the value and if that value changes it can notify any, any interested consumers, right? And we made it really nice that the way we become an interested consumer is that you just reference it. So if you reference it, then you are interested consumer. And so that value will be updated, which is a really nice flow. Here's what we did right this time we made it opt in. Meaning whatever you were working on before, if you were using our old change detection still works. If you didn't want to use signals, nothing changes for you, you could still get all the other stuff. Then we shipped it as a developer preview to signal that it, it wasn't ready for production but we're working on it and we wanna get your feedback much different flow. Think about this for your users at your organizations, for whatever you're working on, how can you do something like this? How can you create developer previews to get feedback? See, these are hard lessons, but it allows us to move at a speed now that we've never been able to move at before because we can release APIs as developer preview, iterate on them, developers can\n'slidetext': ''\n'from': 'vector'\n'score': 0.8975516557693481\n'normalizedScore': 0.8757271507173441\n'beforeDatePenaltyScore': 0.8975516557693481\n\n'documentId': '5ca564ac8c4557f4f949b660'\n'chunk_id': '687a2b82495b49563aa87ad0'\n'access': 'restricted'\n'part_number': 4\n'total_parts': 9\n'contentType': 'RHEINGOLD'\n'title': Level-up your Angular Codebase with Cutting-Edge APIs\n'parentName': International JavaScript Conference Munich 2024\n'language': 'EN'\n'date': '2024-11-13T10:45:00.000Z'\n'abstract': The Angular team is propelling the enterprise frontend framework into a promising future with new, robust APIs. Modern concepts, validated in the JavaScript ecosystem, such as enhanced server-side rendering support, the new Control Flow syntax, Standalone APIs instead of NgModules, and optional RxJS, as well as Zone.js, are paving the way for a brighter future with an easier-to-manage codebase and an excellent developer experience. But how does this impact your current codebase? What refactoring strategy strikes the ideal balance between future-proofing and budget constraints? The reassuring news is that backward compatibility remains paramount. The pace at which you refactor your codebase to leverage the latest framework features is entirely your choice. Join my talk for a practical session where we explore these new APIs and discuss strategies to transform your code into a future-proof application.\n'parentId': 'R8y8tP2vbKi3twHpf'\n'parentDescription': The JavaScript Fullstack Conference - Angular, Node.js, React and more\n'indexBrandName': 'InternationalJavaScriptCon'\n'indexSeriesName': 'Munich'\n'author': 'Michael Egger-Zikes'\n'chunkSource': 'text'\n'text': directly. So turning your, uh, feature based feature modules But this can be done quite easily manually, So whether it is safe to remove the feature module We have here repository So we have normal, uh, ENG modules, um, a boarding, g rooting module here. add angular Core And then here are the questions, right? That's the second step. That's quite un not unusable. because to reach the, the state that much effort as hitting the delete button on your own. Do I need that module anymore? Yes. No, deleting it. But the third one again, is, uh, a helpful one. in your engine module based application, uh, references. Currently this will be converted to an, for standalone adds the providers over there. and just turn your app component into standalone, to convert major parts into standalone Yeah, if you pick the, the first option here, pass here referenced, Yeah, it's only that component. added some imports, uh, right here. and adding the component here to the, to the imports. that is the way of making it compatible that component, use that component in other NG module based Fine. So that's, uh, the part of the schematics here. Sorry, this was the need to pick the, the third one, uh, and then you can see it really deleted our app module. Um, and basically now you have, uh, because of the schematic step, also standalone that you have had back then in the, um, in the, This is a little bit different than generating a new Gimme a moment. So how does a normal that, and it references the app config. It's more aligned with the concept of, of app module, right? It's just called app config. So next thing, uh, control flow, uh, of the structural directives. um, structural directives. So you could have an application where parts are already Nothing to worry here, to have the afin to, RFC phase asked the community, So that proved out to be better. not always, but sometimes really counts and, Sometimes, um, track is now mandatory, so we could use track We needed to reference a function. on when to destroy the dome and when to reuse the dom. through the, through a server, that means each time you and also the ad four are comparing the object references. And then it figures out, okay, that the same data is written into it And this has performance consequences as easy as that. Um, it means if you refactor your application and then just the variable that you use then it uses the flat variable So if the schematics generated for you as it is necessary to the\n'slidetext': ''\n'from': 'vector'\n'score': 0.8948681354522705\n'normalizedScore': 0.8750242240075724\n'beforeDatePenaltyScore': 0.8948681354522705\n\n'documentId': '5ca564ac8c4557f4f949b660'\n'chunk_id': '687a2b83495b49563aa87ad4'\n'access': 'restricted'\n'part_number': 8\n'total_parts': 9\n'contentType': 'RHEINGOLD'\n'title': Level-up your Angular Codebase with Cutting-Edge APIs\n'parentName': International JavaScript Conference Munich 2024\n'language': 'EN'\n'date': '2024-11-13T10:45:00.000Z'\n'abstract': The Angular team is propelling the enterprise frontend framework into a promising future with new, robust APIs. Modern concepts, validated in the JavaScript ecosystem, such as enhanced server-side rendering support, the new Control Flow syntax, Standalone APIs instead of NgModules, and optional RxJS, as well as Zone.js, are paving the way for a brighter future with an easier-to-manage codebase and an excellent developer experience. But how does this impact your current codebase? What refactoring strategy strikes the ideal balance between future-proofing and budget constraints? The reassuring news is that backward compatibility remains paramount. The pace at which you refactor your codebase to leverage the latest framework features is entirely your choice. Join my talk for a practical session where we explore these new APIs and discuss strategies to transform your code into a future-proof application.\n'parentId': 'R8y8tP2vbKi3twHpf'\n'parentDescription': The JavaScript Fullstack Conference - Angular, Node.js, React and more\n'indexBrandName': 'InternationalJavaScriptCon'\n'indexSeriesName': 'Munich'\n'author': 'Michael Egger-Zikes'\n'chunkSource': 'text'\n'text': this, this phase. with Angular, uh, 19. So where the, the, the server coat You can define with the defer block parts, um, or the client logic should only be loaded if a specific uh, something like, uh, react server components that you load from the value load, the H TM L fragment Um, still it's a different platform with an emulated tome, can be used for that as well. That's not always an easy task. Yeah. So if you need SSR support, again, So if you have a repository with several projects, in the angular chase anymore. Um, and, uh, basically meanwhile it's part to ES building read was responsible for and SSR support directly baked into the normal build Um, ES build and weed, um, what about that, uh, That is done per default. Uh, ES build is the, the, uh, is used And, um, so we are using, uh, Um, same story We already know that buil V will be the future. Uh, NG update does not do this automatically for you. Um, if, you know, you can, if you like, you can opt into Um, we know from some third party integrations but the earlier you try it out, the earlier, Um, use schematics, um, to switch to the, a change in your angle adjacent setup. you pick the, the application builder. but again, by running a schematic angio update, Anglo CLI, because it's, it's affecting the build process. So if you run into issues, with your current code base, then you can, uh, Um, this is e buil implementation. the transition from web pack easier. with the browser ES builder, that the normal application bill offers, So the first question was, do we need those features? Yeah. Um, uh, what do we get next maybe? that the Angular team is not angry about me, uh, to be honest, chances are quite good. and data access, this is something that is now added Definitely. Um, it covers data reads currently. So resource is promise based So it can pass in an observable, um, that allows you now, and then adult data loading process, um, is used. or the data is currently loading, it even allows you It's the same filter you can see now. to get some data back in the RX J scenario. recognized, not further events. Yeah. Um, be aware to avoid race conditions. previous ongoing calls that are not finished yet. that triggers, um, and, uh, the next trigger comes in And if you hit the execute, the, the result method, because if you refresh the data, Basically, I\n'slidetext': ''\n'from': 'vector'\n'score': 0.8933086395263672\n'normalizedScore': 0.8734647280816691\n'beforeDatePenaltyScore': 0.8933086395263672\n\n'documentId': 'Es9qB3iW8QsKxfKEh'\n'chunk_id': '687a2d569bbcb45d2a11ead8'\n'access': 'restricted'\n'part_number': 1\n'total_parts': 1\n'contentType': 'RHEINGOLD'\n'title': Modern Angular: Renovierung für Ihre Anwendungen\n'parentName': JavaScript Days Berlin und online 2024\n'language': 'DE'\n'date': '2024-10-24T11:30:00.000Z'\n'abstract': In den letzten Monaten hat Angular zahlreiche neue Features erhalten, die es ermöglichen, das Framework auf moderne und leichtgewichtige Weise zu verwenden. Signals für eine moderne und performante Change Detection, Standalone Components und Standalone APIs, funktionale Guards und Interceptoren, esbuild-Unterstützung sowie und zahlreiche Verbesserungen beim Router sind ein paar Beispiele dafür. In diesem Workshop starten wir mit einer klassischen Angular-Lösungen, die wir nach und nach um die neuen Möglichkeiten erweitern. Somit ergibt sich eine leichtgewichtige und moderne Lösung, die sich einfacher warten lässt und die Vorteile der neuen Features auch nutzen kann. Am Ende wissen Sie, wie sich Ihre Angular-Lösung modernisieren lässt und welche neuen Features sich für Ihre Vorhaben lohnen.\n'parentId': 'bAbqTsTMmppKpiENq'\n'parentDescription': 40 Workshops zu JavaScript, Angular, React, Typescript und KI\n'indexBrandName': 'JavaScriptDays'\n'indexSeriesName': 'Berlin'\n'author': 'Manfred Steyer'\n'chunkSource': 'text'\n'text': Modern Angular: Renovierung für Ihre Anwendungen In den letzten Monaten hat Angular zahlreiche neue Features erhalten, die es ermöglichen, das Framework auf moderne und leichtgewichtige Weise zu verwenden. Signals für eine moderne und performante Change Detection, Standalone Components und Standalone APIs, funktionale Guards und Interceptoren, esbuild-Unterstützung sowie und zahlreiche Verbesserungen beim Router sind ein paar Beispiele dafür. In diesem Workshop starten wir mit einer klassischen Angular-Lösungen, die wir nach und nach um die neuen Möglichkeiten erweitern. Somit ergibt sich eine leichtgewichtige und moderne Lösung, die sich einfacher warten lässt und die Vorteile der neuen Features auch nutzen kann. Am Ende wissen Sie, wie sich Ihre Angular-Lösung modernisieren lässt und welche neuen Features sich für Ihre Vorhaben lohnen.\n'slidetext': ''\n'from': 'vector'\n'score': 0.894394040107727\n'normalizedScore': 0.8734559505808371\n'beforeDatePenaltyScore': 0.894394040107727\n\n'documentId': '22a125a269ee4ccc064bc5d5'\n'chunk_id': '687a26cd96f7bf47ed452442'\n'access': 'restricted'\n'part_number': 5\n'total_parts': 19\n'contentType': 'RHEINGOLD'\n'title': Building the Next Generation of Supercharged Web Applications Today\n'parentName': International JavaScript New York 2024\n'language': 'EN'\n'date': '2024-10-08T13:00:00.000Z'\n'abstract': Web development is on the cusp of a revolution and you need to be a part of it. Users are starting to expect applications to do things that previously required massive engineering efforts. You can harness the power of LLMs and other AI features to build applications that interact with your users in new ways. Tired of web applications that feel static? In this action-packed session, Mark will show you how to use AI to transform your applications and reimagine the way you interact with users. Prepare to be inspired and empowered to reimagine the possibilities of your apps.\n'parentId': 'xhXxg9ohmYPxSZtL6'\n'parentDescription': The JavaScript Fullstack Conference - Angular, Node.js, React and more\n'indexBrandName': 'InternationalJavaScriptCon'\n'indexSeriesName': 'NewYork'\n'author': 'Mark Thompson'\n'chunkSource': 'text'\n'text': of this stuff. You can still find it where it works for you. How does that feel? Feels good. I like the applause. Let's follow their lead. Come on, you can gimme a round applause. I love it. I need it. Thank you. I love it right there. That's the energy I'm talking about. Yes. I feel even, see I just got supercharged. Alright, let's talk about developer experience. Alright, so here's something that we learned on the Angular team. I'm always talking about lessons because I'm always thinking about things that we learned. Anybody's ever said this to themselves while trying to use angular. Angular is hard to learn. Let me reinforce that. Don't even try to read it. I made it small on purpose. I want you to see the volume of code for a hello world. That's a lot of lines of code to get. Hello world. You see something like this in a tutorial, you are gonna do what? You're gonna go away. You're not even gonna spend time on it, right? And so we heard this feedback over and over again and because developer experience is so important, we said fine, we can do better. What if we got to less code? So then we changed it to this. Now this is an entire angular application right now. Now some of you who work in web frameworks may be saying, oh, what about your configuration files? Those are not listed. Well what about your configuration files? Okay, fine. But this is an entire application. You got a component with the decorator that kind of describes it and then you have your properties for your classes and stuff, okay? But this is an entire application. So if you were to copy and paste this into your, your code editor with angular installed on your computer, you can run it. That's the whole thing. Because we heard this feedback and then that let us know that we needed to make changes because the developer experience is everything. What do you all talk about with your friends, your developer friends? I would say your other friends are like, I don't want to hear about your code life, but your developer friends, when you talk about development, you talk about how nice this API is, how smooth this thing is because developer experience still matters. What about better syntax? Okay, now this is some HTML mixed in with some angular, okay? Now this is an if else, lemme walk you through this. So it says if the user is human, if the user is human display, this component called human profile. Alright? It's, it's, it's kind of legible. Well\n'slidetext': ''\n'from': 'vector'\n'score': 0.8949709534645081\n'normalizedScore': 0.8731595762663853\n'beforeDatePenaltyScore': 0.8949709534645081\n\n'documentId': 'vAJzqCurd28Mq4HRk'\n'chunk_id': '687a3236ca798166d3ba4eca'\n'access': 'restricted'\n'part_number': 1\n'total_parts': 1\n'contentType': 'RHEINGOLD'\n'title': Modern-Angular-Workshop: Architektur und Features\n'parentName': BASTA! Herbst 2024\n'language': 'DE'\n'date': '2024-09-20T07:00:00.000Z'\n'abstract': In diesem Workshop tauchen Sie tief in die neuesten Angular-Features ein, um moderne, wartbare Anwendungsarchitekturen zu entwickeln. Lernen Sie, wie Sie Standalone Components nutzen, neue Modularisierungsansätze mit Nx und Sheriff anwenden, und erfahren Sie mehr über die aktualisierten APIs für HttpClient und Router. Entdecken Sie neue Built-in Control Flow Blocks, Signals für verbesserte Change Detection und den Signal Store für effektives State-Management.\n'parentId': 'Hm6SdzajQWSYS6foi'\n'parentDescription': Die Konferenz für .NET, Windows & Open Innovation\n'indexBrandName': 'BASTA!'\n'indexSeriesName': 'Herbst'\n'author': 'Manfred Steyer,Rainer Hahnekamp'\n'chunkSource': 'text'\n'text': Modern-Angular-Workshop: Architektur und Features In diesem Workshop tauchen Sie tief in die neuesten Angular-Features ein, um moderne, wartbare Anwendungsarchitekturen zu entwickeln. Lernen Sie, wie Sie Standalone Components nutzen, neue Modularisierungsansätze mit Nx und Sheriff anwenden, und erfahren Sie mehr über die aktualisierten APIs für HttpClient und Router. Entdecken Sie neue Built-in Control Flow Blocks, Signals für verbesserte Change Detection und den Signal Store für effektives State-Management.\n'slidetext': ''\n'from': 'vector'\n'score': 0.8945451974868774\n'normalizedScore': 0.8717338202887547\n'beforeDatePenaltyScore': 0.8945451974868774\n\n'documentId': 'mrkFPBdm5bQQ8Q8nY'\n'chunk_id': '687a355fca798166d3ba5e1c'\n'access': 'restricted'\n'part_number': 1\n'total_parts': 22\n'contentType': 'RHEINGOLD'\n'title': Renovate your Angular App!\n'parentName': International JavaScript Conference London 2024\n'language': 'EN'\n'date': '2024-04-10T08:30:00.000Z'\n'abstract': The Angular Team is currently pushing the popular enterprise frontend framework into a bright future. New APIs which are prooved as Solid in the JavaScript ecosystem and Qwiker start-up time by introducing more advanced server-side rendering support are combined with the new Control Flow syntax that feels like a perfect joint-venture between Svelte and .NET. The Standalone APIs make NgModules optional as well as RxJS and Zone.js will not be mandatory dependencies in the future anymore. But what does this mean for your current codebase? Which refactoring strategy is the best compromise between good preparation for the future and tight project budgets? The good news - all of this comes with backwards compatibility in mind. It is your own decision which pace to use to refactor your own codebase to the latest framework features. In this practical session, we will discuss those new APIs and discover ways to transform your code into a future-proof application.\n'parentId': 'cKCGY58YaztJ8GQ9k'\n'parentDescription': The JavaScript Fullstack Conference - Angular, Node.js, React and more\n'indexBrandName': 'InternationalJavaScriptCon'\n'indexSeriesName': 'London'\n'author': 'Michael Egger-Zikes'\n'chunkSource': 'text'\n'text': Renovate your Angular App! The Angular Team is currently pushing the popular enterprise frontend framework into a bright future. New APIs which are prooved as Solid in the JavaScript ecosystem and Qwiker start-up time by introducing more advanced server-side rendering support are combined with the new Control Flow syntax that feels like a perfect joint-venture between Svelte and .NET. The Standalone APIs make NgModules optional as well as RxJS and Zone.js will not be mandatory dependencies in the future anymore. But what does this mean for your current codebase? Which refactoring strategy is the best compromise between good preparation for the future and tight project budgets? The good news - all of this comes with backwards compatibility in mind. It is your own decision which pace to use to refactor your own codebase to the latest framework features. In this practical session, we will discuss those new APIs and discover ways to transform your code into a future-proof application. All, Now it works. Hi. Hi again to everyone. Uh, we are, um, today talking about the new Angular features. Uh, the talk is called Runway Weight Your Angle app because, um, actually we are now on version 17 and quite a bunch of features were added recently. If you look back in time, the new generation of Angular two plus applications, some even called it Angular three already because we never had a version three in our framework. Um, it's, it, it changes quite that much, um, that we could even argue. Maybe it's a, it's, it's the third generation of the Angola framework, but this time not that way. Like we had the transition, the, to be honest, painful transition from Angular one to Angular two this time. Um, Ola team learned quite a lot from, uh, those days back then and from the feedback of the community that wasn't, that the community wasn't that happy about all the migration projects that still are today a thing for some companies to migrate. The Angular J called base to Angular two plus applications Angular 17, maybe today. Um, and so they found a quite better strategy, a strategy that leads to more effort for them and not more effort for us implementing our Angular applications and will exactly tackle that topic today. That means, um, since Angular 14 at least, um, they had quite a, a high pace implementing new features, offering new features, offering, develop a preview with, uh, the signals, API with the new control flow with, uh, standalone components at the beginning with Angola. 14. Uh, what else did we receive? Uh, typed finally typed forms. So quite a bunch of\n'slidetext': ''\n'from': 'vector'\n'score': 0.8994925022125244\n'normalizedScore': 0.867753042823255\n'beforeDatePenaltyScore': 0.8994925022125244\n\n'documentId': 'N9G6dCb5BArvu6cbr'\n'chunk_id': '687a2d559bbcb45d2a11ead0'\n'access': 'restricted'\n'part_number': 22\n'total_parts': 23\n'contentType': 'RHEINGOLD'\n'title': Renovate your Angular App!\n'parentName': International JavaScript Conference San Diego 2024\n'language': 'EN'\n'date': '2024-05-21T12:30:00.000Z'\n'abstract': The Angular Team is currently pushing the popular enterprise frontend framework into a bright future. New APIs proved to be solid in the JavaScript ecosystem and quicker start-up time introduced more advanced server-side rendering support. Combined with the new Control Flow syntax, it feels like a perfect joint venture between Svelte and .NET. The Standalone APIs make NgModules optional too. RxJS and Zone.js won't be a mandatory dependency in the future anymore. But what does this mean for your current codebase? Which refactoring strategy is the best compromise between good preparation for the future and tight project budgets? The good news is that all of this comes with backward compatibility in mind. It is your decision which pace to use to refactor your codebase to the latest framework features. In a practical session, we'll discuss those new APIs and discover ways to transform your code into a future-proof application.\n'parentId': 'BYZWRge2q657D9ZYR'\n'parentDescription': The Fullstack Conference for JS Development\n'indexBrandName': 'InternationalJavaScriptCon'\n'indexSeriesName': 'SanDiego'\n'author': 'Michael Egger-Zikes'\n'chunkSource': 'text'\n'text': component, please apply a directive. So a lot of use cases where you normally would need inheritance, for example, you can use instead host directives to add some additional features, um, to your application. Uh, ES build support, new build tool, uh, in some cases, uh, quite easy to migrate. In other cases, a little bit more effort. There's an upgrade guide also, uh, and even an experimental schematics support. Um, you have two options actually. You can migrate the web pack based builder to a, uh, browser builder ES build that has less breaking changes. And you have, uh, the, the application builder, the new one that has, uh, a little bit more breaking changes, but in a lot of code bases it works quite nice. You have much quicker build, you have wheat as a dev server, so that's the new standard for new angular applications for remaining one you can opt in server that rendering, um, angular can now, uh, really do this as part of the Angular framework. So they insourced the, the external universal package into, into the angular names is quite a good thing because then it has another maintenance levered in a community project, um, as it was in the past at least. Um, and it's now part of the application builder. So also the Ang Angular chase setup is it's less to set up actually as configuration in the, in the angular adjacent because it's directly integrated. Um, and the idea is to make this a default feature for everyone in future so that you do not need to think much, whether you want to activate, uh, server set rendering or leave it, um, deactivated, um, it's at the moment and a feature that helps us to, um, basically get, uh, initial few renders, uh, more quickly. So better startup performance, but also it's helpful for server sites, um, uh, for search engine optimizations. Um, so better indexing for the search engines like Google, for example. Uh, and other features were already added. Hydration. That means if something initially runs on the server and it loads some state from, um, from the, uh, backend resource server, for example, it can use that state and directly hand it over to the client, run them. So you do not need to do the initial server course once again. So this is based into the hydration feature. This was often a little bit something, uh, something that was a little bit hard to implement on your own without flickering and so on. Um, and they merged with an internal Google team called with, um, they have quite a, a lot of know-how\n'slidetext': ''\n'from': 'vector'\n'score': 0.8971368074417114\n'normalizedScore': 0.8676530558143649\n'beforeDatePenaltyScore': 0.8971368074417114\n\n'documentId': 'mrkFPBdm5bQQ8Q8nY'\n'chunk_id': '687a355fca798166d3ba5e20'\n'access': 'restricted'\n'part_number': 3\n'total_parts': 22\n'contentType': 'RHEINGOLD'\n'title': Renovate your Angular App!\n'parentName': International JavaScript Conference London 2024\n'language': 'EN'\n'date': '2024-04-10T08:30:00.000Z'\n'abstract': The Angular Team is currently pushing the popular enterprise frontend framework into a bright future. New APIs which are prooved as Solid in the JavaScript ecosystem and Qwiker start-up time by introducing more advanced server-side rendering support are combined with the new Control Flow syntax that feels like a perfect joint-venture between Svelte and .NET. The Standalone APIs make NgModules optional as well as RxJS and Zone.js will not be mandatory dependencies in the future anymore. But what does this mean for your current codebase? Which refactoring strategy is the best compromise between good preparation for the future and tight project budgets? The good news - all of this comes with backwards compatibility in mind. It is your own decision which pace to use to refactor your own codebase to the latest framework features. In this practical session, we will discuss those new APIs and discover ways to transform your code into a future-proof application.\n'parentId': 'cKCGY58YaztJ8GQ9k'\n'parentDescription': The JavaScript Fullstack Conference - Angular, Node.js, React and more\n'indexBrandName': 'InternationalJavaScriptCon'\n'indexSeriesName': 'London'\n'author': 'Michael Egger-Zikes'\n'chunkSource': 'text'\n'text': uh, JavaScript community, if you normally ask them what's the, the really powerful API that Angular has, uh, where Angular has really was really in innovative and, and, um, implemented a set of features that the other frameworks did not have back then. Um, basically it's dependence injection, so that's a big success story. It makes things far easier, uh, in a lean manner, connecting your, um, your dependencies to components, directives and so on. And the system stayed the same, but we received new APIs on how to work with the dependent injection. Um, also because of the standalone, uh, APIs that were introduced, because if you think back, or maybe it's even currently still in your code base, that's perfectly fine. Um, how did we add roots, for example, with the route the module, uh, for root and with the route the module for a child. Today, we make this differently. We have provider functions. We also do this for state management to connect the new states life into our application. Um, we'll also talk about the control flow. That's another nice feature that was added, uh, with the last nature release. Um, it makes, uh, it transforms your code with a schematic generator that we can use, uh, from NG NG four NG switch to a kind of different template language with an add symbol in front. And it looks more like something erect component. You can also say selt component, or there are also similar notations in.net applications, for example, where we can really have code blocks in the template, or at least it looks like a code block. It's still HTML template, but, um, it's, it's far easier to read and, and therefore also not only for reading, uh, something beneficial, but also for performance because the, the angle application can render all your iterable lists like an array, for example, um, more performant than in the past. And then dot, dot, dot, uh, the spread operator. Right? Um, we have some, some other nice features as well, uh, that, that I will take here at least briefly in an overview slide at end. Um, my name is Mikey. I work at the Angular Architects. Um, so together with Maner Van Amp and some other guys, we try to help our customers and Angola with trainings, consultancies and reviews and sometimes, uh, yeah, and even here at conferences, um, hopefully giving you some, some nice inputs about, uh, current topics that, uh, are relevant for the Angular development. Um, yeah, you can find me also on Twitter. I still see Twitter\n'slidetext': ''\n'from': 'vector'\n'score': 0.8972049355506897\n'normalizedScore': 0.8654654761607861\n'beforeDatePenaltyScore': 0.8972049355506897\n\n'documentId': 'N9G6dCb5BArvu6cbr'\n'chunk_id': '687a2d529bbcb45d2a11eaa3'\n'access': 'restricted'\n'part_number': 1\n'total_parts': 23\n'contentType': 'RHEINGOLD'\n'title': Renovate your Angular App!\n'parentName': International JavaScript Conference San Diego 2024\n'language': 'EN'\n'date': '2024-05-21T12:30:00.000Z'\n'abstract': The Angular Team is currently pushing the popular enterprise frontend framework into a bright future. New APIs proved to be solid in the JavaScript ecosystem and quicker start-up time introduced more advanced server-side rendering support. Combined with the new Control Flow syntax, it feels like a perfect joint venture between Svelte and .NET. The Standalone APIs make NgModules optional too. RxJS and Zone.js won't be a mandatory dependency in the future anymore. But what does this mean for your current codebase? Which refactoring strategy is the best compromise between good preparation for the future and tight project budgets? The good news is that all of this comes with backward compatibility in mind. It is your decision which pace to use to refactor your codebase to the latest framework features. In a practical session, we'll discuss those new APIs and discover ways to transform your code into a future-proof application.\n'parentId': 'BYZWRge2q657D9ZYR'\n'parentDescription': The Fullstack Conference for JS Development\n'indexBrandName': 'InternationalJavaScriptCon'\n'indexSeriesName': 'SanDiego'\n'author': 'Michael Egger-Zikes'\n'chunkSource': 'text'\n'text': Renovate your Angular App! The Angular Team is currently pushing the popular enterprise frontend framework into a bright future. New APIs proved to be solid in the JavaScript ecosystem and quicker start-up time introduced more advanced server-side rendering support. Combined with the new Control Flow syntax, it feels like a perfect joint venture between Svelte and .NET. The Standalone APIs make NgModules optional too. RxJS and Zone.js won't be a mandatory dependency in the future anymore. But what does this mean for your current codebase? Which refactoring strategy is the best compromise between good preparation for the future and tight project budgets? The good news is that all of this comes with backward compatibility in mind. It is your decision which pace to use to refactor your codebase to the latest framework features. In a practical session, we'll discuss those new APIs and discover ways to transform your code into a future-proof application. So then let's get the party Started. Microphone on fine. Then. Um, yeah, I've learned I'm not allowed to move that far, but that should be fine. Okay. Uh, welcome everyone here in the room, in, in San Diego, beautiful San Diego and everyone also, uh, connected online, um, through Deaf meal. Uh, hello everyone. Um, I would like to, um, talk a little bit about, uh, renovating Your Angle applications. That means we have received so many APIs that it's basically a challenge to really figure out what to, uh, refactor immediately, what to refactor later. Um, so quite a lot to do for applications and yeah, let's dive directly into that. Um, as soon as my clicker reacts list, um, we will talk about standalone migration. Um, we can do so with some, uh, schematics, but also manually. Um, we look into the signals, API also how we can, uh, refactor our current components into new ones. Um, and, uh, we will talk about the router integration. There are several features, um, that basically makes it easier for us and it, to be honest, feels better than in the past to work with ENG router. So for example, uh, getting an ID out of the URL, uh, using, uh, quite a bunch of modern features, signal, signal inputs, um, and other features, um, to, to get, uh, access to the routing state and, and use it in your child components there. Um, we will also talk about, uh, provider functions and inject functions. So they are important right now. Um, on one hand, you know them basically, uh, maybe already from the Angular framework itself,\n'slidetext': ''\n'from': 'vector'\n'score': 0.8946701884269714\n'normalizedScore': 0.8651864367996249\n'beforeDatePenaltyScore': 0.8946701884269714\n\n\n Dieser Content von  ist in deiner Sprache nicht verfügbar. Zurück zur Antwort"
}